<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FBY展菲个人博客</title>
  
  <subtitle>加微信：『FBY-fan』领资料</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2021-06-07T13:09:17.273Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>FBY展菲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何将 Swift 代码添加为自定义 LLDB 命令</title>
    <link href="https://fanbaoying.github.io/%E5%A6%82%E4%BD%95%E5%B0%86-Swift-%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89-LLDB-%E5%91%BD%E4%BB%A4/"/>
    <id>https://fanbaoying.github.io/如何将-Swift-代码添加为自定义-LLDB-命令/</id>
    <published>2021-06-07T12:59:57.000Z</published>
    <updated>2021-06-07T13:09:17.273Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://swiftsenpai.com/testing/add-custom-lldb/" title="Adding Swift Code as Custom LLDB Command" target="_blank" rel="noopener">Adding Swift Code as Custom LLDB Command</a></p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 <code>po</code>。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？</p><p>在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：</p><ul><li>添加你的第一个 LLDB 命令</li><li>添加带参数的 LLDB 命令</li><li>将复杂的 Swift 代码转换为 LLDB 命令</li></ul><a id="more"></a><h2 id="2-添加您的第一个-LLDB-命令"><a href="#2-添加您的第一个-LLDB-命令" class="headerlink" title="2. 添加您的第一个 LLDB 命令"></a>2. 添加您的第一个 LLDB 命令</h2><h3 id="2-1-了解-LLDB-命令结构"><a href="#2-1-了解-LLDB-命令结构" class="headerlink" title="2.1 了解 LLDB 命令结构"></a>2.1 了解 LLDB 命令结构</h3><p>为了添加自定义 LLDB 命令，我们必须利用 <code>command alias</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias [command_name] expr -l Swift -O -- [swift_code]</span><br></pre></td></tr></table></figure><p><strong>对命令进行详细分解：</strong></p><ul><li><code>command alias</code>：使用名称为 Swift 代码添加别名的 LLDB 命令</li><li><code>[command_name]</code>: 自定义命令名称</li><li><code>expr -l Swift -O --</code>: 要求 LLDB 调试器将后面的所有内容解释为 Swift 代码</li><li><code>[swift_code]</code>：定义自定义命令逻辑的 Swift 代码</li></ul><p>举例说明，如果我们要添加一个别名为 <code>greet</code> 的自定义命令，在控制台上打印结果为 “Hello World！” ，LLDB 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias greet expr -l Swift -O -- print(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-2-添加自定义命令"><a href="#2-2-添加自定义命令" class="headerlink" title="2.2 添加自定义命令"></a>2.2 添加自定义命令</h3><p>现在已经构造了别名为 <code>greet</code> 的命令，然后添加到 LLDB 调试器中。</p><p>将 <code>greet</code> 命令添加到 LLDB 调试器的最直接方法是在 Xcode 控制台中执行别名命令。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a9a2981a3d603298.gif?imageMogr2/auto-orient/strip" alt=""></p><p>但是，这样做只会使 <code>greet</code> 命令在当前特定调试会话中可用。 也就是说，每当开始新的调试会话时，我们就需要重新键入相同的别名命令。</p><p>为了避免这种情况发生，我们可以利用位于主目录中的 <code>.lldbinit</code> 文件。 <strong>请注意</strong>，这是一个隐藏文件，如果看不到该文件，可以使用以下快捷方式在你的查找器中显示隐藏文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift + command + .</span><br></pre></td></tr></table></figure><p>如果在 finder 中启用了显示隐藏文件，仍然没有找到该文件，可以在根目录下使用下面的终端命令创建一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.lldbinit</span><br></pre></td></tr></table></figure><p>之后，打开 <code>.lldbinit</code> 文件将整个别名命令粘贴到文件中。这样，Xcode 将在每次启动新的调试会话时执行别名命令。</p><blockquote><p><strong>Pro Tip:</strong> 如果不想在每次更新 <code>.lldbinit</code> 文件时都重新启动调试会话，可以使用以下命令重新加载它：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command source ~/.lldbinit</span><br></pre></td></tr></table></figure><h2 id="3-添加带参数的-LLDB-命令"><a href="#3-添加带参数的-LLDB-命令" class="headerlink" title="3. 添加带参数的 LLDB 命令"></a>3. 添加带参数的 LLDB 命令</h2><p>接着，让我们尝试添加一个能够接受参数的命令。 在上面 greet 命令的基础上进行修改，使其能够接受一个字符串并且打印出问候消息。</p><p>这一次，我们将使用 <code>command regex</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex [command_name] &apos;s/[regex]/expr -l Swift -O -- [swift_code]/&apos;</span><br></pre></td></tr></table></figure><p>这里对 regex 命令的工作原理不做详细描述。 通常，是将 [regex] 替换为正则表达式语句 (.+)，然后在 Swift 代码中使用 %1 表示参数。</p><p>更新 <code>greet</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+)/expr -l Swift -O -- print(&quot;Hello \(%1)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name = &quot;Swift Senpai&quot;</code> 执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name</span><br><span class="line">Hello Swift Senpai!</span><br></pre></td></tr></table></figure><p>到这里，你可能会问：如果我需要传入多个参数怎么办？ 答案其实很简单。</p><p>首先，将多个 <code>(.+)</code> 添加到正则表达式语句并用空格分隔每个 <code>(.+)</code>。 之后，使用 <code>%2</code>, <code>%3</code>, <code>%4</code>… 来表示 Swift 代码中的每个参数。</p><p>将 <code>greet</code> 命令更新为支持两个参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+) (.+)/expr -l Swift -O -- print(&quot;Hello (%1) and (%2)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name1 = &quot;Swift Senpai&quot;</code> 和 <code>name2 = &quot;iOS developers&quot;</code>，使用该命令，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name1 name2</span><br><span class="line">Hello Swift Senpai and iOS developers!</span><br></pre></td></tr></table></figure><p>到这里，我们已经了解了如何添加带有多个参数的自定义 LLDB 命令。 下面，将向你展示如何将多行 Swift 函数转换为自定义 LLDB 命令。</p><h2 id="将复杂的-Swift-代码转换为-LLDB-命令"><a href="#将复杂的-Swift-代码转换为-LLDB-命令" class="headerlink" title="将复杂的 Swift 代码转换为 LLDB 命令"></a>将复杂的 Swift 代码转换为 LLDB 命令</h2><p>通过前面的介绍，我们知道添加自定义 Swift 代码作为 LLDB 命令，必须在一行中完成。因此，如果有一个多行的 Swift 函数，我们必须先将其转换为单行，然后才能将其添加到 <code>.lldbinit</code> 文件中。</p><p>比如要添加下面这个将 RGB 值转换为十六进制值的 Swift 函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hex</span><span class="params">(r: Int, g: Int, b: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(hex)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面的代码注释使用的是 <code>/* */</code> 而不是 <code>//</code>,这是为了确保将 Swift 代码转换为单行后不会中断。</p><p>下面我们需要将 Swift 代码转换为一行，操作流程如下：</p><ol><li>为每个函数参数定义一个变量。</li><li>将 <code>%1</code>、<code>%2</code>、<code>%3</code>… 分配给每个定义的变量。</li><li>在每个语句的末尾添加 <code>;</code>。</li></ol><p>更新后的 Swift 代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = %<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> g = %<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> b = %<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line"><span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(hex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们需要将 Swift 代码转换为一行，我比较喜欢使用这个<a href="https://www.textfixer.com/tools/paragraph-to-lines.php" title="代码单行转换工具" target="_blank" rel="noopener">免费在线工具</a>进行单行转换</p><p>将代码转换为单行后，就可以进行构造正则表达式命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex hex &apos;s/(.+) (.+) (.+)/expr -l Swift -O -- let r = %1; let g = %2; let b = %3; if (r &gt;= 0 &amp;&amp; r &lt;= 255) &amp;&amp; (g &gt;= 0 &amp;&amp; g &lt;= 255) &amp;&amp; (b &gt;= 0 &amp;&amp; b &lt;= 255) &#123; let rgb:Int = r&lt;&lt;16 | g&lt;&lt;8 | b&lt;&lt;0; let hex = String(format:&quot;#%06x&quot;, rgb); print(hex); &#125; else &#123; print(&quot;Invalid input value&quot;); &#125;/&apos;</span><br></pre></td></tr></table></figure><p>将命令粘贴到 <code>.lldbinit</code> 文件中，然后就可以使用了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-28714c53ef002c05.gif?imageMogr2/auto-orient/strip" alt=""></p><h2 id="实用的自定义-LLDB-命令"><a href="#实用的自定义-LLDB-命令" class="headerlink" title="实用的自定义 LLDB 命令"></a>实用的自定义 LLDB 命令</h2><p>在学会了如何向 LLDB 调试器中添加自定义命令，那么添加什么样的自定义 LLDB 命令最实用呢？</p><p>我个人认为下面的自定义命令非常实用。可以在 Xcode 控制台中将任何 JSON 可序列化类型（例如字典、数组、数据等）打印为 JSON 字符串。 可以参考<a href="https://soffes.blog/debugging-json-data-in-lldb" title="Debugging JSON Data in LLDB" target="_blank" rel="noopener">这篇文章</a>。</p><p>另外，我也很喜欢<a href="https://diamantidis.github.io/2018/10/14/modifying-ui-elements-with-xcode-and-lldb-v2" title="Modifying UI elements with Xcode and LLDB v2" target="_blank" rel="noopener">本文</a>讨论的一系列自定义命令，我们可以使用它们来动态修改 UI 元素的颜色，而无需重新构建项目。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是对 LLDB 调试器功能做了简单介绍。如果你是刚刚接触到 LLDB，希望这篇文章能帮助你开始探索这个神奇的调试工具。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://swiftsenpai.com/testing/add-custom-lldb/&quot; title=&quot;Adding Swift Code as Custom LLDB Command&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Adding Swift Code as Custom LLDB Command&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 &lt;code&gt;po&lt;/code&gt;。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？&lt;/p&gt;
&lt;p&gt;在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加你的第一个 LLDB 命令&lt;/li&gt;
&lt;li&gt;添加带参数的 LLDB 命令&lt;/li&gt;
&lt;li&gt;将复杂的 Swift 代码转换为 LLDB 命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>探索 SwiftUI 基本手势.md</title>
    <link href="https://fanbaoying.github.io/%E6%8E%A2%E7%B4%A2-SwiftUI-%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%8A%BF-md/"/>
    <id>https://fanbaoying.github.io/探索-SwiftUI-基本手势-md/</id>
    <published>2021-06-07T12:40:07.000Z</published>
    <updated>2021-06-07T12:59:17.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。</p><p>今天，我们将回顾<span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span>基本手势：</p><ul><li>TapGesture</li><li>长按手势</li><li>拖动手势</li><li>放大手势</li><li>旋转手势</li></ul><a id="more"></a><h2 id="TapGesture"><a href="#TapGesture" class="headerlink" title="TapGesture"></a>TapGesture</h2><p>轻击手势使我们能够识别 <span style="background-color:rgba(27,31,35,.05);color:orangered;">View</span> 上的一个或多个轻击。<br>我们有几种方法可以添加点击手势。</p><p>第一个是直接使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onTapGesture</span> 修饰符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">  .onTapGesture &#123;</span><br><span class="line">    <span class="comment">// Respond to Tap Gesture </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 文档中使用的其他选项是通过创建手势并将其配置为属性，然后将其与 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.gesture（_：include :)</span> 修饰符一起使用。</p><p><strong>注意：</strong> 为了执行某项操作或响应轻击，我们需要使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭，该操作在手势结束时触发。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SingleTapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">      <span class="type">TapGesture</span>()</span><br><span class="line">          .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">              <span class="comment">// Respond to Tap Gesture</span></span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">Circle</span>()</span><br><span class="line">          .gesture(singleTap)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我更喜欢第二种方法，因为这样我们可以创建不同的手势并通过我们的代码重复使用它们。</p><p>因此，如果我们将代码放在一起，就可以开始编写类似的东西。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-7c948aec7b7e9c3f.image?imageMogr2/auto-orient/strip" alt="giphy.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped1x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>()</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped1x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 1X: <span class="subst">\(tapped1x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"1X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(singleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，我们只需使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">TapGesture(count：Int)</span> 初始化程序就可以控制要响应的数量。</p><p>在这种情况下，您需要点击3次才能触发 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-49af6400b2230e18.image?imageMogr2/auto-orient/strip" alt="2.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGesture3xView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped3x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> multipleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>(<span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped3x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 3X: <span class="subst">\(tapped3x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"3X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(multipleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长按手势"><a href="#长按手势" class="headerlink" title="长按手势"></a>长按手势</h2><p>长按手势可让我们在用户长按定义的时间后以及在用户长按的时间内执行操作。</p><p>我们可以设置一个最小持续时间，以识别我们的长按手势。 可以在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">LongPressGesture</span> 初始化程序中进行设置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>然后，我们可以使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.updating</span> 方法在长按期间执行操作，并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 在识别到我们的手势时执行操作。</p><p>在此示例中，我将在长按操作期间更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 的大小和颜色，并且当识别出手势时，我将显示“文本已完成”。</p><p>另外，我在这里使用的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">GestureState</span> 属性包装器，该包装器在长按期间设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">true</span> ，在手势结束时设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">false</span> 。 我正在将此属性包装器用于示例动画。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-4a9fe52ce65b10a1.image?imageMogr2/auto-orient/strip" alt="3.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LongPressGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">GestureState</span> <span class="keyword">private</span> <span class="keyword">var</span> isLongPressDetected = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isDone = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> longPress: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br><span class="line">            .updating($isLongPressDetected) &#123; currentState, gestureState, transaction <span class="keyword">in</span></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    isDone = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                gestureState = currentState</span><br><span class="line">                transaction.animation = <span class="type">Animation</span>.easeIn(duration: <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; done <span class="keyword">in</span></span><br><span class="line">                isDone = done</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">10</span>, height: <span class="number">10</span>)</span><br><span class="line">                .foregroundColor(isLongPressDetected ? .orange : .primary)</span><br><span class="line">                .scaleEffect(<span class="type">CGSize</span>(</span><br><span class="line">                                width: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>,</span><br><span class="line">                                height: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="keyword">if</span> isLongPressDetected &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Updating..."</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isDone &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Long Press 2 sec"</span>)</span><br><span class="line">                .padding()</span><br><span class="line">                .background(isLongPressDetected ? <span class="type">Color</span>.green : <span class="type">Color</span>.orange)</span><br><span class="line">                .cornerRadius(<span class="number">16</span>)</span><br><span class="line">                .gesture(longPress)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拖动手势"><a href="#拖动手势" class="headerlink" title="拖动手势"></a>拖动手势</h2><p>拖动手势允许我们在拖动视图时执行操作。</p><p>我们可以利用并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 关闭方法来执行某些操作。 这两种方法都为我们提供了出色的属性 <span style="background-color:rgba(27,31,35,.05);color:orangered;">DragGesture.Value</span>，该属性存储以下拖动动作信息：</p><ul><li>location</li><li>predictedEndLocation</li><li>predictedEndTranslation</li><li>startLocation</li><li>time</li><li>translation</li></ul><p>我们可以使用该属性来创建可移动视图。 在当前示例中，我使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 方法更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-9d805e7489eb15e5.image?imageMogr2/auto-orient/strip" alt="4.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，添加了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 方法，以在拖动结束后重置 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-f1710b2656cab2f4.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                withAnimation(.easeOut) &#123;</span><br><span class="line">                    location = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放大手势"><a href="#放大手势" class="headerlink" title="放大手势"></a>放大手势</h2><p>当我们在View上应用放大动作时，放大手势允许做出一些动作。</p><p>在这里，还有 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，我们可以使用它们来在放大动作期间或结束时进行响应。 作为属性，接收到的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">CGFloat</span> 的 <span style="background-color:rgba(27,31,35,.05);color:orangered;">MagnificationGesture.Value</span> 。 我们可以以此为例来更改视图大小。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b3ac91417d23226f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MagnificationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> magnifiedValue: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> magnification: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">MagnificationGesture</span>()</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = value</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = <span class="number">1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span> * magnifiedValue, height: <span class="number">100</span> * magnifiedValue)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .gesture(magnification)</span><br><span class="line">            .animation(.easeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转手势"><a href="#旋转手势" class="headerlink" title="旋转手势"></a>旋转手势</h2><p>旋转手势允许旋转视图，并在旋转过程中和旋转结束时以某些动作做出响应。</p><p>它还为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，这些闭包为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">RotationGesture.Value</span>，它表示手势 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Angle</span> 值。 我们可以使用该值旋转视图。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-0939ef2e20c537bf.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RotationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> angle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> backgroundAngle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rotation: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">RotationGesture</span>()</span><br><span class="line">            .onChanged &#123; angle <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.angle = angle</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; angle <span class="keyword">in</span></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.spring()) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.backgroundAngle = angle</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span>()</span><br><span class="line">            .frame(width: <span class="number">150</span>, height: <span class="number">150</span>, alignment: .center)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .rotationEffect(<span class="keyword">self</span>.angle)</span><br><span class="line">            .gesture(rotation)</span><br><span class="line">            .background(</span><br><span class="line">                <span class="type">Rectangle</span>()</span><br><span class="line">                    .shadow(color: .primary, radius: <span class="number">10</span>, x: <span class="number">0.0</span>, y: <span class="number">0.01</span>)</span><br><span class="line">                    .foregroundColor(.secondary)</span><br><span class="line">                    .rotationEffect(backgroundAngle)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是对  <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 基本手势的总结。我们可以实现更多的交互使我们的 App 变得更生动。</p><p>对于高级的使用，可以将手势组合或者同时使用以做出响应，或者可以实现自己的自定义手势。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt; 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。&lt;/p&gt;
&lt;p&gt;今天，我们将回顾&lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt;基本手势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TapGesture&lt;/li&gt;
&lt;li&gt;长按手势&lt;/li&gt;
&lt;li&gt;拖动手势&lt;/li&gt;
&lt;li&gt;放大手势&lt;/li&gt;
&lt;li&gt;旋转手势&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>解决 iOS 14.5 UDP广播 sendto 返回 -1</title>
    <link href="https://fanbaoying.github.io/%E8%A7%A3%E5%86%B3-iOS-14-5-UDP%E5%B9%BF%E6%92%AD-sendto-%E8%BF%94%E5%9B%9E-1/"/>
    <id>https://fanbaoying.github.io/解决-iOS-14-5-UDP广播-sendto-返回-1/</id>
    <published>2021-06-07T12:37:18.000Z</published>
    <updated>2021-06-07T12:45:39.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h3><ol><li>手机系统升级到 iOS 14.5 之后，UDP 广播发送失败</li><li>项目中老版本使用到 socket </li><li>项目中新版本使用 CocoaAsyncSocket</li><li>两种 UDP 发包方式都会报错 No route to host</li></ol><p><strong>报错具体内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendto: -1</span><br><span class="line">client: sendto fail, but just ignore it</span><br><span class="line">: No route to host</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><h5 id="2-1-sendto-返回-1-问题排查"><a href="#2-1-sendto-返回-1-问题排查" class="headerlink" title="2.1  sendto 返回 -1 问题排查"></a>2.1  sendto 返回 -1 问题排查</h5><p>我们知道发送广播 sendto 返回 -1，正常情况sendto 返回值大于 0 。<br>首先判断 socket 连接是否建立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._sck_fd4 = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">if (DEBUG_ON) &#123;</span><br><span class="line">     NSLog(@&quot;client init() _sck_fd4=%d&quot;,self._sck_fd4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>self._sck_fd4 打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server init(): _sck_fd4=12</span><br></pre></td></tr></table></figure><p>socket 连接正常，接下来判断数据发包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto(self._sck_fd4, bytes, dataLen, 0, (struct sockaddr*)&amp;target_addr, addr_len) = -1</span><br></pre></td></tr></table></figure><p>数据发送失败</p><h5 id="2-2-增加-NSLocalNetworkUsageDescription-权限"><a href="#2-2-增加-NSLocalNetworkUsageDescription-权限" class="headerlink" title="2.2  增加 NSLocalNetworkUsageDescription 权限"></a>2.2  增加 NSLocalNetworkUsageDescription 权限</h5><ol><li><p>Info.plist 添加 <strong>NSLocalNetworkUsageDescription</strong></p></li><li><p>发送一次UDP广播，触发权限弹框，让用户点击好，允许访问本地网络。</p></li></ol><p>发现问题依旧存在</p><h5 id="2-3-发送单播排查"><a href="#2-3-发送单播排查" class="headerlink" title="2.3 发送单播排查"></a>2.3 发送单播排查</h5><p>由于项目中发送广播设置的 hostName 为 255.255.255.255，为了排查决定先发送单播看是否能成功。</p><p>将单播地址改为 192.168.0.101 之后发现是可以发送成功的，然后在新版本 CocoaAsyncSocket 库中发送单播也是可以成功的。</p><p>UDP 广播推荐使用 192.168.0.255 ，将广播地址改了之后，问题解决了，设备可以收到 UDP 广播数据。</p><h3 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3. 问题解决"></a>3. 问题解决</h3><p>由于 192.168.0.255 广播地址只是当前本地地址，App 中需要动态改变前三段 192.168.0 本地地址，解决方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *localInetAddr4 = [ESP_NetUtil getLocalIPv4];</span><br><span class="line"><span class="built_in">NSArray</span> *arr = [localInetAddr4 componentsSeparatedByString:<span class="string">@"."</span>];</span><br><span class="line"><span class="built_in">NSString</span> *deviceAddress4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.%@.%@.255"</span>,arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]];</span><br></pre></td></tr></table></figure><p>发包过滤，只需要过滤地址最后一段是否为 255</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isBroadcast = [targetHostName hasSuffix:@&quot;255&quot;];</span><br></pre></td></tr></table></figure><p>本文已在公众号「<strong>网罗开发</strong>」发布，如需转载请加微信：FBY-fan，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题背景&quot;&gt;&lt;a href=&quot;#1-问题背景&quot; class=&quot;headerlink&quot; title=&quot;1. 问题背景&quot;&gt;&lt;/a&gt;1. 问题背景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;手机系统升级到 iOS 14.5 之后，UDP 广播发送失败&lt;/li&gt;
&lt;li&gt;项目中老版本使用到 socket &lt;/li&gt;
&lt;li&gt;项目中新版本使用 CocoaAsyncSocket&lt;/li&gt;
&lt;li&gt;两种 UDP 发包方式都会报错 No route to host&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;报错具体内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sendto: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client: sendto fail, but just ignore it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;: No route to host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>提升工作效率 Mac 上的必备工具</title>
    <link href="https://fanbaoying.github.io/%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87-Mac-%E4%B8%8A%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    <id>https://fanbaoying.github.io/提升工作效率-Mac-上的必备工具/</id>
    <published>2021-05-02T14:19:35.000Z</published>
    <updated>2021-05-02T16:27:08.033Z</updated>
    
    <content type="html"><![CDATA[<p>Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。</p><p><strong>1. UI调试神器–Reveal</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-b5b7a9d2be34f95e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Reveal是一个界面调试工具。使用Reveal，我们可以在iOS开发时动态地查看和修改应用程序的界面。</p><p>它类似Chrome的“审查元素”功能，我们不但可以在运行时看到iOS程序的界面层级关系，还可以实时地修改程序界面，不用重新运行程序就可以看到修改之后的效果。</p><p><strong>2. 接口调试–Postman</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-a5a8702aaf98cb9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>在我们平时开发中，特别是需要与接口打交道时，无论是写接口还是用接口，拿到接口后肯定都得提前测试一下，这样的话就非常需要有一个比较给力的 Http 请求模拟工具。</p><p>Postman 就是一种网页调试与发送网页 http 请求的 chrome 插件。我们可以用来很方便的模拟 get 或者 post 或者其他方式的请求来调试接口。</p><p><strong>3. 网络拦截–Charles</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-63b1ffa7970c6be1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Charles是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p><p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。很多iOS的高仿应用都是用Charles来拦截获取网络数据的。</p><p><strong>4. 取色工具–Sip</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-5eb2a353d61b4fe4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Sip 是全栈开发人员的利器，用户只需轻点鼠标便可快速取得屏幕当前位置的颜色值，并将数据自动存到剪切板，方便随时粘贴出来。支持 CSS、UIColor 等多种格式。</p><p><strong>5. JSON 生成数据模型工具–JSONExport</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-e6767b6bbec4d27d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>JSONExport 是一个 Mac OS X 应用，用 Swift 编写。它可以将 JSON 自动生成指定语言的 Model 类代码，包括属性，属性的getters和setters方法等。</p><p>不管你 json 数据多复杂，里面嵌套多少层，该工具都可以将它转换出来，这对于我们开发生成数据模型节省了不少时间。JSONExport 支持 OC、Swift、Java 等语言。</p><p><strong>6. Git 代码界面管理工具–SourceTree</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-33833817fdc9e7f9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>SourceTree 是 Windows 和 Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。</p><p>同时它也是 Mercurial 和 Subversion 版本控制系统工具。支持创建、提交、clone、push、pull 和 merge 等操作。</p><p><strong>7. Svn 代码界面管理工具–Cornerstone</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-f5d236668488ba03?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>CornerStone 是 Mac OS X 系统下非常好用的一款 svn 软件管理工具，当然还有 Versions 也是可以用的，但是使用起来不如 CornerStone 好用、强大。</p><p><strong>注意：</strong>CornerStone 是收费，如果是公司需要使用到，建议让公司购买软件使用版权，支持正版。本人所用的是公司购买了使用权的版本。当然网上也是有破解版本的。</p><p><div align="center"></div></p><p><strong style="font-size: 20px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">软 件 链 接</span></strong></p><p><img width="150" height="150" src="https://upload-images.jianshu.io/upload_images/2829694-2fd9a02d886dd857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><section><span style="font-size: 15px;">进入上方<strong><span style="color: rgb(255, 0, 0);">▲</span></strong><span style="background-color: rgb(255, 255, 255);letter-spacing: 1px;">二维码内，回复：<strong style="font-size: 16px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">427</span></strong></span></span></section><br><br><br></p><p><strong><img src="https://upload-images.jianshu.io/upload_images/19359146-e6227bdef1fb12f8?imageMogr2/auto-orient/strip" alt=""></strong> </p><h5 id="分享-6-个百度出品的免费工具，你用过几个？"><a href="#分享-6-个百度出品的免费工具，你用过几个？" class="headerlink" title="分享 6 个百度出品的免费工具，你用过几个？"></a><a href="https://mp.weixin.qq.com/s/SCcQjGgdohHsEaD3m5aegw" target="_blank" rel="noopener">分享 6 个百度出品的免费工具，你用过几个？</a></h5><h5 id="「ApowerREC」一款功能强大的录屏软件"><a href="#「ApowerREC」一款功能强大的录屏软件" class="headerlink" title="「ApowerREC」一款功能强大的录屏软件"></a><a href="https://mp.weixin.qq.com/s/Iq4WccudqFg_0wKJ6UvrnQ" target="_blank" rel="noopener">「ApowerREC」一款功能强大的录屏软件</a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. UI调试神器–Reveal&lt;/strong&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;im
      
    
    </summary>
    
      <category term="软件工具库" scheme="https://fanbaoying.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
    
      <category term="工具" scheme="https://fanbaoying.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 支付宝支付开发（最新版）</title>
    <link href="https://fanbaoying.github.io/iOS-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/iOS-支付宝支付开发（最新版）/</id>
    <published>2021-04-28T14:00:30.000Z</published>
    <updated>2021-04-28T14:05:43.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。</p><p>今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。</p><p>在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。<br>其实如果接入的多的话，那些套路都可以绕着走。<br>网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。</p><a id="more"></a><h2 id="2-交互流程"><a href="#2-交互流程" class="headerlink" title="2. 交互流程"></a>2. 交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是交互流程这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8688fd141e5c4425b1e07ef6d5363447~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115b15944b364a15a6948eb180f086b1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>支付宝支付的功能流程相比较微信支付来说简单的很，如上面两张图展示的，我们的 App（也就是商户客户端）所做的大概只有三个步骤：</p><ul><li>生成订单</li><li>调用支付宝接口，发送订单</li><li>返回订单支付结果并处理</li></ul><h2 id="3-下载支付宝-SDK"><a href="#3-下载支付宝-SDK" class="headerlink" title="3. 下载支付宝 SDK"></a>3. 下载支付宝 SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了最新的 SDK 地址<br><strong>注意</strong>的是下载出来的 SDK 包里面并没有传说中的开发文档，需要其他地方找或者看网页上的。</p><p>公钥、私钥、PID、sellerID、key这些东西的用途和获取方式在文档上都有详细的说明，这里不再赘述，一定要把概念分清楚再去做，不然一会就乱了。如果遇到问题的话咱们可以再一起探讨。</p><h2 id="4-导入库集成SDK"><a href="#4-导入库集成SDK" class="headerlink" title="4.  导入库集成SDK"></a>4.  导入库集成SDK</h2><h3 id="4-1-导入文件和关键库"><a href="#4-1-导入文件和关键库" class="headerlink" title="4.1 导入文件和关键库"></a>4.1 导入文件和关键库</h3><p><strong>通过 CocoaPods 导入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod  &apos;AlipaySDK-iOS&apos;</span><br></pre></td></tr></table></figure><p><strong>手动导入</strong></p><p>官方 demo 截图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36fb998958da4664a3cb2fca96a24958~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>添加 framework 和其他文件<br>打开 iOS 工程，新版本 SDK 文件 Order 文件，你需要复制粘贴到自己工程里的有：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li><li>Until 文件夹</li><li>openssl 文件夹</li><li>libcrypto.a 和 libssl.a</li></ul><p>上面的一部分文件在打开的项目中是看不到的，需要打开项目文件夹找到。</p><p>在 Build Phases 选项卡的 Link Binary With Libraries 中，增加以下依赖：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e052992193d427e91285f9187bddff7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>其中，需要注意的是：</p><ul><li>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；</li><li>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib（如下图）。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b43efaeb56c4339af14127460fcd0c4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>此时，假如你启动工程，很大几率上你会发现报 error 的情况。</p><h3 id="4-2-引入头文件"><a href="#4-2-引入头文件" class="headerlink" title="4.2 引入头文件"></a>4.2 引入头文件</h3><p>在需要调用 AlipaySDK 的文件中，增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在支付宝的接入文档中，是将生成一个订单这步放在客户端来做了，但这个最好是放在服务器端来做。</p><p>后台生成订单然后拼接，签名，然后服务器端直接给客户端传一个加密签名过的参数就可以了，这样比较安全。</p><p>所有的订单信息，商户信息等都掌握在自己的手中，这样的话APP端就不怕被拦截数据，并且调用起来也就特别简单了，只需要调用支付的接口。</p><p>如果只需要发送订单和处理支付返回结果，只需要添加 AlipaySDK.bundle 和AlipaySDK.framework 这两个就行了，下载的SDK中很容易发现。<br>快捷支付方法是这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)payOrder:(NSString *)orderStr fromScheme:(NSString *)schemeStr callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure><p>在支付的按钮中，使用支付宝这个类，再调用这个方法就行啦！如下如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="4-4-配置支付宝客户端返回-url-处理方法"><a href="#4-4-配置支付宝客户端返回-url-处理方法" class="headerlink" title="4.4 配置支付宝客户端返回 url 处理方法"></a>4.4 配置支付宝客户端返回 url 处理方法</h3><p>如示例 AliSDKDemo\APAppDelegate.m 文件中，增加引用代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><p>在 <em>@</em>implementation  AppDelegate 中以下代码中的 NSLog 改为实际业务处理代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-项目配置"><a href="#4-5-项目配置" class="headerlink" title="4.5 项目配置"></a>4.5 项目配置</h3><p>最后，不要忘了还要写一个 URL Scheme，在 Targets -&gt; Info 下最后一个即可找到，<br>点击 “Info” 选项卡，在 “URL Types ”选项中，点击 “+”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/743ffb1092bb4cc4ab6f845a7cb7bd55~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="5-常见问题汇总"><a href="#5-常见问题汇总" class="headerlink" title="5. 常见问题汇总"></a>5. 常见问题汇总</h2><h3 id="5-1-支付后无法返回-App"><a href="#5-1-支付后无法返回-App" class="headerlink" title="5.1 支付后无法返回 App"></a>5.1 支付后无法返回 App</h3><p>一般是由于白名单没有设置正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上方代码中 appScheme 参数需要和文章 <strong>4.5 项目配置</strong>中设置的 URL Schemes 相同，这样才能对应返回 App。</p><h3 id="5-2-include-not-find"><a href="#5-2-include-not-find" class="headerlink" title="5.2 #include  not find"></a>5.2 #include <openssl opensslconf.h=""> not find</openssl></h3><p>这是一个神奇的大坑，我Google了好久，也不得其解，然后经网友提醒之后想起来#import “”和#import &lt;&gt;的区别。</p><p><strong>解决方法</strong>：Targets -&gt; Build Settings 下的 Header Search Paths。<br>添加如下目录 “$(SRCROOT)/项目名称/文件的绝对地址”<br>如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40f0b9ba81d48bc8ded85bf2fe6ae1e~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p><h3 id="5-3-‘openssl-asn1-h’-file-not-found"><a href="#5-3-‘openssl-asn1-h’-file-not-found" class="headerlink" title="5.3 ‘openssl/asn1.h’ file not found"></a>5.3 ‘openssl/asn1.h’ file not found</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae746bcaf0c4c32ae80ed76429b6b2b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>由于在项目中引入 openssl 库，出现这个问题是因为库文件项目无法找到，只需要在 Header Search Paths 中加入 $(PROJECT_DIR)/项目名称/openssl 即可，如下图操作：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5732304211a5473b9b1ed4edf5e61b32~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-4-Undefined-symbol-OBJCMETACLASS-WKWebView"><a href="#5-4-Undefined-symbol-OBJCMETACLASS-WKWebView" class="headerlink" title="5.4 Undefined symbol: _OBJCMETACLASS$_WKWebView"></a>5.4 Undefined symbol: _OBJC<em>METACLASS</em>$_WKWebView</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15de4c63d16e49ba831d344be0e19e3c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>出现上面的问题，需要在项目配置中添加系统类库：WebKit.framework</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8cff9e3b44418cbb2979ec0e9a2de5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-5-如果遇到运行后报错，类似于以下提示信息："><a href="#5-5-如果遇到运行后报错，类似于以下提示信息：" class="headerlink" title="5.5 如果遇到运行后报错，类似于以下提示信息："></a>5.5 如果遇到运行后报错，类似于以下提示信息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot find interface declaration for &apos;NSObject&apos;, superclass of &apos;Base64&apos;</span><br></pre></td></tr></table></figure><p>那么需要打开报错了的文件，增加头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br></pre></td></tr></table></figure><h3 id="5-6-Swift-中接入-SDK-遇到的问题"><a href="#5-6-Swift-中接入-SDK-遇到的问题" class="headerlink" title="5.6 Swift 中接入 SDK 遇到的问题"></a>5.6 Swift 中接入 SDK 遇到的问题</h3><p>如果项目使用 Swift 为开发语言，需要添加桥接文件，如 Bridging-Header.h</p><p>同时，在项目 Build Settings 中设置桥接文件的位置。</p><p>运行时如果发生以下报错，则在桥接文件中，写入#import <uikit uikit.h=""></uikit></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d474efcd7f487887e925a06627a0b7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-7-点击支付跳转至支付宝卡在启动页面"><a href="#5-7-点击支付跳转至支付宝卡在启动页面" class="headerlink" title="5.7 点击支付跳转至支付宝卡在启动页面"></a>5.7 点击支付跳转至支付宝卡在启动页面</h3><p>出现这个情况被卡在的页面会出现相应错误提示，一般有以下几种情况：</p><ul><li>商品信息拼接字符串错误</li><li>支付账号过期待续费状态</li><li>商户 ID 错误</li><li>订单信息验签失败</li></ul><p>获取源码方式：关注「<strong>网罗开发</strong>」回复 “<strong>支付宝支付</strong>” 即可获取</p><p>本文已在公众号「<strong>网罗开发</strong>」发布，如果转载长白请加微信：FBY-fan，备注<strong>转载长白</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-d0f9c79727486cae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。&lt;/p&gt;
&lt;p&gt;今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。&lt;/p&gt;
&lt;p&gt;在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。&lt;br&gt;其实如果接入的多的话，那些套路都可以绕着走。&lt;br&gt;网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native视频播放器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native视频播放器插件/</id>
    <published>2018-12-16T10:00:59.000Z</published>
    <updated>2018-12-16T10:02:20.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生视频播放器插件的开发与使用。</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生视频播放器插件是需要实现打开js端调用播放方法传入的视频链接URL，具体的实现思路如下：</p><ol><li><p>新建mediaPlay类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>创建一个视频播放控制器</p></li><li><p>创建一个视频播放图层</p></li><li><p>将视频播放图层添加到父控件图层</p></li><li><p>JavaScript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建mediaPlay类，实现RCTBridgeModule协议"><a href="#1-新建mediaPlay类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建mediaPlay类，实现RCTBridgeModule协议"></a>1. 新建mediaPlay类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的mediaPlay类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface mediaPlay : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，mediaPlay的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“MediaPlay”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">RCT_EXPORT_METHOD(mediaPlayer:(NSDictionary*)arguments</span><br><span class="line">                           :(RCTResponseSenderBlock)sucessCallback</span><br><span class="line">                           :(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起原声视频播放器的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-创建一个视频播放控制器"><a href="#5-创建一个视频播放控制器" class="headerlink" title="5. 创建一个视频播放控制器"></a>5. 创建一个视频播放控制器</h5><p>视频播放器是使用iOS原声<avfoundation avfoundation.h="">来实现视频的播放，创建一个视频播放控制器代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(AVPlayerViewController *)playerVC</span><br><span class="line">&#123;</span><br><span class="line">    if (_playerVC == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个视频播放控制器</span><br><span class="line">        _playerVC = [[AVPlayerViewController alloc] init];</span><br><span class="line">        //获取视频URL（远程、本地视频URL都可以）</span><br><span class="line">        NSURL * url = [NSURL URLWithString:self.vedioURL];</span><br><span class="line">        //根据URL创建播放曲目</span><br><span class="line">        AVPlayerItem * item = [AVPlayerItem playerItemWithURL:url];</span><br><span class="line">        //创建一个视频播放器</span><br><span class="line">        AVPlayer * player = [AVPlayer playerWithPlayerItem:item];</span><br><span class="line">    &#125;</span><br><span class="line">    return _playerVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></avfoundation></p><h5 id="6-创建一个视频播放图层"><a href="#6-创建一个视频播放图层" class="headerlink" title="6. 创建一个视频播放图层"></a>6. 创建一个视频播放图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个视频播放图层</span><br><span class="line"> AVPlayerLayer * playLayer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br></pre></td></tr></table></figure><h5 id="7-将视频播放图层添加到父控件图层"><a href="#7-将视频播放图层添加到父控件图层" class="headerlink" title="7. 将视频播放图层添加到父控件图层"></a>7. 将视频播放图层添加到父控件图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将视频播放图层添加到父控件图层</span><br><span class="line"> [_playerVC.view.layer addSublayer:playLayer];</span><br><span class="line"> //设置视频播放控制器的播放器为player</span><br><span class="line"> _playerVC.player = player;</span><br></pre></td></tr></table></figure><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const MediaPlayPlugin = NativeModules.MediaPlay;</span><br><span class="line">MediaPlayPlugin.mediaPlayer(&#123;filePath:&quot;http://static.tripbe.com/videofiles/20121214/9533522808.f4v.mp4&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native FMDB数据库插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native-FMDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native-FMDB数据库插件/</id>
    <published>2018-12-16T09:59:40.000Z</published>
    <updated>2018-12-16T10:02:07.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍FMDB数据库插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>FMDB数据库插件是需要实现数据的新增、查询、修改、删除等功能，通过querySQLite方法来实现数据的查询，并将接口提供给Javascript开发使用</p><p>打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建DataBasePlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>判断数据库语句，适合使用那个数据库方法</p></li><li><p>创建数据库DataBase.db</p></li><li><p>打开数据库</p></li><li><p>执行sql语句</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建DataBasePlugin类，实现RCTBridgeModule协议"><a href="#1-新建DataBasePlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建DataBasePlugin类，实现RCTBridgeModule协议"></a>1. 新建DataBasePlugin类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的DataBasePlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface DataBasePlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，DataBasePlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“DataBasePlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(execSQLite:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;数据库常用语句执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(querySQLite:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;数据库查询语句执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-判断数据库语句，适合使用那个数据库方法"><a href="#5-判断数据库语句，适合使用那个数据库方法" class="headerlink" title="5. 判断数据库语句，适合使用那个数据库方法"></a>5. 判断数据库语句，适合使用那个数据库方法</h5><p>由于数据库查询语句中的查询参数，需要通过接口传入，并不是和sql语句一起传入，所以需要进行拼接，这就需要用到数据库查询方法querySQLite，因为查询语句中包含select字符串，因此作出如下判断：<br>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if([arguments[@&quot;sql&quot;] rangeOfString:@&quot;select&quot;].location !=NSNotFound)</span><br><span class="line">    &#123;</span><br><span class="line">        failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;请使用查询方法querySQLite进行查询&quot;&#125;]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="6-创建数据库DataBase-db"><a href="#6-创建数据库DataBase-db" class="headerlink" title="6. 创建数据库DataBase.db"></a>6. 创建数据库DataBase.db</h5><p>在导入第三方FMDB库之后，需要在DataBasePlugin.m引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FMDatabase.h&quot;</span><br></pre></td></tr></table></figure></p><p>实现数据库的第一步，创建数据表，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (FMDatabase *)db</span><br><span class="line">&#123;</span><br><span class="line">    if (!_db) &#123;</span><br><span class="line">        NSString *path = [[self getDocumentPath] stringByAppendingPathComponent:@&quot;DataBase.db&quot;];</span><br><span class="line">        _db = [FMDatabase databaseWithPath:path];</span><br><span class="line">    &#125;</span><br><span class="line">    return _db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-打开数据库"><a href="#7-打开数据库" class="headerlink" title="7. 打开数据库"></a>7. 打开数据库</h5><p>判断数据库表是否已创建，如果创建成功，或者已经存在数据表，即可打开数据库，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (self.db) &#123;</span><br><span class="line">            if ([self.db open]) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;打开数据库失败&quot;&#125;]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;数据库创建失败&quot;&#125;]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-执行sql语句"><a href="#8-执行sql语句" class="headerlink" title="8. 执行sql语句"></a>8. 执行sql语句</h5><p>在创建数据表和打开数据库成功之后，对Javascript传入的sql数据库语句进行处理执行，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL result = [self.db executeUpdate:sqlString];</span><br><span class="line">if (result) &#123;</span><br><span class="line">    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;执行SQL成功&quot;&#125;]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;执行SQL失败&quot;&#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-Javascript调用浏览器方法"><a href="#9-Javascript调用浏览器方法" class="headerlink" title="9. Javascript调用浏览器方法"></a>9. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const DataBasePlugin = NativeModules.DataBasePlugin;</span><br><span class="line">DataBasePlugin.execSQLite(&#123;sql:&quot;CREATE TABLE IF NOT EXISTS NotificatonTable (id integer PRIMARY KEY AUTOINCREMENT, status text NOT NULL, title text NOT NULL, content text NOT NULL, url text NOT NULL, time text NOT NULL, remark text NOT NULL)&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native手势密码插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E6%89%8B%E5%8A%BF%E5%AF%86%E7%A0%81%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native手势密码插件/</id>
    <published>2018-12-16T09:56:29.000Z</published>
    <updated>2018-12-16T10:02:12.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍手势密码插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>手势密码插件是需要实现可视页面控制器、设置手势密码、验证手势密码、密码sm3加密、密码本地保存等功能，这些功能加通过在PwdLockPlugin类中封装的SetPwdLock方法和DecryptLock方法来提供给Javascript开发使用。</p><p>具体的实现思路如下：</p><ol><li><p>新建PwdLockPlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>新建设置密码控制器</p></li><li><p>新建验证密码控制器</p></li><li><p>设置手势密码</p></li><li><p>验证手势密码</p></li><li><p>密码sm3加密</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>实现源码分析是根据上面列出的具体实现思路来为大家解刨内部的实现流程及核心代码分析。</p><h4 id="1-新建PwdLockPlugin类，实现RCTBridgeModule协议"><a href="#1-新建PwdLockPlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建PwdLockPlugin类，实现RCTBridgeModule协议"></a>1. 新建PwdLockPlugin类，实现RCTBridgeModule协议</h4><p>新建继承NSObject的PwdLockPlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface PwdLockPlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h4><p>为了实现RCTBridgeModule协议，PwdLockPlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“PwdLockPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &quot;PwdLockPlugin.h&quot;</span><br><span class="line">@implementation PwdLockPlugin</span><br><span class="line">RCT_EXPORT_MODULE(PwdLockPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h4><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h4 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h4><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。下面通过举例来展示声明的方法，通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &quot;PwdLockPlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation PwdLockPlugin</span><br><span class="line">RCT_EXPORT_MODULE(PwdLockPlugin);</span><br><span class="line">//设置手势密码</span><br><span class="line">RCT_EXPORT_METHOD(SetPwdLock:(RCTResponseSenderBlock)sucessCallback failCallback:(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">        NSLog(@&quot;调起设置密码方法&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">[CLLockVC showSettingLockVCInVC:RCTPresentedViewController() successBlock:^(CLLockVC *lockVC, NSString *pwd) &#123;</span><br><span class="line">[lockVC dismiss:0.0f];</span><br><span class="line">sucessCallback(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;密码设置成功&quot;&#125;]);</span><br><span class="line">                CIBNSLog(@&quot;%@&quot;,[self jsonStringWithDict:@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;密码设置成功&quot;&#125;]);</span><br><span class="line">//存储密码</span><br><span class="line">                pwd = [CLLockVC sm3:pwd];</span><br><span class="line">[CoreArchive setStr:pwd key:CoreLockPWDKey];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//验证手势密码</span><br><span class="line">RCT_EXPORT_METHOD(DecryptLock:(RCTResponseSenderBlock)sucessCallback failCallback:(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">        NSLog(@&quot;调起验证密码方法&quot;);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[CLLockVC showVerifyLockVCInVC:RCTPresentedViewController() forgetPwdBlock:^&#123;</span><br><span class="line">failCallback(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;手势密码三次验证失败&quot;&#125;]);</span><br><span class="line">&#125; successBlock:^(CLLockVC *lockVC, NSString *pwd) &#123;</span><br><span class="line">[lockVC dismiss:0.0f];</span><br><span class="line">sucessCallback(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;手势密码验证成功&quot;&#125;]);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="5-新建设置密码控制器"><a href="#5-新建设置密码控制器" class="headerlink" title="5. 新建设置密码控制器"></a>5. 新建设置密码控制器</h4><p>设置密码控制器是由3乘3的9个可触摸按钮实现，用户可以通过滑动屏幕来触动屏幕按钮，每个按钮有自己特有的编号（编号为0-9），通过触动按钮的先后顺序来记录手势密码，并将密码存储在本地。</p><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)showSettingLockVCInVC:(UIViewController *)vc successBlock:(void(^)(CLLockVC *lockVC,NSString *pwd))successBlock&#123;</span><br><span class="line">    CLLockVC *lockVC = [self lockVC:vc];</span><br><span class="line">    lockVC.title = @&quot;设置密码&quot;;</span><br><span class="line">    lockVC.type = CoreLockTypeSetPwd;</span><br><span class="line">    lockVC.successBlock = successBlock;</span><br><span class="line">    return lockVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-cad7f3f2a337dff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="1.png"></p><h4 id="6-新建验证密码控制器"><a href="#6-新建验证密码控制器" class="headerlink" title="6. 新建验证密码控制器"></a>6. 新建验证密码控制器</h4><p>验证密码控制器是由3乘3的9个可触摸按钮实现，用户可以通过滑动屏幕来触动屏幕按钮，每个按钮有自己特有的编号（编号为0-9），通过触动按钮的先后顺序来记录手势密码，通过和本地存储的密码进行对比验证是否一致，判断是否通过验证。</p><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)showVerifyLockVCInVC:(UIViewController *)vc forgetPwdBlock:(void(^)())forgetPwdBlock successBlock:(void(^)(CLLockVC *lockVC, NSString *pwd))successBlock&#123;</span><br><span class="line">    CLLockVC *lockVC = [self lockVC:vc];</span><br><span class="line">    lockVC.title = @&quot;手势解锁&quot;;</span><br><span class="line">    lockVC.type = CoreLockTypeVeryfiPwd;</span><br><span class="line">    lockVC.successBlock = successBlock;</span><br><span class="line">    lockVC.forgetPwdBlock = forgetPwdBlock;</span><br><span class="line">    return lockVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-8eac35c9db483377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="2.png"></p><h4 id="7-设置手势密码"><a href="#7-设置手势密码" class="headerlink" title="7. 设置手势密码"></a>7. 设置手势密码</h4><p>设置手势密码的滑动实现流程如下：</p><ul><li><ol><li>第一次滑动设置</li></ol></li><li><ol><li>再次确认滑动设置</li></ol></li><li><ol><li>检测密码长度是否符合要求（至少为四个点）</li></ol></li><li><ol><li>判断两次设置的密码是否一致</li></ol></li><li><ol><li>如果密码一致提示设置成功</li></ol></li><li><ol><li>如果不一致提示再次输入</li></ol></li><li><ol><li>将密码存储在本地</li></ol></li></ul><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//第一次滑动设置</span><br><span class="line">self.lockView.setPWBeginBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleFirst];</span><br><span class="line">&#125;;</span><br><span class="line">//再次确认滑动设置</span><br><span class="line">self.lockView.setPWConfirmlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleConfirm];</span><br><span class="line">&#125;;</span><br><span class="line">//检测密码长度是否符合要求（至少为四个点）</span><br><span class="line">self.lockView.setPWSErrorLengthTooShortBlock = ^(NSUInteger currentCount)&#123;</span><br><span class="line">    [self.label showWarnMsg:[NSString stringWithFormat:@&quot;请连接至少%@个点&quot;,@(CoreLockMinItemCount)]];</span><br><span class="line">&#125;;</span><br><span class="line">//判断两次设置的密码是否一致</span><br><span class="line">self.lockView.setPWSErrorTwiceDiffBlock = ^(NSString *pwd1,NSString *pwdNow)&#123;</span><br><span class="line">    [self.label showWarnMsg:CoreLockPWDDiffTitle];</span><br><span class="line">    self.navigationItem.rightBarButtonItem = self.resetItem;</span><br><span class="line">&#125;;</span><br><span class="line">//如果密码一致提示设置成功</span><br><span class="line">self.lockView.setPWFirstRightBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleConfirm];</span><br><span class="line">&#125;;</span><br><span class="line">//如果不一致提示再次输入</span><br><span class="line">self.lockView.setPWTwiceSameBlock = ^(NSString *pwd)&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWSuccessTitle];</span><br><span class="line">    //将密码存储在本地</span><br><span class="line">    [CoreArchive setStr:pwd key:CoreLockPWDKey];</span><br><span class="line">    self.view.userInteractionEnabled = NO;</span><br><span class="line">    if(_successBlock != nil) _successBlock(self,pwd);</span><br><span class="line">    if(CoreLockTypeModifyPwd == _type)&#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-验证手势密码"><a href="#8-验证手势密码" class="headerlink" title="8. 验证手势密码"></a>8. 验证手势密码</h4><p>验证手势密码的滑动实现流程如下：</p><ul><li><ol><li>滑动输入密码</li></ol></li><li><ol><li>检测密码长度是否符合要求（至少为四个点）</li></ol></li><li><ol><li>取出本地存储的密码</li></ol></li><li><ol><li>判断输入的密码和本地密码是否一致</li></ol></li><li><ol><li>如果一致返回验证成功</li></ol></li><li><ol><li>如果不一致提示重新验证</li></ol></li></ul><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//滑动输入密码</span><br><span class="line">self.lockView.verifyPWBeginBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockVerifyNormalTitle];</span><br><span class="line">&#125;;</span><br><span class="line">//检测密码长度是否符合要求（至少为四个点）</span><br><span class="line">self.lockView.verifyPwdBlock = ^(NSString *pwd)&#123;</span><br><span class="line">    //取出本地存储的密码</span><br><span class="line">    NSString *pwdLocal = [CoreArchive strForKey:CoreLockPWDKey];</span><br><span class="line">    BOOL res = [pwdLocal isEqualToString:pwd];</span><br><span class="line">    //判断输入的密码和本地密码是否一致</span><br><span class="line">    if(res)&#123;</span><br><span class="line">        [self.label showNormalMsg:CoreLockVerifySuccesslTitle];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [self.label showWarnMsg:CoreLockVerifyErrorPwdTitle];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9-密码sm3加密"><a href="#9-密码sm3加密" class="headerlink" title="9. 密码sm3加密"></a>9. 密码sm3加密</h4><p>对密码进行sm3加密，可以保证密码在传输过程中安全传输，实现源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *) sm3:(NSString *) input</span><br><span class="line">&#123;</span><br><span class="line">    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSData *outputData = [PwdLockSM3Coded sm3_hashWithPainData:inputData];</span><br><span class="line">    NSString *outputString = [CLLockVC convertDataToHexStr:outputData];</span><br><span class="line">    NSString *upper = [outputString uppercaseString];</span><br><span class="line">    return upper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-Javascript调用浏览器方法"><a href="#10-Javascript调用浏览器方法" class="headerlink" title="10. Javascript调用浏览器方法"></a>10. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const PwdLockPlugin = NativeModules.PwdLockPlugin;</span><br><span class="line">//设置手势密码</span><br><span class="line">PwdlockPlugin.SetPwdLock((msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br><span class="line">//验证手势密码</span><br><span class="line">PwdlockPlugin.DecryptLock((msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native浏览器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native浏览器插件/</id>
    <published>2018-12-16T09:34:19.000Z</published>
    <updated>2018-12-16T10:02:15.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生浏览器插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生浏览器插件是需要实现打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建WebviewManager类，实现自定义浏览器</p></li><li><p>新建Webview类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>URL规范检测</p></li><li><p>根据传参打开浏览器</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建WebviewManager类，实现自定义浏览器"><a href="#1-新建WebviewManager类，实现自定义浏览器" class="headerlink" title="1. 新建WebviewManager类，实现自定义浏览器"></a>1. 新建WebviewManager类，实现自定义浏览器</h5><p>新建继承UIViewController的WebviewManager类，并在.h声明webURL变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface WebviewManager : UIViewController</span><br><span class="line">@property(nonatomic,strong)NSString *webURL;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>通过webURL调用NSURLRequest 封装的requestWithURL方法打开浏览器，并在视图中显示，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.m</span><br><span class="line">#import &quot;WebviewManager.h&quot;</span><br><span class="line">#import&lt;WebKit/WebKit.h&gt;</span><br><span class="line">@interface WebviewManager ()</span><br><span class="line">@property(nonatomic,strong)WKWebView *webView;</span><br><span class="line">@end</span><br><span class="line">@implementation WebviewManager</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    btn.frame = CGRectMake(20, 30, 40, 24);</span><br><span class="line">    [btn setTitle:@&quot;返回&quot; forState:UIControlStateNormal];</span><br><span class="line">    [btn addTarget:self action:@selector(backAction)</span><br><span class="line">              forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    btn.titleLabel.font = [UIFont systemFontOfSize:15];</span><br><span class="line">    [btn setTitleColor:[UIColor blackColor]  forState:UIControlStateNormal];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line">    self.webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 64, [[UIScreen mainScreen]bounds].size.width, [[UIScreen mainScreen]bounds].size.height-64)];</span><br><span class="line">    [self.view addSubview:self.webView];</span><br><span class="line">    [self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:self.webURL]]];   </span><br><span class="line">&#125;</span><br><span class="line">- (void)backAction&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-新建Webview类，实现RCTBridgeModule协议"><a href="#2-新建Webview类，实现RCTBridgeModule协议" class="headerlink" title="2. 新建Webview类，实现RCTBridgeModule协议"></a>2. 新建Webview类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的Webview类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface Webview : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加RCT-EXPORT-MODULE-宏"><a href="#3-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="3. 添加RCT_EXPORT_MODULE()宏"></a>3. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，Webview的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“WebviewPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="4-添加React-Native跟控制器"><a href="#4-添加React-Native跟控制器" class="headerlink" title="4. 添加React Native跟控制器"></a>4. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="5-声明被JavaScript-调用的方法"><a href="#5-声明被JavaScript-调用的方法" class="headerlink" title="5. 声明被JavaScript 调用的方法"></a>5. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起打开浏览器方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="6-URL规范检测"><a href="#6-URL规范检测" class="headerlink" title="6. URL规范检测"></a>6. URL规范检测</h5><p>arguments字典是JavaScript调用方法传参用的，arguments字典里面的具体字段可以和JavaScript约定好，打开浏览器的url就是通过arguments字典传过来的，传过来的url字段还不能直接使用，需要检测是否符合url规范，否则是不能正常打开网页的。<br>URL规范检测代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)smartURLForString:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    NSString *     result;</span><br><span class="line">    NSString *  trimmedStr;</span><br><span class="line">    NSRange     schemeMarkerRange;</span><br><span class="line">    NSString *  scheme;</span><br><span class="line">    assert(str != nil);</span><br><span class="line">    result = nil;</span><br><span class="line">    trimmedStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br><span class="line">    if ( (trimmedStr != nil) &amp;&amp; (trimmedStr.length != 0) ) &#123;</span><br><span class="line">        schemeMarkerRange = [trimmedStr rangeOfString:@&quot;://&quot;];</span><br><span class="line">        if (schemeMarkerRange.location == NSNotFound) &#123;</span><br><span class="line">            result = [NSString stringWithFormat:@&quot;http://%@&quot;, trimmedStr];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scheme = [trimmedStr substringWithRange:NSMakeRange(0, schemeMarkerRange.location)];</span><br><span class="line">            assert(scheme != nil);</span><br><span class="line">            if ( ([scheme compare:@&quot;http&quot;  options:NSCaseInsensitiveSearch] == NSOrderedSame)</span><br><span class="line">                || ([scheme compare:@&quot;https&quot; options:NSCaseInsensitiveSearch] == NSOrderedSame) ) &#123;</span><br><span class="line">                result = trimmedStr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // It looks like this is some unsupported URL scheme.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-根据传参打开浏览器"><a href="#7-根据传参打开浏览器" class="headerlink" title="7. 根据传参打开浏览器"></a>7. 根据传参打开浏览器</h5><p>此浏览器插件支持打开自定义浏览器和打开默认浏览器，具体使用哪种方法打开浏览器，需要JavaScript通过arguments字典以字段的形式传过来，这里就使用openType字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    if ([arguments.allKeys containsObject:@&quot;url&quot;]) &#123;</span><br><span class="line">        NSString *url = [NSString stringWithFormat:@&quot;%@&quot;,arguments[@&quot;url&quot;]];</span><br><span class="line">        NSString *openURL = [self smartURLForString:url];</span><br><span class="line">        NSString *openType = arguments[@&quot;openType&quot;];</span><br><span class="line">        if (!ValidStr(url)&amp;&amp;!ValidStr(openType)) &#123;</span><br><span class="line">            CIBNSLog(@&quot;参数错误&quot;);</span><br><span class="line">            failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if ([openType isEqualToString:[NSString stringWithFormat:@&quot;0&quot;]]) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    WebviewManager *manager = [[WebviewManager alloc]init];</span><br><span class="line">                    manager.webURL = openURL;</span><br><span class="line">                    UIViewController *vc = RCTPresentedViewController();</span><br><span class="line">                    [vc presentViewController:manager animated:YES completion:nil];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSURL *urlStr = [NSURL URLWithString:openURL];</span><br><span class="line">                    [[UIApplication sharedApplication] openURL:urlStr];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const WebviewPlugin = NativeModules.WebviewPlugin;</span><br><span class="line">WebviewPlugin.open(&#123;url:&quot;http://www.baidu.com&quot;,openType:&quot;1&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native网络请求插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native网络请求插件/</id>
    <published>2018-12-16T09:11:01.000Z</published>
    <updated>2018-12-16T10:02:17.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍网络请求插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>网络请求插件是需要实现前端与服务端的数据交互，其中包括GET请求、POST请求、文件上传、单/多张图片上传、文件下载等功能。这些功能将通过封装后的方法暴漏出来，通过RN接口提供给Javascript开发使用。</p><p>具体的实现思路如下：</p><ol><li><p>新建NetWorkPlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>导入AFNetworking请求库</p></li><li><p>新建NetworkHelper类，封装实现网络请求功能</p></li><li><p>实现GET请求</p></li><li><p>实现POST请求</p></li><li><p>实现文件上传</p></li><li><p>实现单/多张图片上传</p></li><li><p>实现文件下载</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建NetWorkPlugin类，实现RCTBridgeModule协议"><a href="#1-新建NetWorkPlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建NetWorkPlugin类，实现RCTBridgeModule协议"></a>1. 新建NetWorkPlugin类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的NetWorkPlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface NetWorkPlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，NetWorkPlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“NetWorkPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。下面通过举例来展示声明的方法，通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(post:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;POST网络请求执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-导入AFNetworking请求库"><a href="#5-导入AFNetworking请求库" class="headerlink" title="5. 导入AFNetworking请求库"></a>5. 导入AFNetworking请求库</h5><p>网络请求使用的第三方库是AFNetworking，这个库很常见，也比较常用，就不做过多的描述，可手动导入也可使用cocoapods自动导入，导入之后在.m文件中引入头文件。</p><h5 id="6-新建NetworkHelper类，封装实现网络请求功能"><a href="#6-新建NetworkHelper类，封装实现网络请求功能" class="headerlink" title="6. 新建NetworkHelper类，封装实现网络请求功能"></a>6. 新建NetworkHelper类，封装实现网络请求功能</h5><p>新建继承NSObject的NetworkHelper类，定义枚举类型来判断网络状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NetworkStatusType) &#123;</span><br><span class="line">    /** 未知网络*/</span><br><span class="line">    NetworkStatusUnknown,</span><br><span class="line">    /** 无网络*/</span><br><span class="line">    NetworkStatusNotReachable,</span><br><span class="line">    /** 手机网络*/</span><br><span class="line">    NetworkStatusReachableViaWWAN,</span><br><span class="line">    /** WIFI网络*/</span><br><span class="line">    NetworkStatusReachableViaWiFi</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定义网络状态的Block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^NetworkStatus)(NetworkStatusType status);</span><br></pre></td></tr></table></figure></p><p>实时获取网络状态,通过Block回调实时获取(此方法可多次调用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkStatusWithBlock:(NetworkStatus)networkStatus;</span><br></pre></td></tr></table></figure></p><h5 id="7-实现GET请求"><a href="#7-实现GET请求" class="headerlink" title="7. 实现GET请求"></a>7. 实现GET请求</h5><p>声明GET请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)GET:(NSString *)URL</span><br><span class="line">                        parameters:(id)parameters</span><br><span class="line">                           success:(HttpRequestSuccess)success</span><br><span class="line">                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><h5 id="8-实现POST请求"><a href="#8-实现POST请求" class="headerlink" title="8. 实现POST请求"></a>8. 实现POST请求</h5><p>声明POST请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                         parameters:(id)parameters</span><br><span class="line">                            success:(HttpRequestSuccess)success</span><br><span class="line">                            failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>POST请求具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                parameters:(id)parameters</span><br><span class="line">                   success:(HttpRequestSuccess)success</span><br><span class="line">                   failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    [self setAFHTTPSessionManagerProperty:^(AFHTTPSessionManager *sessionManager) &#123;</span><br><span class="line">        [sessionManager.requestSerializer setQueryStringSerializationWithBlock:^NSString * _Nonnull(NSURLRequest * _Nonnull request, id  _Nonnull parameters, NSError * _Nullable __autoreleasing * _Nullable error) &#123;</span><br><span class="line">            return parameters;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-实现文件上传"><a href="#9-实现文件上传" class="headerlink" title="9. 实现文件上传"></a>9. 实现文件上传</h5><p>声明文件上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param names       文件对应服务器上的字段</span><br><span class="line"> *  @param filePaths   文件本地的沙盒路径</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                            names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                                        filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                                        progress:(HttpProgress)progress</span><br><span class="line">                                         success:(HttpRequestSuccess)success</span><br><span class="line">                                         failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>文件上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                             parameters:(id)parameters</span><br><span class="line">                                  names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                              filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                               progress:(HttpProgress)progress</span><br><span class="line">                                success:(HttpRequestSuccess)success</span><br><span class="line">                                failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; filePaths.count; i++) &#123;</span><br><span class="line">            NSString *name = names[i];</span><br><span class="line">            NSString *filePath = filePaths[i];</span><br><span class="line">            [formData appendPartWithFileURL:[NSURL fileURLWithPath:filePath] name:name error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        (failure &amp;&amp; error) ? failure(error) : nil;</span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        //上传进度</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="10-实现单-多张图片上传"><a href="#10-实现单-多张图片上传" class="headerlink" title="10. 实现单/多张图片上传"></a>10. 实现单/多张图片上传</h5><p>声明单/多张图片上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param name       图片对应服务器上的字段</span><br><span class="line"> *  @param images     图片数组</span><br><span class="line"> *  @param fileNames  图片文件名数组, 可以为nil, 数组内的文件名默认为当前日期时间&quot;yyyyMMddHHmmss&quot;</span><br><span class="line"> *  @param imageScale 图片文件压缩比 范围 (0.f ~ 1.f)</span><br><span class="line"> *  @param imageType  图片文件的类型,例:png、jpg(默认类型)....</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                                        parameters:(id)parameters</span><br><span class="line">                                              name:(NSString *)name</span><br><span class="line">                                            images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                         fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                                        imageScale:(CGFloat)imageScale</span><br><span class="line">                                         imageType:(NSString *)imageType</span><br><span class="line">                                          progress:(HttpProgress)progress</span><br><span class="line">                                           success:(HttpRequestSuccess)success</span><br><span class="line">                                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>图片经过等比压缩后得到的二进制文件，默认图片的文件名, 若fileNames为nil就使用，单/多张图片上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                               parameters:(id)parameters</span><br><span class="line">                                     name:(NSString *)name</span><br><span class="line">                                   images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                               imageScale:(CGFloat)imageScale</span><br><span class="line">                                imageType:(NSString *)imageType</span><br><span class="line">                                 progress:(HttpProgress)progress</span><br><span class="line">                                  success:(HttpRequestSuccess)success</span><br><span class="line">                                  failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line"></span><br><span class="line">        for (NSUInteger i = 0; i &lt; images.count; i++) &#123;</span><br><span class="line">            NSData *imageData = UIImageJPEGRepresentation(images[i], imageScale ?: 1.f);</span><br><span class="line"></span><br><span class="line">            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">            formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;</span><br><span class="line">            NSString *str = [formatter stringFromDate:[NSDate date]];</span><br><span class="line">            NSString *imageFileName = NSStringFormat(@&quot;%@%ld.%@&quot;,str,i,imageType?:@&quot;jpg&quot;);</span><br><span class="line"></span><br><span class="line">            [formData appendPartWithFileData:imageData</span><br><span class="line">                                        name:name</span><br><span class="line">                                    fileName:fileNames ? NSStringFormat(@&quot;%@.%@&quot;,fileNames[i],imageType?:@&quot;jpg&quot;) : imageFileName</span><br><span class="line">                                    mimeType:NSStringFormat(@&quot;image/%@&quot;,imageType ?: @&quot;jpg&quot;)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="11-实现文件下载"><a href="#11-实现文件下载" class="headerlink" title="11. 实现文件下载"></a>11. 实现文件下载</h5><p>声明文件下载方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL      请求地址</span><br><span class="line"> *  @param fileDir  文件存储目录(默认存储目录为Download)</span><br><span class="line"> *  @param progress 文件下载的进度信息</span><br><span class="line"> *  @param success  下载成功的回调(回调参数filePath:文件的路径)</span><br><span class="line"> *  @param failure  下载失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回NSURLSessionDownloadTask实例，可用于暂停继续，暂停调用suspend方法，开始下载调用resume方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                                       fileDir:(NSString *)fileDir</span><br><span class="line">                                      progress:(HttpProgress)progress</span><br><span class="line">                                       success:(void(^)(NSString *filePath))success</span><br><span class="line">                                       failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>在下载过程中可以获取到下载进度，下载流程为：缓存目录拼接完成，打开文件管理器，创建Download目录，拼接文件路径，返回文件位置的URL路径。文件下载具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                              fileDir:(NSString *)fileDir</span><br><span class="line">                             progress:(HttpProgress)progress</span><br><span class="line">                              success:(void(^)(NSString *))success</span><br><span class="line">                              failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:AllReplaceURL]];</span><br><span class="line">    __block NSURLSessionDownloadTask *downloadTask = [_sessionManager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(downloadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">        NSString *downloadDir = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileDir ? fileDir : @&quot;Download&quot;];</span><br><span class="line"></span><br><span class="line">        NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">        [fileManager createDirectoryAtPath:downloadDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line"></span><br><span class="line">        NSString *filePath = [downloadDir stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line"></span><br><span class="line">        return [NSURL fileURLWithPath:filePath];</span><br><span class="line"></span><br><span class="line">    &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        [[self allSessionTask] removeObject:downloadTask];</span><br><span class="line">        if(failure &amp;&amp; error) &#123;failure(error) ; return ;&#125;;</span><br><span class="line">        success ? success(filePath.absoluteString /** NSURL-&gt;NSString*/) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    [downloadTask resume];</span><br><span class="line">    downloadTask ? [[self allSessionTask] addObject:downloadTask] : nil ;</span><br><span class="line"></span><br><span class="line">    return downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="12-Javascript调用浏览器方法"><a href="#12-Javascript调用浏览器方法" class="headerlink" title="12. Javascript调用浏览器方法"></a>12. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const NetWorkPlugin = NativeModules.NetWorkPlugin;</span><br><span class="line">NetworkPlugin.post(&#123;url:&quot;http://192.168.1.1:8080/ApiSystem/login&quot;,params:&#123;name:&quot;15842137500&quot;,login_type:&quot;0&quot;,password:&quot;000000&quot;&#125;,headers:&#123;&#125;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-React Native 原生密码键盘插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native-%E5%8E%9F%E7%94%9F%E5%AF%86%E7%A0%81%E9%94%AE%E7%9B%98%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native-原生密码键盘插件/</id>
    <published>2018-12-08T12:48:03.000Z</published>
    <updated>2018-12-16T10:02:10.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生密码键盘插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生密码键盘插件是需要实现自定以键盘包含数字、大写字母、小写字母、特殊字符四种切换方式，并且需要实现随机键盘和非随机键盘模式。<br>实现根据密码包含数字、大写字母、小写字母、特殊字符种类判断密码强度和长度。<br>为了密码的安全考虑，实现对输出密码进行SM3加密。<br>实现键盘类型，其中包括以下6种类型：</p><blockquote><p> FBYCustomKeyBordType_NumWord,//数字及字母键盘<br>    FBYCustomKeyBordType_WordNum,//字母及数字键盘<br>    FBYCustomKeyBordType_NumWordSymbol,//数字及字母,标点键盘<br>    FBYCustomKeyBordType_WordNumSymbol,//字母及数字,标点键盘<br>    FBYCustomKeyBordType_Num,//仅数字键盘<br>    FBYCustomKeyBordType_Word//仅字母键盘</p></blockquote><p>基本键盘截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-439e92cad094e974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="66.png"></p><p>实现键盘视图显示类型，其中包括以下5种类型：</p><blockquote><p> FBYCustomKeyBordShowType_Common,//普通<br>    FBYCustomKeyBordShowType_Text,//文本框<br>    FBYCustomKeyBordShowType_Pass,//密码<br>    FBYCustomKeyBordShowType_PayPass,//支付密码格<br>    FBYCustomKeyBordShowType_NoTitle//无标题</p></blockquote><p>带有文本框的键盘：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-a49793a2fd35fc83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="88.png"></p><p>有支付密码格的键盘：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-a23509f64f8eda1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="99.png"></p><p>打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建CustomKeyboard类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>新建数字键盘FBYNumKeyBord类，实现相应视图及功能</p></li><li><p>新建字母键盘FBYWordKeyBord类，实现相应视图及功能</p></li><li><p>新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能</p></li><li><p>新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能</p></li><li><p>新建符号键盘FBYCustomKeyBord类，实现键盘类型切换功能</p></li><li><p>实现根据密码判断密码强度和长度功能</p></li><li><p>实现输出密码SM3加密功能</p></li><li><p>根据传参分析调用自定义键盘</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建CustomKeyboard类，实现RCTBridgeModule协议"><a href="#1-新建CustomKeyboard类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建CustomKeyboard类，实现RCTBridgeModule协议"></a>1. 新建CustomKeyboard类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的CustomKeyboard类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface CustomKeyboard : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，CustomKeyboard的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“KeybordPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(onKeyboard:(NSDictionary *)arguments</span><br><span class="line">                  :(RCTResponseSenderBlock)sucessCallback</span><br><span class="line">                  :(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起原生密码键盘方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-新建数字键盘FBYNumKeyBord类，实现相应视图及功能"><a href="#5-新建数字键盘FBYNumKeyBord类，实现相应视图及功能" class="headerlink" title="5. 新建数字键盘FBYNumKeyBord类，实现相应视图及功能"></a>5. 新建数字键盘FBYNumKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYNumKeyBord类中，视图包含0-9数字按钮、ABC字母切换按钮、@%#特殊字符切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-2417576b5300316d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="number.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//FBYNumKeyBord.m</span><br><span class="line">- (void)setRandom:(BOOL)random&#123;</span><br><span class="line">    _random = random;</span><br><span class="line">    if (random) &#123;</span><br><span class="line">        NSMutableArray *newArray = [NSMutableArray arrayWithArray:self.numArray];</span><br><span class="line">        for(int i = 0; i&lt; self.numArray.count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int m = (arc4random() % (self.numArray.count - i)) + i;</span><br><span class="line">            [newArray exchangeObjectAtIndex:i withObjectAtIndex: m];</span><br><span class="line">        &#125;</span><br><span class="line">        self.numArray = newArray;</span><br><span class="line">        for (UIButton *btn in self.subviews) &#123;</span><br><span class="line">            [btn removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">        [self addControl];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="6-新建字母键盘FBYWordKeyBord类，实现相应视图及功能"><a href="#6-新建字母键盘FBYWordKeyBord类，实现相应视图及功能" class="headerlink" title="6. 新建字母键盘FBYWordKeyBord类，实现相应视图及功能"></a>6. 新建字母键盘FBYWordKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYWordKeyBord类中，视图包含26个字母按钮、大小写切换按钮、123数字键盘切换按钮、@%#特殊字符切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-5c0e7fc781441217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="1234.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//FBYWordKeyBord.m</span><br><span class="line">for (int i = 0; i&lt; 26; i++) &#123;</span><br><span class="line">        FBYCustomKeyBordButton *btn = [FBYCustomKeyBordButton buttonWithTitle:self.wordArray[i] tag:i delegate:self];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchDown:) forControlEvents:(UIControlEventTouchDown)];</span><br><span class="line">         [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpOutside)];</span><br><span class="line">         [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchCancel)];</span><br><span class="line">        [btnArray addObject:btn];</span><br><span class="line">        [self addSubview:btn];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能"><a href="#7-新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能" class="headerlink" title="7. 新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能"></a>7. 新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYNumOnlyKeyBord类中，视图包含0-9数字按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-fe5cee6594182af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="0987.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//FBYNumOnlyKeyBord.m</span><br><span class="line">for (int i=0;i&lt;self.btnArray.count;i++) &#123;</span><br><span class="line">        UIButton *btn =self.btnArray[i];</span><br><span class="line">        if(i&lt;9)&#123;</span><br><span class="line">            btn.frame = CGRectMake(btn.tag % 3 * (btnW ), btn.tag / 3 * (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==9)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 1 * (btnW ),  3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==10)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 0* (btnW ),  3* (btnH ) , btnW, btnH);</span><br><span class="line"></span><br><span class="line">        &#125;else if (i==11)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 2* (btnW ), 3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==12)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 0* (btnW ), 3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能"><a href="#8-新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能" class="headerlink" title="8. 新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能"></a>8. 新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYSymbolKeyBord类中，视图包含30种特殊字符按钮、123数字键盘切换按钮、ABC字母切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-629be3c087db45af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="4321.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//FBYSymbolKeyBord.m</span><br><span class="line">- (NSArray *)symbolArray&#123;</span><br><span class="line">    if (!_symbolArray) &#123;</span><br><span class="line">        _symbolArray = @[@&quot;*&quot;,@&quot;/&quot;,@&quot;:&quot;,@&quot;;&quot;,@&quot;(&quot;,@&quot;)&quot;,@&quot;[&quot;,@&quot;]&quot;,@&quot;$&quot;,@&quot;=&quot;,@&quot;!&quot;,@&quot;^&quot;,@&quot;&amp;&quot;,@&quot;%&quot;,@&quot;+&quot;,@&quot;-&quot;,@&quot;￥&quot;,@&quot;?&quot;,@&quot;&#123;&quot;,@&quot;&#125;&quot;,@&quot;#&quot;,@&quot;_&quot;,@&quot;\\&quot;,@&quot;|&quot;,@&quot;~&quot;,@&quot;`&quot;,@&quot;∑&quot;,@&quot;€&quot;,@&quot;£&quot;,@&quot;。&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return _symbolArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addControl&#123;</span><br><span class="line">    NSMutableArray *btnArray = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">        FBYCustomKeyBordButton *btn = [FBYCustomKeyBordButton buttonWithTitle:self.symbolArray[i] tag:i delegate:self];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchDown:) forControlEvents:(UIControlEventTouchDown)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpOutside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchCancel)];</span><br><span class="line">        [self addSubview:btn];</span><br><span class="line">        [btnArray addObject:btn];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-新建FBYCustomKeyBord类，实现键盘类型切换功能"><a href="#9-新建FBYCustomKeyBord类，实现键盘类型切换功能" class="headerlink" title="9. 新建FBYCustomKeyBord类，实现键盘类型切换功能"></a>9. 新建FBYCustomKeyBord类，实现键盘类型切换功能</h5><p>FBYCustomKeyBord类中根据JS调用键盘时传入的参数，来实现何种键盘模式，实现键盘类型，共有6种类型：数字及字母、字母及数字、数字及字母特殊字符、字母及数字特殊字符、仅数字、仅字母。<br>键盘视图显示类型，共包括5种类型：普通、文本框、密码、支付密码格、无标题。<br>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-(void)setKeybordType:(FBYCustomKeyBordType)keybordType&#123;</span><br><span class="line">    _keybordType=keybordType;</span><br><span class="line">    [self.numPad removeFromSuperview];</span><br><span class="line">    if(_keybordType==FBYCustomKeyBordType_NumWord)&#123;</span><br><span class="line">        self.numPad.random=self.random;</span><br><span class="line">        self.numPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_WordNum)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_Num)&#123;</span><br><span class="line">        self.numOnlyPad.random=self.random;</span><br><span class="line">        self.numOnlyPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numOnlyPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_NumWordSymbol)&#123;</span><br><span class="line">        self.numPad.random=self.random;</span><br><span class="line">        self.numPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_Word)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;else if (keybordType==FBYCustomKeyBordType_WordNumSymbol)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="10-实现根据密码判断密码强度和长度功能"><a href="#10-实现根据密码判断密码强度和长度功能" class="headerlink" title="10. 实现根据密码判断密码强度和长度功能"></a>10. 实现根据密码判断密码强度和长度功能</h5><p>根据密码字符串获取其长度,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//FBYCustomKeyBord.m</span><br><span class="line">#pragma mark 长度计算</span><br><span class="line">-(NSUInteger)messageLength:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line"></span><br><span class="line">    NSUInteger length= msg.length;</span><br><span class="line">    NSLog(@&quot;%lu&quot;,(unsigned long)length);</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据密码字符串message，通过正则校验，判断字符串中包含几种字符，进而判断其密码强度。<br>总共是数字、大写字母、小写字母、特殊字符四种状态，包含两种强度为弱，包含三种强度为中，包含四种强度为强,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//FBYCustomKeyBord.m</span><br><span class="line">#pragma mark 强度计算</span><br><span class="line">-(NSUInteger)messageStrength:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line">    NSUInteger length= msg.length;</span><br><span class="line">    BOOL capitalBool = NO;</span><br><span class="line">    BOOL lowercaseBool = NO;</span><br><span class="line">    BOOL numberBool = NO;</span><br><span class="line">    BOOL stringBool = NO;</span><br><span class="line">    NSString* result1;</span><br><span class="line">    NSString* result2;</span><br><span class="line">    NSString* result3;</span><br><span class="line">    NSString* result4;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        char commitChar = [msg characterAtIndex:i];</span><br><span class="line">        if((commitChar&gt;64)&amp;&amp;(commitChar&lt;91))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有大写英文字母&quot;);</span><br><span class="line">            capitalBool = YES;</span><br><span class="line">        &#125;else if((commitChar&gt;96)&amp;&amp;(commitChar&lt;123))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有小写英文字母&quot;);</span><br><span class="line">            lowercaseBool = YES;</span><br><span class="line">        &#125;else if((commitChar&gt;47)&amp;&amp;(commitChar&lt;58))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有数字&quot;);</span><br><span class="line">            numberBool = YES;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有空格&quot;);</span><br><span class="line">            stringBool = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result1 = [NSString stringWithFormat:@&quot;%d&quot;,capitalBool];</span><br><span class="line">    result2 = [NSString stringWithFormat:@&quot;%d&quot;,lowercaseBool];</span><br><span class="line">    result3 = [NSString stringWithFormat:@&quot;%d&quot;,numberBool];</span><br><span class="line">    result4 = [NSString stringWithFormat:@&quot;%d&quot;,stringBool];</span><br><span class="line"></span><br><span class="line">    NSMutableArray* resultArray = [[NSMutableArray alloc] init];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result1]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result2]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result3]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result4]];</span><br><span class="line">    int intResult=0;</span><br><span class="line">    for (int j=0; j&lt;[resultArray count]; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([[resultArray objectAtIndex:j] isEqualToString:@&quot;1&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            intResult++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSUInteger result;</span><br><span class="line">    if (intResult == 4)&#123;</span><br><span class="line">        result = 3;</span><br><span class="line">    &#125;else if (intResult == 3)&#123;</span><br><span class="line">        result = 2;</span><br><span class="line">    &#125;else if (intResult == 2)&#123;</span><br><span class="line">        result = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="11-实现输出密码SM3加密功能"><a href="#11-实现输出密码SM3加密功能" class="headerlink" title="11. 实现输出密码SM3加密功能"></a>11. 实现输出密码SM3加密功能</h5><p> 这里的密码加密采用的是国密SM3加密方式，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 加密设置</span><br><span class="line">-(NSString *)encryptMessage:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line">    return [self sm3:msg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 对字符串做sm3处理</span><br><span class="line">- (NSString *) sm3:(NSString *) input</span><br><span class="line">&#123;</span><br><span class="line">    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSData *outputData = [CustomKBSM3Coded sm3_hashWithPainData:inputData];</span><br><span class="line">    //NSString *outputString = [GTMBase64 stringByEncodingData:outputData];</span><br><span class="line">    NSString *outputString = [self convertDataToHexStr:outputData];</span><br><span class="line">    NSString *upper = [outputString uppercaseString];</span><br><span class="line">    return upper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="12-根据传参打开浏览器"><a href="#12-根据传参打开浏览器" class="headerlink" title="12. 根据传参打开浏览器"></a>12. 根据传参打开浏览器</h5><p>此浏览器插件支持打开自定义浏览器和打开默认浏览器，具体使用哪种方法打开浏览器，需要JavaScript通过arguments字典以字段的形式传过来，这里就使用openType字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@interface CustomKeyboard ()&lt;FBYCustomKeyBordDelegate&gt;</span><br><span class="line">@property(strong,nonatomic)RCTResponseSenderBlock sucessCallback;</span><br><span class="line">@property(strong,nonatomic)RCTResponseSenderBlock failCallback;</span><br><span class="line">@property (nonatomic, strong) FBYCustomKeyBord *keyBoard;</span><br><span class="line">@property(assign,nonatomic)FBYCustomKeyBordType keybordType;</span><br><span class="line">@property(assign,nonatomic)FBYCustomKeyBordShowType keybordShowType;</span><br><span class="line">@property(strong,nonatomic)NSString *tag;</span><br><span class="line">@property(strong,nonatomic)NSString *isUp;</span><br><span class="line">@end</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.keyBoard = [FBYCustomKeyBord instance];</span><br><span class="line">        self.keyBoard.delegate = self;</span><br><span class="line">        self.sucessCallback = sucessCallback;</span><br><span class="line">        self.failCallback =  failCallback;</span><br><span class="line">        NSString *isUp=@&quot;1&quot;;</span><br><span class="line">        NSString *isRandom=@&quot;0&quot;;</span><br><span class="line">        NSString *type=@&quot;4&quot;;</span><br><span class="line">        NSString *showType=@&quot;0&quot;;</span><br><span class="line">        NSString *isEncrypt=@&quot;0&quot;;</span><br><span class="line">        //是否是随机键盘</span><br><span class="line">        self.keyBoard.random = YES;</span><br><span class="line">        self.keybordType = FBYCustomKeyBordType_Num;   </span><br><span class="line">        self.keybordShowType = FBYCustomKeyBordShowType_Common;     </span><br><span class="line">        self.keyBoard.keybordType = self.keybordType;</span><br><span class="line">        //弹起键盘或收起键盘</span><br><span class="line">        self.keyBoard.keybordShowType = self.keybordShowType;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if ((isUp==nil) || isUp.intValue == 1) &#123;</span><br><span class="line">                [self.keyBoard popKeyBordInParent:RCTPresentedViewController()];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [self.keyBoard disappearSwitchBtnClickWithBlock:^&#123;</span><br><span class="line">                    self.sucessCallback(@[@&#123;SucessReslutCode:@&quot;1&quot;,SucessData:@&quot;ok&quot;&#125;]);</span><br><span class="line">                    CIBNSLog(@&quot;成功调起密码键盘方法&quot;);</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//键盘数据回调</span><br><span class="line">-(void)customKeybord:(FBYCustomKeyBord *)keybord didReturnMessage:(NSString *)message withLength:(NSUInteger)length withStrength:(NSUInteger)strength&#123;</span><br><span class="line">    if(self.tag == nil)&#123;</span><br><span class="line">        self.tag = [CustomKeyboard getSecondTimeStringSince1970];</span><br><span class="line">    &#125;</span><br><span class="line">    if (![self.isUp isEqualToString:@&quot;0&quot;]) &#123;</span><br><span class="line">        self.sucessCallback(@[@&#123;SucessReslutCode:@&quot;1&quot;,SucessData:@&#123;@&quot;pwdLength&quot;:[NSString stringWithFormat:@&quot;%lu&quot;,(unsigned long)length],@&quot;pwdStrong&quot;:[NSString stringWithFormat:@&quot;%lu&quot;,strength],@&quot;pwdValue&quot;:message&#125;&#125;]);</span><br><span class="line">        NSLog(@&quot;成功调起密码键盘方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="13-Javascript调用浏览器方法"><a href="#13-Javascript调用浏览器方法" class="headerlink" title="13. Javascript调用浏览器方法"></a>13. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const CustomkeyBoardPlugin = NativeModules.KeybordPlugin;</span><br><span class="line">CustomkeyBoardPlugin.onKeyboard(&#123;isRandom:&quot;1&quot;,isUp:&quot;1&quot;,type:&quot;4&quot;,showType:&quot;3&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>第三方微信登录 | 静默授权与网页授权的实现</title>
    <link href="https://fanbaoying.github.io/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95-%E9%9D%99%E9%BB%98%E6%8E%88%E6%9D%83%E4%B8%8E%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fanbaoying.github.io/第三方微信登录-静默授权与网页授权的实现/</id>
    <published>2018-04-17T01:24:45.000Z</published>
    <updated>2018-04-17T01:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>第三方登录有QQ、微信、微博、支付宝等等，如果现在自己的项目中实现这些登录，即可以使用友盟的sdk，也可以一个一个接入，各有各的有点，这里不做赘述。</p><p>今天和大家分享的是，在项目中实现微信登录，虽然微信官网给出了接入文档，但是我在接入的过程中，遇到一些问题，在此做出总结以便大家参考。主要讲微信snsapi_base静默授权与snsapi_userinfo网页授权的实现。</p><a id="more"></a><h2 id="二：准备工作"><a href="#二：准备工作" class="headerlink" title="二：准备工作"></a>二：准备工作</h2><p>移动应用微信登录是基于OAuth2.0标准协议构建的微信OAuth2.0授权登录系统。</p><p>在进行微信OAuth2.0授权登录接入之前，需要完成一下工作才可以开始介接入：</p><ol><li>在微信开放平台注册开发者帐号；</li><li>拥有一个已审核通过的移动应用；</li><li>并获得相应的AppID和AppSecret；</li><li>申请微信登录且通过审核。</li></ol><h2 id="三：授权流程"><a href="#三：授权流程" class="headerlink" title="三：授权流程"></a>三：授权流程</h2><p>微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为：</p><ol><li>第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；</li><li>通过code参数加上AppID和AppSecret等，通过API换取access_token；</li><li>通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。</li></ol><p>获取access_token时序图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-006de32d62d4a298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="h.png"></p><h2 id="四：静默授权与网页授权的实现"><a href="#四：静默授权与网页授权的实现" class="headerlink" title="四：静默授权与网页授权的实现"></a>四：静默授权与网页授权的实现</h2><h4 id="1-静默授权与网页授权的区别"><a href="#1-静默授权与网页授权的区别" class="headerlink" title="1. 静默授权与网页授权的区别"></a>1. 静默授权与网页授权的区别</h4><p>网页授权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.scope = @&quot;snsapi_userinfo&quot;;</span><br></pre></td></tr></table></figure></p><p>静默授权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.scope = @&quot;snsapi_base&quot;;</span><br></pre></td></tr></table></figure></p><p>snsapi_base与snsapi_userinfo属于微信网页授权获取用户信息的两种作用域：</p><p>snsapi_base只能获取access_token和openID</p><p>snsapi_userinfo可以获取更详细的用户资料，比如头像、昵称、性别等</p><h4 id="2-获取CODE"><a href="#2-获取CODE" class="headerlink" title="2. 获取CODE"></a>2. 获取CODE</h4><p>再登录按钮的点击事件中写入一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//构造SendAuthReq结构体</span><br><span class="line">SendAuthReq* req =[[[SendAuthReq alloc]init]autorelease];</span><br><span class="line">req.scope = @&quot;snsapi_userinfo&quot;;</span><br><span class="line">req.state = @&quot;123&quot;;</span><br><span class="line">//第三方向微信终端发送一个SendAuthReq消息结构</span><br><span class="line">[WXApi sendReq:req];</span><br></pre></td></tr></table></figure><p>在AppDelegate的didFinishLaunchingWithOptions方法中注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WXApi registerApp:@&quot;wx1234567890&quot;];</span><br></pre></td></tr></table></figure><p>“wx1234567890”为appid，请更换为自己项目的appid</p><p>拉起微信打开授权登录页如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-fa107c90fd2394c5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>点击确认登陆，授权后回调 WXApiDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(void)onResp:(BaseReq *)resp</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     ErrCode ERR_OK = 0(用户同意)</span><br><span class="line">     ERR_AUTH_DENIED = -4（用户拒绝授权）</span><br><span class="line">     ERR_USER_CANCEL = -2（用户取消）</span><br><span class="line">     code    用户换取access_token的code，仅在ErrCode为0时有效</span><br><span class="line">     state   第三方程序发送时用来标识其请求的唯一性的标志，由第三方程序调用sendReq时传入，由微信终端回传，state字符串长度不能超过1K</span><br><span class="line">     lang    微信客户端当前语言</span><br><span class="line">     country 微信用户当前国家信息</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if ([resp isKindOfClass:[SendAuthResp class]]) //判断是否为授权请求，否则与微信支付等功能发生冲突</span><br><span class="line">    &#123;</span><br><span class="line">        SendAuthResp *aresp = (SendAuthResp *)resp;</span><br><span class="line">        if (aresp.errCode== 0)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;code %@&quot;,aresp.code);</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;wechatDidLoginNotification&quot; object:self userInfo:@&#123;@&quot;code&quot;:aresp.code&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用通知，将aresp.code传递到登录页面</p><h4 id="3-通过code获取access-token"><a href="#3-通过code获取access-token" class="headerlink" title="3. 通过code获取access_token"></a>3. 通过code获取access_token</h4><p>在登录页面通过通知，获取到code之后，请求以下链接获取access_token：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>appid：应用唯一标识，在微信开放平台提交应用审核通过后获得</li><li>secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</li><li>code：填写第一步获取的code参数</li><li>grant_type：填authorization_code</li></ul><p>网络请求返回的参数格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">&quot;expires_in&quot;:7200,</span><br><span class="line">&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;scope&quot;:&quot;SCOPE&quot;,</span><br><span class="line">&quot;unionid&quot;:&quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：接口调用凭证</li><li>expires_in：access_token接口调用凭证超时时间，单位（秒）</li><li>refresh_token：用户刷新access_token</li><li>openid：授权用户唯一标识</li><li>scope：用户授权的作用域，使用逗号（,）分隔</li><li>unionid：当且仅当该移动应用已获得该用户的userinfo授权时，才会出现该字段</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><p>1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）；<br>2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为；<br>3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。</p><p>还有就是要注意网络授权<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">网页授权access_token</a> 与 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">普通access_token</a>的区别：<br>1、网页授权的access_token在每次获取openID时一起更新，在接口调用频次限制中为“无上限”；<br>2、普通access_token一般限制为2000次/日，需要自己保存起来并定时更新。</p></blockquote><p>到这里同时获得access_token和openid，静默授权与网页授权操作都是一样的。根据官网文档，网页授权还可以进一步操作，获取用户更多详细信息。</p><h4 id="4-获取用户个人信息（UnionID机制）"><a href="#4-获取用户个人信息（UnionID机制）" class="headerlink" title="4. 获取用户个人信息（UnionID机制）"></a>4. 获取用户个人信息（UnionID机制）</h4><p>此接口用于获取用户个人信息，开发者可通过OpenID来获取用户基本信息，接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：调用凭证</li><li>openid：普通用户的标识，对当前开发者帐号唯一</li></ul><p>正确的Json返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;nickname&quot;:&quot;NICKNAME&quot;,</span><br><span class="line">&quot;sex&quot;:1,</span><br><span class="line">&quot;province&quot;:&quot;PROVINCE&quot;,</span><br><span class="line">&quot;city&quot;:&quot;CITY&quot;,</span><br><span class="line">&quot;country&quot;:&quot;COUNTRY&quot;,</span><br><span class="line">&quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span><br><span class="line">&quot;privilege&quot;:[</span><br><span class="line">&quot;PRIVILEGE1&quot;,</span><br><span class="line">&quot;PRIVILEGE2&quot;</span><br><span class="line">],</span><br><span class="line">&quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-静默授权获取到用户详细资料"><a href="#5-静默授权获取到用户详细资料" class="headerlink" title="5. 静默授权获取到用户详细资料"></a>5. 静默授权获取到用户详细资料</h4><p>在第3步通过snsapi_base，同时获得access_token和openid，</p><p>把这里的access_token和openid用于下面接口中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：调用凭证</li><li>openid：普通用户的标识，对当前开发者帐号唯一</li><li>lang：国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语，默认为zh-CN</li></ul><p>Json返回结果和snsapi_userinfo下获取的用户详情一样。</p><p>但是这个方法的前提是同一个公众号内，用户关注了，如果是其他公众号，还是需要用户点击授权的。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;第三方登录有QQ、微信、微博、支付宝等等，如果现在自己的项目中实现这些登录，即可以使用友盟的sdk，也可以一个一个接入，各有各的有点，这里不做赘述。&lt;/p&gt;
&lt;p&gt;今天和大家分享的是，在项目中实现微信登录，虽然微信官网给出了接入文档，但是我在接入的过程中，遇到一些问题，在此做出总结以便大家参考。主要讲微信snsapi_base静默授权与snsapi_userinfo网页授权的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>AVFoundation | 封装一个好用的视频播放器</title>
    <link href="https://fanbaoying.github.io/AVFoundation-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://fanbaoying.github.io/AVFoundation-封装一个好用的视频播放器/</id>
    <published>2018-04-06T07:25:43.000Z</published>
    <updated>2018-04-08T01:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="video.png"></p><p>上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。</p><a id="more"></a><ul><li><p>CoreAudio : 处理所有音频事件.是由多个框架整合在一起的总称,为音频和MIDI内容的录制,播放和处理提供相应接口.设置可以针对音频信号进行完全控制,并通过Audio Units来构建一些复杂的音频处理.有兴趣的可以单独了解一下这个框架。</p></li><li><p>CoreMedia: 是AVFoundation所用到低层级媒体管道的一部分.提供音频样本和视频帧处理所需的低层级数据类型和接口。</p></li><li><p>CoreAnimation: 动画相关框架, 封装了支持OpenGL和OpenGL ES功能的ObjC各种类. AVFoundation可以利用CoreAnimation让开发者能够在视频的编辑和播放过程中添加动画和图片效果。</p></li></ul><p>下面我就和大家详细的分享一下，如何使用AVFoundation来实现一个好用的视频播放器。如果好用或者对你有所帮助，不要忘了关注点个赞呦！！！</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>视频控制界面实现</p></li><li><p>用于视频显示的View创建</p></li><li><p>视频数据下载器FBYVideoDownload创建</p></li><li><p>播放、暂停、横竖屏操作方法实现</p></li><li><p>监听播放进度</p></li><li><p>控制存储缓冲范围</p></li><li><p>拖动滑块，控制快进快退</p></li><li><p>定义临时文件路径</p></li><li><p>定义缓存文件夹路径</p></li><li><p>发起视频路径网路请求方法</p></li><li><p>播放结束设置</p></li><li><p>前后视频播放控制</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-视频控制界面实现"><a href="#1-视频控制界面实现" class="headerlink" title="1. 视频控制界面实现"></a>1. 视频控制界面实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (FBYVideoPlayerView *)videoPlayControl&#123;</span><br><span class="line">    if (!_videoPlayControl) &#123;</span><br><span class="line">        _videoPlayControl = [[FBYVideoPlayerView alloc] initWithFrame:self.backgroundView.bounds];</span><br><span class="line">        [self.backgroundView addSubview:_videoPlayControl];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return _videoPlayControl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-用于视频显示的View创建"><a href="#2-用于视频显示的View创建" class="headerlink" title="2. 用于视频显示的View创建"></a>2. 用于视频显示的View创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)videoShowView&#123;</span><br><span class="line">    if (!_videoShowView) &#123;</span><br><span class="line">        _videoShowView = [[UIView alloc] init];</span><br><span class="line">        _videoShowView.layer.masksToBounds = YES;</span><br><span class="line">        [self.backgroundView addSubview:_videoShowView];</span><br><span class="line">    &#125;</span><br><span class="line">    return _videoShowView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-视频数据下载器FBYVideoDownload创建"><a href="#3-视频数据下载器FBYVideoDownload创建" class="headerlink" title="3. 视频数据下载器FBYVideoDownload创建"></a>3. 视频数据下载器FBYVideoDownload创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, weak) id &lt;FBYVideoDownloadDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">//定义初始化方法 传入videoUrl参数（NSString）</span><br><span class="line">- (instancetype)initWithURL:(NSString *)videoUrl withDelegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">//开始下载</span><br><span class="line">- (void)start;</span><br><span class="line">//暂停</span><br><span class="line">- (void)suspend;</span><br><span class="line">//关闭</span><br><span class="line">- (void)cancel;</span><br></pre></td></tr></table></figure><h4 id="4-播放、暂停、横竖屏操作方法实现"><a href="#4-播放、暂停、横竖屏操作方法实现" class="headerlink" title="4. 播放、暂停、横竖屏操作方法实现"></a>4. 播放、暂停、横竖屏操作方法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//全屏</span><br><span class="line">[_videoPlayControl setFullScreenButtonClick_block:^&#123;</span><br><span class="line">    if (weakSelf.delegate &amp;&amp; [weakSelf.delegate respondsToSelector:@selector(videoPlayerDidFullScreenButtonClick)]) &#123;</span><br><span class="line">        [weakSelf.delegate videoPlayerDidFullScreenButtonClick];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">//播放/暂停</span><br><span class="line">[_videoPlayControl setPlayButtonClick_block:^(BOOL play) &#123;</span><br><span class="line">    if (play) &#123;</span><br><span class="line">        [weakSelf.player play];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [weakSelf.player pause];</span><br><span class="line">    &#125;</span><br><span class="line">    weakSelf.playButtonState = !weakSelf.playButtonState;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="5-监听播放进度"><a href="#5-监听播放进度" class="headerlink" title="5. 监听播放进度"></a>5. 监听播放进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.timeObserve = [self.player addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) &#123;</span><br><span class="line">        CGFloat current = CMTimeGetSeconds(time);</span><br><span class="line">        CGFloat total = CMTimeGetSeconds(weakSelf.currentPlayerItem.duration);</span><br><span class="line">        CGFloat progress = current / total;</span><br><span class="line"></span><br><span class="line">        weakSelf.videoPlayControl.currentTime = current;</span><br><span class="line">        weakSelf.videoPlayControl.playValue = progress;</span><br><span class="line"></span><br><span class="line">        if (weakSelf.isCanToGetLocalTime) &#123;</span><br><span class="line">            weakSelf.localTime = [weakSelf getLocalTime];</span><br><span class="line">        &#125;</span><br><span class="line">        NSInteger timeNow = [weakSelf getLocalTime];</span><br><span class="line">        if (timeNow - weakSelf.localTime &gt; 1.5) &#123;</span><br><span class="line">            [weakSelf.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">            weakSelf.isCanToGetLocalTime = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h4 id="6-监听播放器的状态"><a href="#6-监听播放器的状态" class="headerlink" title="6. 监听播放器的状态"></a>6. 监听播放器的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="7-监听当前的缓冲进度"><a href="#7-监听当前的缓冲进度" class="headerlink" title="7. 监听当前的缓冲进度"></a>7. 监听当前的缓冲进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;loadedTimeRanges&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="8-监听到当前没有缓冲数据"><a href="#8-监听到当前没有缓冲数据" class="headerlink" title="8. 监听到当前没有缓冲数据"></a>8. 监听到当前没有缓冲数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;playbackBufferEmpty&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="9-控制存储缓冲范围"><a href="#9-控制存储缓冲范围" class="headerlink" title="9. 控制存储缓冲范围"></a>9. 控制存储缓冲范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)playForActivity&#123;</span><br><span class="line">    if (self.playButtonState) &#123;</span><br><span class="line">        [self.player play];</span><br><span class="line">    &#125;</span><br><span class="line">    self.isBufferEmpty = NO;</span><br><span class="line">    self.isPlaying = YES;</span><br><span class="line">    [self.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-拖动滑块，控制快进快退"><a href="#10-拖动滑块，控制快进快退" class="headerlink" title="10. 拖动滑块，控制快进快退"></a>10. 拖动滑块，控制快进快退</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//拖动滑块</span><br><span class="line">[_videoPlayControl setSliderTouchEnd_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">//快进快退</span><br><span class="line">[_videoPlayControl setFastFastForwardAndRewind_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure><h4 id="11-定义临时文件路径"><a href="#11-定义临时文件路径" class="headerlink" title="11. 定义临时文件路径"></a>11. 定义临时文件路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoTempPath = [NSString tempFilePathWithFileName:videoName];</span><br></pre></td></tr></table></figure><h4 id="12-定义缓存文件夹路径"><a href="#12-定义缓存文件夹路径" class="headerlink" title="12. 定义缓存文件夹路径"></a>12. 定义缓存文件夹路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoCachePath = [NSString cacheFilePathWithName:videoName];</span><br></pre></td></tr></table></figure><h4 id="13-发起视频路径网路请求方法"><a href="#13-发起视频路径网路请求方法" class="headerlink" title="13. 发起视频路径网路请求方法"></a>13. 发起视频路径网路请求方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendHttpRequst</span><br><span class="line">&#123;</span><br><span class="line">    [_fileHandle seekToEndOfFile];</span><br><span class="line">    NSURL *url = [NSURL URLWithString:_videoUrl];</span><br><span class="line">    NSMutableURLRequest *requeset = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    //指定头信息  当前已下载的进度</span><br><span class="line">    [requeset setValue:[NSString stringWithFormat:@&quot;bytes=%ld-&quot;, _curruentLength] forHTTPHeaderField:@&quot;Range&quot;];</span><br><span class="line"></span><br><span class="line">    //创建请求</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self.session dataTaskWithRequest:requeset];</span><br><span class="line">    self.dataTask = dataTask;</span><br><span class="line"></span><br><span class="line">    //发起请求</span><br><span class="line">    [self.dataTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-播放结束设置"><a href="#14-播放结束设置" class="headerlink" title="14. 播放结束设置"></a>14. 播放结束设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)playerItemDidPlayToEnd:(NSNotification *)notification&#123;</span><br><span class="line">    //重新开始播放</span><br><span class="line">    __weak typeof(self) weak_self = self;</span><br><span class="line">    [self.player seekToTime:CMTimeMake(0, 1) completionHandler:^(BOOL finished) &#123;</span><br><span class="line">        __strong typeof(weak_self) strong_self = weak_self;</span><br><span class="line">        if (!strong_self) return;</span><br><span class="line">        [strong_self.player play];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-前后视频播放控制"><a href="#15-前后视频播放控制" class="headerlink" title="15. 前后视频播放控制"></a>15. 前后视频播放控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//进入后台</span><br><span class="line">- (void)appDidEnterBackground&#123;</span><br><span class="line">    if (self.stopWhenAppDidEnterBackground) &#123;</span><br><span class="line">        [self pauseVideo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//进入前台</span><br><span class="line">- (void)appDidEnterForeground&#123;</span><br><span class="line">    [self playVideo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYVideoData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"><a href="#2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理" class="headerlink" title="2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"></a>2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYVideoPlayer.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;FBYVideoPlayerDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic ,strong) FBYVideoPlayer *videoPlayer;</span><br><span class="line">@property (nonatomic ,strong) UIView *videoPlayBGView;</span><br><span class="line">@property (nonatomic ,copy)   NSString*videoUrl;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-初始化创建基层view"><a href="#3-初始化创建基层view" class="headerlink" title="3. 初始化创建基层view"></a>3. 初始化创建基层view</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayBGView = [[UIView alloc] initWithFrame:CGRectMake(0, 90, SCREEN_WIDTH, SCREEN_WIDTH * 0.6)];</span><br><span class="line">self.videoPlayBGView.backgroundColor = [UIColor blackColor];</span><br><span class="line">    [self.view addSubview:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="4-初始化调用视频播放方法"><a href="#4-初始化调用视频播放方法" class="headerlink" title="4. 初始化调用视频播放方法"></a>4. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="5-初始化调用视频播放方法"><a href="#5-初始化调用视频播放方法" class="headerlink" title="5. 初始化调用视频播放方法"></a>5. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYVideoPlayer-iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;video.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>人脸识别 -- 活体检测(张嘴摇头识别)</title>
    <link href="https://fanbaoying.github.io/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%B4%BB%E4%BD%93%E6%A3%80%E6%B5%8B-%E5%BC%A0%E5%98%B4%E6%91%87%E5%A4%B4%E8%AF%86%E5%88%AB/"/>
    <id>https://fanbaoying.github.io/人脸识别-活体检测-张嘴摇头识别/</id>
    <published>2018-03-19T01:14:22.000Z</published>
    <updated>2018-03-19T01:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。</p><p>大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。</p><p>在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>点击识别按钮，调用相机</p></li><li><p>CameraRules类，检测相机权限</p></li><li><p>初始化页面，创建摄像页面，创建张嘴数据和摇头数据</p></li><li><p>开启识别，脸部框识别</p></li><li><p>脸部部位识别，脸部识别判断是否检测到人脸</p></li><li><p>检测到人脸之后，判断位置</p></li><li><p>位置判断合适，判断是否张嘴</p></li><li><p>张嘴判断完毕，验证是否摇头</p></li><li><p>摇头判断完毕，3秒倒计时拍照</p></li><li><p>拍照完毕，选择重拍或者上传图片</p></li><li><p>选择重拍重复5-9步骤，选择上传将图片数据回调</p></li><li><p>数据clean</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-点击识别按钮，调用相机"><a href="#1-点击识别按钮，调用相机" class="headerlink" title="1. 点击识别按钮，调用相机"></a>1. 点击识别按钮，调用相机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if([CameraRules isCapturePermissionGranted])&#123;</span><br><span class="line">        [self setDeviceAuthorized:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSString* info=@&quot;没有相机权限&quot;;</span><br><span class="line">            [self showAlert:info];</span><br><span class="line">            [self setDeviceAuthorized:NO];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-CameraRules类，检测相机权限"><a href="#2-CameraRules类，检测相机权限" class="headerlink" title="2. CameraRules类，检测相机权限"></a>2. CameraRules类，检测相机权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//检测相机权限</span><br><span class="line">+(BOOL)isCapturePermissionGranted&#123;</span><br><span class="line">    if([AVCaptureDevice respondsToSelector:@selector(authorizationStatusForMediaType:)])&#123;</span><br><span class="line">        AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];</span><br><span class="line">        if(authStatus ==AVAuthorizationStatusRestricted || authStatus ==AVAuthorizationStatusDenied)&#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(authStatus==AVAuthorizationStatusNotDetermined)&#123;</span><br><span class="line">            dispatch_semaphore_t sema = dispatch_semaphore_create(0);</span><br><span class="line">            __block BOOL isGranted=YES;</span><br><span class="line">            [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) &#123;</span><br><span class="line">                isGranted=granted;</span><br><span class="line">                dispatch_semaphore_signal(sema);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">            return isGranted;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据"><a href="#3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据" class="headerlink" title="3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据"></a>3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建摄像页面，创建张嘴数据和摇头数据</span><br><span class="line">[self faceUI];</span><br><span class="line">[self faceCamera];</span><br><span class="line">[self faceNumber];</span><br></pre></td></tr></table></figure><h4 id="4-开启识别，脸部框识别"><a href="#4-开启识别，脸部框识别" class="headerlink" title="4. 开启识别，脸部框识别"></a>4. 开启识别，脸部框识别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float cx = (left+right)/2;</span><br><span class="line">float cy = (top + bottom)/2;</span><br><span class="line">float w = right - left;</span><br><span class="line">float h = bottom - top;</span><br><span class="line">float ncx = cy ;</span><br><span class="line">float ncy = cx ;</span><br><span class="line"></span><br><span class="line">CGRect rectFace = CGRectMake(ncx-w/2 ,ncy-w/2 , w, h);</span><br><span class="line"></span><br><span class="line">if(!isFrontCamera)&#123;</span><br><span class="line">    rectFace=rSwap(rectFace);</span><br><span class="line">    rectFace=rRotate90(rectFace, faceImg.height, faceImg.width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL isNotLocation = [self identifyYourFaceLeft:left right:right top:top bottom:bottom];</span><br><span class="line"></span><br><span class="line">if (isNotLocation==YES) &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-脸部部位识别，脸部识别判断是否检测到人脸"><a href="#5-脸部部位识别，脸部识别判断是否检测到人脸" class="headerlink" title="5. 脸部部位识别，脸部识别判断是否检测到人脸"></a>5. 脸部部位识别，脸部识别判断是否检测到人脸</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for(id key in keys)&#123;</span><br><span class="line">    id attr=[landmarkDic objectForKey:key];</span><br><span class="line">    if(attr &amp;&amp; [attr isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line"></span><br><span class="line">        if(!isFrontCamera)&#123;</span><br><span class="line">            p=pSwap(p);</span><br><span class="line">            p=pRotate90(p, faceImg.height, faceImg.width);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isCrossBorder == YES) &#123;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        p=pScale(p, widthScaleBy, heightScaleBy);</span><br><span class="line"></span><br><span class="line">        [arrStrPoints addObject:NSStringFromCGPoint(p)];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-检测到人脸之后，判断位置动作提醒"><a href="#6-检测到人脸之后，判断位置动作提醒" class="headerlink" title="6. 检测到人脸之后，判断位置动作提醒"></a>6. 检测到人脸之后，判断位置动作提醒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if (right - left &lt; 230 || bottom - top &lt; 250) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太远了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else if (right - left &gt; 320 || bottom - top &gt; 320) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太近了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    if (isJudgeMouth != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复张嘴动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line"></span><br><span class="line">        if (left &lt; 100 || top &lt; 100 || right &gt; 460 || bottom &gt; 400) &#123;</span><br><span class="line">            isCrossBorder = YES;</span><br><span class="line">            isJudgeMouth = NO;</span><br><span class="line">            self.textLabel.text = @&quot;调整下位置先&quot;;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (isJudgeMouth == YES &amp;&amp; isShakeHead != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复摇头动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;shakeHead&quot; count:4];</span><br><span class="line">        number = 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        takePhotoNumber += 1;</span><br><span class="line">        if (takePhotoNumber == 2) &#123;</span><br><span class="line">            [self timeBegin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isCrossBorder = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-位置判断合适，判断是否张嘴"><a href="#7-位置判断合适，判断是否张嘴" class="headerlink" title="7. 位置判断合适，判断是否张嘴"></a>7. 位置判断合适，判断是否张嘴</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (rightX &amp;&amp; leftX &amp;&amp; upperY &amp;&amp; lowerY &amp;&amp; isJudgeMouth != YES) &#123;</span><br><span class="line"></span><br><span class="line">    number ++;</span><br><span class="line">    if (number == 1 || number == 300 || number == 600 || number ==900) &#123;</span><br><span class="line">        mouthWidthF = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">        mouthHeightF = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">        NSLog(@&quot;%d,%d&quot;,mouthWidthF,mouthHeightF);</span><br><span class="line">    &#125;else if (number &gt; 1200) &#123;</span><br><span class="line">        [self delateNumber];</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mouthWidth = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">    mouthHeight = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">    NSLog(@&quot;%d,%d&quot;,mouthWidth,mouthHeight);</span><br><span class="line">    NSLog(@&quot;张嘴前：width=%d，height=%d&quot;,mouthWidthF - mouthWidth,mouthHeight - mouthHeightF);</span><br><span class="line">    if (mouthWidth &amp;&amp; mouthWidthF) &#123;</span><br><span class="line"></span><br><span class="line">        if (mouthHeight - mouthHeightF &gt;= 20 &amp;&amp; mouthWidthF - mouthWidth &gt;= 15) &#123;</span><br><span class="line">            isJudgeMouth = YES;</span><br><span class="line">            imgView.animationImages = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-张嘴判断完毕，验证是否摇头"><a href="#8-张嘴判断完毕，验证是否摇头" class="headerlink" title="8. 张嘴判断完毕，验证是否摇头"></a>8. 张嘴判断完毕，验证是否摇头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if ([key isEqualToString:@&quot;mouth_middle&quot;] &amp;&amp; isJudgeMouth == YES) &#123;</span><br><span class="line"></span><br><span class="line">        if (bigNumber == 0 ) &#123;</span><br><span class="line">            firstNumber = p.x;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &gt; bigNumber) &#123;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &lt; smallNumber) &#123;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bigNumber - smallNumber &gt; 60) &#123;</span><br><span class="line">            isShakeHead = YES;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="9-摇头判断完毕，3秒倒计时拍照"><a href="#9-摇头判断完毕，3秒倒计时拍照" class="headerlink" title="9. 摇头判断完毕，3秒倒计时拍照"></a>9. 摇头判断完毕，3秒倒计时拍照</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(timeCount &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        self.textLabel.text = [NSString  stringWithFormat:@&quot;%ld s后拍照&quot;,(long)timeCount];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        [theTimer invalidate];</span><br><span class="line">        theTimer=nil;</span><br><span class="line"></span><br><span class="line">        [self didClickTakePhoto];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="10-拍照完毕，选择重拍或者上传图片"><a href="#10-拍照完毕，选择重拍或者上传图片" class="headerlink" title="10. 拍照完毕，选择重拍或者上传图片"></a>10. 拍照完毕，选择重拍或者上传图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickPhotoAgain</span><br><span class="line">&#123;</span><br><span class="line">    [self delateNumber];</span><br><span class="line"></span><br><span class="line">    [self.previewLayer.session startRunning];</span><br><span class="line">    self.textLabel.text = @&quot;请调整位置&quot;;</span><br><span class="line"></span><br><span class="line">    [backView removeFromSuperview];</span><br><span class="line"></span><br><span class="line">    isJudgeMouth = NO;</span><br><span class="line">    isShakeHead = NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-选择重拍重复5-9步骤，选择上传将图片数据回调"><a href="#11-选择重拍重复5-9步骤，选择上传将图片数据回调" class="headerlink" title="11. 选择重拍重复5-9步骤，选择上传将图片数据回调"></a>11. 选择重拍重复5-9步骤，选择上传将图片数据回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickUpPhoto</span><br><span class="line">&#123;</span><br><span class="line">    //上传照片成功</span><br><span class="line">    [self.faceDelegate sendFaceImage:imageView.image];</span><br><span class="line">    [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-数据clean"><a href="#12-数据clean" class="headerlink" title="12. 数据clean"></a>12. 数据clean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)delateNumber</span><br><span class="line">&#123;</span><br><span class="line">    number = 0;</span><br><span class="line">    takePhotoNumber = 0;</span><br><span class="line"></span><br><span class="line">    mouthWidthF = 0;</span><br><span class="line">    mouthHeightF = 0;</span><br><span class="line">    mouthWidth = 0;</span><br><span class="line">    mouthHeight = 0;</span><br><span class="line"></span><br><span class="line">    smallNumber = 0;</span><br><span class="line">    bigNumber = 0;</span><br><span class="line">    firstNumber = 0;</span><br><span class="line"></span><br><span class="line">    imgView.animationImages = nil;</span><br><span class="line">    imgView.image = [UIImage imageNamed:@&quot;shakeHead0&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：讯飞SDK下载及配置"><a href="#四：讯飞SDK下载及配置" class="headerlink" title="四：讯飞SDK下载及配置"></a>四：讯飞SDK下载及配置</h2><h4 id="1-SDK下载"><a href="#1-SDK下载" class="headerlink" title="1. SDK下载"></a>1. SDK下载</h4><p>因为项目中使用到讯飞人脸识别SDK，需要去<a href="http://console.xfyun.cn/app/edit?appId=NWFhNjI3OTM%3D&amp;appName=RkJZRmFjZVJlY29nbml0aW9uX2lPUw%3D%3D" target="_blank" rel="noopener">讯飞开放平台</a>创建应用，下载SDK。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b10687203a879c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><h4 id="2-添加系统库"><a href="#2-添加系统库" class="headerlink" title="2. 添加系统库"></a>2. 添加系统库</h4><p>将开发工具包中lib目录下的iflyMSC.framework添加到工程中。同时请将Demo中依赖的其他库也添加到工程中。 按下图示例添加 SDK 所需要的 iOS系统库：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-93809e5d166a1633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="88.png"></p><h4 id="3-设置Bitcode"><a href="#3-设置Bitcode" class="headerlink" title="3. 设置Bitcode"></a>3. 设置Bitcode</h4><p>在Targets - Build Settings 中搜索Bitcode 即可，找到相应选项，设置为NO，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-3414999985ccd080.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="333.jpg"></p><h4 id="4-用户隐私权限配置"><a href="#4-用户隐私权限配置" class="headerlink" title="4. 用户隐私权限配置"></a>4. 用户隐私权限配置</h4><p>在Info.plist 中增加下图设置：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-19d0d89539d05cbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="444.png"></p><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYFaceData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYFaceRecognitionViewController"><a href="#2-在项目中引入FBYFaceRecognitionViewController" class="headerlink" title="2. 在项目中引入FBYFaceRecognitionViewController"></a>2. 在项目中引入FBYFaceRecognitionViewController</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYFaceRecognitionViewController.h&quot;</span><br></pre></td></tr></table></figure><h4 id="3-在项目识别按钮的点击事件中添加代码"><a href="#3-在项目识别按钮的点击事件中添加代码" class="headerlink" title="3. 在项目识别按钮的点击事件中添加代码"></a>3. 在项目识别按钮的点击事件中添加代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)pushToFaceStreamDetectorVC</span><br><span class="line">&#123;</span><br><span class="line">    FBYFaceRecognitionViewController *faceVC = [[FBYFaceRecognitionViewController alloc]init];</span><br><span class="line">    faceVC.faceDelegate = self;</span><br><span class="line">    [self.navigationController pushViewController:faceVC animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-图片回调函数"><a href="#4-图片回调函数" class="headerlink" title="4. 图片回调函数"></a>4. 图片回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)sendFaceImage:(UIImage *)faceImage</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;图片上传成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendFaceImageError &#123;</span><br><span class="line">    NSLog(@&quot;图片上传失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYFaceRecognitionDemo_iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。&lt;/p&gt;
&lt;p&gt;大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。&lt;/p&gt;
&lt;p&gt;在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 识别集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%AF%86%E5%88%AB%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 实现点击图片放大</title>
    <link href="https://fanbaoying.github.io/iOS-%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7/"/>
    <id>https://fanbaoying.github.io/iOS-实现点击图片放大/</id>
    <published>2018-03-06T02:02:13.000Z</published>
    <updated>2018-03-06T02:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>给UIImageView添加手势</p></li><li><p>封装一个继承NSObject的FBYImageZoom类</p></li><li><p>写一个函数用来接收出入的UIImageView</p></li><li><p>根据传入的UIImageView重新绘制在Window中</p></li><li><p>添加放大后背景视图的颜色和透明度</p></li><li><p>使用动画放大展示ImageView</p></li><li><p>添加恢复ImageView原始尺寸的tap点击事件</p></li><li><p>完成之后将背景视图删掉</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-给UIImageView添加手势"><a href="#1-给UIImageView添加手势" class="headerlink" title="1. 给UIImageView添加手势"></a>1. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.myImageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 150, SCREEN_WIDTH-100, SCREEN_WIDTH-100)];</span><br><span class="line">self.myImageView.image = [UIImage imageNamed:@&quot;bankcard&quot;];</span><br><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br><span class="line">[_myImageView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line">[_myImageView setUserInteractionEnabled:YES];</span><br><span class="line">[self.view addSubview:_myImageView];</span><br></pre></td></tr></table></figure><h4 id="2-封装一个继承NSObject的FBYImageZoom类"><a href="#2-封装一个继承NSObject的FBYImageZoom类" class="headerlink" title="2. 封装一个继承NSObject的FBYImageZoom类"></a>2. 封装一个继承NSObject的FBYImageZoom类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYImageZoom : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-写一个函数用来接收出入的UIImageView"><a href="#3-写一个函数用来接收出入的UIImageView" class="headerlink" title="3. 写一个函数用来接收出入的UIImageView"></a>3. 写一个函数用来接收出入的UIImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @param contentImageview 图片所在的imageView</span><br><span class="line"> */</span><br><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview;</span><br></pre></td></tr></table></figure><h4 id="4-根据传入的UIImageView重新绘制在Window中"><a href="#4-根据传入的UIImageView重新绘制在Window中" class="headerlink" title="4. 根据传入的UIImageView重新绘制在Window中"></a>4. 根据传入的UIImageView重新绘制在Window中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview&#123;</span><br><span class="line"></span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    [self scanBigImageWithImage:contentImageview.image frame:[contentImageview convertRect:contentImageview.bounds toView:window]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-添加放大后背景视图的颜色和透明度"><a href="#5-添加放大后背景视图的颜色和透明度" class="headerlink" title="5. 添加放大后背景视图的颜色和透明度"></a>5. 添加放大后背景视图的颜色和透明度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当前视图</span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    //背景</span><br><span class="line">    UIView *backgroundView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">    [backgroundView setBackgroundColor:[UIColor colorWithRed:107/255.0 green:107/255.0 blue:99/255.0 alpha:0.6]];</span><br></pre></td></tr></table></figure><h4 id="6-使用动画放大展示ImageView"><a href="#6-使用动画放大展示ImageView" class="headerlink" title="6. 使用动画放大展示ImageView"></a>6. 使用动画放大展示ImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//动画放大所展示的ImageView</span><br><span class="line">[UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">    CGFloat y,width,height;</span><br><span class="line">    y = ([UIScreen mainScreen].bounds.size.height - image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width) * 0.5;</span><br><span class="line">    //宽度为屏幕宽度</span><br><span class="line">    width = [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">    //高度 根据图片宽高比设置</span><br><span class="line">    height = image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width;</span><br><span class="line">    [imageView setFrame:CGRectMake(0, y, width, height)];</span><br><span class="line">    //重要！ 将视图显示出来</span><br><span class="line">    [backgroundView setAlpha:1];</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="7-添加恢复ImageView原始尺寸的tap点击事件"><a href="#7-添加恢复ImageView原始尺寸的tap点击事件" class="headerlink" title="7. 添加恢复ImageView原始尺寸的tap点击事件"></a>7. 添加恢复ImageView原始尺寸的tap点击事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件同样是类方法 -&gt; 作用是再次点击回到初始大小</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hideImageView:)];</span><br><span class="line">[backgroundView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  恢复imageView原始尺寸</span><br><span class="line"> */</span><br><span class="line">+(void)hideImageView:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    UIView *backgroundView = tap.view;</span><br><span class="line">    //原始imageview</span><br><span class="line">    UIImageView *imageView = [tap.view viewWithTag:1024];</span><br><span class="line">    //恢复</span><br><span class="line">    [UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">        [imageView setFrame:oldframe];</span><br><span class="line">        [backgroundView setAlpha:0];</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        [backgroundView removeFromSuperview];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-完成之后将背景视图删掉"><a href="#8-完成之后将背景视图删掉" class="headerlink" title="8. 完成之后将背景视图删掉"></a>8. 完成之后将背景视图删掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//完成后操作-&gt;将背景视图删掉</span><br><span class="line">[backgroundView removeFromSuperview];</span><br></pre></td></tr></table></figure><h2 id="四：项目实际使用"><a href="#四：项目实际使用" class="headerlink" title="四：项目实际使用"></a>四：项目实际使用</h2><h4 id="1-引入封装类FBYImageZoom"><a href="#1-引入封装类FBYImageZoom" class="headerlink" title="1. 引入封装类FBYImageZoom"></a>1. 引入封装类FBYImageZoom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYImageZoom.h&quot;</span><br></pre></td></tr></table></figure><h4 id="2-给UIImageView添加手势"><a href="#2-给UIImageView添加手势" class="headerlink" title="2. 给UIImageView添加手势"></a>2. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br></pre></td></tr></table></figure><h4 id="3-调用封装类函数"><a href="#3-调用封装类函数" class="headerlink" title="3. 调用封装类函数"></a>3. 调用封装类函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//浏览大图点击事件</span><br><span class="line">-(void)scanBigImageClick:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    NSLog(@&quot;点击图片&quot;);</span><br><span class="line">    UIImageView *clickedImageView = (UIImageView *)tap.view;</span><br><span class="line">    [FBYImageZoom ImageZoomWithImageView:clickedImageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里点击图片放大到全屏就完成了</p><h2 id="五：项目展示"><a href="#五：项目展示" class="headerlink" title="五：项目展示"></a>五：项目展示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161f900f7b9f73d6?w=300&amp;h=500&amp;f=gif&amp;s=1992499" alt=""></p><h4 id="六-本篇文章demo源码："><a href="#六-本篇文章demo源码：" class="headerlink" title="六. 本篇文章demo源码："></a>六. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYImageZoom-iOS" target="_blank" rel="noopener">github demo</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIDatePicker | 时间选择器</title>
    <link href="https://fanbaoying.github.io/iOS-UIDatePicker%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85/"/>
    <id>https://fanbaoying.github.io/iOS-UIDatePicker的使用详情/</id>
    <published>2018-02-09T07:25:17.000Z</published>
    <updated>2021-06-07T12:43:18.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：UIDatePicker的介绍"><a href="#一：UIDatePicker的介绍" class="headerlink" title="一：UIDatePicker的介绍"></a>一：UIDatePicker的介绍</h2><p>UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。<br>日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。<br>你也可以对其进行定制，令其使用任何范围的日期。</p><p>UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。<br>iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。<br>使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。<br>UIDatePicker给出了倒计时模式，但是并没有实现相关事件。<br>如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。</p><a id="more"></a><h2 id="二：UIDatePicker的使用"><a href="#二：UIDatePicker的使用" class="headerlink" title="二：UIDatePicker的使用"></a>二：UIDatePicker的使用</h2><h2 id="2-1-创建并添加一个UIDatePicker对象"><a href="#2-1-创建并添加一个UIDatePicker对象" class="headerlink" title="2.1 创建并添加一个UIDatePicker对象"></a>2.1 创建并添加一个UIDatePicker对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  DatePicker</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">//创建对象</span><br><span class="line">@property (nonatomic, strong) UIDatePicker *datePicker;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="2-2-配置UIDatePicker对象"><a href="#2-2-配置UIDatePicker对象" class="headerlink" title="2.2 配置UIDatePicker对象"></a>2.2 配置UIDatePicker对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupDateKeyPan &#123;</span><br><span class="line"></span><br><span class="line">    UIDatePicker *datePicker = [[UIDatePicker alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置地区: zh-中国</span><br><span class="line">    datePicker.locale = [NSLocale localeWithLocaleIdentifier:@&quot;zh&quot;];</span><br><span class="line"></span><br><span class="line">    //设置日期模式(Displays month, day, and year depending on the locale setting)</span><br><span class="line">    datePicker.datePickerMode = UIDatePickerModeCountDownTimer;</span><br><span class="line">    // 设置当前显示时间</span><br><span class="line">    [datePicker setDate:[NSDate date] animated:YES];</span><br><span class="line">    // 设置显示最大时间（此处为当前时间）</span><br><span class="line">    [datePicker setMaximumDate:[NSDate date]];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line"></span><br><span class="line">    //监听DataPicker的滚动</span><br><span class="line">    [datePicker addTarget:self action:@selector(dateChange:) forControlEvents:UIControlEventValueChanged];</span><br><span class="line"></span><br><span class="line">    self.datePicker = datePicker;</span><br><span class="line"></span><br><span class="line">    //设置时间输入框的键盘框样式为时间选择器</span><br><span class="line">    self.timeTextField.inputView = datePicker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-禁止用户输入文字"><a href="#2-3-禁止用户输入文字" class="headerlink" title="2.3 禁止用户输入文字"></a>2.3 禁止用户输入文字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//禁止用户输入文字</span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">  return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-显示文本"><a href="#2-4-显示文本" class="headerlink" title="2.4 显示文本"></a>2.4 显示文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)dateChange:(UIDatePicker *)datePicker &#123;</span><br><span class="line"></span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line">    formatter.dateFormat = @&quot;yyyy年 MM月 dd日&quot;;</span><br><span class="line">    NSString *dateStr = [formatter  stringFromDate:datePicker.date];</span><br><span class="line"></span><br><span class="line">    self.timeTextField.text = dateStr;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="三：选择模式"><a href="#三：选择模式" class="headerlink" title="三：选择模式"></a>三：选择模式</h2><p>日期/时间选取器持4种不同模式的选择方式。<br>通过设置 datePickerMode 属性，可以定义选择模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.datePickerMode = UIDatePickerModeTime;</span><br></pre></td></tr></table></figure></p><p>支持的模式：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a1d8372b?w=600&amp;h=214&amp;f=png&amp;s=93770" alt="支持模式"></p><p>四种时间模式样式截图如下：</p><h4 id="3-1-UIDatePickerModeTime"><a href="#3-1-UIDatePickerModeTime" class="headerlink" title="3.1 UIDatePickerModeTime"></a>3.1 UIDatePickerModeTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a01a3438?w=600&amp;h=1065&amp;f=jpeg&amp;s=20585" alt="UIDatePickerModeTime"><br>在这种模式下，显示时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-2-UIDatePickerModeDate"><a href="#3-2-UIDatePickerModeDate" class="headerlink" title="3.2 UIDatePickerModeDate"></a>3.2 UIDatePickerModeDate</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a20f7db1?w=600&amp;h=1065&amp;f=jpeg&amp;s=28097" alt="UIDatePickerModeDate"></p><p>在这种模式下，显示年、月、日。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-3-UIDatePickerModeDateAndTime"><a href="#3-3-UIDatePickerModeDateAndTime" class="headerlink" title="3.3 UIDatePickerModeDateAndTime"></a>3.3 UIDatePickerModeDateAndTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa39d537561?w=600&amp;h=1065&amp;f=jpeg&amp;s=28835" alt="UIDatePickerModeDateAndTime"></p><p>在这种模式下，显示日期的月、日、星期，时间的时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-4-UIDatePickerModeCountDownTimer"><a href="#3-4-UIDatePickerModeCountDownTimer" class="headerlink" title="3.4 UIDatePickerModeCountDownTimer"></a>3.4 UIDatePickerModeCountDownTimer</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a24ca874?w=600&amp;h=1065&amp;f=jpeg&amp;s=21341" alt="UIDatePickerModeCountDownTimer"></p><p>在这种模式下，显示时、分。应用程序必须实现一个计数器（NSTimer对象），让倒计时中的时间不断减少。</p><h2 id="四：日期范围"><a href="#四：日期范围" class="headerlink" title="四：日期范围"></a>四：日期范围</h2><p>你可以通过设置mininumDate 和 maxinumDate 属性，来指定使用的日期范围。如果用户试图滚动到超出这一范围的日期，表盘会回滚到最近的有效日期。两个方法都需要NSDate 对象作参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDate* minDate = [[NSDate alloc]initWithString:@&quot;1900-01-01 00:00:00 -0500&quot;];    </span><br><span class="line">NSDate* maxDate = [[NSDate alloc]initWithString:@&quot;2099-01-01 00:00:00 -0500&quot;];    </span><br><span class="line"></span><br><span class="line">datePicker.minimumDate = minDate;    </span><br><span class="line">datePicker.maximumDate = maxDate;</span><br></pre></td></tr></table></figure></p><p>如果两个日期范围属性中任何一个未被设置，则默认行为将会允许用户选择过去或未来的任意日期。这在某些情况下很有用处，比如，当选择生日时，可以是过去的任意日期，但终止与当前日期。如果你希望设置默认显示的日期，可以使用date属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.date = minDate;</span><br></pre></td></tr></table></figure><p>此外，你还可以用 setDate 方法。如果选择了使用动画，则表盘会滚动到你指定的日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[datePicker setDate:maxDate animated:YES];</span><br></pre></td></tr></table></figure><h4 id="4-本篇文章demo源码："><a href="#4-本篇文章demo源码：" class="headerlink" title="4. 本篇文章demo源码："></a>4. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">UIDatePicker–DEMO</a></p><hr><p>欢迎关注我的公众号：网罗开发</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/29/1613fe638def80c9?w=300&amp;h=300&amp;f=jpeg&amp;s=21616" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;a href=&quot;#一：UIDatePicker的介绍&quot; class=&quot;headerlink&quot; title=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;/a&gt;一：UIDatePicker的介绍&lt;/h2&gt;&lt;p&gt;UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。&lt;br&gt;日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。&lt;br&gt;你也可以对其进行定制，令其使用任何范围的日期。&lt;/p&gt;
&lt;p&gt;UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。&lt;br&gt;iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。&lt;br&gt;使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。&lt;br&gt;UIDatePicker给出了倒计时模式，但是并没有实现相关事件。&lt;br&gt;如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS发红包页面</title>
    <link href="https://fanbaoying.github.io/iOS%E5%8F%91%E7%BA%A2%E5%8C%85%E9%A1%B5%E9%9D%A2/"/>
    <id>https://fanbaoying.github.io/iOS发红包页面/</id>
    <published>2018-02-07T09:38:47.000Z</published>
    <updated>2018-02-07T09:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS APP发红包页面制作，可直接参考源码，节约开发时间。<br><a href="https://github.com/fanbaoying/GiveRedEnvelopes" target="_blank" rel="noopener">点击获取GitHub 源码</a></p><p>来源：来自 qq:668562416 “西安 - 梦龙雪糕” 的贡献</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2829694-0086035242f8609e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="22.png"></p><p>其他干货信息：</p><ul><li><a href="https://github.com/fanbaoying/MsgPlaySound" target="_blank" rel="noopener">获取系统震动和声音</a>(来自”西安 - 梦龙雪糕” 的贡献)</li><li><a href="https://github.com/fanbaoying/AFN-YYCache" target="_blank" rel="noopener">AFN-YYCache二次封装网络请求</a>(来自”MrGoodbye”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYFMDBDemo" target="_blank" rel="noopener">FMDB | 实现数据的增删改查</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYDataDisplay-iOS" target="_blank" rel="noopener">iOS折线图统计图</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYIDCardRecognition-Android" target="_blank" rel="noopener">Android 银行卡身份证识别demo</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYBankCardRecognition-iOS" target="_blank" rel="noopener">iOS 银行卡识别demo</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYIDCardRecognition-iOS" target="_blank" rel="noopener">iOS 身份证识别demo</a>(来自”FBY展菲”的贡献)</li></ul><p>更多干货信息请到：GitHub: <a href="https://github.com/fanbaoying" target="_blank" rel="noopener">https://github.com/fanbaoying</a> 下载</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS APP发红包页面制作，可直接参考源码，节约开发时间。&lt;br&gt;&lt;a href=&quot;https://github.com/fanbaoying/GiveRedEnvelopes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击获取GitHub 源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：来自 qq:668562416 “西安 - 梦龙雪糕” 的贡献&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 贡献集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%B4%A1%E7%8C%AE%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Apple Pay开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-Apple-Pay%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-Apple-Pay开发流程/</id>
    <published>2018-02-06T08:00:31.000Z</published>
    <updated>2018-02-06T08:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下Apple_pay，其他支付也写了对应教程，并且给出了连接。</p><a id="more"></a><h2 id="二：支付流程介绍"><a href="#二：支付流程介绍" class="headerlink" title="二：支付流程介绍"></a>二：支付流程介绍</h2><h2 id="2-1-Apple-Pay-页面演示"><a href="#2-1-Apple-Pay-页面演示" class="headerlink" title="2.1 Apple Pay 页面演示"></a>2.1 Apple Pay 页面演示</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3bdb0c80?w=1240&amp;h=871&amp;f=png&amp;s=238050" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3f1fee30?w=1240&amp;h=974&amp;f=png&amp;s=216268" alt="Apple Pay 页面演示"></p><ol><li>买家在手机应用中购买商品或服务，在订单页面中展示 Apple Pay 按钮</li><li>通过银联控件，掉起 Apple Pay 支付页面</li><li>用户通过支付页面验证 Touch ID，输入银行卡密码 是否需要输入银行卡密码取决于交易限额和银行支持情况</li><li>支付成功，商户应用内展示成功页面<br>(1)支付成功页面应参照 UI 示例，展示“银联”标识，“云闪付”标识。<br>(2)银联 SDK 控件支持折扣功能。在折扣活动期间，商户应用内应参照实例 UI 进行原金 额、折扣金额的展示</li></ol><h3 id="2-2-Apple-Pay-支付的实现方式"><a href="#2-2-Apple-Pay-支付的实现方式" class="headerlink" title="2.2 Apple Pay 支付的实现方式"></a>2.2 Apple Pay 支付的实现方式</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3bcc2b63?w=1240&amp;h=774&amp;f=png&amp;s=76672" alt="Apple Pay 支付的实现方式"></p><p>1-2. 商户生成订单，通过商户 SERVER 端将订单信息发送给银联支付网关;<br>3-4. 银联支付网关记录订单信息，返回用来标识订单的 TN 号，经由商户 SERVER 返回至给 商户 APP;<br>5.商户 APP 调用银联 SDK，将 TN 号传递给银联 SDK<br>6.银联 SDK 向 Apple 公司的 PASSKIT FRAMEWORK 发起支付请求;<br>7.接口返回加密的支付 Token 信息;<br>8-9.银联 SDK 将支付 Token 传递给银联支付网关，完成交易认证;<br>10-12.银联将支付结果返回给商户 APP，商户 SERVER，商户 APP 负责提示用户交易结果。</p><h2 id="三：工程配置"><a href="#三：工程配置" class="headerlink" title="三：工程配置"></a>三：工程配置</h2><p>bundleID设置</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3be01987?w=1069&amp;h=245&amp;f=png&amp;s=55370" alt="bundleID设置"></p><p>Capability中启用Apple Pay权限，并选择merchantID，<a href="https://juejin.im/post/5a31e031f265da430a50971e" target="_blank" rel="noopener">merchantID申请流程</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db41f7cd8f?w=873&amp;h=476&amp;f=png&amp;s=47034" alt="启用Apple Pay权限"></p><p>之后项目会多一个Applepay的配置文件ApplePayYasin.entitlements</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3e704842?w=1136&amp;h=204&amp;f=png&amp;s=49705" alt="项目文件"></p><h2 id="四：下载Apple-Pay-SDK"><a href="#四：下载Apple-Pay-SDK" class="headerlink" title="四：下载Apple Pay SDK"></a>四：下载Apple Pay SDK</h2><p><a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">Apple Pay SDK</a></p><p>下载之后，找到.h文件和库文件，使用UPPaymentControl需要将paymentcontrol/inc目录下UPAPayPlugin.h、UPAPayPluginDelegate.h文件和paymentcontrol/libs目录下的libUPAPayPlugin.a文件添加到商户应用的工程中</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db909531af?w=1238&amp;h=376&amp;f=png&amp;s=79656" alt="SDK路径"></p><h2 id="五：调用支付接口"><a href="#五：调用支付接口" class="headerlink" title="五：调用支付接口"></a>五：调用支付接口</h2><p>在调用银联支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UPAPayPlugin.h&quot;</span><br><span class="line"></span><br><span class="line">// TODO 商户需要换用自己的mertchantID</span><br><span class="line">#define kAppleMerchantID        @&quot;merchant.com.AgreePay.ApplePayAgree&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//当获得的tn不为空时，调用支付接口</span><br><span class="line">if (tn != nil &amp;&amp; tn.length &gt; 0) &#123;</span><br><span class="line">        [UPAPayPlugin startPay:tn</span><br><span class="line">        mode:@&quot;01&quot;</span><br><span class="line">        viewController:ViewController</span><br><span class="line">        delegate:self andAPMechantID:kAppleMerchantID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法需要的几个参数文档上都写的有，tn是交易流水号，服务器端传回来的，客户端只有凭借这个参数才能调用支付控件 进行支付的。只需要调用一个方法就行啦！！！</p><h2 id="六：支付结果回调"><a href="#六：支付结果回调" class="headerlink" title="六：支付结果回调"></a>六：支付结果回调</h2><p>就在调起支付的ViewController 中写入下面代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -</span><br><span class="line">#pragma mark 响应控件返回的支付结果</span><br><span class="line">#pragma mark -</span><br><span class="line">- (void)UPAPayPluginResult:(UPPayResult *)result</span><br><span class="line">&#123;</span><br><span class="line">    if(result.paymentResultStatus == UPPaymentResultStatusSuccess) &#123;</span><br><span class="line">        NSString *otherInfo = result.otherInfo?result.otherInfo:@&quot;&quot;;</span><br><span class="line">        NSString *successInfo = [NSString stringWithFormat:@&quot;支付成功\n%@&quot;,otherInfo];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%@&quot;,successInfo);</span><br><span class="line"></span><br><span class="line">    &#125;else if(result.paymentResultStatus == UPPaymentResultStatusCancel)&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;支付取消&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;else if (result.paymentResultStatus == UPPaymentResultStatusFailure) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *errorInfo = [NSString stringWithFormat:@&quot;%@&quot;,result.errorDescription];</span><br><span class="line">        NSLog(@&quot;支付失败%@&quot;,errorInfo);</span><br><span class="line">    &#125;else if (result.paymentResultStatus == UPPaymentResultStatusUnknownCancel)  &#123;</span><br><span class="line"></span><br><span class="line">        //TODO UPPAymentResultStatusUnknowCancel表示发起支付以后用户取消，导致支付状态不确认，需要查询商户后台确认真实的支付结果</span><br><span class="line">//        NSString *errorInfo = [NSString stringWithFormat:@&quot;支付过程中用户取消了，请查询后台确认订单&quot;];</span><br><span class="line">//        [self showAlertMessage:errorInfo];</span><br><span class="line">        NSLog(@&quot;支付过程中用户取消了，请查询后台确认订单&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db620e1851?w=744&amp;h=1368&amp;f=png&amp;s=163923" alt="支付调起截图"></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下Apple_pay，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 最新版本支付宝支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-最新版本支付宝支付开发流程/</id>
    <published>2018-02-06T07:58:32.000Z</published>
    <updated>2018-02-06T08:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>最近支付宝，微信，银联支付类sdk均做了更新，其中支付宝sdk变化比较大，由原来需要导入六个文件：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li><li>Order.h和Order.m</li><li>Until文件夹</li><li>openssl文件夹</li><li>libcrypto.a和libssl.a</li></ul><p>在新版之后只需要导入两个文件就可以解决了，文件如下：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li></ul><p>下面我在旧版文章的基础上，为大家详细介绍最新版本支付宝支付开发流程。</p><a id="more"></a><p>因为工作的需要，我先后总结了iOS支付相关的近五类支付开发文章，分别是支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，做这些总结第一是方便以后的查阅，第二也为大家提供方便， 以免在用到的地方重复踩坑。</p><blockquote><p>注意开始填坑！！！</p></blockquote><h2 id="二：交互流程"><a href="#二：交互流程" class="headerlink" title="二：交互流程"></a>二：交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是<a href="https://doc.open.alipay.com/doc2/detail?spm=0.0.0.0.w6njr9&amp;treeId=59&amp;articleId=103658&amp;docType=1" target="_blank" rel="noopener">交互流程</a>这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090db631c91f4e?w=848&amp;h=456&amp;f=png&amp;s=79224" alt="功能流程图"></p><p>流程说明：</p><ul><li>第4步：调用支付接口</li><li>第5步：支付请求</li><li>第8步：接口返回支付结果</li><li>第12步：异步发送支付通知</li></ul><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090dbeccf4cb9c?w=885&amp;h=469&amp;f=png&amp;s=93602" alt="数据交互图"></p><p>数据交互说明：</p><ol><li>构造订单数据并签名</li><li>发送请求数据</li><li>手机支付宝支付开发包对请求数据进行处理</li><li>返回处理的结果数据</li><li>商户对获取的返回结果数据进行处理</li></ol><h2 id="三：下载支付宝SDK"><a href="#三：下载支付宝SDK" class="headerlink" title="三：下载支付宝SDK"></a>三：下载支付宝SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了<a href="https://docs.open.alipay.com/54/104509" target="_blank" rel="noopener">最新的sdk地址</a>（注意的是下载出来的SDK包里面并没有传说中的开发文档，需要其他地方找或者看网页上的）。</p><p>公钥、私钥、PID、sellerID、key这些东西的用途和获取方式在文档上都有详细的说明，这里不再赘述，一定要把概念分清楚再去做，不然一会就乱了。如果遇到问题的话咱们可以再一起探讨。</p><h2 id="四：-导入库集成SDK"><a href="#四：-导入库集成SDK" class="headerlink" title="四： 导入库集成SDK"></a>四： 导入库集成SDK</h2><h3 id="4-1-导入文件和关键库"><a href="#4-1-导入文件和关键库" class="headerlink" title="4.1 导入文件和关键库"></a>4.1 导入文件和关键库</h3><p>官方demo文件</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090ea4e1572b1f?w=778&amp;h=370&amp;f=png&amp;s=46381" alt=""></p><p>把iOS包中的压缩文件中以下文件拷贝到项目文件夹下，并导入到项目工程中：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li></ul><p>在Build Phases选项卡的Link Binary With Libraries中，增加以下依赖：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f21ff23afc13?w=800&amp;h=387&amp;f=png&amp;s=161849" alt="配置截图"><br>其中，需要注意的是：</p><ul><li>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；</li><li>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib（如下图）。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f21ff158304a?w=800&amp;h=63&amp;f=png&amp;s=15152" alt=""></p><p>此时，假如你启动工程，很大几率上你会发现报error的情况。<br>报错#include <openssl opensslconf.h=""> not find<br>这是一个神奇的大坑，我Google了好久，也不得其解，然后经网友提醒之后想起来#import “”和#import &lt;&gt;的区别。</openssl></p><blockquote><p>解决方法：Targets -&gt; Build Settings 下的 Header Search Paths。添加如下目录 “$(SRCROOT)/项目名称/文件的绝对地址”<br>如图：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2200ab48e0b?w=910&amp;h=519&amp;f=png&amp;s=274742" alt="3.png"></p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>在需要调用AlipaySDK的文件中，增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在支付宝的接入文档中，是将生成一个订单这步放在客户端来做了，但这个最好是 放在服务器端来做。<br>后台生成订单然后拼接，签名，然后服务器端直接给客户端传一个加密签名过的参数就可以了，这样比较安全。<br>所有的订单信息，商户信息等都掌握在自己的手中，这样的话APP端就不怕被拦截数据，并且调用起来也就特别简单了，只需要调用支付的接口。<br>如果只需要发送订单和处理支付返回结果，只需要添加AlipaySDK.bundle和AlipaySDK.framework这两个就行了，下载的SDK中很容易发现。<br>快捷支付方法是这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)payOrder:(NSString *)orderStr fromScheme:(NSString *)schemeStr callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>在支付的按钮中，使用支付宝这个类，再调用这个方法就行啦！如下如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[AlipaySDK defaultService] payOrder:credential fromScheme:fromScheme callback:^(NSDictionary* resultDic) &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,resultDic);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h3 id="4-4-配置支付宝客户端返回url处理方法"><a href="#4-4-配置支付宝客户端返回url处理方法" class="headerlink" title="4.4 配置支付宝客户端返回url处理方法"></a>4.4 配置支付宝客户端返回url处理方法</h3><p>如示例AliSDKDemo\APAppDelegate.m文件中，增加引用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure></p><p>在@implementation  AppDelegate中以下代码中的NSLog改为实际业务处理代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line"></span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-项目配置"><a href="#4-5-项目配置" class="headerlink" title="4.5 项目配置"></a>4.5 项目配置</h3><p>最后，不要忘了还要写一个URL Scheme，在Targets -&gt; Info 下最后一个即可找到，<br>点击“Info”选项卡，在“URL Types”选项中，点击“+”。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f220218b212e?w=1044&amp;h=348&amp;f=jpeg&amp;s=30900" alt="项目配置"></p><p>到这里支付宝支付就基本完成了，如果小伙伴们在集成过程中遇到什么问题，可以留言给我或者添加qq，在线帮你解决。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;最近支付宝，微信，银联支付类sdk均做了更新，其中支付宝sdk变化比较大，由原来需要导入六个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AlipaySDK.framework&lt;/li&gt;
&lt;li&gt;AlipaySDK.bundle&lt;/li&gt;
&lt;li&gt;Order.h和Order.m&lt;/li&gt;
&lt;li&gt;Until文件夹&lt;/li&gt;
&lt;li&gt;openssl文件夹&lt;/li&gt;
&lt;li&gt;libcrypto.a和libssl.a&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在新版之后只需要导入两个文件就可以解决了，文件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AlipaySDK.framework&lt;/li&gt;
&lt;li&gt;AlipaySDK.bundle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我在旧版文章的基础上，为大家详细介绍最新版本支付宝支付开发流程。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 微信支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-微信支付开发流程/</id>
    <published>2018-02-06T07:53:12.000Z</published>
    <updated>2018-02-06T08:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1" target="_blank" rel="noopener">微信支付开发文档</a>里面有详细的字段和说明。<br>微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）</p><a id="more"></a><h2 id="二：业务流程"><a href="#二：业务流程" class="headerlink" title="二：业务流程"></a>二：业务流程</h2><p>以下是交互时序图，统一下单API、支付结果通知API和查询订单API等都涉及签名过程，调用都必须在商户服务器端完成。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27888c19afc?w=894&amp;h=1042&amp;f=png&amp;s=35313" alt="交互时序图"></p><p>商户系统和微信支付系统主要交互说明：</p><ul><li><ol><li>用户在商户APP中选择商品，提交订单，选择微信支付。</li></ol></li><li><ol><li>商户后台收到用户支付单，调用微信支付统一下单接口。</li></ol></li><li><ol><li>统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为appid，partnerid，prepayid，noncestr，timestamp，package。</li></ol></li><li><ol><li>商户APP调起微信支付。</li></ol></li><li><ol><li>商户后台接收支付通知。</li></ol></li><li><ol><li>商户后台查询支付结果。</li></ol></li></ul><h2 id="三：下载微信SDK"><a href="#三：下载微信SDK" class="headerlink" title="三：下载微信SDK"></a>三：下载微信SDK</h2><p>如果集成了友盟分享里的微信，那就不用下载,也不用配置环境，因为配置友盟分享的时候已经把微信支付的环境都配置好了（包括框架，schema跳转，白名单）如果没有集成过友盟分享那么请到<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">微信开放平台下载SDK</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f278a718dc7b?w=800&amp;h=278&amp;f=png&amp;s=44629" alt="下载微信SDK"></p><blockquote><p> 建议把iOS头文件和支付示例都下载下来</p></blockquote><h2 id="四：导入库集成SDK"><a href="#四：导入库集成SDK" class="headerlink" title="四：导入库集成SDK"></a>四：导入库集成SDK</h2><h3 id="4-1-导入SDK库"><a href="#4-1-导入SDK库" class="headerlink" title="4.1 导入SDK库"></a>4.1 导入SDK库</h3><p>导入上面那个iOS头文件和库下载下载出来的SDK包的就行，然后需要链接上依赖库，在Target —&gt; BuildPhases —&gt; Link Binary With Libraries— 点击+号 -&gt; 搜索你需要的系统库。</p><ul><li>SystemConfiguration.framework</li><li>libz.tbd</li><li>libsqlite3.0.tbd</li><li>CoreTelephony.framework</li><li>QuartzCore.framework</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2788cdb89fc?w=800&amp;h=606&amp;f=png&amp;s=84310" alt="导入SDK库"></p><h3 id="4-2-设置URL-Scheme"><a href="#4-2-设置URL-Scheme" class="headerlink" title="4.2 设置URL Scheme"></a>4.2 设置URL Scheme</h3><p>商户在微信开放平台申请开发APP应用后，微信开放平台会生成APP的唯一标识APPID，在<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="noopener">APP端开发步骤</a>里面说得很清楚了，需要填在URL Schemes这个地方。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27889fad2d9?w=800&amp;h=443&amp;f=png&amp;s=89206" alt="URL Scheme"></p><h3 id="4-2-在Appdelegate中注册APPID"><a href="#4-2-在Appdelegate中注册APPID" class="headerlink" title="4.2 在Appdelegate中注册APPID"></a>4.2 在Appdelegate中注册APPID</h3><p>首先要在Appdelegate中引用头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//微信支付</span><br><span class="line">#import &quot;WXApi.h&quot;</span><br></pre></td></tr></table></figure></p><p>然后注册APPID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">//    向微信终端注册ID</span><br><span class="line"></span><br><span class="line">    [WXApi registerApp:@&quot;wxd930ea5d5a258f4f&quot;];</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在支付成功之后，支付结果返回，需要获取url，也需要在Appdelegate中完成，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line"></span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if ([url.host isEqualToString:@&quot;pay&quot;]) &#123;</span><br><span class="line">        // 处理微信的支付结果</span><br><span class="line">        [WXApi handleOpenURL:url delegate:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if ([url.host isEqualToString:@&quot;pay&quot;]) &#123;</span><br><span class="line">        // 处理微信的支付结果</span><br><span class="line">        [WXApi handleOpenURL:url delegate:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>微信SDK自带的方法，处理从微信客户端完成操作后返回程序之后的回调方法,显示支付结果的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(void) onResp:(BaseResp*)resp</span><br><span class="line">&#123;</span><br><span class="line">    //启动微信支付的response</span><br><span class="line">    NSString *payResoult = [NSString stringWithFormat:@&quot;errcode:%d&quot;, resp.errCode];</span><br><span class="line">    if([resp isKindOfClass:[PayResp class]])&#123;</span><br><span class="line">        //支付返回结果，实际支付结果需要去微信服务器端查询</span><br><span class="line">        switch (resp.errCode) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                payResoult = @&quot;支付结果：成功！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case -1:</span><br><span class="line">                payResoult = @&quot;支付结果：失败！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case -2:</span><br><span class="line">                payResoult = @&quot;用户已经退出支付！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                payResoult = [NSString stringWithFormat:@&quot;支付结果：失败！retcode = %d, retstr = %@&quot;, resp.errCode,resp.errStr];</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在调用微信支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;WXApi.h&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中，需要上传的参数包括：appid、partid（商户号）、prepayid（预支付订单ID）、noncestr（参与签名的随机字符串）、timestamp（参与签名的时间戳）、sign（签名字符串）这六个。<br>在点击支付的控制器中使用核心代码来调起微信客户端支付,这些个参数都是后台传给你的。 加上了注释，应该很好理解的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 微信支付方法</span><br><span class="line">- (void)WechatPay&#123;</span><br><span class="line"></span><br><span class="line">    //需要创建这个支付对象</span><br><span class="line">    PayReq *req   = [[PayReq alloc] init];</span><br><span class="line">    //由用户微信号和AppID组成的唯一标识，用于校验微信用户</span><br><span class="line">    req.openID = appid;</span><br><span class="line">    // 商家id，在注册的时候给的</span><br><span class="line">    req.partnerId = partnerid;</span><br><span class="line">    // 预支付订单这个是后台跟微信服务器交互后，微信服务器传给你们服务器的，你们服务器再传给你</span><br><span class="line">    req.prepayId  = prepayid;</span><br><span class="line">    // 根据财付通文档填写的数据和签名</span><br><span class="line">    req.package  = package;</span><br><span class="line">    // 随机编码，为了防止重复的，在后台生成</span><br><span class="line">    req.nonceStr  = noncestr;</span><br><span class="line">    // 这个是时间戳，也是在后台生成的，为了验证支付的</span><br><span class="line">    NSString * stamp = timestamp;</span><br><span class="line">    req.timeStamp = stamp.intValue;</span><br><span class="line">    // 这个签名也是后台做的</span><br><span class="line">    req.sign = sign;</span><br><span class="line">    //发送请求到微信，等待微信返回onResp</span><br><span class="line">    [WXApi sendReq:req];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-判断手机是否安装微信客户端"><a href="#4-4-判断手机是否安装微信客户端" class="headerlink" title="4.4 判断手机是否安装微信客户端"></a>4.4 判断手机是否安装微信客户端</h3><p>在需要微信支付的地方调用封装的类方法之后会跳转到微信app,如果没有安装则没有任何反应。这里需要注意，因为没有安装微信，必须要提供webview的方式登录微信来支付，否则苹果公司会拒绝应用上架。但是微信又不自带webview的方式，（支付宝是自带的）所以要判断用户有没有安装微信，如果没有安装微信就不显示微信支付这个按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 判断手机有没有微信</span><br><span class="line">    if ([WXApi isWXAppInstalled]) &#123;</span><br><span class="line">        wechatButton.hidden = NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        wechatButton.hidden = YES;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里微信支付就基本完成了，如果小伙伴们在集成过程中遇到什么问题，可以留言给我或者添加qq，在线帮你解决。</p><h2 id="后续：常见问题解决"><a href="#后续：常见问题解决" class="headerlink" title="后续：常见问题解决"></a>后续：常见问题解决</h2><ol><li>如果支付完成后，一直留在微信，那就检查下URLType中的Scheme设置问题。</li><li>能够打开微信客户端，但是打开后只有中间一个白色的 “确定按钮”，点击后会回到客户端上，如果是这样，那应该是prepayid 参数的问题，过期了，或者不是真实的id。</li><li>微信支付的单位是分</li><li>工程-&gt;build setttings -&gt; 搜索other linker flags 添加-Objc -all_load ，运行工程可能会崩溃，原因是程序没有找到sdk库。</li><li><p>白名单：不配置白名单也可以调起支付，如果调不起支付，查看是否是白名单的问题。<br>打开工程里的info.plist文件 添加LSApplicationQueriesSchemes数组并添加wechat 和 weixin字符串。<br>或者info.plist右键-&gt;source code打开添加下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;&lt;string&gt;wechat&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;weixin &lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></li><li><p>中文名的工程会报这个错误，英文名则不会，这是因为缺少UIKit库 在WXApiObject.h里导入库#import <uikit uikit.h="">。</uikit></p></li></ol><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信支付开发文档&lt;/a&gt;里面有详细的字段和说明。&lt;br&gt;微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
