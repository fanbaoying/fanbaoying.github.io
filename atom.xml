<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2023-07-04T07:32:29.555Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 周报 第三十二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十二期/</id>
    <published>2023-07-04T07:20:25.000Z</published>
    <updated>2023-07-04T07:32:29.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十三期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>骚年，努力去成为你期待已久的自己吧，就像<strong>Swift社区</strong>一样，时刻心怀梦想，不断向前！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果已提供新的设计资源</p><p>提案：本期提案没有最新内容</p><p>Swift 论坛：讨论 Non-Reentrant Actors</p><p>推荐博文：AngularGradient 在 swiftUI 中的使用</p><p><strong>话题讨论：</strong> </p><p>你认为 vision pro 是否会加速虚拟现实技术的发展？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/976e8f1f-d753-438d-8117-a58b5a020286.jpeg" alt=""></p><p>根据投票结果，小编认为企业应根据自身情况和员工需求，平衡薪资保密与透明的利弊，制定适合的薪资政策。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="现已提供新的设计资源"><a href="#现已提供新的设计资源" class="headerlink" title="现已提供新的设计资源"></a>现已提供新的设计资源</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/7DD13ED0-F50B-4568-813A-2C89D0D8DB25/2048.jpeg" alt=""></p><p>为方便开发者在 Apple 平台上构建 App，我们现在提供了全新及更新后的设计资源，让你可以更便捷、更准确地设计 App。</p><p>visionOS 设计资料库以及适用于 Figma 和 Sketch 的模板 (英文)。</p><p>适用于 Figma 和 Sketch 的 iOS 17 和 iPadOS 17 设计套件 (英文)。</p><p>适用于 Figma 和 Sketch 的 macOS Sonoma 设计套件 (英文)。</p><p>适用于 Sketch 的 watchOS 10 设计套件 (英文)。</p><p>SF Symbols 5 Beta 版，包含 700 多个新符号 (英文)。</p><p>更新后的《人机界面指南》(英文)，现提供简体中文和日文版本。</p><p>SF 脚本扩展，现已支持亚美尼亚语、格鲁吉亚语和希伯来语 (英文页面)。</p><h3 id="visionOS-SDK-现已发布"><a href="#visionOS-SDK-现已发布" class="headerlink" title="visionOS SDK 现已发布"></a>visionOS SDK 现已发布</h3><p>Apple Vision Pro 提供了一幅无边的画布，你现在就可以开始为这幅画布打造前沿的空间计算 App。下载 Xcode 15 Beta 版 2，其中包含 visionOS SDK 和 Reality Composer Pro — 这是一种新的工具，可让你轻松地预览和准备适用于 visionOS 的 3D 内容。将 visionOS 目标添加到你的现有项目中或构建一个全新的 App，然后在 Xcode 预览中迭代你的 App。你可以在全新的 visionOS 模拟器中与你的 App 互动，探索各种房间布局和光线条件，并创建测试和可视化效果。此外，我们还提供了新的文档和示例代码，帮助你完成整个开发过程。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>本期提案没有最新内容，期待下期更新～～</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/request-for-feedback-partial-consumption-of-fields-of-noncopyable-types/65884" title="使用部分不可复制类型的字段" target="_blank" rel="noopener">使用部分不可复制类型的字段</a></p><p><strong>介绍</strong></p><p>当前给定一个类似于 var 的构造（例如：var、inout），Swift 不允许部使用耗该类型的存储字段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> : ~<span class="title">Copyable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> : ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> first: <span class="type">E</span></span><br><span class="line">    <span class="keyword">var</span> second: <span class="type">Klass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="number">_</span> = s.e <span class="comment">// Error! Cannot partially consume s</span></span><br></pre></td></tr></table></figure><p><strong>不可复制类型的部分使用</strong></p><p>在设计空间中考虑以下几个不同的轴：</p><ol><li>关于带有 deinit 的类型</li><li>启用 Library Evolution 时</li><li>当 Library Evolution 被禁用时</li><li>无论哪种情况，是否应该只允许方法中的部分消耗。</li></ol><p>具有 Deinits 的类型的部分消耗</p><p>禁止使用 deinits 部分消耗不可复制类型，因为当字段被部分消耗，允许该类型被销毁</p><p>例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> : ~<span class="title">Copyable</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> : ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> first: <span class="type">E</span></span><br><span class="line">   <span class="keyword">var</span> second: <span class="type">E</span></span><br><span class="line">   <span class="keyword">deinit</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="number">_</span> = s.first <span class="comment">// s.first is destroyed here</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// s.second is destroyed here</span></span><br></pre></td></tr></table></figure><p>由于这里的 s 已被部分消耗，因此永远不会将其全部销毁，这意味着永远不会调用它自己的 deinit，这意味着不能允许发生。 </p><p><strong>请注意</strong>，即使不允许这样做，仍然允许使用方法的作者使用丢弃运算符来关闭值的 deinit，然后部分解构该值。</p><p>2) 提问<a href="https://forums.swift.org/t/can-a-group-of-weak-references-conform-to-collection/65899" title="一组弱引用可以符合Collection吗？" target="_blank" rel="noopener">一组弱引用可以符合Collection吗？</a></p><p>问题陈述：</p><p>有一个收集弱引用的类型，可以对其进行迭代并追加。 </p><p>希望它符合 RangeReplaceableCollection，但是不能做任何比 Sequence 更具体的事情。</p><p>该类型本身是一个经典的指针长度容量三元组，其中指针指向弱引用缓冲区。 一旦长度==容量，在尝试重新分配之前，会扫描缓冲区以查找可以丢弃的 nils。 仅当无法删除足够的 nil 来为新元素腾出空间时，才会执行重新分配。</p><p>使其符合 Collection 的问题是下标(<code>_:</code>)。 如果索引类型只是缓冲区中的索引，则其他线程可能会导致弱引用从下面删除，因此索引可能会变得无效，而不会对集合进行明显的更改。</p><p>可以想到两种方法来解决这个问题，但都不能令人满意。</p><p>第一个是使索引类型也持有对该对象的强引用。 但是担心当用户没有意识到他们通过索引持有强大的参考时，可能会产生问题。</p><p>第二个是使元素类型为T？ 而不是 T。这是一种误导，因为迭代器会跳过 nils，但会使下标可实现。</p><p>第三个选项是在不实际遵守协议的情况下实现许多（但不是全部）收集操作。 担心这是我必须做的，除非能证明其他两种行为之一是合理的。 </p><p>有没有一种方法可以在不改变类型语义的情况下实现协议？</p><p>回答：</p><p>不是集合似乎是所提供的数据结构的固有属性，而不是实现限制。 如果序列中的第 n 个项目可以从 x 更改为 y，因为 x（或序列中较早的某个其他对象）已被收集，则序列没有稳定的索引。</p><p>3) 提问<a href="https://forums.swift.org/t/no-such-module-uikit-in-swift-macro/65885" title="swift Macro 中没有这样的模块“UIKit”" target="_blank" rel="noopener">swift Macro 中没有这样的模块“UIKit”</a></p><p>在 swift Macro 中导入 UIKit 时，报错 No such module ‘UIKit’ 。</p><p>宏包有以下平台</p><p>平台：[.macOS(.v10_15)、.iOS(.v13)、.tvOS(.v13)、.watchOS(.v6)、.macCatalyst(.v13)]</p><p>回答：</p><p>在构建过程中，宏在编码的计算机（可能是 Mac/Windows/Linux）上运行。 它不在 iOS 上运行，因此无法访问 UIKit。</p><p>为什么在宏中需要 UIKit（而不是在声明宏的包中）？</p><p>可以尝试创建一个可以导入 UIKit 的“Mac Catalyst”宏，但即使有可能，也可能没有用</p><p>4) 提议<a href="https://forums.swift.org/t/pitch-low-level-linkage-control-attributes-used-and-section/65877" title="低级联动控制属性：@used 和@section" target="_blank" rel="noopener">低级联动控制属性：@used 和@section</a></p><p><strong>动机</strong></p><p>动机有两个目标：</p><p>提供低级构建块来构建更多高级 API，例如 “链接器集”（见下文）或自定义每种类型元数据，如 SE-0385 中所述（swift-evolution/proposals/0385-custom-reflection-metadata.md，位于 main·apple/swift-evolution·GitHub 2）。</p><p>尽管这个推介/提案实际上并没有尝试添加或设计高级 API，只是提供了一条单独解锁设计的路径。</p><p>为系统编程用例提供低级机制（这些用例是针对具体系统的定制案例），并构建一个通常可重用的高级 API 是没有意义的（项目作者可以自由地构建这样一个高级 API，例如项目的内部机制）。</p><p>“链接器集”机制是 Swift 已经在使用的一种方法：几乎任何类型的编译器发出的元数据都被放入二进制文件中专门命名的部分中，并给出固定布局的记录。 </p><p>然后，想要查找某些信息时（例如，在二进制文件中查找协议一致性），要求加载器（Darwin 上的 dyld）为我们提供每个加载的该部分的起始/结束地址。 图像，然后可以迭代这些部分中的所有记录。 </p><p>还可以从进程外部提取一些元数据，或者从二进制文件本身中挖掘它。使用现有的反射库来完成此操作，例如 <code>swift-inspect</code> 和 <code>swift-reflection-dump</code>。</p><p>在 Swift 语言中添加功能来表达该机制的第一部分：将固定布局记录放入专门命名的部分。</p><p><strong>提议</strong></p><p>其中一些已经在功能标志下实现为 main 中的下划线属性（ <code>@_section</code>、<code>@_used</code>），通过 <a href="https://github.com/apple/swift/pull/65901" target="_blank" rel="noopener">https://github.com/apple/swift/pull/65901</a> 实现。 总之：</p><p>@used 属性，通过 llvm.used 将全局变量或顶级函数标记为“不要死区”，大致相当于 C/C++ 中的 <strong>attribute</strong>((used)) 。</p><p>@section(“…”) 属性，将全局变量或顶级函数放入具有该名称的节中，大致相当于 C/C++ 中的 <strong>attribute</strong>((section(“…”))) 。</p><p>这些注释只能应用于保证最终“静态初始化”（而不是通过 init_once 运行时调用延迟初始化）的全局变量，因为否则注释没有任何意义。</p><p>这就提出了一个有趣的问题：当用于初始化全局时，哪些表达式可以保证“静态初始化”？ 建议从一组非常基本的表达式开始，并在将来对其进行改进。</p><p>强制优化管道已经使整数文字、元组和简单算术表达式进行“静态初始化”，如果存在任何具有 <code>@section</code> 属性的全局变量，可以在 SIL 管道末尾明确拒绝编译 这不是静态初始化的。 </p><p>然后，作为后续改进，应该考虑允许 POD 结构类型也在强制优化管道中处理，并允许与 <code>@section</code> 一起使用。</p><p>虽然超出了本次推介的范围，但以下是“链接器集”API 的运行时端的草图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// in Module1</span></span><br><span class="line">@used @section(<span class="string">"__DATA,mysection"</span>) <span class="keyword">private</span> <span class="keyword">let</span> my_entry: <span class="type">Int</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// in Module2</span></span><br><span class="line">@used @section(<span class="string">"__DATA,mysection"</span>) <span class="keyword">private</span> <span class="keyword">let</span> my_entry: <span class="type">Int</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> <span class="type">SwiftRuntime</span>.section(<span class="string">"__DATA,mysection"</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; <span class="comment">// this uses the loader's APIs to locate and iterate over the section</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，将其包装到基于宏的解决方案中可能是有意义的，这样就根本不会公开低级属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">LinkerSet</span>(name: <span class="string">"myLinkerSet"</span>) <span class="keyword">private</span> <span class="keyword">let</span> myEntry: <span class="type">Int</span> = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> <span class="type">SwiftRuntime</span>.linkerSet(<span class="string">"myLinkerSet"</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，在想要将元数据附加到类型的情况下（由 SE-0385 推动）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Registered</span>(name: <span class="string">"My Favorite Type"</span>) <span class="comment">// this creates a hidden global in a named section</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> regType <span class="keyword">in</span> allRegisteredTypes &#123; <span class="comment">// queries over the entries in the section</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5) 提问<a href="https://forums.swift.org/t/enable-preprocessor-flags-during-build/65892" title="在构建期间启用预处理器标志" target="_blank" rel="noopener">在构建期间启用预处理器标志</a></p><p>有一个 C++ 头文件，仅在设置了预处理器标志时才公开一个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIX_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Some_Class</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UNIX_ENABLED</span></span></span><br></pre></td></tr></table></figure><p>当调用 swift 编译器时：</p><p>swiftc MyApp.swift -cxx-互操作性模式=默认-Xcc -std=c++17 -I cxx -c -parse-as-library</p><p>并尝试在 MyApp.swift 中使用 Some_Class ，但显然找不到该类。 尝试使用 -D UNIX_ENABLED 但这没有帮助。</p><p>有什么想法可以进行此编译吗？</p><p>回答：</p><p>可以尝试将 -Xcc -D -Xcc UNIX_ENABLED 传递给 swiftc 以确保它将 -D 转发给 clang</p><p>6) 讨论<a href="https://forums.swift.org/t/non-reentrant-actors/65888" title="Non-Reentrant Actors" target="_blank" rel="noopener">Non-Reentrant Actors</a></p><p>每当编写涉及 Actor 的代码时，发现自己想要对 Actor 进行有意义的工作，但最终会在此过程中引入难以捕获的错误。 以这个简单的例子为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">HeavyLifting</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cachedResult: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doHeavyLifting</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedResult &#123; <span class="keyword">return</span> cachedResult &#125;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">try</span> await <span class="comment">// load some resource and process it.</span></span><br><span class="line">        cachedResult = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发人员可能会认为这是确保只执行一次“繁重工作”并缓存结果的完全足够的方法。然而，更精明的审阅者可能会注意到，虽然这不会导致灾难性的失败，实际上也不会保护繁重的工作不被多次完成，因为对此方法的多个并发请求虽然不是“ 一旦达到每个负载的暂停点，每个负载就会开始繁重的工作负载。</p><p>更具冒险精神的开发人员的工具带中确实有一个工具可以解决这个问题 - 非结构化任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">HeavyLifting</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heavyLiftingTask: <span class="type">Task</span>&lt;<span class="type">String</span>, <span class="type">Error</span>&gt;?</span><br><span class="line">    <span class="keyword">var</span> heavyLiftingResult: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> heavyLiftingTask &#123; <span class="keyword">return</span> <span class="keyword">try</span> await heavyLiftingTask.value &#125;</span><br><span class="line">            <span class="keyword">let</span> task = <span class="type">Task</span> &#123; <span class="keyword">try</span> await <span class="comment">// load some resource and process it. &#125;</span></span><br><span class="line">            heavyLiftingTask = task</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> await task.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在引入了不完整样板的微妙平衡，更不用说缺乏对取消传播的适当支持，所有这些都是以防止死锁的名义，而实际上并没有阻止富有冒险精神的开发人员编写可能会导致死锁的代码。</p><p>代码中到处都是这样的样板文件，最终肯定会弄错，当一天结束时，希望并假设在错误的等待最终潜入之前所做的事情，是为了 Actor 的方法在进行过程中不可调用，而 Actor 的其余部分则继续其业务。</p><p>已经使用过 Actor 一段时间，重新审视不可重入性，因为它是比较有用的工具。可以看到单独的方法或函数是希望以某种能力强制执行串行访问的东西，但是也可以看到将其应用于对整个参与者的所有访问的好处。</p><p>回答：</p><p>在未来方向（有任务链重入的奖励积分，但没有任务链重入绝对非常有用）将如那里所描述的那样非常棒。不希望应用于整个 Actor。</p><p>会有助于避免现在很容易变得脆弱的模式来解决缺乏此功能的问题。</p><p>可选的参与者“发送”对 Void 返回函数的支持一起将释放参与者的很大一部分潜力。</p><p>7) 讨论<a href="https://forums.swift.org/t/accessing-source-code-after-macro-expansion/65881" title="宏扩展后访问源代码" target="_blank" rel="noopener">宏扩展后访问源代码</a></p><p>当构建一个使用 SwiftSyntax 遍历 Swift 源代码的工具时，是否有一种直接的方法来遍历宏扩展后的源代码？</p><p>这是否需要通过尝试扩展每个源文件来手动完成？</p><p>正在构建的工具中，复制源文件并对其进行操作，但这是直接来自文件系统和预扩展的。 具体来说，该工具会遍历有效的 .swift 文件并捕获符合给定协议的所有类型。使用宏来添加对该协议的一致性，但是构建插件无法仅通过阅读非扩展源代码来了解最终的一致性。 使用 <code>Target.directory</code> 来确定给定目标的源文件所在的位置，但是是否有更好的方法来访问扩展源所在的构建目录？</p><p>回答：</p><p>如果对宏扩展的工作原理感到好奇，可以在<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/#Macro-Expansion" target="_blank" rel="noopener">这个文档</a>中阅读。</p><p>Swift 中的宏扩展基于语法的内存表示，这意味着无法在不手动执行扩展的情况下直接从源文件中检索扩展的代码。</p><p>可能会考虑尝试使用此方法扩展所有宏：<a href="https://github.com/apple/swift-syntax/blob/b556ac7c099539ed058f6fcfd978d66cb133176e/Sources/SwiftSyntaxMacros/MacroSystem.swift#L576" target="_blank" rel="noopener">SyntaxProtocol.expand(macros:in:)</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swdevnotes.com/swift/2023/angulargradient-in-swiftui/" title="AngularGradient 在swiftUI中的使用" target="_blank" rel="noopener">AngularGradient 在swiftUI中的使用</a></p><p><strong>摘要：</strong> 本篇文章讲解了如何在 swiftUI 中使用  AngularGradient，用于从一种颜色过渡到另一种颜色，可选地通过围绕指定中心点的放射状图案中的一系列颜色。本文探讨了设置不同中心点以及指定渐变的起始角度和结束角度范围的效果。 AngularGradient 可用于在 SwiftUI 视图中创建引人注目的视觉效果，尤其是在圆形或弧形中使用时。</p><p><a href="https://juejin.cn/post/7095940115532349454/" title=" 字节跳动 DanceCC 工具链系列之Swift 调试性能的优化方案" target="_blank" rel="noopener">字节跳动 DanceCC 工具链系列之Swift 调试性能的优化方案</a></p><p><strong>摘要：</strong>  本篇文章讲解了大型 Swift 项目如何通过开关，以及自定义 LLDB ，优化 Swift 开发同学的调试速度，提高整体的研发效能。其中讲解了 LLDB 的部分工作流程，以及针对性优化的技术细节，以及实际效果。</p><p><a href="https://juejin.cn/post/7244809939839434808/" title="Swift 的可选值优化" target="_blank" rel="noopener">Swift 的可选值优化</a></p><p><strong>摘要：</strong> 在 Swift 中，nil 的语义与 Objective-C 中的 nil 不同，它代表没有值的概念。为了表示没有值，Swift 引入了 nil 关键字，但在内存中的表示方式与 Objective-C 不同。文章通过代码展示了 nil 在内存中的真正表示，发现可选的 Int? 类型比普通的 Int 类型多占一个字节，用来表示是否有值。然而，Swift 编译器已经进行了优化，例如 Bool? 类型只占用一个字节，用2来表示 nil 。 String 类型也可以在内存中用0表示没有值。对于 Class 类型和 Enum 类型，空指针或越界值可以表示没有值，也没有内存浪费。总之， Swift 编译器会尽可能地优化可选值的内存占用，但仍建议在某些情况下尽量少使用可选值，特别是在结构体中连续多个可选的 Int 的情况下，可以使用非可选值并用0初始化它们。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>你认为vision pro是否会加速虚拟现实技术的发展？</strong></p><ol><li>会</li><li>不会</li><li>AI发展才是王道</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十三期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;骚年，努力去成为你期待已久的自己吧，就像&lt;strong&gt;Swift社区&lt;/strong&gt;一样，时刻心怀梦想，不断向前！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果已提供新的设计资源&lt;/p&gt;
&lt;p&gt;提案：本期提案没有最新内容&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Non-Reentrant Actors&lt;/p&gt;
&lt;p&gt;推荐博文：AngularGradient 在 swiftUI 中的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为 vision pro 是否会加速虚拟现实技术的发展？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十一期/</id>
    <published>2023-07-04T07:20:20.000Z</published>
    <updated>2023-07-04T07:31:54.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十二期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>若目标远大，就要有大动作。若追求卓越，便须有大改变。<strong>Swift社区</strong>已整装待发，你要不要一起呢？👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：Apple Vision Pro 和 visionOS 撼世登场</p><p>提案：移除由属性包装器引起的 Actor 隔离推断</p><p>Swift 论坛：为什么只能将结构附加到数组一次</p><p>推荐博文：Swift OpenAPI Generator 的介绍</p><p><strong>话题讨论：</strong> </p><p>你认为企业实行薪资保密有哪些利弊</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/273d30d8-22a4-4ef9-9e4b-b6a692f6aac3.png" alt=""></p><p>上期话题投票结果表明，在 2023 年工作更难找的情况下，大家面临着更大的工作压力，裁员消息的传出也增加了担忧。大量的媒体报道可能强调了经济衰退的迹象，这也会加强大家对经济危机的看法。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="注册-WWDC23-实验室和活动"><a href="#注册-WWDC23-实验室和活动" class="headerlink" title="注册 WWDC23 实验室和活动"></a>注册 WWDC23 实验室和活动</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/1AC9D4F4-43B5-4913-B149-B0486FFE64FE/2048.jpeg" alt=""></p><p>通过在线实验室和活动这种绝佳方式，你可以在一整周内与 Apple 工程师、设计师和专家进行交流沟通。</p><p>一对一实验室<br>从开发的基础知识到复杂概念，你都可以在这里获得个性化指导。了解如何运用全新 Apple 技术、探索 UI 设计原则、优化产品在 App Store 上的形象，以及更多主题。</p><p>活动<br>每日都有许多精彩的活动在 Slack 中展开。</p><p>在 Q&amp;A 中就工程和设计主题提问。<br>在大家一起观看讲座视频期间加入或关注实时对话，并与演讲者进行 Q&amp;A。<br>在社区暖场活动中了解其他开发者和 Apple 团队。<br>体验最新的框架，尝试各种设计理念，并在学习区分享你的创作。<br>在 6 月 6 日，与业内的佼佼者比试一下专业知识问答。<br>实验室和活动对 Apple Developer Program 和 Apple Developer Enterprise Program 的所有成员，以及 2023 Swift Student Challenge 参赛者开放。</p><h3 id="Apple-Vision-Pro-和-visionOS-撼世登场"><a href="#Apple-Vision-Pro-和-visionOS-撼世登场" class="headerlink" title="Apple Vision Pro 和 visionOS 撼世登场"></a>Apple Vision Pro 和 visionOS 撼世登场</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/213FE0A2-813D-404D-B093-D766AC8D7AF3/2048.jpeg" alt=""></p><p>Apple Vision Pro 是一款革命性的空间计算设备，可实现数字化内容与真实世界的无缝融合，让用户在沉浸于当下的同时还能与他人沟通交流。在 Apple Vision Pro 中，各种 App 将突破传统显示器的束缚限制，拥有一幅无边的画布。此外，Apple Vision Pro 还推出了一个全三维用户界面，而控制这个界面，仅需要用户的眼睛、双手和语音 — 最自然、最直观的输入工具。Apple Vision Pro 搭载了全球首个空间操作系统 visionOS，让用户能够以一种绝妙的方式与数字化内容互动，如同它们真的存在于现实世界之中。Apple Vision Pro 采用了突破性设计：在显示方面，采用超高分辨率显示屏系统，两块显示屏的总像素为 2,300 万；在性能方面，采用独特的双芯片设计并搭载定制的 Apple 芯片，确保每一刻的体验都真实无比，让人沉浸当下。</p><p>探索丰富实用的资源，助你通过一种全新而又熟悉的方式将空间计算方面的创意变为现实，打造出能够重新定义沟通、效率和娱乐的 App。</p><h3 id="App-Store-中新增的隐私功能"><a href="#App-Store-中新增的隐私功能" class="headerlink" title="App Store 中新增的隐私功能"></a>App Store 中新增的隐私功能</h3><p>在 Apple，我们将隐私视作每个人的基本权利。因此，我们构建了许多功能来帮助用户了解开发者在隐私以及数据收集和共享方面的做法，让用户能够自主掌控他们的数据。通过 App 跟踪透明度 (ATT)，用户可以选择 App 是否有权跟踪用户在其他公司的 App 和网站内的活动，以便投放广告或者与数据代理商共享。借助隐私标签和 App 隐私报告，用户可以查看 App 收集哪些数据以及如何使用这些数据。</p><p>许多 App 会利用第三方软件开发工具包 (SDK)，这些工具包可以提供出色的功能，但可能会对 App 处理用户数据的方式产生影响。为了让开发者可以更轻松地打造出色的 App，同时告知用户数据使用情况并尊重他们在这方面做出的选择，我们推出了两项新功能。</p><p>首先，为了帮助开发者了解第三方 SDK 如何使用数据，我们推出了新的隐私清单。隐私清单是一份文件，会以单一标准格式概述 App 中第三方代码的隐私做法。当开发者准备分发他们的 App 时，Xcode 会将开发者使用的所有第三方 SDK 中的隐私清单合并为一个简单易用的报告。这个报告内容全面，总结了 App 中的所有第三方 SDK，使开发者能够更轻松地创建更准确的隐私标签。</p><p>此外，为了向用户提供额外的隐私保护，如果 App 引用的 API 可能会被用于指纹识别（在 App Store 中被禁止的一种做法），现在需要选择合理的原因来解释为什么使用此 API 并在隐私清单中声明已使用此 App。在这个过程中，App 必须准确描述其对于这些 API 的使用情况，并且只能出于隐私清单中所述的原因而使用这些 API。</p><p>第二，我们希望帮助开发者改善软件供应链的完整性。使用第三方 SDK 时，开发者可能很难知道他们下载的代码是不是由期望的开发者编写的。为了解决这个问题，我们推出了适用于 SDK 的签名功能，这样一来，当开发者在 App 中采用新版本的第三方 SDK 时，Xcode 将验证它是否由同一开发者签名。这个功能将对开发者和用户都十分有帮助。</p><p>我们将在今年晚些时候发布更多信息，包括：</p><p>影响隐私的 SDK 列表 (对用户隐私产生重大影响的第三方 SDK)<br>“需要指明原因”的 API 列表，使用它们时必须给出合理的原因<br>开发者反馈表，用于就调用涉及的 API 提出新的原因<br>其他文档，详细介绍签名和隐私清单、他们的优势以及何时需要使用它们</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" title="SE-0400" target="_blank" rel="noopener">SE-0400</a> <strong>Init 访问器</strong> 提案正在审查。</p><p>该提案的目的是，Init 访问器将属性包装器的离线初始化特性泛化，使得类型中的任何计算属性都可以选择参与确定性初始化分析，并且可以替代使用自定义初始化代码对一组存储属性进行初始化。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md" title="SE-0401" target="_blank" rel="noopener">SE-0401</a> <strong>移除由属性包装器引起的 Actor 隔离推断</strong> 提案正在审查。</p><p>SE-0316：全局 Actors 引入了像 <code>@MainActor</code> 这样的注释，将类型、函数或属性隔离到特定的全局 Actor。还引入了各种规则，用于推断全局 Actor 隔离。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UIUpdating</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">  @<span class="type">MainActor</span> <span class="keyword">var</span> wrappedValue: <span class="type">Wrapped</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CounterView</span> </span>&#123; <span class="comment">// infers @MainActor from use of @UIUpdating</span></span><br><span class="line">  @<span class="type">UIUpdating</span> <span class="keyword">var</span> intValue: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该提案主张在使用 Swift 6 语言模式编译时移除此推断规则。根据上面的示例，<code>CounterView</code> 在 Swift 6 中将不再推断 <code>@MainActor</code> 隔离。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="SE-0400: Init Accessors" target="_blank" rel="noopener">SE-0400: Init Accessors</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" target="_blank" rel="noopener">SE-0400</a>：Init Accessors 314 的审查从现在开始，一直持续到 2023 年 6 月 26 日。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-improve-the-proposal-template-for-better-feature-experimentation/65604" title="改进提案模板以获得更好的功能实践" target="_blank" rel="noopener">改进提案模板以获得更好的功能实践</a></p><p><strong>介绍</strong></p><p>强制性工具链和示例项目以及 Experiment It 部分将允许开发人员在提案审查期间更轻松地进行实验并参与讨论。</p><p><strong>动机</strong></p><p>试验正在审查的功能这是评估提案的重要方式，即使是写得很好和详细的提案也可以从让开发人员试验它中受益。 提案模板可以改进，使任何人在审查期间更容易试用提议的功能。</p><p><strong>建议的解决方案</strong></p><p>将以下标题字段添加到提案模板：工具链和示例项目以及新的 Experiment It 部分。</p><p><strong>工具链</strong></p><p>该字段应指向一个链接，从中可以下载一个 swift 工具链，其中该功能是在实验性标志下实现的。</p><p>目前大多数提案只提到主分支中有一个功能可用，尽管大多数时候该功能都在 Swift.org 上可用的开发快照中 - 下载 Swift 对于新手来说了解这一点并不是那么微不足道，有时还有一个提案审查期 甚至在没有工作快照的情况下启动。</p><p>该链接应该从第一天起就可用，并在审核期间尽可能更新。</p><p>一种可能性是在网站下载页面上添加一个额外的部分，其中包含专用于正在审查的提案的工具链，这可以允许工具链可用，即使由于某种原因它不能出现在主快照中也是如此。</p><p>3) 提问<a href="https://forums.swift.org/t/why-can-i-only-append-a-struct-to-an-array-once/65601" title="为什么只能将结构附加到数组一次？" target="_blank" rel="noopener">为什么只能将结构附加到数组一次？</a></p><p>我的应用程序的目标是提醒用户与他们亲近的人互动。 因此，我的应用程序主要使用两个结构体，称为 Relation（代表一个人）和 Interaction（代表与人的一次交互）。</p><p>我构建了一个名为 “NewInteractionSheet” 的工作表，其目标是向关系的交互数组之一添加一个新的交互。</p><p>在添加交互时，此工作表非常有效。 但是，由于某种原因，它只能工作一次。 为什么要这样做？ 这就是我想要弄清楚的。</p><p>这是 “NewInteractionSheet.swift” 代码的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PhotosUI</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewInteractionSheet</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> isPresentingNewInteractionView: <span class="type">Bool</span></span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> relations: [<span class="type">Relation</span>]</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> newInteraction = <span class="type">Interaction</span>.emptyInteraction</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> relation: <span class="type">Relation</span> = <span class="type">Relation</span>.emptyRelation</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPresentingLocationPicker: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">Form</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">Section</span>(<span class="string">"You interacted with..."</span>) &#123;</span><br><span class="line">                    <span class="type">RelationPicker</span>(relations: $relations, relation: $relation)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">Section</span>(<span class="string">"Interaction details"</span>) &#123;</span><br><span class="line">                    <span class="type">InteractionDatePicker</span>(dateToSet: $newInteraction.date)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">TypePicker</span>(typeToSet: $newInteraction.type)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">DurationPicker</span>(shouldShow: newInteraction.type.hasDuration,</span><br><span class="line">                                   hoursToSet: $newInteraction.durationHours,</span><br><span class="line">                                   minutesToSet: $newInteraction.durationMinutes)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">SummaryTextField</span>(summaryToSet: $newInteraction.summary)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">LocationPicker</span>(shouldShow: newInteraction.type.hasLocation,</span><br><span class="line">                                   coordinatesToSet: $newInteraction.location.coordinates,</span><br><span class="line">                                   locationNameToSet: $newInteraction.location.name,</span><br><span class="line">                                   isPresentingLocationPicker: $isPresentingLocationPicker)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">InteractionPhotosPicker</span>(images: $newInteraction.pictures)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toolbar &#123;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .cancellationAction) &#123;</span><br><span class="line">                    <span class="type">Button</span>(<span class="string">"Dismiss"</span>) &#123;</span><br><span class="line">                        isPresentingNewInteractionView = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .confirmationAction) &#123;</span><br><span class="line">                    <span class="type">Button</span>(<span class="string">"Add"</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> index = relations.firstIndex(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.id == relation.id &#125;) &#123;</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">"\nBefore appending to relations"</span>)</span><br><span class="line">                            <span class="built_in">print</span>(relations[index])</span><br><span class="line">                            <span class="built_in">print</span>(newInteraction)</span><br><span class="line">                            relations[index].interactions.append(newInteraction)</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">"\nAfter having appended to relations"</span>)</span><br><span class="line">                            <span class="built_in">print</span>(relations[index])</span><br><span class="line">                            <span class="built_in">print</span>(newInteraction)</span><br><span class="line">                        &#125;</span><br><span class="line">                        isPresentingNewInteractionView = <span class="literal">false</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//AJOUTER LA PLANIFICATION D'UNE NOTIFICATION</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">"New interaction"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如在代码中看到的，我包含了三个“打印”指令来帮助我调试它。 当我尝试添加两个交互时，以下是控制台中打印的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Before</span> appending to relations</span><br><span class="line"><span class="type">Relation</span>(id: <span class="type">EA18AAD4</span>-<span class="type">E576</span>-49A9-90BF-<span class="type">CC58C5000ECE</span>, firstName: <span class="string">"Johanna"</span>, lastName: <span class="string">"Duby"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1814400.0</span>, birthday: <span class="type">Optional</span>(<span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">40</span> +<span class="number">0000</span>), notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.blue, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">After</span> having appended to relations</span><br><span class="line"><span class="type">Relation</span>(id: <span class="type">EA18AAD4</span>-<span class="type">E576</span>-49A9-90BF-<span class="type">CC58C5000ECE</span>, firstName: <span class="string">"Johanna"</span>, lastName: <span class="string">"Duby"</span>, photo: <span class="literal">nil</span>, interactions: [<span class="type">Relations</span>.<span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])], contactFrequency: <span class="number">1814400.0</span>, birthday: <span class="type">Optional</span>(<span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">40</span> +<span class="number">0000</span>), notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.blue, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"><span class="type">Before</span> appending to relations</span><br><span class="line"><span class="type">Relation</span>(id: 8D3D2012-<span class="type">D8A2</span>-<span class="number">4092</span>-<span class="type">B1A9</span>-<span class="type">D476F7E05B9A</span>, firstName: <span class="string">"Nastassja"</span>, lastName: <span class="string">"Ferrari"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1209600.0</span>, birthday: <span class="literal">nil</span>, notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.green, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 5C4EE2E1-7D2D-4E32-<span class="type">BC00</span>-<span class="type">FCA781EC8C20</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">49</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">After</span> having appended to relations</span><br><span class="line"><span class="type">Relation</span>(id: 8D3D2012-<span class="type">D8A2</span>-<span class="number">4092</span>-<span class="type">B1A9</span>-<span class="type">D476F7E05B9A</span>, firstName: <span class="string">"Nastassja"</span>, lastName: <span class="string">"Ferrari"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1209600.0</span>, birthday: <span class="literal">nil</span>, notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.green, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 5C4EE2E1-7D2D-4E32-<span class="type">BC00</span>-<span class="type">FCA781EC8C20</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">49</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br></pre></td></tr></table></figure><p>4) 提问<a href="https://forums.swift.org/t/are-nested-recursive-macros-supported-in-swift-5-9/65569" title="Swift 5.9 是否支持嵌套/递归宏？" target="_blank" rel="noopener">Swift 5.9 是否支持嵌套/递归宏？</a></p><p>5) 提问<a href="https://forums.swift.org/t/how-to-reference-an-article-in-a-different-module/65581" title="如何引用不同模块中的文章？" target="_blank" rel="noopener">如何引用不同模块中的文章？</a></p><p>查看 DocC 代码链接的语法，似乎我们有办法引用同一模块中的文章：</p><doc:gettingstarted><p>但是我们不能使用前导斜杠语法来指定模块相对路径，因为它已经被 tutorials 命名空间占用：</p><p><a href="doc:/tutorials/SlothCreator" target="_blank" rel="noopener">doc:/tutorials/SlothCreator</a></p><p>如何引用来自不同模块的文章？</p><p>回答：</p><p>库存 DocC 尚不支持外部 - 或者更具体地说，尚未提供公共解决方案。 早期的 DocC 代码中有一些关于允许某些过程的外部引用解析器的位，@ronnqvist 一直在研究更新的解决方案（“分层解析器”）——但我只关注了一些 PR（最近的一个 提取了很多旧代码：通过 d-ronnqvist 添加成功解析的外部引用到参考索引, <a href="https://github.com/apple/swift-docc/pull/582" target="_blank" rel="noopener">Pull Request #582</a>）</p><p>6) 提问<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="Macros包会嵌入到App中吗？" target="_blank" rel="noopener">Macros包会嵌入到App中吗？</a></p><p>例如，当我使用 #stringify Swift 宏在我的应用程序中生成代码时，它会在编译期间用新代码替换我的一些源代码。 那么这个宏包会随我的应用程序一起提供吗？ 或者它只是在编译期间发生</p><p>回答：替换发生在编译时。 宏目标不应链接到应用该目标中包含的宏的代码。</p><p>7) 提问<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="哪个 Apple Networking Api 用于 UDP 多播和单播？" target="_blank" rel="noopener">哪个 Apple Networking Api 用于 UDP 多播和单播？</a></p><p>一般而言，iOS 开发和网络的新手。 开发一个游戏节目类型的应用程序，其中“主机”设备需要多播到“参赛者”设备。 参赛者设备也需要能够响应。 实际上传递的信息很少，但速度很重要，因此使用 UDP。 </p><p>我一直在研究苹果设备的一些常用网络 api：network.framework、CocoaAsyncSocket、Multipeer-Connectivity、BSD 套接字等。总的来说，我倾向于只使用高级 network.framework 但缺乏 示例和资源使决策变得困难。 任何意见，将不胜感激。</p><p>回答：<a href="https://developer.apple.com/documentation/technotes/tn3151-choosing-the-right-networking-api" target="_blank" rel="noopener">TN3151: Choosing the right networking API</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/introducing-swift-openapi-generator/" title=" Swift OpenAPI Generator 的介绍" target="_blank" rel="noopener">Swift OpenAPI Generator 的介绍</a></p><p><strong>摘要：</strong> Swift OpenAPI Generator是一个 SwiftPM 插件，它可以生成客户端代码或服务器端代码，以便处理 HTTP 调用。 OpenAPI 是一种用于记录HTTP服务的规范，可以使用YAML或JSON编写，并可被工具读取，以帮助自动化工作流程，例如生成必要的代码以发送和接收HTTP请求。Swift OpenAPI Generator 可以帮助我们通过 OpenAPI 文档描述HTTP请求和响应的结构，包括 HTTP 方法、 URL 路径和查询参数、HTTP状态码和内容类型，使用 JSON Schema 描述响应体的结构，使得我们能够在开发应用程序时生成网络代码，而不需要手动编写和维护网络代码，专注于核心业务逻辑。要使用 Swift OpenAPI Generator 插件，需要添加 SwiftPM 依赖项以及运行时库和传输实现，然后使用生成的API客户端或服务器端存根。 Swift OpenAPI Generator 支持大多数常用特性，但仍有一些特性需要实现，项目跟踪进展情况可以使用 GitHub issues </p><p><a href="https://www.avanderlee.com/swift/macros/" title=" Swift 宏：使用新的表达方式扩展 Swift" target="_blank" rel="noopener"> Swift 宏：使用新的表达方式扩展 Swift</a></p><p><strong>摘要：</strong>  Swift 宏是在 Swift 5.9发布的一项新功能，它允许你通过自定义编译时检查和生成新的代码，在编译时将它们写入到你的文件中，从而消除冗余的样板代码。本文讲解了宏的工作原理、如何编写自定义宏以及如何进行测试，以验证一个允许在编译时验证 URL 并在 URL 有效时返回解包值的宏的例子。本文还讨论了宏的不同角色，包括独立和附加宏，并解释了为什么你可能考虑在代码中使用宏。</p><p><a href="https://www.avanderlee.com/swift/share-swift-code-swift-on-server-vapor/" title="在 Swift 服务器端 Vapor 和客户端应用之间共享 Swift 代码" target="_blank" rel="noopener">在 Swift 服务器端 Vapor 和客户端应用之间共享 Swift 代码</a></p><p><strong>摘要：</strong> 这篇博客讨论了在客户端应用和后端服务器之间共享 Swift 代码的好处以及如何通过 Swift 包和 Vapor 实现这一目标。通过共享模型和端点定义，您可以确保两个侧面都使用相同的层，避免出现意料之外的请求失败。博客提供了定义软件包结构、暴露模型、共享端点定义和在后端软件包中配置端点的代码示例。此外，它提供了一个通用方法，用于请求端点并在客户端应用中使用它们。作者还提到了优化适用于所有支持的 HTTP 方法的代码的重要性。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>薪酬保密作为人力资源管理中一项颇具争议的举措，近年来学界对其研究越来越多。有人提出，实行薪酬保密，能让企业根据员工绩效的高低提供差异较大的薪酬，提升薪酬激励作用，同时也能避免因为收入差距产生内部冲突。也有人提出公开的薪酬制度能使内部沟通更为有效，减少误传，增强信任感，作为一种制度，薪酬的等级体系、岗位差距以及操作程序还应以公开为准则。<strong>你认为企业实行薪资保密有哪些利弊？</strong></p><p>1.保护员工个人隐私。</p><p>2.避免员工之间的比较和嫉妒心理，减少内部矛盾。</p><p>3.难以查看薪资公正性，更少的保密性意味着更多的平等。</p><p>4.易产生员工对公司不信任，让员工产生长期处于被剥削的感觉。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p></doc:gettingstarted>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十二期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;若目标远大，就要有大动作。若追求卓越，便须有大改变。&lt;strong&gt;Swift社区&lt;/strong&gt;已整装待发，你要不要一起呢？👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：Apple Vision Pro 和 visionOS 撼世登场&lt;/p&gt;
&lt;p&gt;提案：移除由属性包装器引起的 Actor 隔离推断&lt;/p&gt;
&lt;p&gt;Swift 论坛：为什么只能将结构附加到数组一次&lt;/p&gt;
&lt;p&gt;推荐博文：Swift OpenAPI Generator 的介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为企业实行薪资保密有哪些利弊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十期/</id>
    <published>2023-07-04T07:20:16.000Z</published>
    <updated>2023-07-04T07:31:19.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十一期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>求人不如求己，你多一样本领，就少一点啊乞求；<strong>Swift社区</strong>让你多一样技能，少一些嘲讽！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：码出新宇宙，WWDC23 就在眼前</p><p>提案：有 4 个提案通过，本期没有产生新的提案</p><p>Swift 论坛：PermutableCollection 协议</p><p>推荐博文：SwiftUI 中 LinearGradient的用法</p><p><strong>话题讨论：</strong> </p><p>有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/6f2a4159-0a47-4f33-b6d2-5f7516d78f89.png" alt=""></p><p>上期话题讨论结果表明，<strong>社交隔阂</strong>和<strong>个人选择标准的提高</strong>是导致男女群体互不干涉的主要原因，而<strong>社会观念的变化</strong>也起到了一定的影响。这些因素共同作用导致了男群体和女群体相互独立地寻找伴侣的现象。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="App、App-内购买项目和订阅即将实行税率调整"><a href="#App、App-内购买项目和订阅即将实行税率调整" class="headerlink" title="App、App 内购买项目和订阅即将实行税率调整"></a>App、App 内购买项目和订阅即将实行税率调整</h3><p>App Store 的交易和支付机制旨在帮助你在覆盖全球的 175 个国家和地区的商店中，以 44 种货币为你的产品和服务便捷地进行定价与销售。Apple 会为开发者管理其中 70 多个国家和地区的税收，而且你还能够为 App 和 App 内购买项目分配税务类别。我们会根据税务法规的变化，定期更新你在某些地区的收益。</p><p>从 5 月 31 日起，你从 App 和 App 内购买项目 (包括自动续期订阅) 销售中获得的收益将进行调整，以反映以下税率调整。请注意，相关内容的价格将保持不变。</p><p>加纳：增值税率从 12.5% 上调至 15%。<br>立陶宛：对于符合条件的电子书和有声书，增值税率从 21% 下调至 9%。<br>摩尔多瓦：对于符合条件的电子书和期刊，增值税率从 20% 下调至 0%。<br>西班牙：收取 3% 的数字服务税。<br>由于巴西税务法规的变化，在巴西开展的所有 App Store 销售现由 Apple 代扣税款。我们会按月代扣代缴应向相应税务机关缴纳的税款。自 2023 年 6 月开始，你可以在 5 月份的收入中查看从你的收益中扣除的税款金额。巴西境内的开发者不会受到这一变化的影响。</p><p>以上调整生效后，App Store Connect 中“我的 App”的“价格与销售范围”部分会随即更新。一如既往，你可以随时更改你的 App 和 App 内购买项目的价格 (包括自动续期订阅)。现在，你可以从 900 个价格点中选择，为任何店面更改定价。</p><h3 id="码出新宇宙"><a href="#码出新宇宙" class="headerlink" title="码出新宇宙"></a>码出新宇宙</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/B6D2ADBF-1563-457E-82CE-374A654AA6B0/2048.jpeg" alt=""></p><p>WWDC23 就在眼前。太平洋夏令时间 6 月 5 日上午 10 点，Apple 主题演讲将在 apple.com 和 Apple Developer App 线上提供，为本次大会拉开序幕。你还可以通过同播共享，邀请朋友一起观看。</p><p>现在，符合条件的开发者可以开始报名参加活动了。相关活动包括 Q&amp;A、“会见演讲者”以及社区暖场活动等线上聊天室活动，旨在促进你与开发者社区和 Apple 专家的沟通和交流。</p><h3 id="Apple-公证服务更新"><a href="#Apple-公证服务更新" class="headerlink" title="Apple 公证服务更新"></a>Apple 公证服务更新</h3><p>正如去年在 WWDC (简体中文字幕) 上宣布的那样，如果你目前使用 altool 命令行工具或者 Xcode 13 或更早版本通过 Apple 公证服务对 Mac 软件进行公证，则需要改为使用 notarytool 命令行工具，或者升级到 Xcode 14 或更高版本。自 2023 年 11 月 1 日起，Apple 公证服务将不再接受从 altool 或者 Xcode 13 或更早版本上传的内容。已经过公证的现有软件可以继续正常工作。</p><p>Apple 公证服务是一个自动化系统，它会扫描 Mac 软件中有没有恶意内容，检查有没有代码签名问题，并快速返回结果。对软件进行公证可向用户保证，Apple 已检查且未发现软件中包含恶意软件。</p><p>为改进 Apple 平台的安全性和隐私保护，用于验证 App 和关联 App 内购买项目销售的 App Store 收据签名媒介证书将更新为使用 SHA-256 加密算法。此更新将分多个阶段完成，新的 App 和 App 更新可能会受影响，具体取决于它们验证收据的方式。</p><h3 id="Apple-设计大奖入围名单公布"><a href="#Apple-设计大奖入围名单公布" class="headerlink" title="Apple 设计大奖入围名单公布"></a>Apple 设计大奖入围名单公布</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/020C144B-0FE5-49A1-ADB2-7B01072574C7/2048.jpeg" alt=""></p><p>Apple 设计大奖旨在表彰在多元包容、乐趣横生、出色互动、社会影响、视觉图像，以及创新思维等类别中表现出色的 App 和游戏。马上一睹今年的入围作品，我们将在太平洋夏令时间 6 月 5 日下午 6:30 揭晓获奖者，敬请关注。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0399-tuple-of-value-pack-expansion.md" title="SE-0399" target="_blank" rel="noopener">SE-0399</a> <strong>value 包展开的元组</strong> 提案通过审查。该提案已在 <strong>二十九期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0397-freestanding-declaration-macros.md" title="SE-0397" target="_blank" rel="noopener">SE-0397</a> <strong>独立声明 Macros</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0392-custom-actor-executors.md" title="SE-0392" target="_blank" rel="noopener">SE-0392</a> <strong>自定义 Actor 执行器</strong> 提案通过审查。该提案已在 <strong>二十五期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md" title="SE-0390" target="_blank" rel="noopener">SE-0390</a> <strong>引入 @noncopyable </strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://translate.google.com/?sl=en&amp;tl=zh-CN&amp;text=Migrating%20from%20Realm%20Database%20Tips%3F&amp;op=translate" title="从 Realm 数据库迁移提示？" target="_blank" rel="noopener">从 Realm 数据库迁移提示？</a></p><p><strong>提问</strong></p><p>目前正在寻求迁移到更轻量级的解决方案（realm 目前对我的用例来说太过分了）并且想迁移到 grdb，但不必将 realm 作为依赖项持续一年或更长时间……</p><p><strong>回答</strong></p><p>在没有 Realm 库的情况下，您是否能够读取 Realm 数据库文件的内容？ 否则，您必须将 Realm 作为依赖项保留，直到您的用户迁移完毕。</p><p>您可以通过发布能够要求用户升级的应用程序版本来缩短时间跨度。 这将允许您使用 “Realm-only”、“Realm-to-GRDB” 和最终的 “GRDB-only” 版本进行过渡。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-allow-protocols-to-be-nested-in-non-generic-contexts/65285" title="允许 protocol 嵌套在非通用上下文中" target="_blank" rel="noopener">允许 protocol 嵌套在非通用上下文中</a></p><p><strong>介绍</strong></p><p>允许协议嵌套在非通用 struct/class/enum/actors 和函数中。</p><p><strong>动机</strong></p><p>将标称类型嵌套在其他标称类型中允许开发人员表达内部类型的自然范围——例如，String.UTF8View 是嵌套在 struct String 中的 struct UTF8View，它的名称清楚地传达了它作为 UTF-8 代码接口的用途 - 字符串值的单位。</p><p>但是，嵌套目前仅限于在其他 struct/class/enum/actors 中的 struct/class/enum/actors； 协议根本不能嵌套，因此必须始终是模块中的顶级类型。 这很不幸，我们应该放宽此限制，以便开发人员可以表达自然作用于某些外部类型的协议。</p><p><strong>建议的解决方案</strong></p><p>我们将允许在非泛型 struct/class/enum/actors 中以及在不属于泛型上下文的函数中嵌套协议。</p><p>例如，TableView.Delegate 自然是与表视图相关的委托协议。 开发人员应该这样声明它——嵌套在他们的 TableView 类中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableView</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">Delegate</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span>: TableView, didSelectRowAtIndex: Int)</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegateConformer</span>: <span class="title">TableView</span>.<span class="title">Delegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span>: TableView, didSelectRowAtIndex: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前，开发人员采用复合名称（例如 TableViewDelegate）来表达可以通过嵌套表达的相同自然范围。</p><p>作为一个额外的好处，在 TableView 的上下文中，可以使用更短的名称来引用嵌套协议委托（与所有其他嵌套类型一样）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">Delegate</span>?</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">Delegate</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议也可以嵌套在非泛型函数和闭包中。 不可否认，这在某种程度上是有限的实用性，因为对此类协议的所有一致性也必须在同一功能内。 但是，也没有理由人为地限制开发人员在函数中创建的模型的复杂性。 一些代码库（值得注意的是，Swift 编译器本身）使用带有嵌套类型的大型闭包，并且它们受益于使用协议的抽象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">protocol</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     associatedtype <span class="type">ResultType</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">ResultType</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">SomeConformance</span>: <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AnotherConformance</span>: <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">impl</span>&lt;T: Abstraction&gt;<span class="params">(<span class="number">_</span> input: T)</span></span> -&gt; <span class="type">T</span>.<span class="type">ResultType</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">let</span> <span class="number">_</span>: <span class="type">Int</span> = impl(<span class="type">SomeConformance</span>())</span><br><span class="line">   <span class="keyword">let</span> <span class="number">_</span>: <span class="type">String</span> = impl(<span class="type">AnotherConformance</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 提议<a href="https://forums.swift.org/t/permutablecollection-protocol/65314" title="PermutableCollection 协议" target="_blank" rel="noopener">PermutableCollection 协议</a></p><p><strong>简介</strong></p><p>该提案旨在添加一个 PermutableCollection 协议，该协议将位于集合协议层次结构中的 Collection 和 MutableCollection 之间。</p><p><strong>动机</strong></p><p>在某些情况下，人们希望能够移动和排序元素，同时不允许（或限制）元素的突变。 鉴于大量不太重要的收集协议，这是一个值得注意的遗漏。 创建自定义集合类型时，PermutableCollection 协议在任何强制元素唯一性和/或身份的有序集合中都是首选。 用例将包括即将推出的 OrderedDictionary 和 OrderedSet。 对于不可变和可变集合，它还可以提供对 Swift 使用的底层（并且可能是高度优化的）排序算法的统一访问。</p><p><strong>设计</strong></p><p>协议设计简单，只需一个 swapAt 要求</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A collection that supports sorting.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PermutableCollection</span>&lt;<span class="title">Element</span>&gt; : <span class="title">Collection</span> <span class="title">where</span> <span class="title">Self</span>.<span class="title">SubSequence</span> : <span class="title">PermutableCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  mutable <span class="function"><span class="keyword">func</span> <span class="title">swapAt</span><span class="params">(<span class="number">_</span> i: Index, <span class="number">_</span> j: Index)</span></span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 swapAt 函数，通过扩展添加额外的排序函数实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PermutableCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(fromOffsets source: IndexSet, toOffset destination: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// move algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(by belongsInSecondPartition: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">    <span class="comment">// partition algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">()</span></span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">RandomAccessCollection</span>, <span class="type">Self</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// partition algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... more permutation operations that mimic those available for MutableCollection</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/vapor-and-query-caching/65278" title="Vapor和query缓存？" target="_blank" rel="noopener"> Vapor 和 query 缓存？</a></p><p>5) 讨论<a href="https://forums.swift.org/t/in-swift-system-how-does-one-read-a-files-contents-to-a-string/65294" title="在 Swift 系统中，如何将文件内容读取为字符串？" target="_blank" rel="noopener">在 Swift 系统中，如何将文件内容读取为字符串？</a></p><p><strong>提问</strong></p><p>我有一个文件的 FileDescriptor：</p><p>let fd = try FileDescriptor.open(&lt;#filepath#&gt;, .readOnly) 我可以使用 fd.read(into:) 将文件内容加载到 UnsafeMutableRawBufferPointer，但这是将文件内容加载到字符串中的正确第一步吗？ 如果是这样，</p><p>在将它传递给 fd.read(into:) 之前，</p><ol><li>我需要使用 .allocate(byteCount:alignment:) 分配 UnsafeMutableRawBufferPointer。 正确的 byteCount 取决于文件的大小。那么如何使用 Swift System 获取文件的大小呢？</li><li>如何从 UnsafeMutableRawBufferPointer 获取字符串？</li></ol><p><strong>回答</strong></p><p>可以参考这个Git库：<a href="https://github.com/tayloraswift/swift-unidoc/blob/master/Sources/System/FileDescriptor.swift" target="_blank" rel="noopener">https://github.com/tayloraswift/swift-unidoc/blob/master/Sources/System/FileDescriptor.swift</a></p><p>6) 讨论<a href="https://forums.swift.org/t/why-can-t-i-forward-enum-cases-with-dynamicmemberlookup/65290" title="为什么我不能使用 @dynamicMemberLookup 转发 enum cases？" target="_blank" rel="noopener">为什么我不能使用 @dynamicMemberLookup 转发 enum cases？</a></p><p>7) 讨论<a href="https://forums.swift.org/t/how-to-do-performance-testing-properly-in-swift-foundation/65282" title="如何在 swift-foundation 中正确地进行性能测试？" target="_blank" rel="noopener">如何在 swift-foundation 中正确地进行性能测试？</a></p><p><strong>提问</strong></p><p>我想对比一下swift-foundation 和 Xcode 自带的 JSONDecoder 解码的速度。</p><p>我在一个新项目中使用单元测试和 measureBlock 以及在 swift-foundation 中使用 JSONEncoderTests 对其进行了测试。</p><p>swift-foundation 中的 JSONDecoder 看起来太慢了，我认为这是因为 swift-foundation 还没有作为一个库被引入。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7238802590661476412/" title="iOS crash 报告分析系列 - 看懂 crash 报告的内容" target="_blank" rel="noopener">iOS crash 报告分析系列 - 看懂 crash 报告的内容</a></p><p><strong>摘要：</strong> 本篇文章主要介绍了iOS崩溃报告的解读方法，从报告的 Header、Exception information、Diagnostic messages、Backtraces、Thread state 和 Binary images 六个部分详细讲解了各字段含义，并提供示例代码帮助读者更好地理解。同时也引导读者去深入学习符号化的相关知识来获得更多信息。通过阅读本文，开发者可轻松看懂代码中产生的崩溃报告，并进行问题定位和处理。</p><p><a href="https://swdevnotes.com/swift/2023/lineargradient-in-swiftui/" title="SwiftUI 中 LinearGradient的用法" target="_blank" rel="noopener">SwiftUI 中 LinearGradient的用法</a></p><p><strong>摘要：</strong> 这篇博文探讨了在 SwiftUI 中使用 LinearGradient 为对象创建渐变颜色效果。它展示了如何定义颜色数组、使用标准和自定义起点和终点，以及设置坐标以改进铅笔对象上的颜色笔尖。本文还包括用于创建具有各种起点终点组合的不同线性渐变的示例代码。文章以示例结束，展示了如何使用这些技术来自定义一支蓝色铅笔或整套铅笔的外观。</p><p><a href="https://swiftwithmajid.com/2023/05/23/dynamic-member-lookup-in-swift/" title="Swift 中的动态成员查找" target="_blank" rel="noopener">Swift 中的动态成员查找</a></p><p><strong>摘要：</strong> 本文介绍了 Swift 语言中的动态成员查找（Dynamic Member Lookup）特性。通过在类型上使用 @dynamicMemberLookup 属性，我们可以重载该类型的 subscript 方法来更方便地访问其数据。但是，这也意味着缺乏编译时安全性。为了解决这个问题，本文提到了使用 KeyPath 作为参数的 subscript 方法来实现编译时安全检查。最后，作者建议我们可以谨慎地使用 <code>@dynamicMemberLookup</code> 特性来改进 API 设计。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？</strong></p><p>1.是的。确实已经经济危机了，今年工作很难找，同事比以前更卷啦，各种裁员消息不断。</p><p>2.经济危机不可能。五一淄博接待游客超过了100万人次，人挤人的旅游景象依然常在。</p><p>3.经济危机应该是相对的。对于大多数上班族来说，2023年很难，奉劝大家且行且珍惜。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十一期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;求人不如求己，你多一样本领，就少一点啊乞求；&lt;strong&gt;Swift社区&lt;/strong&gt;让你多一样技能，少一些嘲讽！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：码出新宇宙，WWDC23 就在眼前&lt;/p&gt;
&lt;p&gt;提案：有 4 个提案通过，本期没有产生新的提案&lt;/p&gt;
&lt;p&gt;Swift 论坛：PermutableCollection 协议&lt;/p&gt;
&lt;p&gt;推荐博文：SwiftUI 中 LinearGradient的用法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十九期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十九期/</id>
    <published>2023-07-04T07:20:09.000Z</published>
    <updated>2023-07-04T07:30:45.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>最无情的永远不是环境，而是缺乏勇气的内心。<strong>Swift社区</strong>与你一起，赤胆平乱世，长枪定江山！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：担心泄密！外媒：苹果公司限制员工使用ChatGPT</p><p>提案：value 包展开的元组</p><p>Swift 论坛：讨论 Xcode 忽略 Package.resolved 文件</p><p>推荐博文：万字长文详解如何使用 Swift 提高代码质量</p><p><strong>话题讨论：</strong> </p><p>一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/c465cfe7-1b3a-49d3-820c-e7b06fd7738b.png" alt=""></p><p>上期话题讨论结果表明对于 AI 是否会取代软件工程师的问题，大家的观点存在分歧，而实际的结果可能<strong>取决于 AI 技术的发展和与人类工程师的协作方式的演变</strong>。让我们拭目以待。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="担心泄密！外媒：苹果公司限制员工使用ChatGPT"><a href="#担心泄密！外媒：苹果公司限制员工使用ChatGPT" class="headerlink" title="担心泄密！外媒：苹果公司限制员工使用ChatGPT"></a>担心泄密！外媒：苹果公司限制员工使用ChatGPT</h3><p>中新经纬 5 月 19 日电 据华尔街日报中文网 19 日报道，其获悉的一份文件以及知情人士的消息显示，苹果公司已经限制使用 ChatGPT 和其他外部 AI 工具。</p><p>根据这份文件，苹果公司担心员工使用这类程序可能会泄露机密数据。该文件还称，苹果公司还告诉员工，不要使用微软所有的 GitHub 的产品 Copilot。Copilot 可以自动编写软件代码。</p><p>ChatGPT 是 AI 研究公司 OpenAI 开发的一款人工智能聊天机器人。该产品于 2022 年 11 月发布，可以进行从历史到哲学等话题的对话，并对计算机程序代码提供修改建议。</p><p>值得注意的是，在 ChatGPT 爆火的背后，也出现过商业泄密的重大事故。</p><p>今年 4 月，据多家媒体报道，三星电子引入聊天机器人 ChatGPT 不到 20 天，便曝出机密资料外泄，如半导体设备测量数据、产品良率等内容。为杜绝类似事故再发生，三星制定相关保护措施，该公司向员工表示，“若采取信息保护紧急措施后仍发生类似事故，公司内部网络可能会切断 ChatGPT 连接”。</p><p>此外，已经有国家监管机构注意到了数据安全风险。</p><p>当地时间 3 月 31 日，意大利个人数据保护局宣布，即日起禁止使用聊天机器人 ChatGPT ，限制其开发公司 OpenAI 处理意大利用户信息，并开始立案调查。意大利个人数据保护局认为，3 月 20 日 ChatGPT 平台出现了用户对话数据和付款服务支付信息丢失情况，而该平台没有就收集处理用户信息进行告知，且缺乏大量收集和存储个人信息的法律依据。(中新经纬APP)</p><h3 id="苹果公司大幅削减其MR头显销售预期，不足百万台"><a href="#苹果公司大幅削减其MR头显销售预期，不足百万台" class="headerlink" title="苹果公司大幅削减其MR头显销售预期，不足百万台"></a>苹果公司大幅削减其MR头显销售预期，不足百万台</h3><p>品玩 5 月 19 日讯，据界面新闻消息，苹果公司已将其期待已久的混合现实（MR）头显的销售预期下调约三分之二。报道指出，苹果最初希望每年销售约 300 万台，但现在已将销售预期削减至约 100 万台，随后又下调至 90 万台。该公司将于 6 月 5 日举行全球开发者大会，预计将在会上展示该产品。该设备的售价预计会高达 3000 美元左右，是 Meta Platforms 最昂贵的 Quest Pro 头显售价的三倍。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0396-never-codable.md" title="SE-0396" target="_blank" rel="noopener">SE-0396</a> <strong>Never 遵守 Codable</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>允许泛型类型对包进行抽象声明</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>value 包展开的元组</strong> 提案正在审查。</p><p>之前的 SE-0393 引入了 Value 和 Type 参数包。该提案允许引用一个包含在重复模式中的 value 包的元组值。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/swiftui-charts-very-large-data-sets-and-chart-overlay/65054" title="SwiftUI 图表、超大数据集和图表叠加" target="_blank" rel="noopener">SwiftUI 图表、超大数据集和图表叠加</a></p><p>2) 讨论<a href="https://forums.swift.org/t/sendable-warning-with-thread-safe-property-wrapper/65053" title="带有线程安全属性包装器的可发送警告" target="_blank" rel="noopener">带有线程安全属性包装器的可发送警告</a></p><p>当使用有针对性的严格并发进行构建时，我收到一条警告，我想知道除了使我的类型“未经检查的可发送”之外，我是否可以做任何事情。</p><p>考虑一些线程安全的属性包装器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper <span class="class"><span class="keyword">struct</span> <span class="title">ThreadSafe</span>&lt;<span class="title">Value</span>: <span class="title">Sendable</span>&gt;: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock: <span class="type">Lock</span>&lt;<span class="type">Value</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; lock.withLock &#123; $<span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; lock.withLock &#123; $<span class="number">0</span> = newValue &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(lock: .<span class="keyword">init</span>(initialState: wrappedValue))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(lock: <span class="type">Lock</span>&lt;<span class="type">Value</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.lock = lock</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并考虑使用它来强制执行线程安全和可发送性的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeSendable</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">    @<span class="type">ThreadSafe</span></span><br><span class="line">    <span class="keyword">var</span> someBool: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使我的课程是线程安全的，我仍然收到此警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stored</span> property '_someBool' of '<span class="type">Sendable'</span>-conforming <span class="class"><span class="keyword">class</span> '<span class="title">SomeSendable</span>' <span class="title">is</span> <span class="title">mutable</span></span></span><br></pre></td></tr></table></figure><p>编译器诊断似乎没有检查属性包装器的可发送性。</p><p>有没有办法在不使我的类型“未选中”的情况下平息此警告？</p><p><strong>回答</strong></p><p>问题是任何带有 var 的类总是不可发送的，并且属性包装器不允许 let。</p><p>但对我来说，真正的问题是 SomeSendable 使用起来真的不是那么安全，特别是 <code>@ThreadSafe</code> 是不安全的。 它使得以易受竞争影响的方式使用可变状态变得太容易了。 由于数据被锁定，您肯定不会遇到运行时崩溃，但您很容易得到不正确的结果。</p><p>例如，像旋转 1,000 个任务来切换布尔值这样简单的事情在最后总是会产生一个真值，但有时你会得到假，有时你会得到真：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = <span class="type">SomeSendable</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">1000</span> &#123;</span><br><span class="line">  <span class="type">Task</span> &#123; object.toggle() &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(object.someBool)</span><br></pre></td></tr></table></figure><p>这是一个相当大的问题，它正在发生，因为 <code>@ThreadSafe</code> 允许直接写入底层值。 所以像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.someBool = !object.someBool</span><br></pre></td></tr></table></figure><p>…隐藏竞争条件。</p><p>实际上，您可能应该直接在类中保留 Lock 值，而不是使用 <code>@ThreadSafe</code> 属性包装器，然后仅通过它的 withValue 进行变异。 当然，如果可变数据的安全是最重要的问题，那么您真的应该使用 actor。</p><p>3) 讨论<a href="https://forums.swift.org/t/using-snippets-in-documentation-comments-not-possible/65046" title="无法在文档注释中使用片段？" target="_blank" rel="noopener">无法在文档注释中使用片段？</a></p><p>我阅读 SE-0356 的方式应该可以在 Swift 包的 Snippets 文件夹中创建一个片段文件，然后通过@Snippet 在我的文档评论中引用它。</p><p>但这似乎并不像我预期的那样工作（使用 Xcode 14.3 / Swift 5.8）：</p><p><code>@Snippet</code> 给我警告：“符号源文档不支持指令”<br>显示我记录的类型的快速帮助不包括片段。</p><p>使用菜单“产品”&gt;“构建文档”生成没有代码片段的文档。</p><p><strong>回答</strong></p><p>片段在 Swift 5.7 中实现，并可通过 <code>swift-docc-plugin</code> 与 SwiftPM 一起使用，但正如其他人指出的那样，没有与基于 Xcode 的文档工作流集成，因为它使用不同的构建系统。 我会更新提案。</p><p>4) 讨论<a href="https://forums.swift.org/t/xcode-ignoring-package-resolved-file/65031" title="Xcode 忽略 Package.resolved 文件" target="_blank" rel="noopener"> Xcode 忽略 Package.resolved 文件</a></p><p>我不确定这是 SPM 问题还是 Xcode 问题，但将 SPM 与 Xcode 一起使用时最令人沮丧的经历之一是它经常忽略我的 repo 中的 <code>Package.resolved</code> 文件，通常是在切换分支或不同机器之间时。</p><p><code>Package.resolved</code> 文件应该是我的依赖项的真实来源，它永远不应该被忽略——如果有问题，包解析失败，但永远不要改变我的依赖项。</p><p>似乎发生的情况是，Xcode 更愿意使用其源缓存中恰好满足包版本要求的库版本，而不是解析文件中的库版本。 例如，我有一个版本要求为“2.2.0 up to next minor”的库。 </p><p>Package.resolved 文件中有 2.2.3，所以这是我希望始终使用的版本，除非我进行一些会引入冲突的更改。 当我在另一台机器上打开同一个项目时，出于某种原因它坚持要更改为 2.2.2，大概这是它缓存中的版本。 为什么？ 如果可以忽略已解析文件的意义何在？</p><p><strong>回答</strong></p><p>我可能遗漏了一些细节，但在更新到 Xcode 14.3 并在我们的 CI 中面对这个问题时，我们意识到我们从未使用 <code>-onlyUsePackageVersionsFromResolvedFile</code> 标志调用 xcodebuild。 现在我们这样做了，而且 CI 似乎尊重我们的 Package.resolved 文件。</p><p>对于我们来说，这个问题只存在于 Xcode 的 GUI 中。 （与此同时，我同样感到困惑，为什么需要 <code>-onlyUsePackageVersionsFromResolvedFile</code> 而不是 CLI 和 GUI 的默认模式！）</p><p>5) 讨论<a href="https://forums.swift.org/t/without-objective-c-or-swift-how-can-a-display-name-be-retrieved-from-cgdirectdisplayid-in-c-or-c/65034" title="如果没有 Objective-C 或 Swift，如何在 C 或 C++ 中从 CGDirectDisplayID 检索显示名称？" target="_blank" rel="noopener">如果没有 Objective-C 或 Swift，如何在 C 或 C++ 中从 CGDirectDisplayID 检索显示名称？</a></p><p>我试图在纯 C++（或 C）中从 <code>CGDirectDisplayID</code> 获取显示名称</p><p>我可以在 Objective-C++ 中做到这一点，类似于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;CoreGraphics/CoreGraphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;IOKit/graphics/IOGraphicsLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> getDisplayNameForDispID(<span class="built_in">CGDirectDisplayID</span> dispID,</span><br><span class="line">                             std::string&amp; strOutName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> bRes = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    strOutName.clear();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *screens = [<span class="built_in">NSScreen</span> screens];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSScreen</span> *screen <span class="keyword">in</span> screens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span>* screenDictionary = [screen deviceDescription];</span><br><span class="line">        <span class="keyword">if</span>(screenDictionary)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span>* screenID = [screenDictionary objectForKey:<span class="string">@"NSScreenNumber"</span>];</span><br><span class="line">            <span class="keyword">if</span>(screenID)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CGDirectDisplayID</span> aID = [screenID unsignedIntValue];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(aID == dispID)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Got it</span></span><br><span class="line">                    <span class="built_in">NSString</span>* pName = [screen localizedName];</span><br><span class="line">                    </span><br><span class="line">                    strOutName.assign([pName UTF8String], [pName lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line"></span><br><span class="line">                    bRes = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我不想仅仅为了完成这一项任务而将这个缓慢的 Objective-C 代码添加到我的项目中。 在低级 C 中，必须有一种方法可以做到这一点。</p><p>我知道有一个完整的主题专门讨论它。 由于 <code>CGDisplayIOServicePort</code> 已弃用并且仅返回 0 并且任何后续调用都会执行操作，因此请注意，没有任何解决方法为 macOS Ventura 提供工作。</p><p><strong>回答</strong></p><p>如果您坚持不直接使用任何 Objective C 代码，您仍然可以使用 Objective C 运行时 API 从 C 调用 Objective C API，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class nsScreen = objc_lookUpClass(<span class="string">"NSScreen"</span>);</span><br><span class="line">objc_object *screens = objc_msgSend(nsScreen, sel_getUid(<span class="string">"screens"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Desugaring "fast enumeration" is particularly knarly.</span></span><br><span class="line"><span class="comment">// for (NSScreen *screen in screens)</span></span><br><span class="line">objc_object *enumerator = objc_msgSend(screens, sel_getUid(<span class="string">"objectEnumerator"</span>));</span><br><span class="line">objc_object *screen;</span><br><span class="line"><span class="keyword">while</span> ((screen = objc_msgSend(enumerator, sel_getUid(<span class="string">"nextObject"</span>)) != <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>你会发现它比 Objective C 代码（实际上只是这类函数调用的语法糖）要“迟钝”得多，因为你需要一直转换所有内容。</p><p>我也完全忘记了手动添加内存管理。 你需要保留/释放一大堆东西。 真是一团糟。 如果你可以管理它，我强烈建议将其编译为 Objective C。</p><p>6) 讨论<a href="https://forums.swift.org/t/does-task-cancellation-propagate-to-urlsessiontasks/65041" title="任务取消是否传播到 URLSession 任务？" target="_blank" rel="noopener">任务取消是否传播到 URLSession 任务？</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="type">Task</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> (data, response) = <span class="keyword">try</span> await <span class="type">URLSession</span>.shared.data(from: <span class="type">URL</span>(string: <span class="string">"https://some-image-url.com"</span>)!)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我执行 <code>task.cancel()</code>，URLSession 是否也会自动取消 <code>URLSessionTask？</code> 假设 URLSessionTask 也被取消似乎很粗心，但我找不到关于此事的任何文档。 但是，如果 URLSessionTask 没有自动取消，那么我不得不使用基于闭包的 <code>URLSession.dataTask(with:,completionHandler:)</code> 来获取对 URLSessionTask 的引用，然后还调用 <code>dataTask.cancel()</code> 在 <code>task.cancel()</code> 之上，这有点奇怪。</p><p><strong>回答</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task will start"</span>)</span><br><span class="line">            <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://postman-echo.com/delay/10"</span>)!</span><br><span class="line">            <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: <span class="number">60.0</span>)</span><br><span class="line">            <span class="keyword">let</span> (data, response) = <span class="keyword">try</span> await <span class="type">URLSession</span>.shared.data(<span class="keyword">for</span>: request)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task did complete, response: <span class="subst">\(response)</span>, data: <span class="subst">\(data)</span>"</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task did error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: will cancel task"</span>)</span><br><span class="line">        t.cancel()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: did cancel task"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: waiting"</span>)</span><br><span class="line">    <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">60</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await main()</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">52</span> +<span class="number">0000</span>: task will start</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: will cancel task</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: did cancel task</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: waiting</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: task did error</span><br></pre></td></tr></table></figure><p>7) 讨论<a href="https://forums.swift.org/t/evolving-the-swift-workgroups/65052" title="发展 Swift 工作组" target="_blank" rel="noopener">发展 Swift 工作组</a></p><p>今天，Swift 核心团队宣布对 Swift 的结构、工作和周围的人进行前瞻性的改变。 这些更改包括新的组、名称、组织以及作为每个组的一流概念的包含。</p><p>链接：<a href="https://www.swift.org/blog/evolving-swift-project-workgroups/" target="_blank" rel="noopener">https://www.swift.org/blog/evolving-swift-project-workgroups/</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7231359714055077946/" title="万字长文详解如何使用 Swift 提高代码质量 | 京东云技术团队" target="_blank" rel="noopener">万字长文详解如何使用 Swift 提高代码质量 | 京东云技术团队</a></p><p><strong>摘要：</strong> 文章介绍了如何使用 Swift 提高代码质量。 Swift 的三个重要特性：富有表现力、安全性和快速。通过使用这些特性，可以提高代码质量并减少 Crash 的发生率。同时，本文还分享了一些实践技巧来提高使用 Swift 编写代码的效率和可读性，如利用编译检查、减少使用 Any/AnyObject 、不推荐大量使用 Dictionary 数据结构等。最后，从性能优化的角度，谈到了使用源代码打包，减少方法动态派发，使用 Slice 共享内存优化性能等来提高代码质量。</p><p><a href="https://swiftwithmajid.com/2023/05/03/the-power-of-overlays-in-swiftui/" title="swiftUI 中视图叠加的强大能力" target="_blank" rel="noopener">swiftUI 中视图叠加的强大能力</a></p><p><strong>摘要：</strong> 本博客文章讨论了 SwiftUI 中两个有趣的叠加使用案例。第一个案例涉及使用叠加来保持视图的结构标识，这对于防止性能问题和状态丢失至关重要。第二个用例是通过叠加视图修饰符构建自定义导航转换，使开发人员能够创建流畅的动画而不依赖 NavigationView 或 NavigationStack。提供示例以说明这些概念，并提供其他资源供进一步学习。总体而言，本文展示了 SwiftUI 中叠加功能的强大之处以及它们如何增强应用程序开发中用户体验。</p><p><a href="https://swiftwithmajid.com/2023/05/10/file-importing-and-exporting-in-swiftui/" title="SwiftUI 中的文件导入和导出" target="_blank" rel="noopener">SwiftUI 中的文件导入和导出</a></p><p><strong>摘要：</strong> 本篇博客讨论了如何使用 fileImporter 和 fileExporter 视图修饰符在 SwiftU I视图中导入和导出文件。文章包括两种操作的代码示例，以及一个额外部分介绍如何使用 fileMover 视图修改器进行文件移动。此外，还介绍了 TextDocument 类型，它符合 FileDocument 协议并允许从文件读取纯文本字符串，并将字符串数据导出到文件。总体而言，这篇文章强调了使用这些简单的视图修饰符可以轻松实现 SwiftUI 应用程序中的文件管理体验。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？</strong></p><p>1、社交隔阂：社交圈子的分隔和交流机会的减少<br>2、忙碌生活：现代社会的快节奏和高压力导致个人时间和精力有限<br>3、数字化社交：社交媒体和在线交友平台的兴起导致<br>4、个人选择标准的提高：个人对伴侣的要求变得更加苛刻，导致匹配的难度增加<br>5、社会观念的变化：个人对恋爱和婚姻的态度发生了变化，导致对寻找恋爱对象的需求减少</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;最无情的永远不是环境，而是缺乏勇气的内心。&lt;strong&gt;Swift社区&lt;/strong&gt;与你一起，赤胆平乱世，长枪定江山！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：担心泄密！外媒：苹果公司限制员工使用ChatGPT&lt;/p&gt;
&lt;p&gt;提案：value 包展开的元组&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Xcode 忽略 Package.resolved 文件&lt;/p&gt;
&lt;p&gt;推荐博文：万字长文详解如何使用 Swift 提高代码质量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十八期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十八期/</id>
    <published>2023-07-04T07:20:04.000Z</published>
    <updated>2023-07-04T07:30:00.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十九期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>用鞭子抽打，陀螺才会旋转。览<strong>Swift社区</strong>，技能方可升华！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：外媒：iPhone 的平均售价直逼 1000 美元创历史新高</p><p>提案：<code>Never</code> 遵守 <code>Codable</code></p><p>Swift 论坛：讨论在函数参数列表中使用 $ 进行绑定</p><p>推荐博文：抖音 Swift 编译优化</p><p><strong>话题讨论：</strong> </p><p>你认为AI会取代软件工程师吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="外媒：iPhone-的平均售价直逼-1000-美元创历史新高"><a href="#外媒：iPhone-的平均售价直逼-1000-美元创历史新高" class="headerlink" title="外媒：iPhone 的平均售价直逼 1000 美元创历史新高"></a>外媒：iPhone 的平均售价直逼 1000 美元创历史新高</h3><p>近日根据调研公司公布的数据显示，全球智能手机市场表现整体下行，不过高端手机近三年同比都呈现增长趋势，尤其是 600 美元以上的机型。市场研究机构 CIRP 的数据报告显示在 2023 年第一季度 iPhone 的平均售价达到 988 美元 ( 约合人民币 6837 元 ) ，同比增长 12%，创历史新高，其中 iPhone 14 Pro 以及 iPhone 14 Pro Max 是 iPhone 系列最受欢迎的型号，虽然两款手机价格相对较高，但还是占据了总销量的近一半。去年同期 iPhone 的平均售价为 882 美元，2021 年的收尾价为 847 美元。</p><p><img src="http://zkres2.myzaker.com/202305/645351248e9f095a955c2015_1024.jpg" alt=""></p><p>相比之下 iPhone 14 的两款入门款机型的表现平平，而且跟上一代机型基本相同，大家宁愿买 iPhone 13 也不愿意买 iPhone 14。此外，用户对于手机存储空间的需求也在增加，导致更多人选择了更高容量的手机，这也进一步提升了平均售价。</p><h3 id="分析师：iPhone需求良好，苹果股价还能涨22"><a href="#分析师：iPhone需求良好，苹果股价还能涨22" class="headerlink" title="分析师：iPhone需求良好，苹果股价还能涨22%"></a>分析师：iPhone需求良好，苹果股价还能涨22%</h3><p>根据 Refinitiv 的预期，苹果最新财季的每股收益预计为 1.43 美元，营收为 929.7 亿美元，暗示将同比下滑 4.4%。另据 FactSet 的估计，苹果最新财季 iPhone 的收入预计将同比下滑 3.8% 至 486.6 亿美元，且预计包括 iPhone 在内的每条硬件产品线都会出现同比下滑。</p><p>不过，Wedbush 高级分析师 Daniel Ives 在发给《每日经济新闻》记者的置评邮件中称，根据他们最近对亚洲供应链的调查，他们认为苹果周四盘后发布的财报中，iPhone 的营收应该至少与预期一致。</p><p>“我们认为，尽管宏观形势不稳，但由于较高的平均售价和 iPhone14 Pro 的整体升级活动，以及 iPhone 本季度在关键的中国市场的需求明显上升，该产品线的营收可能会出现一些上升。随着本季度 App Store 营收的增长，我们认为苹果的服务收入应该是稳定的，结合起来应该转化为苹果的核心收入，至少应该符合市场预期，我们维持对苹果的‘跑赢大盘’评级和 205 美元的目标价。”这意味着，苹果较周三收盘价 167.45 美元还有 22% 的上涨空间。</p><p>“苹果在中国的市场份额正在增加，美国和欧洲的需求也保持良好，我们估计目前约有 25% 的 iPhone 用户在过去四年多的时间里没有换过新机。由于备受期待的周年纪念版iPhone 15 将于 9 月份发布，从 iPhone 14 到 iPhone 15 的过渡看起来将比过去的 iPhone 换代周期更加稳定。我们还认为，iPhone 的平均售价将升至 900 美元 ~ 925 美元左右，这将是下一个 iPhone 周期一个值得关注的趋势。”Daniel Ives补充道。</p><h3 id="准备好迎接即将在-5-月-9-日推出的增强全球定价机制"><a href="#准备好迎接即将在-5-月-9-日推出的增强全球定价机制" class="headerlink" title="准备好迎接即将在 5 月 9 日推出的增强全球定价机制"></a>准备好迎接即将在 5 月 9 日推出的增强全球定价机制</h3><p>借助 App Store 世界级的商务和支付系统，你能够便捷高效地为国际市场设定均衡的价格，根据外汇汇率或税费的变化进行调整，还可以管理每个店面的价格。上个月，我们推出了重大定价机制升级，其中包括将增强全球定价机制的适用范围扩展至所有购买类型。如今，更新后的价格点将跟随各个国家或地区最常见的定价方式，并且将根据金融数据机构提供的公开汇率信息做调整，在全球范围内与你为基准店面设定的价格保持平衡，因此更适用于当地顾客。</p><p>谨此提醒，自 2023 年 5 月 9 日起，App Store 各店面的现有 App 和一次性 App 内购买项目的价格都将以产品当前在美国店面的价格为基础进行更新，除非你在 2023 年 3 月 8 日后进行了相关更新。你随时可以使用 App Store Connect 或 App Store Connect API 更新基准店面的国家或地区。如果你选择进行更新，在 App Store 根据外汇变化或新的税费生成全球均衡价格时，你所选基准店面的价格将不会受到调整。你还可以选择手动调整多个所选店面中的价格，而不使用均衡的价格。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0391-package-registry-publish.md" title="SE-0391" target="_blank" rel="noopener">SE-0391</a> <strong>Package Registry 公开发布</strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0394-swiftpm-expression-macros.md" title="SE-0394" target="_blank" rel="noopener">SE-0394</a> <strong>Package Manager 支持自定义宏</strong> 提案通过审查。该提案已在 <strong>二十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0396-never-codable.md" title="SE-0396" target="_blank" rel="noopener">SE-0396</a> <strong>Never 遵守 Codable</strong> 提案正在审查。</p><p>该提案主要介绍 <code>Never</code> 扩展，使其符合 <code>Encodable</code> 和 <code>Decodable</code> 协议，一起称为 <code>Codable</code>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0397-freestanding-declaration-macros.md" title="SE-0397" target="_blank" rel="noopener">SE-0397</a> <strong>独立声明 Macros</strong> 提案正在审查。</p><p>该提案概括了为 Expression Macros 引入的 <code>#</code> -prefixed 宏扩展语法，允许宏生成声明，支持许多其他用例，包括：</p><ul><li>从模板或其他数据格式（例如 JSON）生成数据结构。</li><li>将 SE-0196 中引入的 <code>#warning</code> 和 <code>#error</code> 指令作为宏。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>允许泛型类型对包进行抽象声明</strong> 提案正在审查。</p><p>之前的 SE-0393 引入了 Value 和 Type 参数包和几个相关概念，允许泛型函数声明抽象出可变数量的类型。该提案将这些想法概括为泛型类型声明。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/avoiding-sendable-warning-for-unused-async-result/64633" title="避免未使用的异步结果的可发送警告" target="_blank" rel="noopener">避免未使用的异步结果的可发送警告</a></p><p><strong>内容大概</strong></p><p>有一个独立于专用 actor 的功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@globalActor</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeDedicatedActor</span> </span>&#123;</span><br><span class="line">    actor <span class="type">Actor</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Actor</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">SomeDedicatedActor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> async -&gt; [<span class="type">Any</span>] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常从与@SomeDedicatedActor 隔离的其他函数调用 f()，但我们有一个调用是我们想从不同的 actor 进行的。</p><p>我们做这个调用纯粹是为了 f 的副作用，根本不关心返回结果。 我希望以下构造是有效的，但是通过 Targeted/Complete Sendable 检查，我们会收到警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">MainActor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="comment">// Non-sendable type '[Any]' returned by implicitly asynchronous call</span></span><br><span class="line">    <span class="comment">// to global actor 'SomeDedicatedActor'-isolated function cannot cross</span></span><br><span class="line">    <span class="comment">// actor boundary</span></span><br><span class="line">    <span class="number">_</span> = await f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用 Swift 会忽略跨角色边界传输结果是否合理？</p><ul><li>如果是这样，那么这只是一个虚假的警告，还是这个构造现在实际上是不安全的（因为该值确实强行跨越参与者边界）？</li><li>如果不是，是否有理由必须跨界传输结果？</li></ul><p><strong>回答</strong></p><p>如果该值是不可发送的，它可能具有只允许在其原始 actor 中发生的 deinit 效果。 因此，忽略结果实际上必须“避免返回”actor 的结果，因为它必须在离开 actor 的隔离上下文之前销毁该值。 这对我来说似乎相当微妙，但也许它与编写一个返回非 Sendable 类型的隔离方法是一致的，因为您永远无法使用隔离之外的结果。</p><p>2) 讨论<a href="https://forums.swift.org/t/using-for-binding-in-function-parameter-list/64645" title="在函数参数列表中使用 $ 进行绑定" target="_blank" rel="noopener">在函数参数列表中使用 $ 进行绑定</a></p><p><strong>内容大概</strong></p><p>最近发现可以像这样在闭包参数中使用 $ 变量名：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bind</span>(<span class="string">"Title"</span>) &#123; $title <span class="keyword">in</span></span><br><span class="line">      <span class="type">TextField</span>(title, text: $title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，对于像这样的函数参数来说，同样的事情似乎是不可能的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(title $title: Binding&lt;String&gt;)</span></span> &#123;</span><br><span class="line">      <span class="type">TextField</span>(title, text: $title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是编译器在函数声明处给出了一个错误：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cannot</span> declare entity named '$title'; the '$' <span class="keyword">prefix</span> <span class="keyword">is</span> reserved <span class="keyword">for</span> implicitly-synthesized declarations</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>您需要在参数上使用属性包装器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(@Binding title: String)</span></span> &#123;</span><br><span class="line">  <span class="type">TextField</span>(title, text: $title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo($title: .constant(<span class="string">"R.I.P. Taylor Hawkins 🥁"</span>))</span><br></pre></td></tr></table></figure><p>3) 讨论<a href="https://forums.swift.org/t/task-awaiting-for-variable-change/64626" title="Task - 等待变量更改" target="_blank" rel="noopener">Task - 等待变量更改</a></p><p><strong>内容大概</strong></p><p>在使用 Task 时有一个如何解决问题的建议。<br>在等待 Task 内部的一些变量更改以进一步移动。</p><p>意思是说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">  ... <span class="keyword">for</span> example here comes some complex code that <span class="keyword">is</span> sending requests </span><br><span class="line">   through web socket to outer world, </span><br><span class="line">   response from websocket will change the variable result on this clas </span><br><span class="line">   but out of this scope</span><br><span class="line"></span><br><span class="line">   <span class="comment">// with this line we are waiting for variable change with reasonable timeout</span></span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> await @change(variable: <span class="keyword">self</span>.result, timeout:<span class="number">10</span> sec)</span><br><span class="line">   &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      ... timeout</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"we are waiting too long for server response"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>您目前可以使用异步序列解决此问题。 现在的一个常见模式是执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> async &#123;</span><br><span class="line">  <span class="keyword">var</span> cont = <span class="type">AsyncStream</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Continuation</span>!  </span><br><span class="line">  <span class="keyword">let</span> stream = <span class="type">AsyncStream</span>&lt;<span class="type">Int</span>&gt; &#123; cont = $<span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> continuation = cont</span><br><span class="line">  </span><br><span class="line">  setupWebsocket(continuation)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> await element <span class="keyword">in</span> stream &#123;</span><br><span class="line">    <span class="comment">// process the result</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupWebsocket</span><span class="params">(continuation: AsyncStream&lt;Int&gt;.Continuation)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Setup the web socket and at some point call the following code</span></span><br><span class="line">  continuation.yield(<span class="number">2</span>) <span class="comment">// Yield your result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一件可能对这里有帮助的事情是当前正在发生的 Observation pitch，这将允许你观察类并让 Task 改变它； 然而，重要的是你需要确保一切都是线程安全的。</p><p>4) 更新 <a href="https://forums.swift.org/t/whats-next-for-foundation-april-2023-update/64637" title="Foundation 的下一步计划 - 2023 年 4 月更新" target="_blank" rel="noopener">Foundation 的下一步计划 - 2023 年 4 月更新</a></p><p>链接：<a href="https://www.swift.org/blog/future-of-foundation/" target="_blank" rel="noopener">https://www.swift.org/blog/future-of-foundation/</a></p><p>更多相关的详细信息链接：<a href="https://www.swift.org/blog/foundation-preview-now-available/" target="_blank" rel="noopener">https://www.swift.org/blog/foundation-preview-now-available/</a></p><p>5) 更新 <a href="https://forums.swift.org/t/swift-evolution-dashboard-support-for-upcoming-feature-flags/64617" title="Swift Evolution Dashboard 支持即将推出的 Feature Flags" target="_blank" rel="noopener">Swift Evolution Dashboard 支持即将推出的 Feature Flags</a></p><p>Swift Evolution Dashboard 现在包括对即将推出 Feature Flags 的支持。</p><p>Swift 5.8 引入了使用新编译器选项启用即将推出的功能的能力：-enable-upcoming-feature 后跟即将推出的功能的名称。</p><p>这些即将到来的特征标识符被称为即将到来的特征标志或简称 UFF。（详见 SE-0362 1）</p><p>随着 Dashboard 的更新，您现在可以轻松找到所有带有即将推出的功能标志的提案以及用于每个功能的标志名称。</p><p>您可以使用 Swift Evolution 仪表板来：</p><ul><li>查看提案的 UFF（如果有的话）</li><li>按名称搜索 UFF</li><li>过滤以查看所有带有 UFF 的提案</li><li>新的 UFF 过滤器按钮与现有的搜索字段和状态过滤器结合使用。</li></ul><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.avanderlee.com/swiftui/deeplink-url-handling/" title="SwiftUI 中的 Deeplink URL 处理" target="_blank" rel="noopener">SwiftUI 中的 Deeplink URL 处理</a></p><p><strong>摘要：</strong> 本文讨论深度链接（ deeplinks ）以及如何在 SwiftUI 中配置应用程序来处理它们。深度链接允许用户通过打开特定位置，在启动后深入进入您的应用程序，例如基于所点击的链接打开某个菜谱或电影等。本文提供了在 Xcode 中配置URL类型和使用视图修饰符或 AppDelegate/SceneDelegate 方法处理传入 URL 的步骤。此外，它建议使用深度链接进行其他场景，例如使用特定账户登录或在预发布和生产环境之间切换。该文章还强调了考虑安全性时定义支持 Deeplink URL 的重要性。</p><p><a href="https://juejin.cn/post/7221444501956886588" title="抖音 Swift 编译优化 - 基于自定义 Toolchain 编译提速 60%" target="_blank" rel="noopener">抖音 Swift 编译优化 - 基于自定义 Toolchain 编译提速 60%</a></p><p><strong>摘要：</strong> 本篇博客主要介绍了抖音团队基于自定义 Toolchain 提出的 Swift 编译优化方案，重点讨论在全部模块化后解决依赖瓶颈所采用的方法以及优化效果。通过裁剪 Clang Header 指定内容来降低 OC 头文件预编译耗时，并采用细粒度控制方案，实现编译提速 60%。文章还分享了方案拆解、快速验证、开发调试、验证上线等具体流程，对于有需要进行Swift编译优化的读者可以参考此文中给出的思路和方法。</p><p><a href="https://juejin.cn/post/7222189908429275173" title="Swift 最佳实践之 Property Wrapper" target="_blank" rel="noopener">Swift 最佳实践之 Property Wrapper</a></p><p><strong>摘要：</strong>  本文介绍了 Swift 5.1 中引入的 Property Wrapper，它是对属性的一层封装，隐藏与属性相关的逻辑细节从而提高代码复用性。文章详细讲解了 Property Wrapper 的定义、使用、初始化以及 Projected Value 等概念，并通过示例展示了在 SwiftUI、线程安全保护、Codable 和 User Defaults 存储等方面应用 Property Wrapper 的方法和好处。最后还指出了使用 Property Wrapper 标记属性时需要注意的限制。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>你认为AI会取代软件工程师吗？</strong></p><p>1、会<br>2、不会</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十九期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;用鞭子抽打，陀螺才会旋转。览&lt;strong&gt;Swift社区&lt;/strong&gt;，技能方可升华！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：外媒：iPhone 的平均售价直逼 1000 美元创历史新高&lt;/p&gt;
&lt;p&gt;提案：&lt;code&gt;Never&lt;/code&gt; 遵守 &lt;code&gt;Codable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论在函数参数列表中使用 $ 进行绑定&lt;/p&gt;
&lt;p&gt;推荐博文：抖音 Swift 编译优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为AI会取代软件工程师吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十七期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十七期/</id>
    <published>2023-07-04T07:19:58.000Z</published>
    <updated>2023-07-04T07:29:17.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十八期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>再暗的黑夜也会迎来黎明，再长的坎坷也会连接平川。怀抱<strong>Swift社区</strong>，一颗永不放弃的希望之心，明天将会是温暖的阳光雨露！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：因增速放缓 苹果公司将开启大规模收购</p><p>提案：Package Manager 支持自定义宏</p><p>Swift 论坛：讨论为什么 didSet 观察者在使用中会触发 Set 类型的属性</p><p>推荐博文：在 SwiftUI 中掌握 Canvas 的使用</p><p><strong>话题讨论：</strong> </p><p>你存钱了吗？你存钱的目的是什么呢？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果公司向“恢复基金”再投2亿美元，推进碳移除项目"><a href="#苹果公司向“恢复基金”再投2亿美元，推进碳移除项目" class="headerlink" title="苹果公司向“恢复基金”再投2亿美元，推进碳移除项目"></a>苹果公司向“恢复基金”再投2亿美元，推进碳移除项目</h3><p><img src="https://jg-app.obs.cn-north-4.myhuaweicloud.com/prod/upload/jpg/0a52d53f56fb4270855286d10f80f239.jpg" alt=""></p><p>据界面新闻消息，苹果公司 4 月 12 日宣布，在最初 2 亿美元的投资基础上，将向 2021 年设立的“恢复基金”（Restore Fund）再投多达 2 亿美元。该基金旨在为高质量的自然碳移除项目提供资金，激励全球投资保护和恢复“关键生态系统”。苹果公司还希望帮助无法通过现有技术避免或减少碳排放的企业，推广可行的碳移除解决方案。</p><p>加码后的基金将由汇丰资产管理部门和 Polliation 合资成立的 Climate Asset Management 管理，额外投资预计将使苹果此前提出的每年从大气中清除 100 万公吨二氧化碳目标翻倍，同时为投资者带来经济回报。</p><p>该基金期望把重点放在面向自然的农业项目以及保护和恢复关键生态系统的项目上，前者将帮助公司从可持续管理的农业实践中获得收入，后者则能从大气中移除并储存二氧化碳。苹果公司表示，“恢复基金”的投资将遵循“严格的社会和环境标准”。</p><h3 id="因增速放缓-苹果公司将开启大规模收购"><a href="#因增速放缓-苹果公司将开启大规模收购" class="headerlink" title="因增速放缓 苹果公司将开启大规模收购"></a>因增速放缓 苹果公司将开启大规模收购</h3><p>【环球网科技综合报道】4 月 7 日消息，据外媒报道称，苹果公司目前拥有超过 1650 亿美元的现金储备，鉴于苹果公司当前增速放缓，这家公司未来会开启大规模的收购。</p><p>不过，和微软、亚马逊等大手笔收购类型不同，苹果公司更倾向于收购小型初创公司。</p><p>外媒称，苹果喜欢以培养、孵化的方式开展收购，并耐心等待这些初创公司成长，来撬动新的市场。</p><p>据此前报道，今年 2 月，苹果收购了位于加州的 AI 算法公司 WaveOne 。今年 3 月，苹果公司已经收购了英国开放银行初创公司 CreditKudos 。</p><p>据了解，苹果经常收购小型企业，以加强其技术和专业知识，但显然没有或立即将其推广到产品或服务中。另一方面，许多收购确实成为苹果生态系统的关键部分。近年来，苹果已经收购了音乐识别服务 Shazam 和自动驾驶汽车公司 Drive.ai 等企业。</p><h3 id="Swift-Student-Challenge-现已开放申请"><a href="#Swift-Student-Challenge-现已开放申请" class="headerlink" title="Swift Student Challenge 现已开放申请"></a>Swift Student Challenge 现已开放申请</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/1FFB9751-9FB2-4171-B6E2-14CF821F6887/2048.jpeg" alt=""></p><p>我们很高兴能一如既往地为世界各地热爱编程的学生提供长期支持。欢迎使用 Swift Playgrounds 或 Xcode 编写 App Playground (主题自选) 并提交你的杰作，向我们展现你对于编程的热爱。优胜者将获得奖项和表彰，以及额外奖励。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md" title="SE-0393" target="_blank" rel="noopener">SE-0393</a> <strong>Value 和 Type 参数包</strong> 提案通过审查。该提案已在 <strong>二十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0394-swiftpm-expression-macros.md" title="SE-0394" target="_blank" rel="noopener">SE-0394</a> <strong>Package Manager 支持自定义宏</strong> 提案正在审查。</p><p>宏提供了一种扩展 Swift 的方法，通过对输入源代码执行任意语法转换来生成新代码。该提案涵盖了如何将自定义宏作为 Swift 软件包的一部分进行定义、构建和分发。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0395-observability.md" title="SE-0395" target="_blank" rel="noopener">SE-0395</a> <strong>Observation</strong> 提案正在审查。</p><p>该提案定义了什么是可观察的引用，观察者需要遵守什么，以及类型与其观察者之间的联系。这种设计模式是许多语言都支持的，Swift 引入之后，无疑将更加强大、安全和高性能。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-variadic-generic-types-abstracting-over-packs/64377" title="可变泛型类型抽象包" target="_blank" rel="noopener">可变泛型类型抽象包</a></p><p><strong>介绍</strong></p><p>之前的 SE-0393 引入了类型参数包和几个相关概念，允许泛型函数声明抽象出可变数量的类型。 该提案将这些想法概括为泛型类型声明。</p><p><strong>动机</strong></p><p>当试图在集合上概括通用算法时，自然会出现对可变数量的类型进行抽象的通用类型声明。 例如，惰性 ZipSequence 可能在两个序列上是通用的。 可以声明一个 ZipSequence 类型，它将固定序列列表的元素表示为元组序列：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZipSequence</span>&lt;<span class="title">each</span> <span class="title">S</span>: <span class="title">Sequence</span>&gt;: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Element</span> = (<span class="keyword">repeat</span> each <span class="type">S</span>.<span class="type">Element</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> seq: (<span class="keyword">repeat</span> each <span class="type">S</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Iterator</span>(iter: (<span class="keyword">repeat</span> (each seq).makeIterator()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = (<span class="keyword">repeat</span> each <span class="type">S</span>.<span class="type">Element</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iter: (<span class="keyword">repeat</span> each <span class="type">S</span>.<span class="type">Iterator</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">      <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议的解决方案</strong></p><p>在泛型类型的泛型参数列表中，each 关键字声明了一个泛型参数包，就像它在泛型函数的泛型参数列表中所做的那样。 存储属性的类型可以包含包扩展类型，如上面的 let seq 和 var iter。</p><p>2) 讨论<a href="https://forums.swift.org/t/dot-prefixing-considered-ugly/64376" title="点前缀被认为是丑陋的" target="_blank" rel="noopener">点前缀被认为是丑陋的</a></p><p>虽然我们已经习惯了，但在静态成员和枚举常量前加上点会引入视觉噪音，看起来太聪明了，总是让我的其他语言背景的同事感到惊讶：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> v: Color)</span></span> &#123;...&#125;</span><br><span class="line">object.foo(.red) <span class="comment">// 🤔</span></span><br></pre></td></tr></table></figure><p>在声明中缺少点前缀之间也存在这种令人不安的不对称性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> green</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> blue = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在其他地方使用这些前缀：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line">    <span class="keyword">case</span> .red: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .green: <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">foo(.red)</span><br><span class="line">foo(.blue)</span><br></pre></td></tr></table></figure><p>有趣的是，我已经可以在某些上下文中使用“object.foo(red)”（例如，在 Color 的静态方法中），但不能在其他上下文中使用。</p><p>我很欣赏这将是一个突破性的变化，我们不可能在现阶段迅速适应这一变化。 暂时忘记这一点，你认为 Swift 通过以下更改会变得更好还是更糟？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> v: Color)</span></span> &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">object.foo(<span class="type">Color</span>.red) <span class="comment">// ok</span></span><br><span class="line">object.foo(.red)      <span class="comment">// 🛑 prohibited</span></span><br><span class="line">object.foo(red)       <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line">    <span class="keyword">case</span> .red: <span class="keyword">break</span>  <span class="comment">// 🛑 prohibited</span></span><br><span class="line">    <span class="keyword">case</span> red: <span class="keyword">break</span>   <span class="comment">// ✅</span></span><br><span class="line">&#125;</span><br><span class="line">dispatchPrecondition(condition: .onQueue(.main)) <span class="comment">// 🛑</span></span><br><span class="line">dispatchPrecondition(condition: onQueue(main))   <span class="comment">// ✅</span></span><br><span class="line">bar(.<span class="keyword">init</span>()) <span class="comment">// 🛑</span></span><br><span class="line">bar(<span class="keyword">init</span>())  <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// While choosing what "red" to use – follow these new resolution rules:</span></span><br><span class="line"><span class="comment">// - use local variable if exists</span></span><br><span class="line"><span class="comment">// - or use instance variable if exists (in which case self should be captured strongly explicitly or implicitly)</span></span><br><span class="line"><span class="comment">// - or use static variable if exists (in case of enum could be an enumeration constant)</span></span><br><span class="line"><span class="comment">// - or use global variable if exists</span></span><br><span class="line"><span class="comment">// - otherwise emit an error</span></span><br></pre></td></tr></table></figure><p>3) 讨论<a href="https://forums.swift.org/t/can-non-sendable-types-be-captured-in-tasks/64372" title="非 Sendable 类型可以在 Tasks 中捕获吗？" target="_blank" rel="noopener">非 Sendable 类型可以在 Tasks 中捕获吗？</a></p><p>现在，我猜想下面的代码应该会出现任何错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="built_in">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="built_in">count</span> = <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someClass = <span class="type">SomeClass</span>(<span class="built_in">count</span>: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init(priority: TaskPriority? = nil, operation: @escaping @Sendable () async -&gt; Success)</span></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    someClass.<span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init(priority: TaskPriority? = nil, operation: @escaping @Sendable () async -&gt; Success)</span></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    someClass.<span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在 Swift（5.8 版）中，此代码片段可以编译。 在 Swift6 中，这段代码有没有出现错误？</p><p><strong>回答：</strong></p><p>在 Swift v.Future 中，全局 someClass 必须与全局 actor 隔离，因此行 someClass.count += 1 将需要：</p><p>整个 Task 闭包被隔离到同一个global actor，或者您为该操作切换到适当的global actor<br>（例如：await MainActor.run { someClass.count += 1 }）很难准确地说出在 Swift 6 中什么会/不会是错误。您可以使用一些编译器标志来尝试一些事情，但它们是不一致的。</p><p>4) 讨论<a href="https://forums.swift.org/t/why-does-didset-observer-fire-for-property-of-type-set-after-calling-insert-with-value-already-in-the-set/64350" title="为什么 didSet 观察者在使用集合中已有的值调用插入后会触发 Set 类型的属性？" target="_blank" rel="noopener">为什么 didSet 观察者在使用集合中已有的值调用插入后会触发 Set 类型的属性？</a></p><p>Xcode Playground 中的以下代码片段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> collection = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"didSet"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.insert(<span class="string">"Test1"</span>)</span><br><span class="line">collection.insert(<span class="string">"Test2"</span>)</span><br><span class="line">collection.insert(<span class="string">"Test1"</span>)</span><br><span class="line">collection.insert(<span class="string">"Test3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done"</span>)</span><br></pre></td></tr></table></figure><p>为什么是输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="type">Done</span></span><br></pre></td></tr></table></figure><p>而不是:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="type">Done</span></span><br></pre></td></tr></table></figure><p>为什么当集合未更改时它会触发，因为该值已经在集合中？</p><p><strong>回答：</strong></p><p>每个mutating函数都会像这样。<br>没有特殊的机制可以让属性知道 Set 没有在内部被修改。</p><p>5) 讨论<a href="https://forums.swift.org/t/a-simultaneously-simple-yet-probably-fatally-complex-use-of-variadic-generics/64347" title="可变参数泛型的同时简单但可能致命复杂的使用" target="_blank" rel="noopener">可变参数泛型的同时简单但可能致命复杂的使用</a></p><p>我很好奇即将到来的可变参数泛型特性是否能让我们实现像 transform(<em>:</em>:) 这样的函数，你可以在下面看到它的使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasPrimeNumberOfCharacters: <span class="type">Bool</span> &#123;</span><br><span class="line">        transform(</span><br><span class="line">            <span class="keyword">self</span>,</span><br><span class="line">            &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;,</span><br><span class="line">            &#123; $<span class="number">0</span>.isPrime &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数采用一个强制性的第一个参数，即要转换的值，然后是一个可变的转换闭包列表，每个闭包都对它之前的闭包的输出类型进行操作，第一个对初始值进行操作。 在上面的例子中，参数是：String, (String)-&gt;Int, (Int)-&gt;Bool。</p><p>我已经阅读了大量的可变参数泛型文档，如果我现在必须给出我最好的猜测，我会说我的 transform(<em>:</em>:) 函数在可变参数泛型的第一次迭代中是不可能的。</p><p>下面是一个非常粗略的草图，它是我能想象到的最接近如何编写这样一个函数签名的草图。 我发现有必要发明许多新的语法，这支持了我的猜测，即这是不可能的，至少在最初是不可能的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span></span></span><br><span class="line"><span class="function">    &lt;InitialValue,</span></span><br><span class="line"><span class="function">     each (T, U)&gt;</span></span><br><span class="line"><span class="function">    <span class="params">(<span class="number">_</span> initialValue: InitialValue,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="number">_</span> transform: <span class="keyword">repeat</span> each <span class="params">(T)</span></span></span>-&gt;<span class="type">U</span>)</span><br><span class="line">-&gt; last <span class="type">U</span> or <span class="type">InitialValue</span></span><br><span class="line"><span class="keyword">where</span> first <span class="type">T</span> == <span class="type">InitialValue</span> &#123;</span><br><span class="line">    <span class="comment">// How would one even implement this if the above syntax were valid?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6) 讨论<a href="https://forums.swift.org/t/building-distros-for-debian-ubuntu/64367" title="为 Debian/Ubuntu 构建发行版？" target="_blank" rel="noopener">为 Debian/Ubuntu 构建发行版？</a></p><p>现在我希望在 Jetson Nano（它有一个 ARM Cortex-A57 CPU）上用 Swift 做一个机器人项目，它只能使用 Ubuntu 18.04。 18.04 没有预构建的 5.8 .deb 包，这有点痛苦，因为这意味着我必须从源代码构建，并且一些构建依赖项（例如 cmake）必须从源代码构建才能获得最新的 足够的版本。 我以前构建过工具链，现在我正在 Jetson Nano 上构建它，但它花费了很长时间，尽管构建在连接的 SSD 上（操作系统运行在 SD 卡上）。</p><p>我想知道在我的 M1 Max MacBook Pro 上的 Ubuntu 18.04 Docker 容器（或者可能是 Parallels VM）中构建工具链是否有意义，然后构建将正确安装在任何 18.04 ARM 机器上的工具链的 .deb。</p><p>你认为那会建造得更快吗？</p><p>是否存在对构建 .deb 包的支持？ 20.04 和 22.04 包是如何构建的？</p><p><strong>回答：</strong></p><p>另一种选择是构建 MacOS -&gt; 18.04 交叉编译工具链。 不久前，我将 x-compiler 配置移到了 focus，但要翻转回 bionic 配置应该很容易。</p><p>7) 发布<a href="https://forums.swift.org/t/swift-5-8-released/64346" title="Swift 5.8 发布！" target="_blank" rel="noopener">Swift 5.8 发布！</a></p><p><strong>链接：</strong> <a href="https://www.swift.org/blog/swift-5.8-released/" target="_blank" rel="noopener">https://www.swift.org/blog/swift-5.8-released/</a></p><p>您可能已经看到，Swift 5.8 现已正式发布！ :tada: 此版本包括对语言和标准库的主要补充，包括支持逐步采用即将推出的功能的 hasFeature、改进的开发人员体验、改进 Swift 生态系统中的工具，包括 Swift-DocC、Swift Package Manager 和 SwiftSyntax，经过改进 Windows 支持等。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/04/11/mastering-canvas-in-swiftui/" title="在 SwiftUI 中掌握 Canvas 的使用" target="_blank" rel="noopener">在 SwiftUI 中掌握 Canvas 的使用</a></p><p><strong>摘要：</strong> 文章介绍了如何使用 Canvas 视图在 SwiftUI 中绘制 2D 图形，而无需使用 Shape API 。在 Canvas 视图中，我们可以使用 GraphicsContext 实例进行绘图，调整透明度、缩放和混合模式等参数，并添加不同的滤镜。 Canvas 还提供了 stroke、 fill 和 clip 函数，允许我们绘制任何我们需要的路径，同时也提供了draw函数，允许我们绘制文本和图像。我们可以使用 Canvas 类型绘制任何 SwiftUI 视图，但需要在创建 Canvas 时使用 symbols 闭包中注册它们。虽然 Canvas 视图不支持动画，但可以通过将其嵌入到带有动画调度程序的 TimelineView 中来实现动画效果。 Canvas 视图没有辅助功能树，但可以附加一组辅助视图修饰符，以使每个人都可以访问其内容。</p><p><a href="https://www.swiftbysundell.com/articles/observing-swiftui-scrollview-content-offset/#resolving-frames-using-geometryreader" title="监听 SwiftUI ScrollView 的内容偏移量" target="_blank" rel="noopener">监听 SwiftUI ScrollView 的内容偏移量</a></p><p><strong>摘要：</strong> 文章介绍了如何监听 SwiftUI ScrollView 的内容偏移量。在构建可滚动的 UI 时，通常需要观察当前滚动位置以便进行操作，但目前（在撰写本文时）SwiftUI 的 ScrollView 没有内置的方式来执行此类滚动观察。作者提供了一种利用 GeometryReader 解析器并使用 PreferenceKey 类型来实现的方法，使我们能够观察当前的内容偏移。最终作者实现了一个名为 OffsetObservingScrollView 的自定义滚动视图，可以实现监听当前内容偏移量的功能。</p><p><a href="https://www.swiftbysundell.com/articles/opaque-return-types-primary-associated-types/" title="Swift 中如何将不透明返回类型与主要关联类型相结合" target="_blank" rel="noopener">Swift 中如何将不透明返回类型与主要关联类型相结合</a></p><p><strong>摘要：</strong>  文章介绍了 Swift 5.7 引入的主关联类型和不透明返回类型相结合的使用方式。通过声明主关联类型，我们可以在使用 some 关键字时避免类型擦除，并使代码更加类型安全。该功能不仅适用于 Combine 框架，还可以在处理自己的泛型协议时使用。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>4月11日，央行公布了2023年一季度的金融数据，居民超额存款三年10.8万亿：北京人均存款已接近27万，上海人均超21万。<strong>你存钱了吗？你存钱的目的是什么呢？</strong></p><ol><li>有安全感：为了应对失业、突发疾病等，避免因意外事件而出现经济困难。</li><li>实现个人目标：买房、买车、旅行等，通过积累资金来实现自己的愿望。</li><li>投资理财：通过投资股票、基金、房地产等资产来增加财富，实现长期的财务目标。</li><li>应对退休生活：通过积累养老金和退休金来保障自己的生活质量和经济安全。</li><li>没有存款：支出基本等于收入，实在是存不了钱。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十八期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;再暗的黑夜也会迎来黎明，再长的坎坷也会连接平川。怀抱&lt;strong&gt;Swift社区&lt;/strong&gt;，一颗永不放弃的希望之心，明天将会是温暖的阳光雨露！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：因增速放缓 苹果公司将开启大规模收购&lt;/p&gt;
&lt;p&gt;提案：Package Manager 支持自定义宏&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论为什么 didSet 观察者在使用中会触发 Set 类型的属性&lt;/p&gt;
&lt;p&gt;推荐博文：在 SwiftUI 中掌握 Canvas 的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你存钱了吗？你存钱的目的是什么呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十六期/</id>
    <published>2023-07-04T07:19:52.000Z</published>
    <updated>2023-07-04T07:28:35.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十七期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>考验人的才能不在于他是否拿到一副好牌，而在于他能打好一副坏牌。选择<strong>Swift社区</strong>，教你打好人生的每一张卡牌！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：WWDC23 将于北京时间 6 月 6 日举行</p><p>提案：提出添加 Value 和 Type 参数包</p><p>Swift 论坛：讨论 KeyPath 会产生内存泄漏吗？</p><p>推荐博文：使用 Hummingbird framework 对数据进行编码和解码</p><p><strong>话题讨论：</strong> </p><p>当代大学生脱掉孔乙己长衫，选择普通的非技术岗位就业，这算是一种思想的进步吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="WWDC23-将于北京时间-6-月-6-日举行"><a href="#WWDC23-将于北京时间-6-月-6-日举行" class="headerlink" title="WWDC23 将于北京时间 6 月 6 日举行"></a>WWDC23 将于北京时间 6 月 6 日举行</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/4508744A-29D9-43A0-9B71-E245065F041C/2048.jpeg" alt=""></p><p>万勿错过北京时间 6 月 6 日至 10 日为期一周丰富多彩的技术和社区活动，现在就添加到你的日历吧。你将能抢先了解 Apple 平台、技术和工具的最新动态，还有机会与 Apple 专家和其他开发者互动。以上活动均免费在线举行。</p><p>此外，Apple 将于太平洋夏令时间 6 月 5 日在 Apple Park 举办面向开发者和学生的全天特别活动。我们将一起观看主题演讲和 State of the Union 视频，与部分 Apple 团队会面交流，在 Apple 设计大奖颁奖典礼上为卓越的 App 欢呼庆祝，还能一起乐享当晚的活动。</p><p>另外，富有才华的学生们还可通过展现自己的创造力，角逐 Swift Student Challenge 并获得奖励。</p><h3 id="4-月-25-日起将实行以下-App-Store-内容提交要求"><a href="#4-月-25-日起将实行以下-App-Store-内容提交要求" class="headerlink" title="4 月 25 日起将实行以下 App Store 内容提交要求"></a>4 月 25 日起将实行以下 App Store 内容提交要求</h3><p>自 2023 年 4 月 25 日起，提交至 App Store 的 iOS、iPadOS 和 watchOS App 必须使用 Xcode 14.1 或更高版本构建。你可以从 Mac App Store 中免费获得最新版本的 Xcode 14，其中包含适用于 iOS 16、iPadOS 16 和 watchOS 9 的最新 SDK。</p><p>当你构建 App 时，我们强烈建议你利用 iOS 16、iPadOS 16 和 watchOS 9 中的最新改进。</p><p>iOS 16 满载全新的个性化功能、更具深度的智能技术，以及更多无缝式的沟通与共享方式，让 iPhone 的体验更进一步。利用“实时活动”帮助用户通过 iPhone 14 Pro 上的锁定屏幕和灵动岛，直接了解你的 App 中正在发生的事情。借助 App Intents，用户可以通过语音或轻点方式快速完成与你的 App 相关的任务。此外，你还可以充分利用 MapKit、ARKit 和 Core ML 等技术中的最新增强功能。</p><p>iPadOS 16 引入了新的效率功能，让你能够在 iPad 上提供引人入胜的协作体验，构建更丰富、更直观的 App 和强大的专业工作流程。你可以为 iPad App 带来桌面级功能，如编辑器风格的导航栏、增强的文本编辑菜单和外置显示器支持。同时，Metal 3 也引入了多项强大功能，可协助你的游戏和专业 App 在最新一代的 iPad Pro 和 iPad Air 上充分发掘 Apple 芯片的潜能。</p><p>watchOS 9 为 watchOS App 提供了强大的新通信功能。你可以在更多 Apple Watch 表盘上通过丰富的复杂功能提供及时资讯，支持用户从你的 App 中分享内容，让用户直接通过 Apple Watch 进行 VoIP 通话等。此外，watchOS App 的结构经过简化，更是让管理项目变得前所未有的简单。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0385-custom-reflection-metadata.md" title="SE-0385" target="_blank" rel="noopener">SE-0385</a> <strong>自定义反射元数据</strong> 提案被驳回。该提案已在 <strong>二十二期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md" title="SE-0393" target="_blank" rel="noopener">SE-0393</a> <strong>Value 和 Type 参数包</strong> 提案正在审查。</p><p>该提案添加了类型参数包和值参数包，方便对 Value 和 Type进行抽象实现。这是 Swift 向可变泛型迈出的关键一步。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-conform-never-to-codable/64056" title="使 Never 符合 Codable" target="_blank" rel="noopener">使 Never 符合 Codable</a></p><p><strong>介绍</strong></p><p>扩展 Never 使其符合 Encodable 和 Decodable 协议，统称为 Codable。</p><p><strong>动机</strong></p><p>Swift 可以为任何具有 Codable 成员的类型综合 Codable 一致性。 泛型类型通常通过约束它们的泛型参数来参与这种综合一致性，例如 Either 类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Either</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">left</span>(<span class="type">A</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">right</span>(<span class="type">B</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Either</span>: <span class="title">Codable</span> <span class="title">where</span> <span class="title">A</span>: <span class="title">Codable</span>, <span class="title">B</span>: <span class="title">Codable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样，两个泛型参数都是 Codable 的 Either 实例本身就是 Codable，例如 Either<int, double="">。 但是，由于 Never 不可编码，因此使用 Never 作为参数之一会阻止条件一致性，即使编码或解码像 Either<int, never=""> 这样的类型是完全没问题的。</int,></int,></p><p><strong>建议的解决方案</strong></p><p>标准库应该向 Never 类型添加 Encodable 和 Decodable 一致性。</p><p><strong>详细设计</strong></p><p>Encodable 一致性很简单——因为不可能有 Never 实例，encode(to:) 方法可以简单地为空。<br>Decodable 协议需要 init(from:) 初始化器，它显然不能创建 Never 实例。 如果尝试解码，该实现会抛出 DecodingError。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-import-c-structs-with-arc-pointer-members/64059#introduction-1" title="导入带有 ARC 指针成员的 C 结构体" target="_blank" rel="noopener">导入带有 ARC 指针成员的 C 结构体</a></p><p><strong>介绍：</strong></p><p>目前，Swift 可以导入 C 结构，其成员是 Swift 可导入的值类型，例如 int、BOOL 和 <code>__unsafe_unretained ARC</code> 指针，它们都是简单的构造和可析构的。 基于 Akira 在 LLVM 中启用强引用和弱引用的工作，我们应该能够导入这些类型和声明。</p><p><strong>动机：</strong></p><p>自 2018 年以来，这些指针类型已可用于 Objective-C/Objective-C++（以及之前的 Objective-C++），而 Swift 迄今为止尚未扩展以导入它们。 这是 Swift &lt;&gt; C++ 互操作的必要部分，我们应该能够移植值类型的引用类型成员的默认和成员构造和销毁，包括 Objective-C 语言模式中结构中的 ARC 指针。 Puyan 已经在此处合并了一些使用 C++ interop 构建这些类型的代码。</p><p><strong>建议的解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct WithArcPointers &#123;</span><br><span class="line">    __unsafe_unretained NSString *usUR;</span><br><span class="line">    __strong _Nonnull NSString *sStr;</span><br><span class="line">    __weak _Nullable NSString *wStr;</span><br><span class="line">    NSInteger count;</span><br><span class="line">&#125; WithArcPointers;</span><br></pre></td></tr></table></figure><p>应该导入到 Swift 作为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WithArcPointers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(usUR: <span class="type">String</span>!, sStr: <span class="type">String</span>, wStr: <span class="type">String</span>?, <span class="built_in">count</span>: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">var</span> usUR: <span class="type">Unmanaged</span>&lt;<span class="type">NSString</span>&gt;!</span><br><span class="line">  <span class="keyword">var</span> sStr: <span class="type">String</span></span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> wStr: <span class="type">NSString</span>?</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应保留各种 arc 存储类型，并在可能的情况下尊重预期的类型桥接和可空性注释。 弱成员在 Swift 端必须是 Optional，并且 <code>__unsafe_unretained</code> 必须是非桥接类型的 Unmanaged。 这些结构应该是成员可构造的，如果它们不包含非空成员，那么也可以通过可用的 init() 轻松构造。</p><p>结构中的非空弱引用虽然在 Clang 中是合法的，但不会被导入并且编译器将发出适当的诊断，因为 Swift 要求弱引用是可选的。 C 声明可能也应该有一个诊断，与适当错误的 ObjC 类一致，但这超出了本提案的范围。</p><p>3) 提议<a href="https://forums.swift.org/t/pitch-variadic-sequences/64072" title="可变序列" target="_blank" rel="noopener">可变序列</a></p><p>Swift 可以通过在方法定义中允许重复的参数序列来使可变参数表达式更强大。</p><p>这是在 Swift 5.7 语法中有效的可变参数函数定义和调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> value: <span class="params">(name: String, age: Int)</span></span></span>..., and otherName: <span class="type">String</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction((name: <span class="string">"Ada"</span>, age: <span class="number">26</span>), (name: <span class="string">"Bob"</span>, age: <span class="number">21</span>), and: <span class="string">"Carl"</span>)</span><br></pre></td></tr></table></figure><p>但是，我相信相同的定义/调用应该具有如下所示的能力：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(name: String..., age: ...Int, and anotherParameter: String)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction(name: <span class="string">"Ada"</span>, age: <span class="number">26</span>, name: <span class="string">"Bob"</span>, age: <span class="number">21</span>, and: <span class="string">"Carl"</span>)</span><br></pre></td></tr></table></figure><p>这可能是一种称为可变序列的新语言功能，其中可以在方法定义中包含任意数量的序列参数。 请注意新的 …Int 语法：这表示可变序列的结尾。 此功能为开发人员在编写方法调用时提供了更友好的体验。</p><p>至于在函数实现中获取可变参数序列，可以使用美元符号语法。 或者，每个可变序列元素都可以通过参数名称作为元组数组获得。 最后，可以通过使用 for in 循环 [1] 来迭代可变序列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(a: String..., b: ...Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> allSequences: [(a: <span class="type">String</span>, b: <span class="type">Int</span>)] = $<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> allValuesOfA: [<span class="type">String</span>] = a</span><br><span class="line">  <span class="keyword">let</span> allValuesOfB: [<span class="type">Int</span>] = b</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> myA, myB <span class="keyword">in</span> $<span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> aValue: <span class="type">String</span> = myA</span><br><span class="line">    <span class="keyword">let</span> bValue: <span class="type">Int</span> = myB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提议的细节：</p><p>每个可变参数序列都以打开和关闭参数开始和结束。 开放参数使用 Type… 语法。 关闭参数使用新的 …Type 语法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> <span class="keyword">open</span>: String..., <span class="number">_</span> close: ...String)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可变序列可以包含中间参数。 中间参数的类型使用普通语法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Variadic sequence with 3 elements</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> <span class="keyword">open</span>: String..., <span class="number">_</span> middle: String, <span class="number">_</span> close: ...String)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variadic sequence with 4 elements</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: String, <span class="number">_</span> <span class="built_in">c</span>: String, <span class="number">_</span> d: ...String)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可变参数序列可以使用任何需要的类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: Double, <span class="number">_</span> <span class="built_in">c</span>: ...T, <span class="number">_</span> d: Int)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction(<span class="string">"Swift"</span>, <span class="number">5.7</span>, objectA, <span class="string">"Objective-C"</span>, <span class="number">2.0</span>, objectB, <span class="number">1234</span>)</span><br></pre></td></tr></table></figure><p>对具有可变序列参数的函数的调用可以根据需要包含尽可能多的重复：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunction(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"B"</span>, <span class="number">2</span>, <span class="string">"C"</span>, <span class="number">3</span>, <span class="string">"D"</span>, <span class="number">4</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>Varadic 序列元素可以命名为 [2]：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span>&lt;A, B&gt;<span class="params">(property path: KeyPath&lt;A, B&gt;..., <span class="number">_</span> middle: Comparison, value: ...B)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction(property: \.name, .equals, value: <span class="string">"Ada"</span>, property: \.age, .greaterThan, value: <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>方法定义中可能存在多个不同长度的可变序列。 在这种情况下，每个相应的序列都是使用 $0、$1、$2 等获得的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: ...Int, <span class="number">_</span> <span class="built_in">c</span>: Double..., _d: Date, <span class="number">_</span> e: ...Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> abValues: [(<span class="type">String</span>, <span class="type">Int</span>)] = $<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> cdeValues: [(<span class="type">Double</span>, <span class="type">Date</span>, <span class="type">Int</span>)] = $<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数序列可以与常规参数和现有的可变参数一起使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: ...Int, _c: Double, <span class="number">_</span> d: Int...)</span></span></span><br><span class="line">myFunction(<span class="string">"Ada"</span>, <span class="number">26</span>, <span class="string">"Bob"</span>, <span class="number">21</span>, <span class="number">5.7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/pitch-observation-revised/63757" title="有没有办法从字符串中验证 URL" target="_blank" rel="noopener">有没有办法从字符串中验证 URL</a></p><p>可以用第三方库：GitHub：<a href="https://github.com/vapor/validation/blob/master/Sources/Validation/Validators/URLValidator.swift" title="vapor/validation" target="_blank" rel="noopener">vapor/validation</a></p><p>5) 讨论<a href="https://forums.swift.org/t/does-keypath-produce-memory-leaks/64050" title="KeyPath 会产生内存泄漏吗？" target="_blank" rel="noopener"> KeyPath 会产生内存泄漏吗？</a></p><p>回答：是的，KeyPath 实例在第一次使用时被缓存并保留在内存中直到程序结束。</p><p>6) 讨论<a href="https://forums.swift.org/t/for-in-vs-foreach-when-sequence-element-is-dictionary-key/64053" title="当序列元素为 Dictionary.Key 时，For-in 与 forEach()" target="_blank" rel="noopener">当序列元素为 Dictionary.Key 时，For-in 与 forEach()</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(keys: any Sequence&lt;Key&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys &#123;</span><br><span class="line">            <span class="keyword">let</span> value = <span class="keyword">self</span>[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(keys: any Sequence&lt;Key&gt;)</span></span> &#123;</span><br><span class="line">        keys.forEach &#123; key <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> value = <span class="keyword">self</span>[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for-in 中，key 的类型被推断为 Any，而在 forEach() 中，其类型为 Key。 这是设计使然还是错误？</p><p><strong>回答：</strong></p><p>首先，要知道这一点，但 f1 和 f2 实际上应该采用一些 Sequence<key> 类型的参数，而不是任何类型的参数，这将使错误消失。<br>这是一个已知的限制，将来可能会被取消。 让我试着分解一下。</key></p><p>从 f2: forEach 开始可以保留具体的 Key 类型，这要归功于 SE-0353：受限存在类型中的 Covariant Erasure with Constrained Existentials 1。 所以这是相对简单的。</p><p>对于 f1，编译器基本上将 for 循环重写为 while 循环，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = keys.makeIterator()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> key = iterator.next() &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们手动编写这个 while 循环，我们会在第一行的 makeIterator() 调用中遇到错误：</p><p>错误：推断结果类型“any IteratorProtocol”需要显式<br>由于通用要求的丢失而导致的强制编译器强制我们将 keys.makeIterator() 编写为任何 IteratorProtocol，以确认迭代器变量失去了其 Element == Key 的知识，这就是为什么 for 循环中的元素类型为 Any 的原因。</p><p>在 SE-0352: Implicitly Opened Existentials 中类型擦除结果值时“丢失”约束中描述了几乎这种情况：</p><p>当涉及打开的存在类型的调用结果被类型擦除时，可能一些关于返回类型的信息无法用存在类型表示，因此上述“上界”将丢失信息。</p><p>该部分还提到，未来的编译器版本可以通过恢复现在更多的类型信息来提高语言的表达能力。 它甚至明确提到了可能有助于解决此问题的主要关联类型 SE-0353。</p><p>总而言之，当从任何 Sequence<t> 生成迭代器时，编译器似乎可以（并且最终应该）保留元素类型信息，但这尚未实现（如果实现，它可能也会有 经历 Swift Evolution）。</t></p><p>7) 讨论<a href="https://forums.swift.org/t/void-as-an-associated-type/64043" title="Void 作为关联类型？" target="_blank" rel="noopener">Void 作为关联类型？</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.avanderlee.com/swift/operation-couldnt-completed-error-code/" title="在 Swift 中解决 The operation couldn’t be completed 错误" target="_blank" rel="noopener">在 Swift 中解决 The operation couldn’t be completed 错误</a></p><p><strong>摘要：</strong> 本篇博客讨论如何解决 Swift 中出现 “The operation couldn’t be completed” 的错误，当收到 “The operation couldn’t be completed” 错误消息时该如何处理。作者解释说，这些错误通常会附带错误代码，但没有描述，因此很难确定如何解决问题。该文章建议在GitHub上搜索错误域以查找错误代码的描述，然后在Google上搜索相关信息并找到带有描述的苹果文档。作者还介绍了 What The Error Code ，这是一个提供即时错误代码描述的简单工具的使用。最后，作者解释说他们已经将 What The Error Code 添加到 RocketSim 上，以简化其使用。</p><p><a href="https://juejin.cn/post/7216130963277332535" title="Swift 之 struct 二进制大小分析" target="_blank" rel="noopener">Swift 之 struct 二进制大小分析</a></p><p><strong>摘要：</strong> 文章讨论了 struct 对比 class 的一些优劣势，重点分析了 struct 和 class 对包体积带来的影响及规避措施，并分别比较了使用 let 和 var 修饰下二者二进制大小的区别，为我们在日常开发中 struct 和 class 选择上提供了包大小维度的衡量。</p><p><a href="https://theswiftdev.com/encoding-and-decoding-data-using-the-hummingbird-framework/" title="使用 Hummingbird framework 对数据进行编码和解码" target="_blank" rel="noopener">使用 Hummingbird framework 对数据进行编码和解码</a></p><p><strong>摘要：</strong>  这篇博文介绍了 <code>HummingbirdFoundation</code> 框架对数据进行编解码，它支持 HTML、JSON 和 plain text 等多种数据类型。该框架还允许将传入的 HTTP 请求体对象轻松转换为 Swift 数据结构并返回它们。作者展示了框架通过 Codable 协议和使用 <code>HBResponseCodable</code> 协议、 <code>HBResponseEncodable</code> 协议、 <code>HBRequestDecoder</code> 和 <code>HBResponseEncoder</code> 实现的 JSON 对象内置编码和解码支持。此外，文章还解释了使用  <code>HummingbirdFoundation</code> 支持的两种编码类型—— <code>application/x-www-form-urlencoded</code> 和 <code>multipart/form-data——</code> 对 HTML 表单进行编码和解码。</p><p><a href="https://swdevnotes.com/swift/2023/how-to-cancel-a-background-task-in-swift//" title="在 Swift 中如何取消后台任务" target="_blank" rel="noopener">在 Swift 中如何取消后台任务</a></p><p><strong>摘要：</strong>  本文演示了在 Swift 5.5 中使用 async/await 异步编程时取消后台任务的不同方法。文章强调了取消不必要的任务的重要性，以防止不需要的后台任务干扰应用程序的性能。文章提供了各种取消任务的方法，包括使用取消标志、使用 <code>Task.checkCancellation()</code> 检查任务取消情况以及使用 <code>Task.isCancelled</code> 来将取消传播到子任务。文章为每种方法提供了示例代码，并解释了每种方法的优点和缺点。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>当代大学生脱掉孔乙己长衫，选择普通的非技术岗位就业，这算是一种思想的进步吗？</strong></p><ol><li>必须算啊，勇于突破陈旧观念，值得尊敬。</li><li>不能算的，选择了普通非技术岗位，意味着自己的大学生涯毫无价值体现。</li><li>无所谓进步与否，只不过是当今经济环境下的无奈选择罢了。</li></ol><p><img src="https://files.mdnice.com/user/17787/6cdea255-542f-4168-93f8-31cf18c17ce5.png" alt="本图来源于网络"></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十七期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;考验人的才能不在于他是否拿到一副好牌，而在于他能打好一副坏牌。选择&lt;strong&gt;Swift社区&lt;/strong&gt;，教你打好人生的每一张卡牌！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：WWDC23 将于北京时间 6 月 6 日举行&lt;/p&gt;
&lt;p&gt;提案：提出添加 Value 和 Type 参数包&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 KeyPath 会产生内存泄漏吗？&lt;/p&gt;
&lt;p&gt;推荐博文：使用 Hummingbird framework 对数据进行编码和解码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;当代大学生脱掉孔乙己长衫，选择普通的非技术岗位就业，这算是一种思想的进步吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十五期/</id>
    <published>2023-07-04T07:19:48.000Z</published>
    <updated>2023-07-04T07:27:45.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十六期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>选择与放弃，是生活与人生处处需要面对的关口。选择了<strong>Swift社区</strong>，就拥有了一道最靓丽的风景！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：印度将首次成为苹果公司自有销售地区</p><p>提案：提案 SE-0382、SE-0388、SE-0389 通过审查</p><p>Swift 论坛：提议 Observation 修订</p><p>推荐博文：两个新的开源 Swift 库：<code>Swift Certificates</code> 和 <code>Swift ASN.1</code></p><p><strong>话题讨论：</strong> </p><p>文心一言挑战 ChatGPT，谁更胜一筹？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="印度将首次成为苹果公司自有销售地区"><a href="#印度将首次成为苹果公司自有销售地区" class="headerlink" title="印度将首次成为苹果公司自有销售地区"></a>印度将首次成为苹果公司自有销售地区</h3><p>【环球网科技综合报道】3 月 9 日消息，据外媒报道，苹果公司正在改变国际业务的管理方式，推动印度首次成为其自有销售区。</p><p>据悉，负责苹果印度、中东、地中海、东欧和非洲地区业务的副总裁休斯·阿斯曼（HuguesAsseman）退休后，苹果计划将印度调整成自有销售区域。而阿希什·乔杜里（AshishChowdhary）将升职，成为印度地区的负责人，直接向苹果的产品销售负责人汇报。</p><p>外媒分析称，作为世界第二大智能手机市场，印度市场对于苹果而言越来越重要。2022 年第 四 季度，苹果在印度市场的销售额创新高。</p><p>目前，苹果已开始在印度生产一些 iPhone 型号，包括 iPhone14 。此外，苹果计划于今年晚些时候在该国开设第一家零售店。</p><h3 id="Meta第二轮裁员波及万人，苹果推迟发放奖金"><a href="#Meta第二轮裁员波及万人，苹果推迟发放奖金" class="headerlink" title="Meta第二轮裁员波及万人，苹果推迟发放奖金"></a>Meta第二轮裁员波及万人，苹果推迟发放奖金</h3><p>硅谷的裁员、降薪潮远未结束。</p><p>3 月 14 日周二，Meta 和苹果纷纷宣布最新的人事政策。</p><p>周二，Meta 的第二轮裁员终于确定，将裁员大约一万人，同时还将关闭 5000 个额外空缺职位，以求节省开支、提高效率。这是 Meta 在六个月时间里的第二轮重大裁员行动。</p><p>Meta 的首席执行官马克·扎克伯格周二在声明中表示，该公司的目标是通过取消管理层的多层级结构来让公司变得更加扁平化。</p><p>周二，Meta 高开高走，当前股价上涨 5.93% ，报 191.62 美元。</p><p><img src="https://files.mdnice.com/user/17787/aa91dde5-2de2-465a-8eb9-ae37aeb84cdd.png" alt=""></p><p>上个月，有媒体报道称，Meta 还一直致力于扁平化其组织，向管理人员提供买断方案，并裁减其认为不必要的整个团队，此举仍在最后敲定中，可能会影响数千名员工。</p><p>知情人士称，Meta 即将到来的新一轮裁员是由财务目标推动的，与公司“扁平化”没有直接关系。知情人士说，Meta 已经看到广告收入放缓，并将重点转移到元宇宙平台，公司高层一直在要求董事和副总裁列出可以解雇的员工名单。</p><p>据知情人士透露，这一阶段的裁员最快可能会在本周完成。一位知情人士说，那些正在制定裁员计划的人希望在首席执行官扎克伯格为他的第三个孩子休育儿假之前准备好，因此这次裁员的速度可能会非常快。</p><h3 id="App-Store-的定价机制升级现已扩展至所有购买类型"><a href="#App-Store-的定价机制升级现已扩展至所有购买类型" class="headerlink" title="App Store 的定价机制升级现已扩展至所有购买类型"></a>App Store 的定价机制升级现已扩展至所有购买类型</h3><p>在 12 月，我们宣布对 App Store 进行问世至今最全面的定价机制升级，其中包括新增价格点和按店面管理定价的全新工具。即日起，这些升级和新价格适用于所有类型的 App 和 App 内购买项目，包括付费 App 和一次性 App 内购买项目。</p><p>更为灵活的价格点。可在 900 个价格点中选择定价 — 比此前付费 App 和一次性 App 内购买项目的可选价格点数量增加了近 9 倍。这些选项也提供了更高的定价灵活度，价格点按价格区间逐渐递增 (如在 RMB 10 以下每档相差 RMB 0.5；RMB 10 到 RMB 200 之间每档相差 RMB 1 等)。</p><p>增强的全球定价机制。全球均衡价格遵循了各个国家或地区最常见的定价方式。采用全球均衡价格，你可以提供更适用于当地顾客的定价。</p><p>根据基准价格提供全球定价形式。针对付费 App 和一次性 App 内购买项目，指定你熟悉的国家或地区，以之为基础为其他 174 个国家或地区的店面以及 43 种货币生成全球均衡价格。你为这个基准店面设定的价格，Apple 不会根据税款或外汇变化进行调整。此外，你也可以按个人喜好为每个店面自行设定价格。</p><p>为上架产品提供地区性定价方案。针对不同国家和地区的店面决定 App 内购买项目 (包括订阅) 的销售范围，因此你可以为各个市场分发定制的内容和服务。</p><p>准备好迎接即将在 5 月推出的增强全球定价机制<br>App Store 的全球均衡价格工具为你提供了一种简单便捷的方式来管理国际市场的定价。在 2023 年 5 月 9 日，在所有 175 个 App Store 店面中的现有 App 和一次性 App 内购买项目的价格都将更新，以充分利用此次全新的增强全球定价机制。更新后的价格将根据金融数据机构提供的公开汇率信息做调整，在全球范围内与你为基准店面设定的价格保持平衡。这些价格点将跟随各个国家或地区最常见的定价方式，让价格更适用于当地顾客。</p><p>你即刻就能使用 App Store Connect 或 App Store Connect API 更新你的当前定价，以充分利用此次全新升级。在 5 月 9 日，如果你的现有 App 和一次性 App 内购买项目还没有完成价格更新，Apple 将以产品当前在美国店面的价格为基础，为它们生成相应的更新价格。如果你希望以其他价格作为基础，现在可通过更新基准店面的国家或地区，为 App 或 App 内购买项目选择新的基准店面。你还可以选择手动管理所选店面中的价格，而不使用均衡的价格。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过审查的提案"><a href="#通过审查的提案" class="headerlink" title="通过审查的提案"></a>通过审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案通过审查。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md" title="SE-0388" target="_blank" rel="noopener">SE-0388</a> <strong>增加 Async[Throwing]Stream.makeStream 方法</strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0389-attached-macros.md" title="SE-0389" target="_blank" rel="noopener">SE-0389</a> <strong>Attached Macros</strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0392-custom-actor-executors.md" title="SE-0392" target="_blank" rel="noopener">SE-0392</a> <strong>自定义 Actor 执行器</strong> 提案正在审查。</p><p>该提案介绍了一种用于自定义 actor 执行程序的基本机制。通过提供执行者的实例，参与者可以影响他们将在什么地方执行正在运行的一些任务。</p><blockquote><p><strong>注意：</strong> 该提案仅定义了一组 API 来自定义 actor 执行器，其他类型的执行器控制超出了该特定提案的范围。</p></blockquote><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-observation-revised/63757" title="Observation（修订）" target="_blank" rel="noopener">Observation（修订）</a></p><p><strong>介绍</strong></p><p>制作响应式应用程序通常需要能够在基础数据发生变化时更新演示文稿。 观察者模式允许一个主题维护一个观察者列表，并通知他们特定的或一般的状态变化。 这具有不直接将对象耦合在一起并允许在潜在的多个观察者之间隐式分布更新的优点。 可观察对象不需要关于其观察者的特定信息。</p><p>这种设计模式是许多语言都走过的一条很好的道路，Swift 有机会提供一个健壮的、类型安全的和高性能的实现。 该提议定义了什么是可观察引用、观察者需要遵守什么以及类型与其观察者之间的联系。</p><p><strong>动机</strong></p><p>Swift 中已经有一些观察机制。 其中包括键值观察 (KVO) 和 <code>ObservableObject</code>，但它们中的每一个都有局限性。 KVO 只能与 NSObject 后代一起使用，而 <code>ObservableObject</code> 需要使用 Combine，它仅限于 Darwin 平台并且不使用当前的 Swift 并发功能。 通过从这些现有系统中吸取经验，我们可以构建一个更普遍有用的功能，适用于所有 Swift 引用类型，而不仅仅是那些继承自 NSObject 的引用类型，并使其跨平台工作，并具有 <code>async/await</code> 等语言功能的优势。</p><p>现有系统获得了许多正确的行为和特征。 但是，有许多领域可以在安全性、性能和表现力之间提供更好的平衡。 例如，将相关的更改分组到一个独立的事务中是一项常见的任务，但是这在使用 Combine 时很复杂并且在使用 KVO 时不受支持。 在实践中，观察者想要访问交易，并能够指定如何解释交易。</p><p>注释阐明了可观察的内容，但也可能很麻烦。 例如，Combine 不仅要求类型符合 <code>ObservableObject</code>，还要求被观察的每个属性都标记为 <code>@Published</code>。 此外，无法直接观察计算出的属性。 实际上，在可观察的类型中具有非观察字段并不常见。</p><p>在整个文档中，对 KVO 和 Combine 的引用将说明哪些功能是有益的并且可以合并到新方法中，以及可以以更稳健的方式解决哪些缺点。</p><p><strong>现有技术</strong></p><p><strong>KVO</strong></p><p>Objective-C 中的键值观察很好地服务于该模型，但仅限于从 NSObject 继承的类层次结构。 API 仅提供事件拦截，这意味着更改通知位于 willSet 和 didSet 事件之间。 KVO 在事件粒度方面具有很大的灵活性，但缺乏可组合性。 KVO 观察者还必须继承自 NSObject，并依赖 Objective-C 运行时来跟踪发生的变化。 尽管 KVO 的接口已经更新为使用更现代的 Swift 强类型键路径，但在底层它的事件仍然是字符串类型的。</p><p><strong>Combine</strong></p><p>Combine 的 <code>ObservableObject</code> 在 <code>willSet/didSet</code> 事件的前缘产生变化，所有的值都在值被设置之前传递。 虽然这很好地服务于 SwiftUI，但它对非 SwiftUI 的使用有限制，并且对于第一次遇到该限制的开发人员来说可能会感到惊讶。 <code>ObservableObject</code> 还要求将所有观察到的属性标记为 <code>@Published</code>  以与更改事件进行交互。 在大多数情况下，这一要求适用于每一个单独的属性，对开发者来说变得多余； 编写符合 <code>ObservableObject</code> 类型的人必须重复（几乎没有真正获得清晰度）注释每个属性。 最后，这会导致对参与项目或不参与项目的意义疲劳。</p><p>我们提出了一个名为 <code>Observation</code> 的新标准库模块，其中包括实现这种模式的协议、类型和宏。<br>基本上，一个类型可以简单地通过使用 <code>@Observable</code> 宏注解将自己声明为可观察的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Observable</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> someProperty: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> someOtherProperty = <span class="number">0</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> somePrivateProperty = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Observable</code> 宏声明并实现与 <code>Observable</code> 协议的一致性，该协议包括一组处理观察的扩展方法。 在最简单的情况下，客户端可以使用 <code>changes(for:)</code> 方法来观察给定实例的特定属性的变化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processChanges</span><span class="params">(<span class="number">_</span> object: MyObject)</span></span> async &#123;</span><br><span class="line">    <span class="keyword">for</span> await value <span class="keyword">in</span> object.values(<span class="keyword">for</span>: \.someProperty) &#123;</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这允许 <code>Observable</code> 类型的用户将特定值的更改或整个实例作为更改事件的异步序列进行观察。 <code>changes(for:)</code> 方法提供类型安全，因为它只提供对一个特定属性的更改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object.someProperty = <span class="string">"hello"</span> </span><br><span class="line"><span class="comment">// prints "hello" in the awaiting loop</span></span><br><span class="line">object.someOtherProperty += <span class="number">1</span></span><br><span class="line"><span class="comment">// nothing is printed</span></span><br></pre></td></tr></table></figure><p>可观察对象还可以提供分组到事务中的更改，这些事务合并了在暂停点之间进行的任何更改。 默认情况下，交易会单独交付给您提供的参与者或主要参与者。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processTransactions</span><span class="params">(<span class="number">_</span> object: MyObject)</span></span> async &#123;</span><br><span class="line">    <span class="keyword">for</span> await change <span class="keyword">in</span> objects.changes(<span class="keyword">for</span>: [\.someProperty, \.someOtherProperty]) &#123;</span><br><span class="line">        <span class="built_in">print</span>(myObject.someProperty, myObject.someOtherProperty)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>ObservableObject</code> 和 <code>@Published</code> 不同，<code>@Observable</code> 类型的属性不需要单独标记为可观察。 相反，所有存储的属性都是隐式可观察的。<br>对于只读计算属性，作者可以添加 <code>static dependencies(of:)</code> 方法来声明额外的关键路径作为他们观察的一部分。 这类似于 KVO 用来提供对键路径有影响的附加键路径的机制。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> someComputedProperty: <span class="type">Int</span> &#123; </span><br><span class="line">        somePrivateProperty + someOtherProperty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonisolated <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">dependencies</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        of keyPath: PartialKeyPath&lt;<span class="keyword">Self</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> -&gt; <span class="type">TrackedProperties</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> keyPath &#123;</span><br><span class="line">        <span class="keyword">case</span> \.someComputedProperty:</span><br><span class="line">            <span class="keyword">return</span> [\.somePrivateProperty, \.someOtherProperty]</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> [keyPath]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于所有对观察变化的访问都是通过关键路径进行的，因此 public 和 private 等可见性关键字决定了可以观察到什么，不能观察到什么。 与 KVO 不同，这意味着只能观察到在特定范围内可访问的成员。 这一事实反映在设计中，其中事务表示为 <code>TrackedProperties</code> 实例，它允许查询更改的键路径，但不能查询它们的迭代。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-elide-some-in-swift-6/63737" title="在 Swift 6 中省略 some" target="_blank" rel="noopener">在 Swift 6 中省略 some</a></p><p><strong>介绍</strong></p><p>目前，在类型位置中编写普通协议名称的默认值是 any，但其中许多隐含的 any 用法可以替换为 some，从而为它们提供更多类型信息，同时仍能正确运行。 该提议翻转了默认值，以便在编写普通协议时，类型将默认为 some 而不是 any。 使默认值 some 保证固定的底层类型，它保留与底层类型的静态类型关系，使您可以完全访问使用 Self 和关联类型的协议要求和扩展方法。</p><p><strong>动机</strong></p><p>一段时间以来，Swift 一直致力于改进泛型的 UI，在 Swift 5.1 中引入了 some 关键字来表示不透明类型——特定具体类型的抽象类型占位符——它在 Swift 5.7 类型中扩展到参数，这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>&lt;T&gt;<span class="params">(<span class="number">_</span> bar: T)</span></span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Equatable</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is equivalent to </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> bar: some T)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>Swift 5.6 引入了 explicit any，这在 Swift 6 语言模式中是必需的，以确保选择类型擦除而不是使用类型参数是明确和深思熟虑的。 引入使用显式 any 的要求并鼓励默认编写一些，这为将一些作为普通协议名称的默认值提供了机会。</p><p>通用代码已经在比您想象的更多的地方得到了简化。 以协议扩展为例。 要编写适用于任何符合协议的具体类型的通用代码，您只需编写扩展关键字和普通协议名称。 在此示例中，我们使用 Collection 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What you write to extend all concrete types conforming to 'Collection':</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在通用代码中，通用签名表示通用参数和对这些参数的任何要求。 在协议扩展的情况下，有一个名为 Self 的隐式类型参数和单一一致性要求 <code>Self: Collection</code> 由编译器添加，而不需要您编写。 这允许您从符合要求的 Self 类型上的 Collection 协议访问所有协议要求、关联类型和其他扩展方法。</p><p>当存在不需要使用 where 子句内化泛型签名的垫脚石时，程序员学习泛型编程会容易得多。 程序员可以使用更直接、更直观的语法来表达同一事物。 Swift 6 可以将同样的原则应用于其他上下文中的普通协议名称。 这种做法对于学习 Swift 的初学者来说可能是无价的，它消除了在向代码中添加协议时比较某些和任何之间的权衡的心理负担。 初学者不需要在使用 some 还是 any 之间做出决定，推迟完全理解语义差异的需要，直到绝对有必要在两者之间进行选择。 即使您不是初学者，一些默认设置仍然可以通过使代码更简洁来提高代码的可读性。</p><p>3) 讨论<a href="https://forums.swift.org/t/really-bad-performance-with-concurrecny-and-how-to-optimize-the-code/63732/1" title="并发性能真的很差以及如何优化代码" target="_blank" rel="noopener">并发性能真的很差以及如何优化代码</a></p><p><strong>内容大概：</strong></p><p>我们正在对各种编程语言的并发性进行比较，并使用 Swift 实现一维热方程求解器。 与 Python、Rust 和 C++ 相比，swift 的性能看起来不是很好。<br>首先，代码最多只能扩展到三个内核，见下文</p><p>核心，总时间</p><p>10,2111.423936009407<br>8,2189.256893992424<br>5,1967.6182420253754<br>4,1929.6173659563065<br>2,3097.796007990837<br>1,4388.57520699501</p><p>然而，每秒的浮点运算相当低，例如在三个内核上我们每秒可以进行 500 次浮点运算。 与其他语言相比，这并不多。</p><p>所以，既然我们想发布结果，我想寻求一些帮助，因为我认为我们在 Swift 中的实现并不好。</p><p><strong>Vote最多的回答：</strong></p><p>这种问题对于简单的并发或多线程来说通常是一个非常糟糕的情况：</p><p>您的工作集太大。 在 <code>2 * 10000000 * MemoryLayout(Double).size</code>，你有一个 160MB 的工作集，它不适合缓存，所以你实际上受到内存速度的限制，而不是计算速度，这 与额外资源的扩展几乎不一样。</p><p>如果你用较小的工作集解决了这个问题，你就会被数据局部性所困扰。 您确实希望将每个 worker 固定到数据的固定部分，因此它会在下一个时间步位于与 worker 关联的缓存中。</p><p>4) 讨论<a href="https://forums.swift.org/t/state-not-initializing-correctly/63726" title="@State 没有正确初始化" target="_blank" rel="noopener">@State 没有正确初始化</a></p><p>5) 讨论<a href="https://forums.swift.org/t/a-light-weight-mvvmlight-architecture-pattern-in-swift/63722" title="Swift 中的轻量级 MVVMLight 架构模式" target="_blank" rel="noopener">Swift 中的轻量级 MVVMLight 架构模式</a></p><p>6) 讨论<a href="https://forums.swift.org/t/generic-where-fails-for-protocol-types/63729/1" title="协议类型里的Generic“where”失效" target="_blank" rel="noopener">协议类型里的 Generic“where” 失效</a></p><p>7) 讨论<a href="https://forums.swift.org/t/how-to-kind-of-emulate-raii-using-defer/63719" title="如何使用 `defer` 模拟 RAII" target="_blank" rel="noopener">如何使用 <code>defer</code> 模拟 RAII</a></p><p><strong>内容大概</strong></p><p>Swift 的 defer 语句具有很好的模拟 C++ 的资源获取即初始化行为的能力，由于 ARC，我们无法做到这一点。 如果您正在使用 <code>UnsafeMutablePointer</code> 通过确保在退出范围时正确清理资源来执行某些操作，这可能会很方便：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> file: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">FILE</span>&gt;?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(filePath: <span class="type">String</span>) &#123;</span><br><span class="line">        file = fopen(filePath, <span class="string">"r"</span>)</span><br><span class="line">        <span class="keyword">guard</span> file != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Error: Unable to open the file."</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> file != <span class="literal">nil</span> &#123;</span><br><span class="line">            fclose(file)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readAndProcessFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> file != <span class="literal">nil</span> &#123;</span><br><span class="line">                fclose(file)</span><br><span class="line">                file = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read and process the file</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fileHandler = <span class="type">FileHandler</span>(filePath: <span class="string">"path/to/your/file.txt"</span>) &#123;</span><br><span class="line">    fileHandler.readAndProcessFile()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们有一个管理文件的 <code>FileHandler</code> 类。 当调用 <code>readAndProcessFile</code> 方法时，我们使用 defer 块来确保在方法退出时关闭文件，无论它是正常退出还是由于错误退出。 这类似于 C++ 中的 RAII 概念，其中在对象超出范围时执行资源清理。</p><p>当然，这不是 RAII 的 1:1，但它显示了一种可以使用 defer 来实现类似效果的方法。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/03/15/performance-testing-in-swift-using-xctest-framework" title="Swift 中如何使用 XCTest 框架进行性能测试" target="_blank" rel="noopener">Swift 中如何使用 XCTest 框架进行性能测试</a></p><p><strong>摘要：</strong> 本文介绍了如何在 Swift 中使用 XCTest 框架进行性能测试，并通过 measure 函数来测量应用程序中特定代码路径的性能。</p><p><a href="https://www.swift.org/blog/swift-certificates-and-asn1" title="两个新的开源 Swift 库：Swift Certificates 和 Swift ASN.1" target="_blank" rel="noopener">两个新的开源 Swift 库：Swift Certificates 和 Swift ASN.1</a></p><p><strong>摘要：</strong> 这篇文章介绍了两个新的开源 Swift 库：Swift Certificates 和 Swift ASN.1。这两个库共同提供了更快、更安全的 X.509 证书实现，X.509 证书是支持 TLS 安全的关键技术之一。文章解释了X.509 证书和 ASN.1 格式的概念，和为什么需要构建一个 ASN.1 库以支持完整的 X.509 库，并介绍了 Swift ASN.1 和 Swift Certificates 的功能和目标。 Swift Certificates 目前可以解析大多数符合 RFC 5280 标准和 Web PKI 中使用的 X.509 证书，支持插件式 X.509 验证策略和 OCSP 分辨率。短期目标是使用 Swift Certificates 替换 swift-nio-ssl 中的 BoringSSL 实现，以提供更高性能和更好的内存安全性。</p><p><a href="https://juejin.cn/post/7207269389474037817" title="云音乐 Swift 混编 Module 化实践" target="_blank" rel="noopener">云音乐 Swift 混编 Module 化实践</a></p><p><strong>摘要：</strong>  文章介绍了网易云音乐 iOS App 在支持 Swift 混编过程中，Module 化阶段的分析与实践以及在实践过程中可能会遇到各种未知问题。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>文心一言挑战ChatGPT，谁更胜一筹？</strong></p><ol><li>文心一言</li><li>ChatGPT</li><li>不分伯仲</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十六期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;选择与放弃，是生活与人生处处需要面对的关口。选择了&lt;strong&gt;Swift社区&lt;/strong&gt;，就拥有了一道最靓丽的风景！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：印度将首次成为苹果公司自有销售地区&lt;/p&gt;
&lt;p&gt;提案：提案 SE-0382、SE-0388、SE-0389 通过审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议 Observation 修订&lt;/p&gt;
&lt;p&gt;推荐博文：两个新的开源 Swift 库：&lt;code&gt;Swift Certificates&lt;/code&gt; 和 &lt;code&gt;Swift ASN.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;文心一言挑战 ChatGPT，谁更胜一筹？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十四期/</id>
    <published>2023-07-04T07:19:43.000Z</published>
    <updated>2023-07-04T07:27:10.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十五期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>一个人真正觉悟的时候，就会去追寻内心世界真正的财富。<strong>Swift社区</strong>渴望走进你的内心，与你一起拥抱财富！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果高管确认，新品即将上市</p><p>提案：围绕 <code>Macros</code> 提出多个提案</p><p>Swift 论坛：新发布 VSCode devContainers 的新功能</p><p>推荐博文：使用 <code>async/await</code> 完成后台任务管理</p><p><strong>话题讨论：</strong> </p><p>程序员养生喝什么？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果高管确认，新品即将上市"><a href="#苹果高管确认，新品即将上市" class="headerlink" title="苹果高管确认，新品即将上市"></a>苹果高管确认，新品即将上市</h3><p>众所周知，苹果对待还未正式发布的产品，向来采取较为严格的保密政策。<br>不过，在去年 3 月举办的苹果春季发布会上，苹果对新品的一波预告，似乎成了近些年来罕有的例外。</p><p><img src="https://pics0.baidu.com/feed/58ee3d6d55fbb2fbd4417ebff105eeaf4723dc94.jpeg@f_auto?token=aac9eaa5fbccbd32593233adc298b6cf" alt=""></p><p>苹果硬件工程高级副总裁 John Ternus 在发布会结尾，暗示了即将要推出新款 Mac Pro 的消息。</p><p>实际上这也并不稀奇，苹果早在 2020 年就曾宣布了一项「两年计划」，预计在两年时间内将旗下所有 Mac 产品都转向自研芯片，彻底抛弃英特尔。</p><p>而如今两年之期已到，Mac 产品线中，也仅剩 Mac Pro 一款产品还未搭载 M 系芯片。</p><p>就在许多期待这款新 Mac 的小伙伴望眼欲穿之际，另一位苹果高管为我们带来了与之相关的最新消息。</p><p>近期，苹果全球产品营销副总裁 Bob Borchers 接受了 India Today 的采访，并针对一些产品问题进行了回复。</p><p><img src="https://pics0.baidu.com/feed/8435e5dde71190ef286707907054531dfcfa60b8.jpeg@f_auto?token=3c29a4745197240d1fc4ebb55a85bd89" alt=""></p><p>Bob Borchers 表示，在将大部分 Mac 产品都搭载 M 系芯片后，现阶段苹果的「两年计划」还在进行中。</p><p>也就是说，苹果的终极目标是将 Mac 产品线完成全系自研后，将自研芯片扩展至所有苹果产品中，其中自然也包括新款 Mac Pro。</p><p>从这两年的苹果的一系列动作来看，推动 Mac 全面自研化的进程已经接近收官，目前只差 Mac Pro。</p><h3 id="对等组基准指标现已在“App-分析”中发布"><a href="#对等组基准指标现已在“App-分析”中发布" class="headerlink" title="对等组基准指标现已在“App 分析”中发布"></a>对等组基准指标现已在“App 分析”中发布</h3><p>App Store Connect 中的“App 分析”是一款实用的工具，它具备丰富的功能，可帮助你了解和改进你的 App 在 App Store 中的表现。借助与获客率、使用和盈利策略相关的指标，你可以通过“App 分析”监控客户生命周期 (从认知到转化再到留存) 中各个阶段的结果。对等组基准指标会将你 App 的表现与 App Store 中类似的 App 进行比较，从今天开始，你可以使用此功能在有效情境中衡量 App 的表现。现在，你将获得更多见解，更有效地发现业务增长机会。</p><p>对等组基准指标会在整个客户旅程中提供独到且实用的新见解，帮助你更准确地了解 App 在哪些方面表现出色，并找到改进的方向。系统会根据 App 的 App Store 类别、商业模式和下载量将 App 归入不同的对等组中，以确保比较数据的相关性。此外，对等组基准指标使用行业领先的差分隐私技术，提供相关且切实可行的见解，同时确保单个 App 表现的私密性。</p><p>查看新的基准指标数据，然后利用 App Store Connect 中的其他工具来改善转化率、收益、崩溃率和用户留存率。你可以测试产品页上的不同元素以找出最能引起用户共鸣的部分，创建出额外的产品页版本以重点推介特定功能或内容，获得有关 Beta 版 App 的反馈，提供 App 内活动以鼓励参与，等等。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案重新恢复审查。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md" title="SE-0388" target="_blank" rel="noopener">SE-0388</a> <strong>增加 Async[Throwing]Stream.makeStream 方法</strong> 提案正在审查。</p><p>改天建议引入辅助方法来创建 <code>AsyncStream</code> 和 <code>AsyncThrowingStream</code> 实例，使开发者使用起来更加方便。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0389-attached-macros.md" title="SE-0389" target="_blank" rel="noopener">SE-0389</a> <strong>Attached Macros</strong> 提案正在审查。</p><p><code>Attached Macros</code> 是 Swift 中 <code>Macros</code> 愿景的一部分，该提案以 SE-0382 <code>Expression Macros</code> 的思想和动机为基础，涵盖了大量新的用例，将参考该提案以了解 <code>Macros</code> 如何集成到语言中的基本模型。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md" title="SE-0390" target="_blank" rel="noopener">SE-0390</a> <strong>引入 @noncopyable </strong> 提案正在审查。</p><p>该提案引入了 <code>@noncopyable</code> 类型（也称为 <code>move-only</code> 类型）的概念。 <code>@noncopyable</code> 类型的实例始终具有唯一所有权，这与可以自由复制的普通 Swift 类型不同。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0391-package-registry-publish.md" title="SE-0391" target="_blank" rel="noopener">SE-0391</a> <strong>Package Registry 公开发布</strong> 提案正在审查。</p><p><code>Package Registry</code> 公开发布后，可以对外公开可用。 从 Swift 5.7 开始，SwiftPM 支持使用任何实现与 SE-0292 一起提出的服务规范的注册表的依赖项解析和包下载。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/weburl-keyvaluepairs-api/63164" title="包管理器支持自定义宏" target="_blank" rel="noopener">包管理器支持自定义宏</a><br><strong>介绍</strong><br>宏提供了一种通过对输入源代码执行任意句法转换来生成新代码来扩展 Swift 的方法。 一个例子是之前在<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" target="_blank" rel="noopener">SE-0382</a> 中提出的表达式宏。该提案涵盖了如何定义、构建和分发自定义宏作为 Swift 包的一部分。<br><strong>动机</strong><br><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" target="_blank" rel="noopener">SE-0382</a> 和 <a href="https://gist.github.com/DougGregor/4f3ba5f4eadac474ae62eae836328b71" target="_blank" rel="noopener">A Possible Vision for Macros in Swift</a> 涵盖了宏本身的动机，将它们定义为包的一部分将提供一种直接的方式来重用和分发宏作为源代码。<br><strong>提议的解决方案</strong><br>在外部程序中实现的宏可以通过新的宏目标类型声明为包的一部分，定义在 CompilerPluginSupport 库：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Creates a macro target.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///     - name: The name of the macro.</span></span><br><span class="line">    <span class="comment">///     - dependencies: The macro's dependencies.</span></span><br><span class="line">    <span class="comment">///     - path: The path of the macro, relative to the package root.</span></span><br><span class="line">    <span class="comment">///     - exclude: The paths to source and resource files you want to exclude from the macro.</span></span><br><span class="line">    <span class="comment">///     - sources: The source files in the macro.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">macro</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        name: String,</span></span></span><br><span class="line"><span class="function"><span class="params">        dependencies: [Dependency] = [],</span></span></span><br><span class="line"><span class="function"><span class="params">        path: String? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        exclude: [String] = [],</span></span></span><br><span class="line"><span class="function"><span class="params">        sources: [String]? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> -&gt; <span class="type">Target</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似于包插件（SE-0303“包管理器可扩展构建工具”），宏插件被构建为主机的可执行文件（即，运行编译器的地方）。 编译器从构建系统接收到这些可执行文件的路径，并将作为编译过程的一部分按需运行它们。 宏可执行文件可自动用于任何通过包清单传递依赖于它们的目标。<br>包含宏的实现、定义和客户端的最小包如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"><span class="keyword">import</span> CompilerPluginSupport</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"MacroPackage"</span>,</span><br><span class="line">    targets: [</span><br><span class="line">        .macro(name: <span class="string">"MacroImpl"</span>),</span><br><span class="line">        .target(name: <span class="string">"MacroDef"</span>, dependencies: [<span class="string">"MacroImpl"</span>]),</span><br><span class="line">        .executableTarget(name: <span class="string">"MacroClient"</span>, dependencies: [<span class="string">"MacroDef"</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>宏实现将在类似于 package plugins 的沙盒中执行，防止文件系统和网络访问。 这是一种鼓励宏不依赖于任何状态的实用方法，除了它们被赋予扩展的特定宏扩展节点及其子节点（但不是其父节点），以及宏扩展上下文专门提供的信息。 如果将来宏需要访问其他信息，这将通过扩展宏扩展上下文来实现，这也为编译器提供了一种机制来跟踪宏实际查询的信息。</p><p>2) 新发布<a href="https://forums.swift.org/t/a-few-features-for-vscode-devcontainers-now-available/63485" title="VSCode devContainers 的新功能" target="_blank" rel="noopener">VSCode devContainers 的新功能</a><br>这些新功能它们让我的生活更轻松，所以我将它们添加到可用容器的通用目录中，以支持在 Swift:5.7 及更高版本中使用 .devContainer 设置。 具有三个独立的功能：</p><ul><li>jemalloc - 安装 jemalloc 库（如果你正在探索使用 package-benchmark 1 会很有帮助）</li><li>swiftpm - 安装构建 SwiftPM 所需的 sqlite 和 libsqlite 库</li><li>foundationnetworking - 安装 libcurl-openssl 以支持基础网络</li></ul><p>3) 提问<a href="https://forums.swift.org/t/how-to-measure-the-actual-memory-footprint-of-an-instance-of-a-struct/63474" title="如何测量结构实例的实际内存占用量？" target="_blank" rel="noopener">如何测量结构实例的实际内存占用量？</a><br>MemoryLayout.size(ofValue: theInstance) 但它只返回错误的大小（可能是指针的大小）。<br>将这个问题的范围缩小到仅结构体。例如：测量仅包含结构体的字典结构占用了多少内存。<br>回答：<br>一旦部分“值”没有存储在堆栈中，这个问题也变得没有意义。 如果我说 let newDict = existingDict，占用空间估计函数可能会说它们每个总共有 1024 个字节，因此您可能会得出结论，它们加起来是 2048 个字节。 但事实并非如此，因为 Dictionary 被记录为像这样的简单副本共享存储，直到一个值或另一个值发生变化； 实际总数大约是 1032 字节。 同样，您可以想象在这些字典中还嵌套了其他字典； 如果您修改其中一个顶级词典，将分配新的存储空间，但仍将共享嵌套词典。<br>说“这个值能保持多少内存”绝对是有价值的，但在一种具有无处不在的引用计数（或垃圾收集，就此而言）的语言中，它没有一个简单的答案。</p><p>4) 讨论<a href="https://forums.swift.org/t/why-so-many-expressions/63461" title="为什么有这么多“@”表达式？" target="_blank" rel="noopener">为什么有这么多“@”表达式？</a><br>我不是每天都使用 Swift，因为它实际上是 Apple 专用的语言。<br>所以当我最近回到它时，我发现了两个新问题。<br>使用 Swift 5 编译器编译后运行良好的代码在使用 5.9-dev 编译器构建时无法正确运行。 后者会产生以前不存在的运行时错误。<br>查看一些示例代码，我看到比以前更多的 @ 表达式，例如 @frozen、@State、@stateobject 等。 有没有完整的列表？ 这些都有什么用？ 文档（在其存在的范围内）含糊不清。 这些表达式不会降低代码的可读性吗？<br>回答：<br>一些“@表达式”内置于编译器中，如@available、@propertyWrapper、@dynamicMemberLookup。<br>大多数由 SwiftUI 等库以 Property Wrappers 的形式提供<br>这些表达式不会降低代码的可读性吗？相反，与手卷替代方案相比，它们大大提高了可读性。<br>属性包装器让您可以提取自动应用于获取或设置值的可重用行为（如 JS 2 中的处理程序方法或 Python 1 中的描述符）。<br>例如，每次写入标记为@Published 的属性时，您的 ObservedObject 都会自动发出一个 objectWillChange 事件。 如果 @Published 属性包装器不存在，代码中的 @ 符号就会减少，但您还需要在每次写入属性时执行类似 objectWillChangePublisher.send() 的操作。 这很费力，引入了疯狂的重复和忘记这样做的机会。 在不知不觉中，您会在论坛上看到类似以下的问题：<br>提问者：“为什么当我更改此属性时我的视图没有更新？”<br>回答者：“因为你忘记了 objectWillChangePublisher.send()。”<br>提问者：“为什么框架不能自动为我调用它？”<br>因此，出现了属性包装器。</p><p>5) 提问<a href="https://forums.swift.org/t/how-to-launch-effect-onapper-only-once/63455" title="SwiftUI 如何只启动一次 onApper？" target="_blank" rel="noopener">SwiftUI 如何只启动一次 onApper？</a></p><p>6) 提问<a href="https://forums.swift.org/t/opting-out-of-automatic-foundation-linking-on-macos/63430" title="选择取消 macOS 上的自动 Foundation 链接？" target="_blank" rel="noopener">选择取消 macOS 上的自动 Foundation 链接？</a></p><p>7) GSoC<a href="https://forums.swift.org/t/swift-to-participate-in-gsoc-2023/63441" title="Swift参加GSoC 2023！" target="_blank" rel="noopener">Swift参加GSoC 2023！</a><br>很高兴与大家分享，Swift 将再次参加 Google Summer of Code 3！ 到现在为止，也许您已经看到潜在的参与者开始了一些话题<br>去年，我们设法运行了 5 个很棒且成功的项目。 如果您对它们是什么感到好奇，您可以直接在 Swift 博客 10 上从他们的参与者和导师那里了解相关信息。<br>今年，我们已经收集了一些潜在的项目想法以及他们自愿参与 Swift 网站的导师：Swift.org - GSoC 2023 的项目想法 23。<br>今年我们准备了一个专门针对 GSoC 6 的新论坛类别，因为我们发现虽然有些项目有很好的空间来讨论它（比如服务器类别），但有些项目以前并没有真正的讨论空间（ 之后）他们开始了。 我们仍然鼓励使用 gsoc-2023 标签 2 来标记所有与 gsoc 相关的线程，并且并非所有线程都需要属于这个新类别。 然而，这个类别应该有助于引导讨论，否则没有一个很好的归宿。<br>与往常一样，我们期待听到您的项目想法，并建议在新论坛类别中打开一个主题，描述您的项目想法以及您需要帮助以使其成为现实的领域。 如果某个项目看起来很有吸引力并且有可能在 GSoC 时间框架内实现，我们将尽最大努力为其寻找导师。<br>我们对有助于“Swift 项目”的项目感兴趣，其中包括各个重点领域的各种项目。 以下是一些可能成为 GSoC 项目创意候选者的项目示例：<br>Swift 编译器 2 本身（类型检查器、前端、后端、标准库），项目可以包括改进调试、性能、添加一个小功能，<br>相关包，如 Collections、Async Algorithms、SwiftSyntax、SourceKit-LSP、DocC、Distributed Actor Cluster 等 1，<br>主要由服务器生态系统使用的包，包括为尚未支持的数据库、队列或其他 API 提议新的库，<br>Swift Package Manager 2、Swift 网站、文档或 Swift 的其他部分。<br>您可以在我们的 Swift 博客上回顾去年的成功项目 10 ，了解接受了哪些类型的项目。<br>今年我们还为非 Apple 员工开放了导师角色。 如果您是一位经验丰富的 Swift 贡献者，并且有兴趣作为 GSoC 导师为我们的参与者提供指导，请留意进一步的公告，或使用下面的联系方式与我联系。 这对我们来说是一个新流程，所以我们将看看它是如何运作的，但我们有兴趣向更广泛的 Swift 项目贡献者开放指导。<br>作为 GSoC 体验的一部分，我们也在考虑提供更多机会与其他 Swift 贡献者会面。</p><p>8) GSoC<a href="https://forums.swift.org/t/interested-in-improving-user-experience-with-scripting-in-swift/63478" title="有兴趣使用 Swift 中的脚本来改善用户体验" target="_blank" rel="noopener">有兴趣使用 Swift 中的脚本来改善用户体验</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swdevnotes.com/swift/2023/use-async-let-to-run-background-tasks-in-parallel-in-swift/" title="Use async let to run background tasks in parallel in Swift" target="_blank" rel="noopener">使用 async let 在 Swift 中并行运行后台任务</a></p><p><strong>摘要：</strong> 本文介绍了如何在后台执行长期运行的任务并保持 UI 响应。<code>async/await</code> 提供了执行异步任务的干净机制。允许并行执行多个后台任务。</p><p><a href="https://swdevnotes.com/swift/2023/how-to-cancel-a-background-task-in-swift/" title="How to cancel a background task in Swift" target="_blank" rel="noopener">如何在 Swift 中取消后台任务</a></p><p><strong>摘要：</strong> Swift 5.5 中引入的 <code>async/await</code> 语法允许以可读的方式编写异步代码。异步编程可以提高应用程序的性能，同时很重要的一点是要取消不需要的任务，以确保暂时不需要的后台任务不会干扰应用程序。本文演示了如何取消任务，并解释了如何自动取消子任务。</p><p><a href="https://sarunw.com/posts/how-to-use-async-await-in-flutter/" title="How to use async/await in Flutter" target="_blank" rel="noopener">如何在 Flutter 中使用 async/await</a></p><p><strong>摘要：</strong> 在本文中展示了一系列异步实现示例，并在最后给出三个组件（<code>Future</code>，<code>async</code> 和 <code>await</code>）的使用说明。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>程序员养生喝什么？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十五期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;一个人真正觉悟的时候，就会去追寻内心世界真正的财富。&lt;strong&gt;Swift社区&lt;/strong&gt;渴望走进你的内心，与你一起拥抱财富！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果高管确认，新品即将上市&lt;/p&gt;
&lt;p&gt;提案：围绕 &lt;code&gt;Macros&lt;/code&gt; 提出多个提案&lt;/p&gt;
&lt;p&gt;Swift 论坛：新发布 VSCode devContainers 的新功能&lt;/p&gt;
&lt;p&gt;推荐博文：使用 &lt;code&gt;async/await&lt;/code&gt; 完成后台任务管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;程序员养生喝什么？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十三期/</id>
    <published>2023-07-04T07:19:38.000Z</published>
    <updated>2023-07-04T07:26:28.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十四期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>勇敢是即便知道好结局不会每每降临在我们身上，但也依然选择热爱和坚持。<strong>Swift社区</strong>会伴你一起，见证每一刻勇敢的光亮！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及</p><p>Swift 论坛：讨论嵌套泛型的问题</p><p>推荐博文：iOS App 项目优化</p><p><strong>话题讨论：</strong> </p><p>生活中遇到的问题你会使用 chatGTP 寻找答案吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果iPhone-15-Pro硬件细节曝光，广大网友期待USB-C接口迎来普及"><a href="#苹果iPhone-15-Pro硬件细节曝光，广大网友期待USB-C接口迎来普及" class="headerlink" title="苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及"></a>苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及</h3><p>苹果在欧美市场已被多个监管施压放弃Lighting接口改为USB-C接口，最新关于苹果 iPhone 15 Pro硬件细节爆料消息，似乎透露着苹果公司将将在自家产品正式放弃Lighting接口改为 USB-C 接口。从苹果 iPhone 15 Pro 真机图片来看，苹果 iPhone 15 Pro 开始使用USB-C接口。随着安卓手机厂商普遍采用 USB-C 接口，目前来看苹果公司在自家新品上采用 USB-C 接口，也是整个手机行业的大势所趋。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0218%2F2eca6bd0j00rqa52w001id000u000gvm.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt=""></p><p>除此之外，苹果 iPhone 15 Pro 硬件外观部分也更加圆润，同时音量键设计也改为电容式设计，后置摄像头的镜头模组也变得更加凸起，意味着苹果公司在新的 iPhone 15 Pro 机型镜头模组进行了升级。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0218%2Fe1795fd6j00rqa52l000ad000sg00e8m.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt=""></p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0218%2F6f5d7cdaj00rqa52n000sd000sg00e8m.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt=""></p><p>总体来说，iPhone 15 Pro 大概率也将是 iPhone 14Pro 升级产品，相较前代机型，在细节部分进行了进一步的优化完善。来源: IT极客世界。</p><h3 id="苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工"><a href="#苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工" class="headerlink" title="苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工"></a>苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/down/d572ac3a4cab7954fc5bacdf5e12aa1f.jpeg" alt=""></p><p>在亚马逊、微软、谷歌等国际科技巨头们裁员后，苹果也被曝出裁员消息。2 月 17 日，《纽约邮报》援引知情人士报道，苹果公司在过去几天裁减了数百名合同未到期的外包合同工。</p><p>作为全世界最赚钱的公司之一，苹果公司曾在 2022 年公开宣称不会裁员，但将停止招聘。但随着 2022 年四季度不及预期的财报发布后，苹果还是动了裁员的念头。</p><p>据苹果公司发布 10-12 月份的季度业绩显示，其实现总净销售额 1171.54 亿美元，同比下滑 5% ，不仅低于市场预期的 1211.04 亿元，还创造了 2019 财年来首次营收同比下滑。iPhone、Mac、可穿戴设备等业务营收均出现不同程度的下滑，仅iPad业务的营收实现了同比增长。</p><p>为挽救业务，苹果一方面加大促销力度，于 2022 年 9 月开始在中国销售的 iPhone 14 系列，在上市不到半年后即推出“全系降价 600 元- 800 元”的促销活动。搁往年，苹果最新款降价一般都在六七月份。如今，裁员也成为“降本增效”的新选择。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/weburl-keyvaluepairs-api/63164" title="WebURL KeyValuePairs API" target="_blank" rel="noopener">WebURL KeyValuePairs API</a></p><p>为了更容易地从 URL 组件读取/写入键值对，WebURL 0.5.0 将包含一个新的 KeyValuePairs 类型。 当前的 formParams 视图将在下一个次要版本中弃用和删除。</p><p>2) 讨论<a href="https://forums.swift.org/t/partition-the-reflection-metadata-to-runtime-and-debug-categories/63163/1" title="将反射元数据划分为运行时和调试类别" target="_blank" rel="noopener">将反射元数据划分为运行时和调试类别</a></p><p>目前的情况：</p><ul><li>可以完全启用或禁用反射功能。 （中间没有选项）</li><li>当使用 <code>-disable-reflection-metadata</code> 标志禁用时，LLDB 将无法使用反射元数据，从而导致调试功能显着降低。</li><li>启用后，dsymutil 将反射信息从 TEXT 复制到 dSYM 的 DWARF 段，这允许 lldb 稍后发现它。</li><li>通过使用 <code>-enable-reflection-for-debugger-only</code> 标志，LLDB 可以使用反射，但是，它不会链接到 NTD，这将允许链接器通过 dead-stripping 消除它。</li></ul><p>设计：</p><p>快速编译器：</p><ul><li><p>扩展 FieldTypeMetadataBuilder（可能还有其他构建器）并使其可从外部进行配置。</p></li><li><p>在 emitFieldDescriptor 中实例化两个 FieldTypeMetadataBuilder，一个将直接在 _DWARF 中发射全反射，另一个将像往常一样发射反射到 _TEXT 段。 前者将由 -g 系列标志控制，而后者将由反射标志控制。</p></li></ul><p>DSYMUTIL：</p><ul><li>更改 dsymutil，而不是从 TEXT 复制反射，而是将其复制到 DWRAF 段。</li></ul><p>LLDB：</p><ul><li>可能需要更改 LLDB，以教会它在没有提供 DSYM 的情况下进行调试时发现 DWARF 段中的反射。</li></ul><p>3) 讨论<a href="https://forums.swift.org/t/prevent-optimizing-away-public-interfaces-needed-by-an-xcframework-aka-dyld-symbol-not-found/63162" title="防止优化 XCFramework 所需的公共接口（又名 dyld：未找到符号）" target="_blank" rel="noopener">防止优化 XCFramework 所需的公共接口（又名 dyld：未找到符号）</a></p><p>4) 提议<a href="https://forums.swift.org/t/se-0388-convenience-async-throwing-stream-makestream-methods/63139" title="SE-0388：便捷 Async[Throwing]Stream.makeStream 方法" target="_blank" rel="noopener">SE-0388：便捷 Async[Throwing]Stream.makeStream 方法</a></p><p>便捷 Async[Throwing]Stream.makeStream 方法”的审查现在开始，一直持续到 2023 年 2 月 26 日。</p><p>该提案可在此处获得：<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md" target="_blank" rel="noopener">https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md</a></p><p>5) 讨论<a href="https://forums.swift.org/t/swift-devcontainer-template/63161" title="Swift 开发容器模板" target="_blank" rel="noopener">Swift 开发容器模板</a></p><p><strong>内容大概：</strong></p><p>Visual Studio Code 的优势之一是您可以在 docker 容器内开发项目。 如果你在 macOS 上开发但部署到 Linux，你不再需要在 Linux 上运行你的代码来验证它是否工作，你可以在你的 Mac 上编辑、编译、运行和调试你的项目，在 VS Code 中运行的 docker 容器中。</p><p>到目前为止，您可以通过手动编辑 devcontainer.json 文件或下载由 Microsoft 管理的快速开发模板来定义容器环境。</p><p>由 Microsoft 管理模板意味着在需要对模板进行更改时需要他们的输入（通过 PR 审查），例如添加新版本的 swift。</p><p>最近这种情况发生了变化，Swift devcontainer 模板的责任已转移到 SSWG。 devcontainer 现在存储在 swift-server GitHub 组织中。</p><p>我们做的第一件事是使模板现代化。 我们用等效的 devcontainer common-utils 功能替换了原始模板具有的 shell 脚本。 您可以在此处找到有关 <code>devcontainer</code> 功能的更多信息。原始模板有一个安装 Node.js 的选项（在大多数模板中实现的标准 MS）。 这已被删除，因为现在可以通过 devcontainer 功能完成。</p><p><strong>新的 devcontainer GitHub链接</strong>：<a href="https://github.com/swift-server/swift-devcontainer-template" target="_blank" rel="noopener">https://github.com/swift-server/swift-devcontainer-template</a></p><p>6) 提问<a href="https://forums.swift.org/t/nested-generic-trouble/63152" title="嵌套泛型的问题" target="_blank" rel="noopener">嵌套泛型的问题</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>: <span class="title">P</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>&lt;T: P&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(type(of: value)) <span class="comment">// S</span></span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// S()</span></span><br><span class="line">    bar(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(<span class="number">_</span> value: S)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"S call"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: P&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"P call"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="type">S</span>()</span><br><span class="line">    bar(s) <span class="comment">// S call</span></span><br><span class="line">    foo(s) <span class="comment">// P call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calling bar 直接打印出预期的“S call”，但通过“foo”调用它会打印出意外的“P call”。我的期望是错误的？<br>有趣的是它在 C++ 中按预期工作。</p><p>7) 提议<a href="https://forums.swift.org/t/swift-async-algorithms-proposal-buffer/63155" title="Swift 异步算法提案：缓冲区" target="_blank" rel="noopener">Swift 异步算法提案：缓冲区</a></p><p><strong>介绍：</strong></p><p>缓冲是一种通过临时存储元素来平衡生产和消耗率波动来平衡供需的技术。 <code>AsyncStream</code> 通过允许您控制缓冲区的大小和处理超过该大小的元素的策略来促进此过程。 但是，这种方法可能并不适合所有情况，并且它不提供一种方法来调整其他 <code>AsyncSequence</code> 类型以合并缓冲。</p><p>该提案提出了一种新类型，可以满足这些更高级的要求，并为异步序列中的缓冲提供全面的解决方案。</p><p>8) 提议<a href="https://forums.swift.org/t/pitch-custom-actor-executors/63135" title="自定义 Actor 执行器" target="_blank" rel="noopener">自定义 Actor 执行器</a></p><p><strong>介绍：</strong></p><p>该提案侧重于使 actor 执行程序可由库作者或最终用户配置的最小可行部分。 它基于 <code>@John_McCall</code> 的自定义执行器 16 的早期草案，我们在 Swift 并发性首次引入时分享了该草案，但我们从未正式确定它引入的想法。</p><p>在过去的几年里，我们发现了什么有效，什么需要更多的思考。 该提案侧重于标准化基本的 <code>SerialExecutor</code> 机制以及参与者如何自定义他们想要运行任务的位置。 我们也承认之前提出的未来工作领域，我们不打算在本提案中一次解决所有这些问题； 请参阅“未来方向”部分以了解更多信息。 有趣的是，这个 API 的某些部分被默默地引入并融入了 Swift 并发的 ABI——在适用的情况下，我们解释了这些关系以及我们如何使提议的 API 满足那些现有的要求。</p><p>这个推介也与最近推介的 <code>unsafeAssumeMainActor</code> 想法有一点关系，因为它打开了共享同一个串行执行器的各种参与者的领域，并引入了基于此的断言。</p><p><strong>附上 GitHub 链接</strong>：<a href="https://github.com/ktoso/swift-evolution/blob/wip-custom-executors/proposals/nnnn-custom-actor-executors.md" target="_blank" rel="noopener">https://github.com/ktoso/swift-evolution/blob/wip-custom-executors/proposals/nnnn-custom-actor-executors.md</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7197970175478464571" title="百度 APP iOS 端内存优化-原理篇" target="_blank" rel="noopener">百度 APP iOS 端内存优化-原理篇</a></p><p><strong>摘要：</strong> 本文介绍了 Mach 虚拟内存的特点、内存管理的数据结构以及 Mach 内核提供的内存操作接口，同时对 OC 内存分配核心函数 alloc 做了源码分析。</p><p><a href="https://juejin.cn/post/7185083491061596219/" title="iOS 包体积优化3 - 代码管理" target="_blank" rel="noopener">iOS 包体积优化3 - 代码管理</a></p><p><strong>摘要：</strong> 本文是 iOS 包体积优化的系列文章中代码管理模块，主要讲述了如何做好项目中的代码管理工作。</p><p><a href="https://juejin.cn/post/7185101900303728695" title="iOS 包体积优化5 - 编译优化" target="_blank" rel="noopener">iOS 包体积优化5 - 编译优化</a></p><p><strong>摘要：</strong> 本文是 iOS 包体积优化的系列文章中编译优化模块，介绍了多种项目实战所用到的编译优化方法。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>生活中遇到的问题你会使用 chatGTP 寻找答案吗？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十四期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;勇敢是即便知道好结局不会每每降临在我们身上，但也依然选择热爱和坚持。&lt;strong&gt;Swift社区&lt;/strong&gt;会伴你一起，见证每一刻勇敢的光亮！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论嵌套泛型的问题&lt;/p&gt;
&lt;p&gt;推荐博文：iOS App 项目优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;生活中遇到的问题你会使用 chatGTP 寻找答案吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十二期/</id>
    <published>2023-07-04T07:19:30.000Z</published>
    <updated>2023-07-04T07:25:41.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十三期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>渺小不可怕，可怕的是比你优秀的强者还比你更加努力。<strong>Swift社区</strong>不会辜负每一位努力的勇士，优秀终将与你不期而遇！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：因iPhone销量下降 苹果利润2016年以来首次低于预期</p><p>提案：新年开始多个提案状态发生变化</p><p>Swift 论坛：讨论如何设置需要异步初始化的静态变量</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="因-iPhone-销量下降，苹果利润-2016-年以来首次低于预期"><a href="#因-iPhone-销量下降，苹果利润-2016-年以来首次低于预期" class="headerlink" title="因 iPhone 销量下降，苹果利润 2016 年以来首次低于预期"></a>因 iPhone 销量下降，苹果利润 2016 年以来首次低于预期</h3><p>2 月 3 日凌晨，多家美股科技巨头公布财报。苹果 2023 财年 Q1 净利润录得 299 亿美元，低于市场预期，原因是 iPhone 的供应出现问题，导致销售疲软。苹果当季销售额下降 5% ，至 1172 亿美元，全球各地的销售额均出现下滑。除服务和 ipad 以外，所有产品类别的销售额都有所下降。这是自 2016 年以来苹果首次未能达到华尔街的利润预期。不过，苹果CEO库克在最新业绩会上表示，中国市场的需求已经有非常好的复苏，去年 12 月和 11 月相比市场确实发生了很大变化。库克还表示，苹果将很快在印度开设第一批零售店。</p><h3 id="App-和-App-内购买项目即将实行税率和价格调整"><a href="#App-和-App-内购买项目即将实行税率和价格调整" class="headerlink" title="App 和 App 内购买项目即将实行税率和价格调整"></a>App 和 App 内购买项目即将实行税率和价格调整</h3><p>App Store 的交易和支付机制旨在帮助您在覆盖全球的 175 个国家和地区的商店中，以 45 种货币为您的产品和服务便捷地进行定价与销售。我们会根据税款和外币汇率变化，定期在相关地区的 App Store 更新定价。相关调整将根据金融数据机构提供的公开汇率信息进行，以此确保 App 和 App 内购买内容的定价在所有商店中保持平衡。</p><p>2023 年 2 月 13 日起，哥伦比亚、埃及、匈牙利、尼日利亚、挪威、南非和英国 App Store 的 App 及 App 内购买项目 (自动续期订阅除外) 的价格将上调。由于乌兹别克斯坦的增值税率从 15% 下调至 12%，该地区的价格亦将相应下调。您的收益将随之进行调整，并会根据不含税的价格来进行计算。</p><p>虽然爱尔兰、卢森堡、新加坡和津巴布韦 App Store 的价格不会改变，但您的收益将进行调整以反映以下税率调整：</p><p>爱尔兰：电子报纸和期刊的增值税率从 9% 下调至 0%<br>卢森堡：增值税率从 17% 下调至 16%<br>新加坡：商品和服务税率从 7% 上调至 8%<br>津巴布韦：增值税率从 14.5% 上调至 15%<br>此外，在柬埔寨、吉尔吉斯斯坦、印度尼西亚、新加坡、韩国、塔吉克斯坦、泰国和乌兹别克斯坦销售产品和服务的当地开发者的收益将在一月底前相应增加。</p><p>Apple 在计算抽成之前会根据您提供的税务类别信息估算并移除相关税费。《付费 App 协议》的附录 B 亦将更新以反映此调整。</p><p>以上调整生效后，在“我的 App”中“价格与销售范围”部分会随即更新。一如既往，您可以随时在 App Store Connect 中更改您的 App 和 App 内购买项目的价格 (包括自动续期订阅)。如果您有提供订阅项目，您可以选择为现有订阅者保留当前价格。</p><p>正如我们此前所宣布，从 2023 年春季起，App 和 App 内购买项目的定价功能升级将带来 700 个新增的价格点；我们还将提供针对全球不同地区更加灵活的价格设定，您将能够不受全球均衡价格的影响，自由管理外币汇率变化。</p><h3 id="Ask-Apple-Q-amp-A-和调查表"><a href="#Ask-Apple-Q-amp-A-和调查表" class="headerlink" title="Ask Apple Q&amp;A 和调查表"></a>Ask Apple Q&amp;A 和调查表</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/5A13BEF0-31D6-466B-B88B-8484635BEA2A/2048.jpeg" alt=""></p><p>感谢大家参与 10 月、11 月和 12 月举办的三场精彩的 Ask Apple 活动周。Ask Apple 参与者仍可以根据需要访问并查阅 Slack 中的 Q&amp;A。</p><p>我们非常希望获得您的反馈，如果您尚未与我们分享您的 Q&amp;A 体验，恳请完成我们的简短调查表。只需几分钟时间即可完成，并且您的回答将被匿名处理。</p><p>我们期待不久之后能再次与您沟通交流。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过审查的提案"><a href="#通过审查的提案" class="headerlink" title="通过审查的提案"></a>通过审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0384-importing-forward-declared-objc-interfaces-and-protocols.md" title="SE-0384" target="_blank" rel="noopener">SE-0384</a> <strong>导入已声明的 Objective-C 接口和协议</strong> 提案通过审查。该提案已在 <strong>二十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0383-deprecate-uiapplicationmain-and-nsapplicationmain.md" title="SE-0383" target="_blank" rel="noopener">SE-0383</a> <strong>弃用 @UIApplicationMain 和 @NSApplicationMain</strong> 提案通过审查。该提案已在 <strong>二十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0381-task-group-discard-results.md" title="SE-0381" target="_blank" rel="noopener">SE-0381</a> <strong>DiscardingTaskGroups</strong> 提案通过审查。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0380-if-switch-expressions.md" title="SE-0380" target="_blank" rel="noopener">SE-0380</a> <strong>if 和 switch 表达式</strong> 提案通过审查。该提案已在 <strong>十九期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0378-package-registry-auth.md" title="SE-0378" target="_blank" rel="noopener">SE-0378</a> <strong>Package 注册表认证</strong> 提案通过审查。该提案已在 <strong>十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0377-parameter-ownership-modifiers.md" title="SE-0377" target="_blank" rel="noopener">SE-0377</a> <strong>提出了新的 <code>borrow</code> 和 <code>take</code> 参数修饰符</strong> 提案通过审查。该提案已在 <strong>十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案被驳回。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0379-opt-in-reflection-metadata.md" title="SE-0379" target="_blank" rel="noopener">SE-0379</a> <strong>Swift 选择加入 Reflection 元数据</strong> 提案被驳回。该提案已在 <strong>十九期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0387-cross-compilation-destinations.md" title="SE-0387" target="_blank" rel="noopener">SE-0387</a> <strong>交叉编译项目</strong> 提案正在审查。</p><p><code>Cross-compilation</code> 是一个常见的开发用例。该提案的作者知道已建立的“构建/主机/目标平台”命名惯例，但认为“目标”在构建系统命名中已经具有不同的含义。此外，“平台”本身的定义相当松散。为了避免可能的混淆，我们在这个建议中使用“构建时三元组”和“运行时三元组”术语。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0386-package-access-modifier.md" title="SE-0386" target="_blank" rel="noopener">SE-0386</a> <strong>新的访问修饰符:package</strong> 提案正在审查。</p><p>该提案引入了 <code>package</code> 作为一个新的访问修饰符。目前，要访问另一个模块中的符号，该符号需要声明为 <code>public</code>。但是，<code>public</code> 符号允许从任何模块访问它，无论是在包内还是从包外，有时候这样做不能满足需求。需要一个新的访问修饰符来更好地控制此类符号的可见范围。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0385-custom-reflection-metadata.md" title="SE-0385" target="_blank" rel="noopener">SE-0385</a> <strong>自定义反射元数据</strong> 提案正在审查。</p><p>该提案引入了使用自定义属性将库定义的反射元数据附加到声明中的功能，然后库可以查询这些元数据，以便于将客户端代码选择到库功能中。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/how-to-set-static-variable-that-requires-async-initialization/62661" title="如何设置需要异步初始化的静态变量" target="_blank" rel="noopener">如何设置需要异步初始化的静态变量</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@globalActor <span class="keyword">public</span> actor <span class="type">ImageDatabase</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="type">ImageDatabase</span> = <span class="type">ImageDatabase</span>() </span><br><span class="line">    <span class="comment">// 'async' call cannot occur in a global variable initializer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> transport : <span class="type">ImageTransportLayer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() async &#123;</span><br><span class="line">           <span class="keyword">self</span>.transport = await <span class="type">ImageTransportLayer</span>()</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">ImageDatabase</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageTransportLayer</span> </span>&#123; &#125; <span class="comment">// CRUD</span></span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong> 可以稍后在应用程序启动序列中手动初始化 <code>ImageTransportLayer</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@globalActor <span class="keyword">public</span> actor <span class="type">ImageDatabase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="type">ImageDatabase</span> = <span class="type">ImageDatabase</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> transport: <span class="type">ImageTransportLayer</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">initTransport</span><span class="params">()</span></span> async &#123;</span><br><span class="line">        transport = await <span class="type">ImageTransportLayer</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">ImageDatabase</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageTransportLayer</span> </span>&#123;&#125; <span class="comment">// CRUD</span></span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    await <span class="type">ImageDatabase</span>.shared.initTransport()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Continue using ImageDatabase.shared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 讨论<a href="https://forums.swift.org/t/swift-5-7-on-macos-catalina-and-a-toolchain-for-macos/62656" title="macOS Catalina 上的 Swift 5.7 和适用于 macOS 的工具链" target="_blank" rel="noopener"> macOS Catalina 上的 Swift 5.7 和适用于 macOS 的工具链</a></p><p>3) 发布<a href="https://forums.swift.org/t/vscode-swift-v1-0-0/62668" title="VSCode Swift v1.0.0" target="_blank" rel="noopener"> VSCode Swift v1.0.0</a></p><p>Swift Visual Studio Code 扩展的 1.0 版已经发布。 它不再处于预览状态。<br>此版本对 v0.10.0 进行了一些小的添加，并修复了一些错误。 更新日志链接：<a href="https://marketplace.visualstudio.com/items/sswg.swift-lang/changelog" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items/sswg.swift-lang/changelog</a></p><p>4) 讨论<a href="https://forums.swift.org/t/asyncsequences-and-cooperative-task-cancellation/62657" title="AsyncSequences 和 cooperative 任务取消" target="_blank" rel="noopener"> AsyncSequences 和 cooperative 任务取消</a></p><p>5) 讨论<a href="https://forums.swift.org/t/property-wrapper-on-a-functions-signature/62660" title="函数签名的属性包装器" target="_blank" rel="noopener">函数签名的属性包装器</a></p><p>6) 提问<a href="https://forums.swift.org/t/integrating-a-function-into-a-struct/62634" title="将函数集成到结构中" target="_blank" rel="noopener">将函数集成到结构中</a></p><p>目标是有一个接受字符串的字段，它下面的文本将打印一条消息，其中包含输入的单词和它包含的字母数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> newWord = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">VStack</span> &#123;</span><br><span class="line">          <span class="type">TextField</span>(<span class="string">"Enter a word"</span>, text: $newWord)</span><br><span class="line">              .frame(height: <span class="number">50</span>)</span><br><span class="line">              .cornerRadius(<span class="number">10</span>)</span><br><span class="line">              .background(.gray.opacity(<span class="number">0.1</span>))</span><br><span class="line">              .padding(.horizontal, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//Text(countLetters(myWord: newWord))</span></span><br><span class="line">          <span class="type">Text</span>(myMessage)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLetters</span><span class="params">(myWord: String)</span></span> -&gt; (<span class="type">String</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myCounter = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> characters = <span class="string">""</span></span><br><span class="line">  <span class="keyword">for</span> letter <span class="keyword">in</span> myWord &#123;</span><br><span class="line">      characters += <span class="string">"<span class="subst">\(letter)</span>"</span></span><br><span class="line">      myCounter += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (characters, myCounter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myWordCount = countLetters(myWord: <span class="string">"Gregory"</span>)</span><br><span class="line"><span class="keyword">var</span> myMessage = <span class="string">"There are <span class="subst">\(myWordCount)</span> letters in the"</span></span><br></pre></td></tr></table></figure><p><strong>解决：</strong> 字符串有一个 <code>.count</code> 属性，可以直接使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  @<span class="type">State</span> <span class="keyword">var</span> text = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">VStack</span> &#123;</span><br><span class="line">          <span class="type">TextField</span>(<span class="string">"Enter a word"</span>, text: $text)</span><br><span class="line">          <span class="type">Text</span>(<span class="string">"There are <span class="subst">\(text.<span class="built_in">count</span>)</span> letters in your word"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7) 发布<a href="https://forums.swift.org/t/released-asyncobjects-2-0/62664" title="AsyncObjects 2.0" target="_blank" rel="noopener"> AsyncObjects 2.0</a></p><p>8) 提议<a href="https://forums.swift.org/t/pitch-add-keypaths-boolean-custom-operators/62626" title="添加 KeyPaths Boolean自定义运算符" target="_blank" rel="noopener">添加 KeyPaths Boolean 自定义运算符</a></p><p><strong>内容大概：</strong></p><p>在<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0249-key-path-literal-function-expressions.md" target="_blank" rel="noopener">SE-0249</a> 引入了在允许 (Root) -&gt; Value 函数的任何地方使用关键路径表达式 \Root.value 的能力。</p><p>现在在各个项目中得到了广泛的使用。<br>在这里试图提议的是为关键路径添加一些新的运算符，以便在尝试对其应用任何逻辑时更容易使用它。</p><p>这里有几个例子：</p><p>假设我们想过滤字典并获取所有为真的值。<br>我们现在可以通过以下方式使用关键路径轻松完成此操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = [<span class="string">"a"</span>: <span class="literal">true</span>, <span class="string">"b"</span>: <span class="literal">true</span>, <span class="string">"c"</span>: <span class="literal">false</span>]</span><br><span class="line"><span class="keyword">let</span> filtered = dict.<span class="built_in">filter</span>(\.value) <span class="comment">// returns ["a": true, "b": true]</span></span><br></pre></td></tr></table></figure><p>但是如果我们想过滤字典中的错误值怎么办？那么现在我们不能使用关键路径，我们需要依赖闭包：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered = dict.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.value &#125; <span class="comment">// returns ["c": false]</span></span><br></pre></td></tr></table></figure><p>这里的建议是添加以下运算符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> !&lt;V&gt;<span class="params">(keyPath: KeyPath&lt;V, Bool&gt;)</span></span> -&gt; (<span class="type">V</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    &#123; !$<span class="number">0</span>[keyPath: keyPath]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ==&lt;T, V: Equatable&gt;<span class="params">(lhs: KeyPath&lt;T, V&gt;, rhs: V)</span></span> -&gt; (<span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; $<span class="number">0</span>[keyPath: lhs] == rhs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> !=&lt;T, V: Equatable&gt;<span class="params">(lhs: KeyPath&lt;T, V&gt;, rhs: V)</span></span> -&gt; (<span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; $<span class="number">0</span>[keyPath: lhs] != rhs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将使我们能够按如下方式使用关键路径：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = [<span class="string">"a"</span>: <span class="literal">true</span>, <span class="string">"b"</span>: <span class="literal">true</span>, <span class="string">"c"</span>: <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filtered = dict.<span class="built_in">filter</span>(!\.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filtered2 = dict.<span class="built_in">filter</span>(\.value == <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十三期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;渺小不可怕，可怕的是比你优秀的强者还比你更加努力。&lt;strong&gt;Swift社区&lt;/strong&gt;不会辜负每一位努力的勇士，优秀终将与你不期而遇！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：因iPhone销量下降 苹果利润2016年以来首次低于预期&lt;/p&gt;
&lt;p&gt;提案：新年开始多个提案状态发生变化&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论如何设置需要异步初始化的静态变量&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十一期/</id>
    <published>2023-07-04T07:19:17.000Z</published>
    <updated>2023-07-04T07:24:11.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十二期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>烟花，如此短暂，却如此的奔放热烈。<strong>Swift社区</strong>，积聚无数力量，却只为给你展现一刹那辉煌！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果市值两年来首次跌破2万亿美元</p><p>提案：弃用 <code>@UIApplicationMain</code> 和 <code>@NSApplicationMain</code></p><p>Swift 论坛：改变一个属性包装器</p><p>推荐博文：iOS 应用卡顿监控与治理</p><p><strong>话题讨论：</strong> </p><p>您觉得烟花应该被禁止吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果市值两年来首次跌破2万亿美元"><a href="#苹果市值两年来首次跌破2万亿美元" class="headerlink" title="苹果市值两年来首次跌破2万亿美元"></a>苹果市值两年来首次跌破2万亿美元</h3><p>鞭牛士 1 月 4 日消息，据报道，当地时间 1 月 3 日，苹果（AAPL）收报 125.07 美元，跌幅 3.74% ，市值 1.99 万亿美元。市值一夜蒸发 773 亿美元（约 5345 亿元人民币）。</p><p><img src="https://files.mdnice.com/user/17787/2f40682e-f405-4394-9578-ce298cae2821.png" alt=""></p><p>Tech 星球 1 月 4 日消息，据凤凰网科技，在遭遇了去年的大幅下跌后，苹果公司市值本周二继续大幅缩水，自 2021 年 3 月以来首次跌破 2 万亿美元，面临被微软公司超越的风险。而就在一年前，苹果曾成为首家市值触及 3 万亿美元的公司。</p><p>截至周二收盘，苹果股价下跌 3.7% ，至 125.07 美元。此前，法国巴黎银行分析师杰罗姆·拉梅尔(Jerome Ramel)将苹果股票评级从“跑赢大盘”下调至“中性”，并将其目标价从 180 美元下调至 140 美元。拉梅尔还将 iPhone 2023 财年的出货量预期从 2.45 亿部下调至 2.24 亿部，以反映代工商富士康的供应链问题以及消费者削减在高端手机上的支出。</p><p>与此同时，投资者还担心，全球经济放缓和高通胀可能会损害消费者对苹果设备的需求。日本媒体报道称，苹果已经要求供应商减少为其耳机、手表和笔记本电脑生产零部件。</p><p>在经历了周二的下跌后，苹果目前的市值为 1.99 万亿美元，稍稍领先微软，后者的市值约为 1.8 万亿美元。苹果、微软、亚马逊、谷歌母公司 Alphabet 、脸书母公司 Meta 目前在标普 500 指数中的市值占比约为 18% ， 低于 2020 年一度达到的 24% 。</p><h3 id="TrendForce-集邦咨询：疫情影响，2022-年-iPhone-14-系列出货量滑至-7-810-万支"><a href="#TrendForce-集邦咨询：疫情影响，2022-年-iPhone-14-系列出货量滑至-7-810-万支" class="headerlink" title="TrendForce 集邦咨询：疫情影响，2022 年 iPhone 14 系列出货量滑至 7,810 万支"></a>TrendForce 集邦咨询：疫情影响，2022 年 iPhone 14 系列出货量滑至 7,810 万支</h3><p>富士康（Foxconn）郑州厂自 10 月起至今持续受疫情影响，稼动率仍难突破七成，而 10 月底正值苹果（Apple）新机销售的冲刺期，其中 Pro 系列因受市场青睐而持续调升生产比重，使得作为 Apple Pro 系列主力组装厂的富士康备感压力，即便有富士康深圳厂支持生产，但仍缓不济急，故 TrendForce 集邦咨询下调 2022 年 iPhone 14 系列出货量至 7,810 万支。</p><h3 id="富士康独供地位不再，立讯确定将加入-iPhone-15-Pro-Max-生产行列"><a href="#富士康独供地位不再，立讯确定将加入-iPhone-15-Pro-Max-生产行列" class="headerlink" title="富士康独供地位不再，立讯确定将加入 iPhone 15 Pro Max 生产行列"></a>富士康独供地位不再，立讯确定将加入 iPhone 15 Pro Max 生产行列</h3><p>富士康长年稳站 Pro 系列的独家组装，但苹果基于风险控管，原本即有意找寻其他业者加入生产组装行列，并且在 iPhone 14 Pro 系列上试行，富士康由于疫情影响稼动率，这也让立讯精密（Luxshare）成为 iPhone 15 Pro Max 组装供应链行列之一，目前其 iPhone 代工厂仍坐落中国，越南厂则是以苹果周边为主，目前尚无 iPhone 产线规划。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0383-deprecate-uiapplicationmain-and-nsapplicationmain.md" title="SE-0383" target="_blank" rel="noopener">SE-0383</a> <strong>弃用 @UIApplicationMain 和 @NSApplicationMain</strong> 提案正在审查。</p><p><code>@UIApplicationMain</code> 和 <code>@NSApplicationMain</code> 曾经是 iOS 和 macOS 应用程序分别为应用程序声明合成平台特定入口点的标准方式。 这些函数已经被 SE-0281 引入的 <code>@main</code> 属性淘汰了。 这个提议试图在 Swift 6 之前弃用这些可选的入口点属性，从而支持 @main。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0384-importing-forward-declared-objc-interfaces-and-protocols.md" title="SE-0384" target="_blank" rel="noopener">SE-0384</a> <strong>导入已声明的 Objective-C 接口和协议</strong> 提案正在审查。</p><p>该提案主要目的是通过减少对已声明的 Swift API 可见性的负面影响，来提高 Swift 中现有 Objective-C 库的可用性。希望可以用合成占位符类型来表示 Swift 中已声明的 Objective-C 接口和协议。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论 <a href="https://forums.swift.org/t/se-0384-importing-forward-declared-objective-c-interfaces-and-protocols/62392" title="SE-0384：导入前向声明的 Objective-C 接口和协议" target="_blank" rel="noopener">SE-0384：导入前向声明的 Objective-C 接口和协议</a></p><p>2) 讨论 <a href="https://forums.swift.org/t/design-priorities-for-the-swift-6-language-mode/62408" title="Swift 6 语言模式的设计优先级" target="_blank" rel="noopener">Swift 6 语言模式的设计优先级</a></p><p>Swift 6 重点领域</p><p>Swift 语言工作组确定了三个重点领域，Swift 的系统改进将取决于源代码不兼容的更改。 涉及 Swift 6 源代码不兼容更改的提案应解决以下多个领域之一：</p><p>默认情况下的数据竞争安全性：默认情况下的数据竞争安全性是对只能在新语言版本中上演的模型的重大转变，但它有很大的回报，因为它使并发程序更容易正确编写。 Swift 6 将需要加强围绕 Sendable 和 actor-isolation 检查的语义，但可能还需要额外的更改或功能来使在该安全模型中工作更容易。</p><p>性能可预测性：Swift 提供了一种富有表现力的相当高级的编程模型，可以抽象掉不必要的细节。 然而，Swift 开发可能会遇到性能“悬崖”，其中一个小的变化可能会导致程序运行时性能意外下降（例如，由于写时复制数据类型的过度复制）或 Swift 工具的性能（ 例如，“表达式太复杂”错误）。Swift 6 可以考虑更改默认语言语义以提高性能可预测性，例如通过调整有关变量生命周期的规则，使某些带有运行时成本的功能选择加入而不是选择退出，或调整类型推断规则以启用 一个性能更好的类型检查器实现。</p><p>包生态系统的可扩展性：Swift 语言和社区的长期健康取决于拥有一个强大的包生态系统。 Swift 语言和包管理器可能需要进行调整，以便更轻松地扩展包生态系统。 例如，Swift 的模块系统可能会得到改进，以限制模块的实现依赖性对其客户端模块的影响，从而使模块和包更能适应变化。</p><p>3) 讨论 <a href="https://forums.swift.org/t/vapor-how-to-get-response-url-using-async-http-vapor-client/62418" title="Vapor：如何使用 async-http / Vapor 客户端获取响应 URL" target="_blank" rel="noopener">Vapor：如何使用 async-http / Vapor 客户端获取响应 URL</a></p><p>4) 讨论 <a href="https://forums.swift.org/t/how-can-i-use-return-values-from-functions-instead-of-using-binding-to-pass-data-between-views/62413" title="如何使用函数的返回值而不是使用@Binding 在视图之间传递数据？" target="_blank" rel="noopener">如何使用函数的返回值而不是使用@Binding 在视图之间传递数据？</a></p><p>5) 提议 <a href="https://forums.swift.org/t/implicit-guarding-self-in-closures/62386" title="在闭包中隐式使用guard self" target="_blank" rel="noopener">在闭包中隐式使用guard self</a></p><p>受 SE-0365 的启发：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [guarded <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    dismiss()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里 guard self 以确保 self（否则返回），这通常在这种情况下使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    dismiss()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6) 讨论 <a href="https://forums.swift.org/t/mutating-a-property-wrapper/62403" title="改变一个属性包装器" target="_blank" rel="noopener">改变一个属性包装器</a></p><p>Property wrapper 一个栗子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">PropertyWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">        _modify &#123; yield &amp;<span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; box.value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; box.value = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> box: <span class="type">Box</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(wrappedValue: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.box = <span class="type">Box</span>(value: wrappedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">needsCopyOnWrite</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        !isKnownUniquelyReferenced(&amp;box)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(value: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span> </span>&#123;</span><br><span class="line">    @<span class="type">PropertyWrapper</span></span><br><span class="line">    <span class="keyword">var</span> property: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> propertyWrapper: <span class="type">PropertyWrapper</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; _property.projectedValue &#125;</span><br><span class="line">        _modify &#123; yield &amp;_property.projectedValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Struct</span>(property: <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.$property.needsCopyOnWrite()) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(s.propertyWrapper.needsCopyOnWrite()) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>7) 讨论 <a href="https://forums.swift.org/t/caveats-of-keeping-task-instance-beyond-its-bodys-execution/62400" title="保持任务实例超出其主体执行的警告？" target="_blank" rel="noopener">保持任务实例超出其主体执行的警告？</a></p><p>8) 讨论 <a href="https://forums.swift.org/t/returned-for-revision-se-0379-opt-in-reflection-metadata/62390" title="SE-0379: Opt-in Reflection Metadata" target="_blank" rel="noopener">SE-0379: Opt-in Reflection Metadata</a></p><p>更改反射生成的默认行为:</p><p>该提案规定，在 Swift 6 语言模式下，反射的默认行为应该成为选择加入。 社区对提案的这一方面反应不一，许多开发人员担心这会对现有代码中普遍使用打印、镜像和其他基于反射的 API 产生影响。 关于支持“按使用量付费”模型和提供丰富的运行时设施之间的紧张关系，有很好的哲学讨论。 该提案建议通过使依赖反射的 API 在其参数中添加 Reflectable 约束来解决这种紧张关系。 然而，对于许多 API 来说，这是一个问题，特别是标准库设施，如打印和相关的字符串化功能，旨在尽最大努力处理任何值。 要求通过潜在的许多 API 层线程化通用约束只是为了添加一些日志记录或 printf 调试将是一个严重的强加。 但是，消除对这些约束的需求会使编译器没有面包屑来帮助开发人员制作所有需要的类型 Reflectable 或 Custom * StringConvertible；开发人员必须通过大量专门测试来发现和修复运行时影响。</p><p>Language Workgroup 还注意到 Swift 项目先前尝试追溯更改运行时行为，特别是 SE-0083，它通过从运行时中删除 Foundation 类型桥接来简化动态转换行为。 当时的核心团队最终拒绝了该提议，因为考虑到该提议的动态性质，他们无法想出一种方法来评估对 Swift 生态系统的影响，并有足够的把握认为该变化不会造成过度破坏。 语言工作组对更改默认反射行为也有类似的担忧； 即使默认更改受语言版本限制，我们希望开发人员采用 Swift 6 以获得静态并发安全和其他更改的好处，并期望他们也审计项目的动态行为以防止意外的反射依赖项将是一个障碍 更新他们的语言版本模式。 如果没有评估更改默认设置对现实世界影响的计划，我们就不会接受这种更改。</p><p>Reflectable 的本质和动态投射支持:</p><p>提案规定 Reflectable 和 Sendable 一样是一个标记协议； 然而，与真正的标记协议不同，约束的存在对运行程序可用的元数据类型具有真正的运行时影响。 此外，与遵循协议不同，反射元数据不能通过其定义模块之外的扩展追溯添加到类型中。 因此，尽管将其作为通用约束是一种很好的语言设计，但将其称为标记协议或协议似乎不太正确。</p><p>该提案还规定，程序员可以通过动态转换查询一个类型是否携带全反射元数据？ 可反射。 如果 Reflectable 是一个标记协议，那么它如何在完全通用的情况下工作还不清楚，因为尽管我们可能静态地将表达式 x 识别为？ 可反射的，不可能将 x 处理为？ T 表示在运行时绑定到 Reflectable 存在类型的泛型类型参数 T。 但是，语言工作组还认为，在新的 Reflection 库中将此功能表达为独立的查询功能可能会更好，这样可以降低它必须与整个动态转换基础结构进行交互的复杂性。</p><p>现在的语言中存在一个非协议泛型约束——AnyObject 约束，只有类和没有见证表的类存在性才能满足。 编译器在内部将其归类为“布局约束”，因为它不需要明确的一致性，但其布局本质上满足约束要求的类型会隐式满足它。 目前还有一些其他布局约束只为优化器实现以允许部分专门化，但其中一些，特别是按位可复制类型的约束，在 C++ 行话中称为“平凡”或“POD”，也可以浮出水面 在语言中。 Reflectable 可能也适合这个系列，因为当编译器设置为发出所有反射元数据时，它不需要明确的“一致性”； 虽然它不是专门针对类型值的布局的约束，但它确实对该类型的元数据布局施加了约束。</p><p>调试器支持:</p><p>需要进一步考虑的实现的一个方面是它与调试器的交互。 LLDB 的 Swift 支持目前严重依赖全反射元数据来提供完整的功能，语言工作组希望看到一个计划来确保调试支持可用</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7176823567059779639" title="出行iOS用户端卡顿治理实践" target="_blank" rel="noopener">出行iOS用户端卡顿治理实践</a></p><p><strong>摘要：</strong> 这篇文章主要讲解该如何去做好卡顿治理。我们使用APP有时会遇到点击响应迟钝、页面跳转缓慢、滑动列表不流畅、卡死无响应，这些就是卡顿问题，它会影响用户体验，严重时会导致用户的流失，因此卡顿治理是非常重要的。</p><p><a href="https://juejin.cn/post/7176441132447399993" title="58同城iOS包大小治理工具解密" target="_blank" rel="noopener">58同城iOS包大小治理工具解密</a></p><p><strong>摘要：</strong> 本文通过58同城包大小治理的实践经验，来讲解如何解决混编环境下OC/Swift无用类、无用资源、重复资源等检测问题，同时结合业内常见的段迁移、链接时优化(LTO)等多种技术手段，来辅助App进行瘦身。</p><p><a href="https://juejin.cn/post/7181352292673650746" title="iOS卡顿监控探索与实践" target="_blank" rel="noopener">iOS卡顿监控探索与实践</a></p><p><strong>摘要：</strong> 这篇文章主要讲解如何监控卡顿，帮助开发者进一步解决卡顿问题。与用户交互的事件都是在主线程里处理的，但如果主线程无法响应用户的交互就会造成卡顿，卡顿时间比较长是非常影响App的功能和用户体验的，所以这也是一个非常值得重视的问题。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>您觉得烟花应该被禁止吗？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十二期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;烟花，如此短暂，却如此的奔放热烈。&lt;strong&gt;Swift社区&lt;/strong&gt;，积聚无数力量，却只为给你展现一刹那辉煌！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果市值两年来首次跌破2万亿美元&lt;/p&gt;
&lt;p&gt;提案：弃用 &lt;code&gt;@UIApplicationMain&lt;/code&gt; 和 &lt;code&gt;@NSApplicationMain&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swift 论坛：改变一个属性包装器&lt;/p&gt;
&lt;p&gt;推荐博文：iOS 应用卡顿监控与治理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;您觉得烟花应该被禁止吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十期/</id>
    <published>2023-07-04T07:18:55.000Z</published>
    <updated>2023-07-04T07:23:12.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十一期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：部分 iPhone 14 Pro / Max 被爆开机闪现水平线</p><p>提案：<code>DiscardingTaskGroups</code> 提案正在审查</p><p>Swift 论坛：讨论修改 SE-0368 以删除前缀 <code>+</code> 运算符</p><p>推荐博文：SwiftUI 的优势、劣势和缺陷</p><p><strong>话题讨论：</strong> </p><p>疫情放开，你处于什么阶段</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="部分-iPhone-14-Pro-Max-被爆开机闪现水平线"><a href="#部分-iPhone-14-Pro-Max-被爆开机闪现水平线" class="headerlink" title="部分 iPhone 14 Pro / Max 被爆开机闪现水平线"></a>部分 iPhone 14 Pro / Max 被爆开机闪现水平线</h3><p>一些 iPhone 14 Pro 和 iPhone 14 Pro Max 用户报告说，当设备被打开时，iPhone 显示屏上闪烁着水平线，但没有明确的原因或如何修复它。</p><p>在 Reddit 的主题帖子中，数十名 iPhone 14 Pro 用户报告说，当设备被打开时，一条或多条绿色和黄色的线条可能会在屏幕上闪烁，几秒钟后消失。根据这些用户的说法，苹果支持部门已经通知他们，该问题不是硬件缺陷造成的，而是 iOS 16 的错误 Bug。</p><p><img src="https://files.mdnice.com/user/17787/ce2b2a90-fc9c-4b44-8a32-13231e4e9198.png" alt=""></p><h3 id="iOS-16-2-不能升级-Home-应用架构"><a href="#iOS-16-2-不能升级-Home-应用架构" class="headerlink" title="iOS 16.2 不能升级 Home 应用架构"></a>iOS 16.2 不能升级 Home 应用架构</h3><p>苹果已取消 iOS 16.2 升级到新 Home 家庭架构的选项，iOS 16.2 和 macOS Ventura 13.1 的主要新功能之一是能够升级到新的 Home 家庭应用架构。虽然苹果没有分享具体的变化细节，但表示，该升级为 HomeKit 配件提供了“更好的性能和可靠性”。</p><p><img src="https://files.mdnice.com/user/17787/b9c275dc-da92-405e-b108-cdd13178785e.png" alt=""></p><h3 id="AppleWatch-或可无创测血压"><a href="#AppleWatch-或可无创测血压" class="headerlink" title="AppleWatch 或可无创测血压"></a>AppleWatch 或可无创测血压</h3><p>Apple Watch 无创测血压功能即将到来，苹果正积极积累相关技术。IT 之家 12 月 23 日消息，知情人士在今年 4 月透露，苹果计划在 Apple Watch 中添加血压监测功能，但由于遇到障碍，该项技术预计最早要到 2024 年才能推出。苹果目前也在积极地积累技术支持，美国商标和专利局（USPTO）公示了一项新的苹果专利（专利号 US 20220400959），涉及获取和分析无创血压测量数据的系统和方法。</p><p><img src="https://files.mdnice.com/user/17787/3edae191-378a-48a6-9031-ff6b8ad169d7.png" alt=""></p><h3 id="iPhone15-系列将继续采用高通5G基带芯片"><a href="#iPhone15-系列将继续采用高通5G基带芯片" class="headerlink" title="iPhone15 系列将继续采用高通5G基带芯片"></a>iPhone15 系列将继续采用高通5G基带芯片</h3><p>苹果 iPhone 15 系列将采用高通骁龙 X70 5G 基带芯，根据 DigiTimes 报道，苹果 iPhone 15 系列将继续采用高通 5G 调制解调器（基带芯片），因为苹果公司仍在继续开发自有的 5G 定制芯片。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0381-task-group-discard-results.md" title="SE-0381" target="_blank" rel="noopener">SE-0381</a> <strong>DiscardingTaskGroups</strong> 提案正在审查。</p><p>该提案建议为 <code>TaskGroup</code> 和 <code>ThrowingTaskGroup</code> 引入一个新的布尔参数 <code>discardResults</code>。此参数将控制 <code>TaskGroup</code> 是保留其已完成子任务的结果，然后确定是传递给 <code>next()</code>，还是立即丢弃。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案正在审查。</p><p><code>Expression Macros</code> 提供了一种用新型表达式扩展 Swift 的方法，这些表达式可以对其参数执行任意语法转换以生成新代码。 <code>Expression Macros</code> 使得用以前只有引入新的语言特性才能实现的方式扩展 Swift 成为可能，帮助开发人员构建更具表现力的库并消除无关的样板。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) Swift to C++ <a href="https://forums.swift.org/t/swift-to-c-incorporating-swift-argument-labels-into-generated-c-function-name/62195" title="将 Swift 参数标签合并到生成的 C++ 函数名中" target="_blank" rel="noopener">将 Swift 参数标签合并到生成的 C++ 函数名中</a></p><p>2) 讨论<a href="https://forums.swift.org/t/how-to-test-long-running-effect-that-sends-actions/62201" title="如何测试发送动作的长时间运行效果？" target="_blank" rel="noopener">如何测试发送动作的长时间运行效果？</a></p><p>3) 议案 <a href="https://forums.swift.org/t/pitch-result-builder-scoped-unqualified-lookup/62190" title="[Pitch] 结果构建器范围内的不合格查找" target="_blank" rel="noopener">[Pitch] 结果构建器范围内的不合格查找</a></p><p><strong>介绍:</strong></p><p>结果构建器为定义声明式 DSL 提供了基础——特定领域的语言提供了在特定领域工作的定制语法，例如生成图表或文本处理。 利用结果构建器的复杂 DSL API 遇到了设计可扩展性和类型检查性能方面的问题，引入了需要解决的关键挑战。 </p><p>扩展结果构建器以支持在其主体内进行范围内的非限定名称查找，即特定于构建器类型的范围内名称间距，将启用新的 API 模式，显着降低类型检查的复杂性，同时改善调用站点的美感。</p><p>4) 议案<a href="https://forums.swift.org/t/pitch-amend-se-0368-to-remove-prefix-operator/62173" title="修改 SE-0368 以删除前缀 + 运算符" target="_blank" rel="noopener">修改 SE-0368 以删除前缀 + 运算符</a></p><p>内容:<a href="https://forums.swift.org/t/se-0368-staticbigint/59421" title="SE-0368" target="_blank" rel="noopener">SE-0368</a>包括对 <code>StaticBigInt</code> 的以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns the given value unchanged.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="number">_</span> rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br></pre></td></tr></table></figure><p>这被包括在内，以便前缀 + 可以作为文字前缀包含在上下文中，在这些上下文中，值需要是 <code>StaticBigInt</code> 类型，而不是另一种类型的文字，以便与 - 对称：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signs: [<span class="type">StaticBigInt</span>] = [-<span class="number">1</span>, <span class="number">0</span>, +<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>事实证明，这是一个源代码的突破性变化，因为有如下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Int</span> = <span class="number">7</span></span><br><span class="line"><span class="keyword">let</span> b = +<span class="number">1</span>     <span class="comment">// Inferred as `StaticBigInt` because concrete `+` beats</span></span><br><span class="line">               <span class="comment">// the generic one on `AdditiveArithmetic`</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a + b  <span class="comment">// Error: Cannot convert `b` from `StaticBigInt` to `Int`</span></span><br></pre></td></tr></table></figure><p>之前，<code>b</code> 被赋予了 <code>Int</code> 类型，这个例子编译正确。建议修改 <code>SE-0368</code> 以删除此运算符。 这对于想要使用 <code>StaticBigInt</code> 值的代码来说是一个小小的不便，但是不存在这样的代码，因为 5.7 中不存在该类型。</p><p>这样的代码可以省略前导 + 作为解决方法。</p><p>一旦解决了源中断问题，我们就可以调查其他选项以在空闲时恢复所需的语法。</p><p>5) 讨论 <a href="https://forums.swift.org/t/no-such-file-errors-with-argumentparser-package/62183" title="ArgumentParser 包出现 no such file 错误" target="_blank" rel="noopener">ArgumentParser 包出现 no such file 错误</a></p><p>6) 讨论<a href="https://forums.swift.org/t/how-can-i-print-https-url-params-and-body/62153" title="如何打印 HTTPS URL 参数和正文" target="_blank" rel="noopener">如何打印 HTTPS URL 参数和正文</a></p><p>7) 提议 <a href="https://forums.swift.org/t/pitch-better-result-success-failure-guard-evaluation/62158" title="&lt;Success, Failure&gt; Guard Evaluation 会更好" target="_blank" rel="noopener"><success, failure=""> Guard Evaluation 会更好</success,></a></p><p>内容:</p><p>在 <code>SE-0235</code> 中将结果类型引入标准语言是我在构建库时最喜欢的功能之一。 当返回的 Result 用户想要评估时，通常看起来有点像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result:  <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getResult()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">  <span class="comment">// Do something with the data here</span></span><br><span class="line"><span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">  <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这对大多数情况都很好。 然而，如果我们需要级联多个结果，它会变得有点难看。</p><p><strong>例如：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstResult:  <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getFirstResult()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> firstResult &#123;</span><br><span class="line"><span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">  <span class="keyword">let</span> secondResult: <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getSecondResult(using: data)</span><br><span class="line">  <span class="keyword">switch</span> secondResult &#123;</span><br><span class="line">  <span class="keyword">case</span> .success(<span class="keyword">let</span> secondData):</span><br><span class="line">    <span class="comment">// Do something with secondData</span></span><br><span class="line">  <span class="keyword">case</span> .failure(<span class="keyword">let</span> secondError):</span><br><span class="line">    <span class="comment">// Handle secondError</span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">case</span> .failure(<span class="keyword">let</span> firstError):</span><br><span class="line">  <span class="comment">// Handle firstError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，嵌套切换变得有点沉重。 这常常让我想起嵌套的 if 语句，作为一个“从不嵌套”的人，我通常会在这里求助于 <code>guard</code> 关键字。 我认为 guard 关键字对于评估 Result 类型也非常有用，但是因为它现在有效，但 gaurd 关键字对于 Result type 用起来有问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstResult:  <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getFirstResult()</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">case</span> .success(<span class="keyword">let</span> data) = firstResult <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Handle first error - But no reference to firstError! </span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> secondResult: <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getSecondResult(using: data)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">case</span> .success(<span class="keyword">let</span> secondData) = secondResult <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Handle second error - But no reference to secondError! </span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如评论所暗示的那样，我没有引用 <code>guard</code> 语句的 <code>else</code> 部分中的错误类型。 据我所知，没有办法使用这种语法并访问返回的错误类型。</p><p>也许有一些方法可以通过扩展 <code>guard</code> 语句或更新 <code>Result</code> 类型来实现此功能？</p><p>所以这就是为什么我要提出这个建议。我不是确定能百分百修复。甚至不确定这是对语言的有用更改还是其他 Swift 用户想要的东西。让我们在这里讨论一下！</p><p>8) 讨论 <a href="https://forums.swift.org/t/are-we-allowed-to-overload-a-property-or-not/62167" title="Swift 是否允许重载属性" target="_blank" rel="noopener">Swift 是否允许重载属性</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7140825514108780580" title="2021 年的 SwiftUI: 优势、劣势和缺陷" target="_blank" rel="noopener">2021 年的 SwiftUI: 优势、劣势和缺陷</a></p><p><strong>摘要：</strong> 这篇文章主要目的是帮助你理解 SwiftUI 的利弊，这样你可以就 SwiftUI 是否适合下一个项目做出更明智的决定。</p><p><a href="https://juejin.cn/post/7175051294808211512" title="用 SwiftUI 实现 AI 聊天对话 app - iChatGPT" target="_blank" rel="noopener">用 SwiftUI 实现 AI 聊天对话 app - iChatGPT</a></p><p><strong>摘要：</strong> 关于 ChatGPT 的话题，大家都不陌生，我们直入话题，因为 ChatGPT 目前限制中国访问服务，所以如果直接使用 ChatGPT 网页进行对话，还是不太方便。通过 ChatGPT SessionToken 就可以不限制网络访问，所以大家发挥想象力实现各种的聊天机器人、小程序，而原生 app 可能体验更好</p><p><a href="https://mp.weixin.qq.com/s/fgHkd_EFPkNwG3G3KPq92w" target="_blank" rel="noopener">SwiftUI 布局协议 - Part 2</a></p><p><strong>摘要：</strong> 在 Part 1 我们探索了布局协议的基础知识，为理解布局是如何工作的打下了坚实的基础。现在，是时候深入研究那些更少提及的功能了，以及如何使用它们来为我们带来便利。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>疫情放开，你处于什么阶段</strong></p><p>123</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的各种交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a> 文章中外引链接较多，可以点击 <strong>阅读原文</strong> 更加方便阅读。</p><h2 id="关于我们-1"><a href="#关于我们-1" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十一期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：部分 iPhone 14 Pro / Max 被爆开机闪现水平线&lt;/p&gt;
&lt;p&gt;提案：&lt;code&gt;DiscardingTaskGroups&lt;/code&gt; 提案正在审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论修改 SE-0368 以删除前缀 &lt;code&gt;+&lt;/code&gt; 运算符&lt;/p&gt;
&lt;p&gt;推荐博文：SwiftUI 的优势、劣势和缺陷&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;疫情放开，你处于什么阶段&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十九期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十九期/</id>
    <published>2023-07-04T07:18:19.000Z</published>
    <updated>2023-07-04T07:23:26.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>十期磨一剑，废铁亦有形，<strong>Swift社区</strong>就是你梦想已久的香格里拉，哪怕青冥长天，纵然绿水波澜！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果汽车计划 2026 年推出，大降级！苹果汽车售价或低于 10 万美元，不支持完全自动驾驶</p><p>提案：Swift 选择加入 <code>Reflection</code> 元数据</p><p>Swift 论坛：使用较新的 macOS 版本生成 <code>Package.swift</code> 文件</p><p>推荐博文：用 ChatGPT 写 SwiftUI</p><p><strong>话题讨论：</strong> </p><p>你如何看待各地疫情管控放开</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="12-月-12-日，参与新一周的-Ask-Apple-活动"><a href="#12-月-12-日，参与新一周的-Ask-Apple-活动" class="headerlink" title="12 月 12 日，参与新一周的 Ask Apple 活动"></a>12 月 12 日，参与新一周的 Ask Apple 活动</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/019C1E1E-C787-48F6-A858-12BFD1B7C326/2048.jpeg" alt=""></p><p>欢迎继续参与新一周激动人心的 Ask Apple，与 Apple 专家直接交流沟通，获取关于最新技术和设计问题的解答；或者只是随意听听，从对话中学习。针对如何使用最新的框架、改善 App 的 UI 设计、使用 Beta 版 OS 软件和工具进行开发等主题大胆提问。</p><p>活动将于 12 月 12 日至 16 日举行，届时将提供多种语言和多个时区的在线一对一咨询和小组 Q&amp;A。现已面向 Apple Developer Program 和 Apple Developer Enterprise Program 的当前成员开放注册。</p><h3 id="苹果汽车计划-2026-年推出，大降级！苹果汽车售价或低于-10-万美元，不支持完全自动驾驶"><a href="#苹果汽车计划-2026-年推出，大降级！苹果汽车售价或低于-10-万美元，不支持完全自动驾驶" class="headerlink" title="苹果汽车计划 2026 年推出，大降级！苹果汽车售价或低于 10 万美元，不支持完全自动驾驶"></a>苹果汽车计划 2026 年推出，大降级！苹果汽车售价或低于 10 万美元，不支持完全自动驾驶</h3><p>12 月 6 日，苹果宣布推出 Apple Music Sing 功能，该功能可以让用户通过可调节的人声和实时歌词演唱自己喜欢的歌曲。此外据彭博社报道，苹果已经缩减了其汽车项目，计划在 2026 年之前推出定价在 10 万美元以下的汽车。苹果不再计划发布完全自动驾驶的汽车，其原来想制造一辆没有方向盘和油门的自动驾驶汽车，现在已经放弃。</p><h3 id="Apple-宣布-App-Store-定价机制最重大升级，新增-700-个价格点"><a href="#Apple-宣布-App-Store-定价机制最重大升级，新增-700-个价格点" class="headerlink" title="Apple 宣布 App Store 定价机制最重大升级，新增 700 个价格点"></a>Apple 宣布 App Store 定价机制最重大升级，新增 700 个价格点</h3><p>Apple 今日宣布对 App Store 进行问世至今最全面的定价机制升级，为开发者提供新增的 700 个价格点和全新定价工具，让开发者更轻松地针对不同国家和地区的 App Store 设定价格、管理外币汇率变化等。</p><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/E73B40B4-60FF-476B-9B85-D4A051078351/2048.jpeg" alt=""></p><h3 id="假日将至，请为您的-App-做好准备"><a href="#假日将至，请为您的-App-做好准备" class="headerlink" title="假日将至，请为您的 App 做好准备"></a>假日将至，请为您的 App 做好准备</h3><p>App Store 最繁忙的季节即将到来！确保及时更新您的 App 和产品页面，并在岁末假日到来之前做好准备。很高兴今年的整个假日季期间同样会开放 App 提交，我们非常期待看到您提交的 App。平均而言，90% 的提交内容会在 24 小时内得到审核。但请注意，在 12 月 23 日至 27 日，完成审核所需的时间可能略长一些。外国的圣诞节就相当于中国的春节，所以 12 月 23 日至 27 日就相当于中国的春节放假哟。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0379-opt-in-reflection-metadata.md" title="SE-0379" target="_blank" rel="noopener">SE-0379</a> <strong>Swift 选择加入 Reflection 元数据</strong> 提案正在审查。</p><p>该提案旨在通过改进现有机制，并提供机会在使用 Swift Reflection 元数据的 API 中表达对反射元数据的要求，从而提高 Swift Reflection 元数据的安全性、效率和保密性。</p><p><strong>Swift-evolution 线程</strong>：<a href="https://forums.swift.org/t/pitch-3-opt-in-reflection-metadata/58852" title="该提案的讨论主题" target="_blank" rel="noopener">该提案的讨论主题</a>。感兴趣的小伙伴可以参与讨论交流。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0380-if-switch-expressions.md" title="SE-0380" target="_blank" rel="noopener">SE-0380</a> <strong>if 和 switch 表达式</strong> 提案正在审查。</p><p>本提案介绍了使用 <code>if</code> 和 <code>switch</code> 语句作为表达式的功能，主要内容包含：</p><ul><li>函数、属性和闭包的返回值</li><li>为变量赋值</li><li>声明变量</li></ul><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1)讨论 <a href="https://forums.swift.org/t/dangerous-default-implementation-of-under-comparable/61928" title="Comparable 下 == 的危险默认实现" target="_blank" rel="noopener">Comparable 下 == 的危险默认实现</a></p><p>2)提议<a href="https://forums.swift.org/t/mach-port-api/61930" title="Mach Port API" target="_blank" rel="noopener">Mach Port API</a></p><p><strong>简介:</strong> Mach Port API 是一种难以安全使用的神秘技术。<br>但是，作为我们操作系统的一个组成部分，它们有时需要处理。</p><p>该提案广泛使用了mach port术语。<br>如果您想复习基础知识，<a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html#//apple_ref/doc/uid/TP30000905-CH209-TPXREF104" target="_blank" rel="noopener">请查看端口、端口权限、端口集和端口命名空间</a>。</p><p><strong>动机:</strong> Mach ports 很难正确设置，主要是由于管理 mach port 权限的方式。 程序员需要在头脑中跟踪类型、生命周期和其他状态。</p><p>Swift 的高级类型系统，最近增加了 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md" target="_blank" rel="noopener">move-only types</a>，提供了一个新的机会来创建一个能够在编译时防止整个类错误的 Mach port 接口。</p><p><strong>建议的解决方案:</strong><br>建立不同的类型来表示接收、发送和发送一次的权利。<br>提供 Mach port权限的自动生命周期管理，这与普通的 OOP 对象不同。</p><p>3)议案 <a href="https://forums.swift.org/t/pitch-noncopyable-or-move-only-structs-and-enums/61903" title="Noncopyable (或者 “move-only”) 结构和枚举" target="_blank" rel="noopener">Noncopyable (或者 “move-only”) 结构和枚举</a></p><p>4)议案 <a href="https://forums.swift.org/t/pitch-globalconstructor/61901" title="@globalConstructor" target="_blank" rel="noopener">@globalConstructor</a></p><p><strong>简介:</strong> <code>@globalConstructor</code> 属性提供了一种在启动可执行文件或加载动态库时自动调用函数的方法。</p><p><strong>动机:</strong> 在许多用例中，您可能想要执行代码而不必直接调用它。</p><p><strong>例如：</strong><br>在您希望将库插入应用程序的位置进行调试，而无需手动调用库重建应用程序<br>包含可选库的插件系统将自己注册到主应用程序以更改行为<br>希望在启动时进行 1 次设置而不要求开发人员显式调用其配置的第三方库作者<br>如今，在这些情况下，开发人员不得不回退到 Objective-C/C++/C（使用 <strong>attribute</strong>((constructor)))，即使他们只需要调用一个 Swift 函数。</p><p><strong>建议的解决方案:</strong></p><p>添加一个新的 <code>@globalConstructor</code> 属性，该属性可以添加到顶级函数，以便在启动可执行文件或加载包含该函数的动态库时自动调用它们。</p><p>5)讨论<a href="https://forums.swift.org/t/se-0380-if-and-switch-expressions/61899" title="SE-0380：if 和 switch 表达式" target="_blank" rel="noopener">SE-0380：if 和 switch 表达式</a></p><p>6)议案<a href="https://forums.swift.org/t/pitch-generate-package-swift-files-with-newer-macos-versions/61925" title="使用较新的 macOS 版本生成 Package.swift 文件" target="_blank" rel="noopener">使用较新的 macOS 版本生成 Package.swift 文件</a></p><p><strong>简介:</strong> 目前，没有明确定义支持的最低平台版本的 Swift Package Manager 包会自动默认为第一个支持的版本，对于许多平台来说，这是 2017 年的版本。这在某些情况下会增加新生成的包的摩擦。</p><p><strong>动机:</strong> 当前，在 macOS 上构建全新的 Swift Package Manager 包时，构建目标是 2017 年的 macOS 10.13。当他们添加诸如 swift-syntax 之类的具有更高最低支持版本的依赖项时，这可能是一种令人沮丧的新用户体验，导致他们必须立即弄清楚如何配置此选项。</p><p><strong>建议的解决方案:</strong></p><p>我建议我们自动将 macOS 上生成的新包的最低支持版本添加到用户当前的 macOS 版本中。 例如，不是生成这个 Package.swift 内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"name"</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>目前在 macOS 上我们将生成以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"name"</span>,</span><br><span class="line">    platforms: [.macOS(<span class="string">"13.0"</span>)],</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>7)讨论 <a href="https://forums.swift.org/t/withunsafebytes-is-deprecated/61891" title="“withUnsafeBytes”已弃用" target="_blank" rel="noopener">“withUnsafeBytes”已弃用</a></p><p>8)讨论 <a href="https://forums.swift.org/t/is-auto-compilation-of-the-standard-library-on-linux-broken/61918" title="Linux 上标准库的自动编译是否损坏" target="_blank" rel="noopener">Linux 上标准库的自动编译是否损坏？</a></p><p>9)讨论 <a href="https://forums.swift.org/t/read-modify-yield-and-non-escaping-closures/61902" title="Read/modify, yield, 和 non-escaping closures" target="_blank" rel="noopener">Read/modify, yield, 和 non-escaping closures</a></p><p>10)议案 <a href="https://forums.swift.org/t/pitch-objective-c-implementations-in-swift/61907" title="Swift 中的 Objective-C 实现" target="_blank" rel="noopener">Swift 中的 Objective-C 实现</a><br>我们提出了 <code>@objc</code> 类的替代方案，其中 <code>Objective-C</code> 标头 <code>@interface</code> 声明由 Swift 扩展实现。 生成的类将在 Swift 中实现，但与 Objective-C 类没有区别，完全支持 ObjC 子类化和运行时技巧。<br>使用 <code>@objcImplementation</code>，您可以像编写 Objective-C 类一样手写头文件，但不是在 Objective-C 中实现方法和属性，而是在 Swift 中实现它们。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://zhuanlan.zhihu.com/p/589572374" title="ChatGPT 注册攻略" target="_blank" rel="noopener">ChatGPT 注册攻略</a></p><p><strong>摘要：</strong> Chat GPT 由人工智能公司 Open AI 于近日推出，其对自己的定义是（优化对话的语言模型）非常火爆，近期不断有研究者发布与 Chat GPT 对话的内容，但其不支持中国大陆用户的注册，把一众想尝试进去玩一玩的人拒之门外。这里为大家提供一种注册方式。核心内容在使用国外手机号获取验证码。</p><p><a href="https://www.createwithswift.com/prototyping-swiftui-interfaces-with-openais-chatgpt/" title="Prototyping SwiftUI interfaces with OpenAI&#39;s ChatGPT" target="_blank" rel="noopener">使用 OpenAI 的 ChatGPT 写 SwiftUI 代码</a></p><p><strong>摘要：</strong> 上面介绍了如何注册 ChatGPT，本篇文章介绍如何使用 ChatGPT 写 SwiftUI 代码。你觉得 ChatGPT 以后能代替基础人工吗？</p><p><a href="https://mp.weixin.qq.com/s/SfqdGs8TbEjxISgrsy_yIg" target="_blank" rel="noopener">SwiftUI 布局协议 - Part 1</a></p><p><strong>摘要：</strong> 今年 SwiftUI 新增最好的功能之一必须是布局协议。它不但让我们参与到布局过程中，而且也给了我们一个很好的机会去更好的理解布局在 SwiftUI 中的作用。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>你如何看待各地疫情管控放开</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;十期磨一剑，废铁亦有形，&lt;strong&gt;Swift社区&lt;/strong&gt;就是你梦想已久的香格里拉，哪怕青冥长天，纵然绿水波澜！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果汽车计划 2026 年推出，大降级！苹果汽车售价或低于 10 万美元，不支持完全自动驾驶&lt;/p&gt;
&lt;p&gt;提案：Swift 选择加入 &lt;code&gt;Reflection&lt;/code&gt; 元数据&lt;/p&gt;
&lt;p&gt;Swift 论坛：使用较新的 macOS 版本生成 &lt;code&gt;Package.swift&lt;/code&gt; 文件&lt;/p&gt;
&lt;p&gt;推荐博文：用 ChatGPT 写 SwiftUI&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你如何看待各地疫情管控放开&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十八期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十八期/</id>
    <published>2022-11-29T03:25:32.000Z</published>
    <updated>2022-11-29T03:26:37.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第九期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>蝴蝶的生命之所以如此短暂，因为它的翅膀太过精致了。Swift社区之所以浩瀚汹涌，因为它总想牵动起每一位读者的心！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果 70 亿收购曼联消息不实</p><p>提案：Package 注册表认证</p><p>Swift 论坛：讨论数组的悬空指针</p><p>推荐博文：灵动岛开发</p><p><strong>话题讨论：</strong> </p><p>世界杯你赚钱了吗？</p><p>你觉得国足几年内能进世界杯？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果-70-亿收购曼联消息不实"><a href="#苹果-70-亿收购曼联消息不实" class="headerlink" title="苹果 70 亿收购曼联消息不实"></a>苹果 70 亿收购曼联消息不实</h3><p>此前，有消息称苹果有意以 70 亿美元收购曼联。11 月 25 日消息，有多位知情人士表示，这条消息并不属实，苹果目前不准备收购英超俱乐部曼联。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/news/ce99a6dd230252a9a9df8a2a37678858.jpeg" alt="苹果公司"></p><p>据悉，苹果收购曼联这条消息出自英国小报《The Daily Star》，苹果公司计划斥资大约 70 亿美元用于收购曼联，但据外媒 MacRumors 直接联系多名知情人士，确认这则报道是错误的、不实的。虽然没有收购曼联的计划，但苹果一直在推动体育内容的发展。该公司与 MLB 合作，在 2022 年常规赛期间，每周在 Apple TV + 上播放“ Friday Night Baseball ”两场比赛，并且在未来10年内，它将成为 MLS 比赛的独家供应商。</p><p>虽然苹果不准备收购曼联，但确实在推进体育方面的内容。苹果与美国职业棒球大联盟（MLB）合作，2022 年每周通过 Apple TV+ 播放常规赛。该公司还将成为未来 10 年的美国职业足球大联盟（MLS）的独家提供商。另有消息称，苹果还可能从下个赛季开始购买美国职业橄榄球联盟（NFL）的流媒体转播权。</p><p>目前，世界杯正在进行中，有关足球的消息总能吸引外界，但苹果收购曼联这事确实让人摸不着头脑。</p><h3 id="供应链确认-iPhone15-全系-C-口"><a href="#供应链确认-iPhone15-全系-C-口" class="headerlink" title="供应链确认 iPhone15 全系 C 口"></a>供应链确认 iPhone15 全系 C 口</h3><p>供应链传出苹果下一代 iPhone 15 最新规格。业内人士预计，升级焦点将集中在 Pro 上，包括 3nm AP、8GB LPDDR5 DRAM 和虚拟侧键等。基本型号的配备规格则预计包括 4nm AP、开孔设计和 48MPx 主镜头。此外，iPhone 15 系列所有机型都将采用 USB Type-C 接口。（财联社）</p><p><img src="https://files.mdnice.com/user/17787/d0c12b07-ba20-4345-aa0a-64013bdb9fd4.gif" alt=""></p><h3 id="iPhone15-或告别纯直边！效果图出炉：神似-iPhone-5C"><a href="#iPhone15-或告别纯直边！效果图出炉：神似-iPhone-5C" class="headerlink" title="iPhone15 或告别纯直边！效果图出炉：神似 iPhone 5C"></a>iPhone15 或告别纯直边！效果图出炉：神似 iPhone 5C</h3><p>据 AppleInsider 报道，据博主 ShrimpApplePro 掌握的早期信息，iPhone15 将采用全新的边框设计，后边缘角将变圆，不再是直边框，材料也将会是钛金属。还有网友提前带来了效果图，来看看！</p><p><img src="https://files.mdnice.com/user/17787/cc52aa27-8c5c-4022-a7d1-534ba1095105.gif" alt=""></p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0378-package-registry-auth.md" title="SE-0378" target="_blank" rel="noopener">SE-0378</a> <strong>Package 注册表认证</strong> 提案正在审查。</p><p>Web 服务使用的常用身份验证方法包括基本身份验证、访问令牌和 OAuth。SwiftPM 目前只支持基本的身份验证，这限制了它与 Package 注册服务交互的能力。</p><p>Package 注册表需要对其部分或全部 API 进行身份验证，以便识别执行操作的用户并相应地授权请求。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/should-i-stick-with-codable-or-switch-back-to-nscoding/61604" title="是否应该用 Codable 还是用 NSCoding" target="_blank" rel="noopener">是否应该用 Codable 还是用 NSCoding</a></p><p>2) 讨论<a href="https://forums.swift.org/t/nskeyedarchiver-coredata-and-other-storage-solutions/61603" title="NSKeyedArchiver, CoreData 和其他的存储方案" target="_blank" rel="noopener">NSKeyedArchiver, CoreData 和其他的存储方案</a></p><p>3) 讨论<a href="https://forums.swift.org/t/dangling-pointer-from-array/61609" title="数组的悬空指针" target="_blank" rel="noopener">数组的悬空指针</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">let</span> ptrToArray = <span class="type">UnsafeBufferPointer</span>&lt;<span class="type">Int</span>&gt;(start: &amp;array, <span class="built_in">count</span>: array.<span class="built_in">count</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> ptrToArray &#123;</span><br><span class="line">        <span class="built_in">print</span>(number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">array.withUnsafeBufferPointer &#123; ptrToArray <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> ptrToArray &#123;</span><br><span class="line">        <span class="built_in">print</span>(number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/how-to-trigger-action-from-alert-callback-created-in-reducerprotocol/61598" title="如何从 ReducerProtocol 中创建的alert回调中触发操作" target="_blank" rel="noopener">如何从 ReducerProtocol 中创建的alert回调中触发操作</a></p><p>5) 讨论<a href="https://forums.swift.org/t/code-size-difference-with-keypath-vs-closure/61599" title="键路径与闭包的代码大小差异" target="_blank" rel="noopener">键路径与闭包的代码大小差异</a></p><p>6) 讨论<a href="https://forums.swift.org/t/migrating-an-objective-c-codebase-to-swift/61592" title="将 Objective-C 代码库迁移到 Swift" target="_blank" rel="noopener">将 Objective-C 代码库迁移到 Swift</a><br>Steve Barnegren 撰写的从 Objective-C 迁移到 Swift 30 的博客文章是一本不错的读物。</p><p>7) 讨论<a href="https://forums.swift.org/t/difference-between-rawrepresentable-string-and-losslessstringconvertible/61600" title="RawRepresentable&lt;String&gt; 和 LosslessStringConvertible 的区别" target="_blank" rel="noopener">RawRepresentable<string> 和  LosslessStringConvertible 的区别</string></a><br>LosslessStringConvertible 改进了 CustomStringConvertible，这会影响其他事情，例如对 String(describing:) 的调用。<br>从语义上讲，LosslessStringConvertible 意味着它可以表示为字符串（例如整数），而 RawRepresentable<string> 意味着它在底层是一个字符串（例如原始类型为 String 的枚举）。</string></p><p>8) 讨论<a href="https://forums.swift.org/t/i-cant-recreate-my-class-using-protocols-extension-stored-properties/61589" title="无法使用 protocol 重新创建的类 - 扩展存储属性" target="_blank" rel="noopener">无法使用 protocol 重新创建的类 - 扩展存储属性</a><br>简短的回答是“ protocol 不能定义存储的属性”。 协议一致性可以在定义类型的模块之外定义，这很自然地得出结论：这样的协议如何添加存储？<br>您能做的最好的事情就是让协议要求您的类型具有存储空间。 您的类型定义仍然必须实际定义该存储。</p><p>9) 讨论<a href="https://forums.swift.org/t/uuid-in-state-initializer/61593" title="状态初始化器中的 UUID" target="_blank" rel="noopener">状态初始化器中的 UUID</a></p><p>10) 讨论<a href="https://forums.swift.org/t/decimal-or-double-for-financial-calculations/61585" title="对于金融计算用 Decimal 还是 Double" target="_blank" rel="noopener">对于金融计算用 Decimal 还是 Double</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2022/09/28/mastering-dynamic-island-in-swiftui/" title="Mastering Dynamic Island in SwiftUI" target="_blank" rel="noopener">在 SwiftUI 中开发灵动岛</a></p><p><strong>摘要：</strong> 本文将详细介绍使用 WidgetKit 框架中新的 API 实现灵动岛的开发配置和自定义功能。</p><p><a href="https://nemecek.be/blog/171/dynamic-island-and-live-activities-quick-start-tutorial" title="Dynamic Island (and Live Activities): Quick start tutorial" target="_blank" rel="noopener">灵动岛快速入门教程</a></p><p><strong>摘要：</strong> Dynamic Island 是 <code>Live Activities</code> API 的一部分，Live Activities API 是 <code>Widgets</code> 系统的一部分。关于 Widgets 详细使用可以参考之前发布的 <a href="https://mp.weixin.qq.com/s/jYbRAJhhdE8H8xeoBnTEaA" target="_blank" rel="noopener">SwiftUI 锁屏小组件</a></p><p><a href="https://zhuanlan.zhihu.com/p/577728766" title="iOS16 灵动岛 ActivityKit 开发" target="_blank" rel="noopener">iOS16 灵动岛 ActivityKit 开发</a></p><p><strong>摘要：</strong> iOS16.1 苹果向我们开放了 ActivityKit。 使用此框架我们可以在锁定屏幕或者灵动岛上显示实时活动。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>世界杯你赚钱了吗？</strong></p><p>14 亿人为什么选不出一支十多人的优秀团队？到底是哪里出了问题？元芳，你怎么看？国足⚽️的未来在哪里？</p><p><strong>你觉得国足几年内能进世界杯？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第九期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;蝴蝶的生命之所以如此短暂，因为它的翅膀太过精致了。Swift社区之所以浩瀚汹涌，因为它总想牵动起每一位读者的心！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果 70 亿收购曼联消息不实&lt;/p&gt;
&lt;p&gt;提案：Package 注册表认证&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论数组的悬空指针&lt;/p&gt;
&lt;p&gt;推荐博文：灵动岛开发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;世界杯你赚钱了吗？&lt;/p&gt;
&lt;p&gt;你觉得国足几年内能进世界杯？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十七期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十七期/</id>
    <published>2022-11-14T07:53:09.000Z</published>
    <updated>2022-11-14T07:54:53.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第八期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>风起雨坠袭大地，叶落冬来又一年。<strong>Swift社区</strong>，和你同风雨，与你共未来！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果发布最新声明！将工人健康放在首位，iPhone 14 Pro 收获需等待更长时间。</p><p>提案：Swift 论坛讨论人气最高的提案</p><p>Swift 论坛：比较两个 “any Error” 的相等性</p><p>推荐博文：iOS 16 统计图实战汇总</p><p><strong>话题讨论：</strong> 大家觉得互联网行业会不会持续走下坡路？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="11-月-14-日，参与新一周的-Ask-Apple-活动"><a href="#11-月-14-日，参与新一周的-Ask-Apple-活动" class="headerlink" title="11 月 14 日，参与新一周的 Ask Apple 活动"></a>11 月 14 日，参与新一周的 Ask Apple 活动</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f24c1898773749e790a319f674361501~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>欢迎继续参与新一周激动人心的 Ask Apple 开发者系列活动，与 Apple 专家直接交流沟通。针对如何将最新技术集成到您的 App 中、设计直观的 UI，以及测试最新软件等主题大胆提问。</p><p>活动将于 11 月 14 日至 18 日举行，届时将提供多种语言和多个时区的在线一对一咨询和小组 Q&amp;A。现已面向 Apple Developer Program 和 Apple Developer Enterprise Program 的当前成员开放注册。</p><p>Ask Apple 开发者系列活动终场周将在 12 月推出，敬请关注详情。</p><h3 id="苹果发布最新声明！将工人健康放在首位，iPhone-14-Pro-收获需等待更长时间。"><a href="#苹果发布最新声明！将工人健康放在首位，iPhone-14-Pro-收获需等待更长时间。" class="headerlink" title="苹果发布最新声明！将工人健康放在首位，iPhone 14 Pro 收获需等待更长时间。"></a>苹果发布最新声明！将工人健康放在首位，iPhone 14 Pro 收获需等待更长时间。</h3><p>11 月 7 日，苹果对 iPhone 14 Pro 和 iPhone 14 Pro Max 目前的供应情况做出最新声明。苹果称，富士康郑州工厂目前的产能大幅度降低，iPhone 14 Pro 和 iPhone 14 Pro Max 的出货量将低于预期。</p><p>苹果表示，“我们继续看到对 iPhone 14 Pro 和 iPhone 14 Pro Max 机型的强劲需求。然而，我们现在预计 iPhone 14 Pro 和 iPhone 14 Pro Max 的出货量将低于我们之前的预期，顾客将需要等待更长的时间才能收到新产品。”</p><p>苹果称，正在与供应商密切合作，以恢复正常的生产水平，同时确保每个工人的健康和安全。</p><h3 id="macOS-Ventura-更高效，更尽兴，更跨界。"><a href="#macOS-Ventura-更高效，更尽兴，更跨界。" class="headerlink" title="macOS Ventura 更高效，更尽兴，更跨界。"></a>macOS Ventura 更高效，更尽兴，更跨界。</h3><p>macOS Ventura 让各种日常操作都进化成神操作。一波新技能助你搞定更多，一众常用 app 能分享和协作，晋级的游戏让你更投入，还有种种妙招能拉上其他设备一起显身手。</p><p>优化的搜索功能，搜索功能可提供更准确、更完整的搜寻结果，还能在你键入前就提供搜索建议。</p><p>聚焦的快速操作，现在，你可使用聚焦搜索快速执行操作，比如设置闹钟、开启专注模式、用 Shazam 查找歌名、运行快捷指令等。</p><p>共享标签页组，从 Safari 浏览器直接分享标签页和书签，或发送信息。无论是与好友规划行程，还是与家人选购沙发，你都可以在一处地方集中分享所有标签页。而你的伙伴也可把他们的标签页添加进来。</p><p>收发信息的新技能，现在，你可对刚发出的信息进行编辑，或是将其撤回。另外，对于无法及时回复，想回头再来处理的信息，可标为未读。</p><p>iCloud 共享照片图库，可与最多五人顺畅地分享照片和视频，鼓励大家一起制作家庭照片集，让回忆更丰富完整。iCloud 共享照片图库会把家人们的美好回忆都集于一处，让每个家庭成员随时都能欣赏，即使不是自己拍摄或编辑的照片也能看到。</p><p>多种智能的共享方式，共享照片图库可以根据开始日期或照片中的人物，选取想要囊括的内容来进行设置。完成后，你可以手动分享，也可以看看边栏里新的“为共享图库推荐”，根据它的智能建议将照片添加进来。</p><p>在 App 之间切换，轻点一下，可在各 app 和窗口之间流畅切换；点按桌面任意位置，则能快速返回某个文件或文件夹。</p><p>FaceTime 通话也能玩接力了，轻轻一点，就能在设备之间转移 FaceTime 通话，方便你随时换上合适的设备。</p><p>让 iPhone 兼职网络摄像头，iPhone 强大的摄像头系统配合 Mac，能实现以往普通网络摄像头做不到的效果。只要将 iPhone 靠近 Mac，输入源就会自动切换为 iPhone，而且过程是无线的，不用动手插拔。</p><p>更多 macOS Ventura 新功能请查阅 <a href="https://www.apple.com.cn/macos/ventura/" target="_blank" rel="noopener">https://www.apple.com.cn/macos/ventura/</a></p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>提案模块本期没有新的状态更新。下面推荐几个在 <strong>Swift 论坛讨论人气最高</strong>的往期提案。感兴趣的小伙伴可以去参与讨论。</p><p>提案 SE-0374: <a href="https://forums.swift.org/t/se-0374-add-sleep-for-to-clock/60787/19" title="SE-0374" target="_blank" rel="noopener">将 sleep(for:) 添加到 Clock</a>。该提案已在<a href="https://mp.weixin.qq.com/s/x-ufc5MauRGfoY571WePFA" target="_blank" rel="noopener">十五期周报</a>正在审查的提案模块做了详细介绍。</p><p>提案 SE-0376: <a href="https://forums.swift.org/t/se-0376-function-back-deployment/61015/16" title="SE-0376" target="_blank" rel="noopener">函数反向部署</a>。该提案已在<a href="https://mp.weixin.qq.com/s/_igJkQdGWEGSfbDmVL9bbg" target="_blank" rel="noopener">十六期周报</a>正在审查的提案模块做了详细介绍。</p><p>提案 SE-0377: <a href="https://forums.swift.org/t/se-0377-borrow-and-take-parameter-ownership-modifiers/61020/14" title="SE-0377" target="_blank" rel="noopener">提出了新的 borrow 和 take 参数修饰符</a>。该提案已在<a href="https://mp.weixin.qq.com/s/_igJkQdGWEGSfbDmVL9bbg" target="_blank" rel="noopener">十六期周报</a>正在审查的提案模块做了详细介绍。</p><p>提案 SE-0366: <a href="https://forums.swift.org/t/se-0366-second-review-take-operator-to-end-the-lifetime-of-a-variable-binding/61021/14" title="SE-0366" target="_blank" rel="noopener">代码上下文新增敏感关键字 move 修订后</a>。该提案已在<a href="https://mp.weixin.qq.com/s/i5a-jhRRdf36KUNRoMX_8w" target="_blank" rel="noopener">十一期周报</a>正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) <a href="https://forums.swift.org/t/an-informal-introduction-to-move-only-types/61358" title="Move-Only 类型的非正式介绍" target="_blank" rel="noopener">Move-Only 类型的非正式介绍</a></p><p>2) <a href="https://forums.swift.org/t/same-values-equality-complexity-guarantees/61334" title="相同的值相等的复杂性保证" target="_blank" rel="noopener">相同的值相等的复杂性保证</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: <span class="type">String</span> = ....</span><br><span class="line"><span class="keyword">let</span> bar = foo</span><br><span class="line">foo == bar <span class="comment">// is this O(1) ?</span></span><br></pre></td></tr></table></figure><p>3) 资料分享 <a href="https://forums.swift.org/t/signal-handling-in-swift/61351" title="swift package SignalHandler" target="_blank" rel="noopener">swift package SignalHandler</a></p><p>4) 讨论<a href="https://forums.swift.org/t/issues-with-using-5-7-regex-on-linux/61344" title="在 Linux 上使用 5.7 Regex 的问题" target="_blank" rel="noopener">在 Linux 上使用 5.7 <code>Regex</code> 的问题</a></p><p>5) 讨论 <a href="https://forums.swift.org/t/an-ios-app-for-the-swift-forum/61335/1" title="Swift 论坛的 iOS 应用" target="_blank" rel="noopener">Swift 论坛的 iOS 应用</a></p><p>Discourse Hub App可以用来浏览Swift论坛内容，App基于WebView，本质与用浏览器没有区别😂</p><p>6) 讨论<a href="https://forums.swift.org/t/detect-the-number-of-usb-ports-available-on-the-mac-device/61321" title="检测 Mac 设备上可用的 USB 端口数量" target="_blank" rel="noopener">检测 Mac 设备上可用的 USB 端口数量</a></p><p>7) 讨论<a href="https://forums.swift.org/t/comparing-two-any-error-s-for-equality/61338" title="比较两个“any Error”的相等性" target="_blank" rel="noopener">比较两个“any Error”的相等性</a></p><p>问题描述：有一个错误类型，它包含另一个存在的any Error：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@frozen <span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecursiveError</span>&lt;<span class="title">Location</span>&gt;:<span class="title">Error</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/// The location (key or index) where the error occurred.</span></span><br><span class="line">    <span class="keyword">public</span></span><br><span class="line">    <span class="keyword">let</span> location:<span class="type">Location</span></span><br><span class="line">    <span class="comment">/// The underlying error that occurred.</span></span><br><span class="line">    <span class="keyword">public</span></span><br><span class="line">    <span class="keyword">let</span> error:any <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    @inlinable <span class="keyword">public</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> error:any <span class="type">Error</span>, <span class="keyword">in</span> location:<span class="type">Location</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.location = location</span><br><span class="line">        <span class="keyword">self</span>.error = error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Unit Test:</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">0</span>.test(name: <span class="string">"int32-to-uint8"</span>, decoding: bson,</span><br><span class="line">    failure: <span class="type">RecursiveError</span>&lt;<span class="type">String</span>&gt;.<span class="keyword">init</span>(</span><br><span class="line">        <span class="type">IntegerOverflowError</span>&lt;<span class="type">UInt8</span>&gt;.int32(.<span class="built_in">max</span>),</span><br><span class="line">        <span class="keyword">in</span>: <span class="string">"int32"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> $<span class="number">0</span>[<span class="string">"int32"</span>].decode(to: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Error</span> <span class="title">where</span> <span class="title">Self</span>:<span class="title">Equatable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">equals</span><span class="params">(<span class="number">_</span> other:any Error)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        (other <span class="keyword">as</span>? <span class="type">Self</span>).<span class="built_in">map</span> &#123; $<span class="number">0</span> == <span class="keyword">self</span> &#125; ?? <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8) 讨论 <a href="https://forums.swift.org/t/boolean-operators-and-async-let/61354" title="Boolean 运算和 async let" target="_blank" rel="noopener">Boolean 运算和 <code>async let</code></a></p><p><strong>执行：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">let</span> first: <span class="type">Int</span>[] = someAsyncCall()</span><br><span class="line">async <span class="keyword">let</span> second: <span class="type">Int</span>[] = anotherAsyncCall()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bothEmpty = (await first).isEmpty &amp;&amp; (await second).isEmpty</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> bothEmpty = await (first.isEmpty &amp;&amp; second.isEmpty)</span><br><span class="line"><span class="comment">// or any other variation I can think of</span></span><br></pre></td></tr></table></figure><p><strong>会有以下 Error：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;async let&apos; in an autoclosure that does not support concurrency</span><br><span class="line">Capturing &apos;async let&apos; variables is not supported</span><br></pre></td></tr></table></figure><p>Boolean 运算是使用标记为自动闭包的 rhs 参数定义的，这意味着右侧的表达式会自动捆绑到闭包中，从而延迟其执行直到需要。 值得注意的是，这个 rhs 闭包属性没有被标记为 async ，所以没有 await 语句可以出现在它的“内部”。</p><p><strong>解决：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bothEmpty = await [first, second].allSatisfy(\.isEmpty)</span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/16+在iOS16中用SwiftUI图表定制一个线图.md" title="在 iOS16中用SwiftUI图表定制一个线图" target="_blank" rel="noopener">在 iOS16 中用 SwiftUI 图表定制一个线图</a></p><p><strong>摘要：</strong> 在 iOS 16 中引入的 SwiftUI 图表，可以以直观的视觉格式呈现数据，并且可以使用 SwiftUI 图表快速创建。本文演示了几种定制折线图并与区域图结合来展示数据的方法。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/10%20在%20Swift图表中使用Foudation库中的测量类型.md" target="_blank" rel="noopener">在 Swift 图表中使用 Foudation 库中的测量类型</a></p><p><strong>摘要：</strong> 本篇文章使用今年推出的新的 Swift Charts 框架，实现如何绘制默认不符合 Plottable 协议的类型的数据。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/15%20在iOS%2016中用SwiftUI%20Charts创建一个折线图%20.md" target="_blank" rel="noopener">在 iOS 16 中用 SwiftUI Charts 创建一个折线图</a></p><p><strong>摘要：</strong> 苹果在 WWWDC 2022 上推出了 SwiftUI 图表，本文展示了如何用比以前从头开始创建同样的折线图少得多的代码轻松创建折线图。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/13%20如何在SwiftUI中创建条形图.md" target="_blank" rel="noopener">如何在 SwiftUI 中创建条形图</a></p><p><strong>摘要：</strong> 本文将展示如何创建一个垂直条形图，其中矩形的高度将代表每个类别的值。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios#8" title="Flutter 实战" target="_blank" rel="noopener">Flutter 实战整理</a></p><p><strong>摘要：</strong> 文章仓库增加 Flutter 实战模块，整理相关主题文章。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>都说互联网红利已经没有了，那么大家觉得互联网行业会不会持续走下坡路？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第八期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;风起雨坠袭大地，叶落冬来又一年。&lt;strong&gt;Swift社区&lt;/strong&gt;，和你同风雨，与你共未来！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果发布最新声明！将工人健康放在首位，iPhone 14 Pro 收获需等待更长时间。&lt;/p&gt;
&lt;p&gt;提案：Swift 论坛讨论人气最高的提案&lt;/p&gt;
&lt;p&gt;Swift 论坛：比较两个 “any Error” 的相等性&lt;/p&gt;
&lt;p&gt;推荐博文：iOS 16 统计图实战汇总&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; 大家觉得互联网行业会不会持续走下坡路？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十六期/</id>
    <published>2022-10-31T10:58:53.000Z</published>
    <updated>2022-11-14T07:54:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第七期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>当你来到双水村以外的大世界，你的人生目标便不单单是一名庄稼人了。<strong>Swift社区</strong>陪你一起成长，一起创造更多可能！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：【挑战上岛】适配实时活动和灵动岛</p><p>提案：函数反向部署</p><p>Swift 论坛：围绕 Swift 6 lock 展开的讨论</p><p>推荐博文：推荐 500+ 款 App UI 设计</p><p>工具推荐：妙言</p><p><strong>话题讨论：</strong> 如果您年龄超过 35 岁被裁员，再入职时能接受降薪吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="挑战上岛：适配实时活动和灵动岛"><a href="#挑战上岛：适配实时活动和灵动岛" class="headerlink" title="挑战上岛：适配实时活动和灵动岛"></a>挑战上岛：适配实时活动和灵动岛</h3><p>Apple 大中华区设计与开发加速器推出全新挑战活动，邀请开发团队限期完成实时活动和灵动岛适配。</p><p>实时活动用于在 iPhone 锁屏以及灵动岛上显示来自 App 的最新信息，帮助用户及时查看当前任务和事件的进展。参与此次活动，您将了解如何设计和开发您的实时活动，以及如何利用灵动岛带来更出色的用户体验。</p><p>我们会提供主题设计与开发讲座，您将了解如何设计和开发您的实时活动，以及如何利用灵动岛带来更出色的用户体验。</p><p>参与讲座的开发团队可在讲座当天报名参与实时活动和灵动岛适配挑战，通过审核后可获得一对一的咨询与深度辅导。参加挑战，并能够在 2022 年 12 月 20 日前完成适配和上线的团队，将有机会获得更多 App 的推广机会。</p><p>名额有限。请在 2022 年 11 月 8 日前报名参加。</p><p>要报名参加，您必须是位于大中华区的 Apple Developer Program 成员。</p><h3 id="用-SwiftUI-实现-App-导航"><a href="#用-SwiftUI-实现-App-导航" class="headerlink" title="用 SwiftUI 实现 App 导航"></a>用 SwiftUI 实现 App 导航</h3><p>导航是一个 App 的核心，它可以将用户带往 App 里功能不同的页面当中，因此，清晰而强大的导航架构对 App 而言是非常重要的。通过本次活动，我们将从设计和研发两方面来为您介绍，如何使用 SwiftUI 来实现 App 的导航架构，让用户能快速定位到 App 的各项功能。</p><p>名额有限。请在 2022 年 11 月 7 日前报名参加。</p><p>要报名参加，您必须是位于大中华区的 Apple Developer Program 成员。</p><h3 id="使用最新-Beta-版本，做好充足准备"><a href="#使用最新-Beta-版本，做好充足准备" class="headerlink" title="使用最新 Beta 版本，做好充足准备"></a>使用最新 Beta 版本，做好充足准备</h3><p>Beta 版iOS 16.2、iPadOS 16.2、 macOS 13.1、Apple tvOS 16.2 和 watchOS 9.2 现已推出。请确认您的 App 在这些版本上工作正常，确保 App 做好准备。要利用最新 SDK 中的改进功能，请务必使用 Xcode 14.1 RC 2 进行构建和测试。</p><p>要了解之前 Beta 版本中的已知问题是否已解决或是否有临时应对办法，请查看最新的发布说明。如果您遇到问题或有其他反馈，请告诉我们。我们十分重视您的反馈，并相信您的反馈对我们解决问题、优化功能和更新文档将大有助益。</p><h3 id="Apple-Search-Ads-推出全新广告投放位置，现已亮相-App-Store"><a href="#Apple-Search-Ads-推出全新广告投放位置，现已亮相-App-Store" class="headerlink" title="Apple Search Ads 推出全新广告投放位置，现已亮相 App Store"></a>Apple Search Ads 推出全新广告投放位置，现已亮相 App Store</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/D69BBA69-3F0C-4470-8190-56498AE2116C/2048.jpeg" alt=""></p><p>Apple Search Ads 让您能轻松地在 App Store 上推广自己的 App。现在，借助全新的“Today”标签页和产品页广告投放位置，您在 App Store 上提升 App 曝光度的机会大大增加 — 当人们首次登陆、搜索特定内容和浏览要下载的 App 时，都是您推广自己 App 的大好时机。</p><p>在中国大陆的 App Store 上暂不可用。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0375-opening-existential-optional.md" title="SE-0375" target="_blank" rel="noopener">SE-0375</a> <strong>允许非可选非空参数传递给可选类型的参数</strong> 提案已通过。该提案已在<a href="https://mp.weixin.qq.com/s/x-ufc5MauRGfoY571WePFA" target="_blank" rel="noopener">十五期周报</a>正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0373-vars-without-limits-in-result-builders.md" title="SE-0373" target="_blank" rel="noopener">SE-0373</a> <strong>取消 <code>result builders</code> 中对变量的所有限制</strong> 提案已通过。该提案已在<a href="https://mp.weixin.qq.com/s/x-ufc5MauRGfoY571WePFA" target="_blank" rel="noopener">十五期周报</a>正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0377-parameter-ownership-modifiers.md" title="SE-0377" target="_blank" rel="noopener">SE-0377</a> <strong>提出了新的 <code>borrow</code> 和 <code>take</code> 参数修饰符</strong> 正在审查。</p><p>本提案提出的 <code>borrow</code> 和 <code>take</code> 参数修饰符，允许开发人员自主选择函数，用于接收不可变参数的所有权约定。这样可以通过减少调用函数所需的 ARC 来优化性能，并为 <code>move-only</code> 类型提供了必要的先决条件，指定函数是否会消耗 <code>move-only</code> 值。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0376-function-back-deployment.md" title="SE-0376" target="_blank" rel="noopener">SE-0376</a> <strong>函数反向部署</strong> 提案正在审查。</p><p>弹性 Swift 资源库，例如 Apple 平台 SDK 中存在的库，作为动态库分发。这些库的作者使用 <code>@available</code> 注释来指示引入声明的操作系统版本。</p><p>函数反向部署可以避免下面的缺点：</p><ol><li>当原始库可用时，首选使用原始库的 API。</li><li>当客户端二进制文件永远不会使用时，API 实现的后备副本不存在。</li></ol><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md" title="SE-0366" target="_blank" rel="noopener">SE-0366</a> <strong>代码上下文新增敏感关键字 move</strong> 修订后，重新审查。该提案已在<a href="https://mp.weixin.qq.com/s/i5a-jhRRdf36KUNRoMX_8w" target="_blank" rel="noopener">十一期周报</a>正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-isolated-function-values-and-sendable/61046" title="隔离函数 Value 和 Sendable" target="_blank" rel="noopener">隔离函数 Value 和 Sendable</a></p><p>2) 提议<a href="https://forums.swift.org/t/pitch-swift-distributed-actors-cluster/61061" title="Swift 分布式 Actors (集群)" target="_blank" rel="noopener">Swift Distributed Actors (Cluster)</a></p><p><strong>提议动机:</strong> 在 Swift 5.7 中，分布式 Actor 被引入为名义类型。 与 Actors 类似，它们可以使用 <code>distributed actor</code> 关键字对来声明。 就它们自己而言，它们不能真正做任何事情， 所有分布式的行为比如 actor 的行为实际上都由给定 actor 类型相关联的 ActorSystem 处理。具体来说，一个 actor 必须声明它将与什么类型的 actor 系统一起使用，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Distributed</span><br><span class="line"><span class="keyword">import</span> DistributedCluster</span><br><span class="line">distributed actor <span class="type">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ActorSystem</span> = <span class="type">ClusterSystem</span></span><br><span class="line">    distributed <span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(name)</span>!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的 Greeter 声明可以在集群分布式 actors 系统中使用此类。 也可以声明一个模块范围的默认分布式 actor 系统类型。有关更多信息，可以参考 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0344-distributed-actor-runtime.md" title="Swift Distributed Actor Runtime" target="_blank" rel="noopener">Swift Distributed Actor Runtime</a> 和 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0336-distributed-actor-isolation.md" title="Swift Distributed Actor Isolation" target="_blank" rel="noopener">Swift Distributed Actor Isolation</a> 这是大多数用户可能使用此功能的方式，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">DefaultDistributedActorSystem</span> = <span class="type">ClusterSystem</span></span><br></pre></td></tr></table></figure><p>为了避免在每个分布式 actor 模块中重复声明 ActorSystem 类型别名。这里提出的包提供了 ClusterSystem 的实现。</p><p><strong>解决方案:</strong> DistributedCluster 中包括 ClusterSystem 类型，它是库的核心部分。 创建之后，它会绑定到主机/端口对并开始监听传入连接:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@main</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> system = await <span class="type">ClusterSystem</span>(<span class="string">"FirstSystem"</span>) &#123; settings <span class="keyword">in</span></span><br><span class="line">            settings.endpoint.host = <span class="string">"127.0.0.1"</span></span><br><span class="line">            settings.endpoint.port = <span class="number">7337</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> await system.terminated</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）提议<a href="https://forums.swift.org/t/pitch-package-registry-authentication/61047" title="Package Registry Authentication" target="_blank" rel="noopener">Package Registry Authentication</a></p><p>在<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0292-package-registry-service.md" target="_blank" rel="noopener">SE-0292</a>（API 规范）中提出的package registry服务可能需要对其部分或全部 API 进行身份验证，以便识别执行操作的用户并相应地授权请求。</p><p><strong>提议动机：</strong> Web 服务中常见的身份验证方法包括基本验证 (authentication), access token 和 OAuth。 SwiftPM 目前仅支持基本验证，这限制了它与包注册服务交互的能力。<br>建议的解决方案: 建议修改 swift package-registry 指令和 registry 的配置并且加入 token authentication 的支持。 这些更改还应确保将来可以灵活地添加其他验证方法。</p><p>4）提议<a href="https://forums.swift.org/t/pitch-convenience-async-throwing-stream-makestream-methods/61030" title="方便的 AsyncThrowingStream.makeStream 方法" target="_blank" rel="noopener">方便的 AsyncThrowingStream.makeStream 方法</a></p><p>在<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0314-async-stream.md" target="_blank" rel="noopener">SE-0314</a>中介绍了 AsyncStream 和 AsyncThrowingStream，它们充当标准库提供的 AsyncSequence。</p><p>提议动机：在使用 Async[Throwing]Stream 一段时间后，我们发现一个常见的用法是将 continuation 和 Async[Throwing]Stream 传递到不同的地方。这需要将 Async[Throwing]Stream.Continuation excaping 并且出传递给初始化程序的闭包。Escaping continuation 使用起来不方便，因为它需要对隐式 optional value 进行格外的操作。</p><p>建议的解决方案：为了填补这个不足，建议在 AsyncStream 和 AsyncThrowingStream 上添加一个新的静态方法 makeStream ，它返回 stream 和 continuation。</p><p>5) 讨论<a href="https://forums.swift.org/t/what-does-use-async-safe-scoped-locking-instead-even-mean/61029" title="围绕 Swift 6 lock 展开的讨论" target="_blank" rel="noopener">围绕 Swift 6 lock 展开的讨论</a></p><p>6) 讨论<a href="https://forums.swift.org/t/remove-digit-from-number-to-maximize-result/61049" title="围绕 leetcode 2259 题 Remove Digit From Number to Maximize Result 展开的讨论" target="_blank" rel="noopener">围绕 leetcode 2259 题 Remove Digit From Number to Maximize Result 展开的讨论</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/7个大型iOS项目的Xcode快捷方式.pdf" title="7 个大型 iOS 项目的 Xcode 快捷方式" target="_blank" rel="noopener">7 个大型 iOS 项目的 Xcode 快捷方式</a></p><p><strong>摘要：</strong> 分享的 7 个 Xcode 快捷方式，非常的实用。希望能对你的项目开发有所帮助。</p><p><a href="https://mp.weixin.qq.com/s/jYbRAJhhdE8H8xeoBnTEaA" target="_blank" rel="noopener">SwiftUI 锁屏小组件</a></p><p><strong>摘要：</strong> iOS 呼声最高的功能之一是可定制的锁屏。终于，在最新发布的 iOS 16 得以实现。我们可以用可浏览的小组件填充锁屏。</p><p><a href="https://mp.weixin.qq.com/s/84TG_7yFxpsXF7cHTbVbFw" target="_blank" rel="noopener">iOS16 中的 3 种新字体宽度样式</a></p><p><strong>摘要：</strong> 在 iOS 16 中，Apple 引入了三种新的宽度样式字体到 SF 字体库。1、Compressed，2、Condensed，3、Expend。</p><p><a href="https://mp.weixin.qq.com/s/MsFjb49JUtZlGn6XSJghyQ" target="_blank" rel="noopener">推荐 500+ 款 App UI 设计</a></p><p><strong>摘要：</strong> 500+ 款 App UI 设计，激发你的设计灵感。</p><p><a href="https://mp.weixin.qq.com/s/V1KLRAVK-DEWr7Gneatr1A" target="_blank" rel="noopener">Swift社区回馈读者</a></p><p><strong>摘要：</strong> Swift社区回馈读者 – 送书活动还在进行中，机会不要错过，马上参与吧。</p><h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><p><strong>妙言：</strong> 一个简洁好看的开源的 Mac Markdown 编辑器，没有任何多余的功能，使用原生 Swift 开发，轻量性能高，安全纯本地使用，具备语法高亮、黑暗模式、自动格式化、单独编辑、演示模式、图床等功能。</p><p><img src="https://user-images.githubusercontent.com/8736212/193432093-113a3667-c0b7-4711-9479-5679abed83af.png" alt=""></p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>如果您年龄超过 35 岁被裁员，再入职时能接受降薪吗?</strong></p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第七期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;当你来到双水村以外的大世界，你的人生目标便不单单是一名庄稼人了。&lt;strong&gt;Swift社区&lt;/strong&gt;陪你一起成长，一起创造更多可能！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：【挑战上岛】适配实时活动和灵动岛&lt;/p&gt;
&lt;p&gt;提案：函数反向部署&lt;/p&gt;
&lt;p&gt;Swift 论坛：围绕 Swift 6 lock 展开的讨论&lt;/p&gt;
&lt;p&gt;推荐博文：推荐 500+ 款 App UI 设计&lt;/p&gt;
&lt;p&gt;工具推荐：妙言&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; 如果您年龄超过 35 岁被裁员，再入职时能接受降薪吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十五期/</id>
    <published>2022-10-17T03:29:52.000Z</published>
    <updated>2022-11-14T07:54:40.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第六期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>果然，十一假期与新一轮疫情撞了个满怀，远方的你还好吗？<strong>Swift社区</strong>愿与你携手，一起尖叫一起笑，一起撑伞一起闹！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone14 车祸检测功能摆乌龙 坐过山车自动报警</p><p>提案：申请将 <code>sleep(for:)</code> 添加到 <code>Clock</code></p><p>Swift 论坛：Bug <code>@available</code> 在 <code>literal</code> 初始化中没有效果</p><p>推荐博文：<code>async/await</code> 系列代码示例详解</p><p><strong>话题讨论：</strong> 面对各厂新一轮裁员，你焦虑了吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="Apple-Entrepreneur-Camp-现已开放申请"><a href="#Apple-Entrepreneur-Camp-现已开放申请" class="headerlink" title="Apple Entrepreneur Camp 现已开放申请"></a>Apple Entrepreneur Camp 现已开放申请</h3><p>Apple Entrepreneur Camp 旨在为 App 驱动型组织中的少数群体创业者及开发者提供支持，助力其研发新一代的前沿 App 并开拓全球网络，鼓励这些创业者在技术领域不断探索并取得持续发展。</p><p>三组面向女性、黑人以及西班牙裔及拉丁裔创业者的在线课程将在 2023 年 1 月开展，欢迎选择合适的一组提交申请。课程期间，Apple 工程师将为学员提供编程指导，Apple 高层也将作为导师分享见解、启发灵感。申请截止日期为 2022 年 12 月 5 日。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/03fdd37a55a8a6506c6dccc39ac1855e.jpeg" alt=""></p><h3 id="iPhone14-车祸检测功能摆乌龙-坐过山车自动报警"><a href="#iPhone14-车祸检测功能摆乌龙-坐过山车自动报警" class="headerlink" title="iPhone14 车祸检测功能摆乌龙 坐过山车自动报警"></a>iPhone14 车祸检测功能摆乌龙 坐过山车自动报警</h3><p>据美国有线电视新闻网等多家媒体报道，近日有游客在携带苹果公司的新款手机 iPhone14 乘坐过山车时，手机会错误检测到遭遇车祸并自动报警。目前在美国游乐园，已发生多起类似事件，而造成这一切的原因是 iPhone14 自带的车祸检测功能存在问题。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/9206d54e5b8d1f780b3783c62a438b5a.png" alt=""></p><p>苹果在９月初发布了新款手机 iPhone14，其中一项“车祸检测”新功能颇为引人关注。该功能借助加速度传感器、陀螺仪、麦克风等多种传感器来感知四种碰撞场景，包括正面、侧面、追尾和翻车。一旦检测到车祸，系统会自动弹窗询问机主是否遭遇了紧急情况，在一定时间内若未收到回应，系统将自动报警。</p><p>不过，设计人员可能没有考虑到，乘坐过山车与汽车行驶状态容易混淆。据了解，iPhone14 上市以来，在美国多家游乐园的过山车上，都发生过报警乌龙。有的游乐园无奈之下只能提醒游客，坐过山车之前关闭车祸检测功能，或把手机调成飞行模式。(看看新闻Knews)</p><h3 id="苹果自研-5G-芯片或要等-2025-年"><a href="#苹果自研-5G-芯片或要等-2025-年" class="headerlink" title="苹果自研 5G 芯片或要等 2025 年"></a>苹果自研 5G 芯片或要等 2025 年</h3><p>此前爆料称，苹果将为未来的 iPhone 开发自主研发的 5G 基带芯片，但据预测，高通仍将是所有 iPhone 15 和 iPhone 16 系列机型的调制解调器供应商，这表明苹果的基带芯片至少要到 2025 年才会亮相。</p><p>海通国际证券分析师 Jeff Pu 在周五的研究报告中说，他预计 2024 年发布的 iPhone 机型（暂称 iPhone 16 系列）将使用高通尚未公布的骁龙 X75 调制解调器。与骁龙 X70 一样，X75 预计将基于台积电的 4nm 工艺制造，有助于提高能效。（IT之家)</p><h3 id="欧盟批准强制苹果使用-USB-C-接口"><a href="#欧盟批准强制苹果使用-USB-C-接口" class="headerlink" title="欧盟批准强制苹果使用 USB C 接口"></a>欧盟批准强制苹果使用 USB C 接口</h3><p>【欧盟将统一便携智能设备充电接口】据@央视新闻 ，欧洲议会 10 月 4 日通过一项新规，要求从 2024 年底开始，所有手机、平板电脑等便携智能设备新机都使用 USB Type-C 的充电接口。</p><p>欧洲议会当天以 602 票赞成、13 票反对的投票结果通过有关统一便携智能设备充电接口的法案。所有手机、平板电脑、数码相机、耳机、便携音箱、手持视频游戏机、电子阅读器、键盘、鼠标和便携式导航系统将在两年内统一充电接口。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0375-opening-existential-optional.md" title="SE-0375" target="_blank" rel="noopener">SE-0375</a> <strong>允许非可选非空参数传递给可选类型的参数</strong> 提案正在审查。</p><p>在 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0352-implicit-open-existentials.md" title="SE-0352" target="_blank" rel="noopener">SE-0352</a> 提案中有一个限制，可选类型的参数不允许接受非可选参数。本提案申请更改这个限制，当非可选非空参数传递给可选类型的参数时，允许调用成功。示例代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acceptOptional</span>&lt;T: P&gt;<span class="params">(<span class="number">_</span> x: T?)</span></span> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(p: any P, pOpt: <span class="params">(any P)</span></span></span>?) &#123;</span><br><span class="line">  acceptOptional(p) <span class="comment">// SE-0352 does not open "p"; this proposal will open "p" and bind "T" to its underlying type</span></span><br><span class="line">  acceptOptional(pOpt) <span class="comment">// does not open "pOpt", because there is no "T" to bind to when "pOpt" is "nil"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0374-clock-sleep-for.md" title="SE-0374" target="_blank" rel="noopener">SE-0374</a> <strong>将 <code>sleep(for:)</code> 添加到 <code>Clock</code></strong> 提案正在审查。</p><p>Swift 5.7 中引入的 Clock 协议提供了一种方法来暂停到未来的某个时刻，但没有提供一种方法来休眠一段时间。这与 Task 上的静态 sleep 方法不同，后者提供了一种方法来休眠到某一时刻或一段时间。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0373-vars-without-limits-in-result-builders.md" title="SE-0373" target="_blank" rel="noopener">SE-0373</a> <strong>取消 <code>result builders</code> 中对变量的所有限制</strong> 提案正在审查。</p><p><code>result builders</code> 转换的实现（由 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md" title="SE-0289" target="_blank" rel="noopener">SE-0289</a> 引入）对转换函数中的局部变量声明设置了许多限制。具体来说，局部变量需要有一个初始化表达式，它们不能被计算，它们不能有观察者，它们不能有附加的属性包装器。这些限制在 SE-0289 提案中都没有明确说明，但它们实际上是当前功能的一部分。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/should-apple-create-a-simple-programming-language/60746" title="苹果是否应该创造一个简单编程语言" target="_blank" rel="noopener">苹果是否应该创造一个简单编程语言</a></p><p>2) <strong>Bug</strong> <a href="https://github.com/apple/swift/issues/61564" title="@available 在 literal 初始化中没有效果" target="_blank" rel="noopener">@available 在 literal 初始化中没有效果</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> bar: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(*, deprecated)</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(stringLiteral value: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.bar = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Foo</span> = <span class="type">Foo</span>(stringLiteral: <span class="string">""</span>) <span class="comment">// warning: 'init(stringLiteral:)' is deprecated</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Foo</span> = <span class="string">""</span> <span class="comment">// no warning</span></span><br></pre></td></tr></table></figure><p>3) 讨论<a href="https://forums.swift.org/t/reconsider-inference-of-global-actor-based-on-property-wrappers/60821" title="重新考虑基于 property wrappers 的全局 actor 推断" target="_blank" rel="noopener">重新考虑基于 property wrappers 的全局 actor 推断</a><br>内容概括：</p><p>4) 提问<a href="https://forums.swift.org/t/splitting-information-elements/60835" title="拆分我的信息元素" target="_blank" rel="noopener">拆分我的信息元素</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foo.swift</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x : <span class="type">Int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> ();</span><br><span class="line">    <span class="keyword">init</span> (v: <span class="type">Int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Int</span>;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">(u:Int, v:Int)</span></span> -&gt; <span class="type">Int</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> () &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> (v: <span class="type">Int</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">(u:Int, v:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>使用 <code>convenience</code> 初始化方法, <code>designated</code> 初始化方法必须写在 class 的主体中但 <code>convenience</code> 初始化方法可以在 <code>extension</code> 中使用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note that this is a designated init because it doesn't have the</span></span><br><span class="line">    <span class="comment">// `convenience` keyword.</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(v: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        x = v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(u:Int, v:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + u + v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5) 讨论 <a href="https://forums.swift.org/t/iphone-picture-taking-and-lidar-data-acquisition/60799" title="iPhone 拍照和激光雷达数据采集" target="_blank" rel="noopener">iPhone 拍照和激光雷达数据采集</a></p><p>6) 讨论<a href="https://forums.swift.org/t/using-mainactor-to-ensure-execution-on-the-main-thread/60764" title="使用 @MainActor 确保在主线程上执行" target="_blank" rel="noopener">使用 @MainActor 确保在主线程上执行</a></p><p>7) 讨论 <a href="https://forums.swift.org/t/an-alternative-to-the-switch-statement/60714/10" title="switch 语句的替代方法" target="_blank" rel="noopener">switch 语句的替代方法</a></p><p>8) 讨论<a href="https://forums.swift.org/t/accumulating-http-request-body-parts-is-storing-bytebuffer-s-a-good-idea/60813" title="累积 HTTP 请求nody部分：存储 ByteBuffer 是个好主意吗？" target="_blank" rel="noopener">累积 HTTP 请求 body 部分：存储 ByteBuffer 是个好主意吗？</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://mp.weixin.qq.com/s/IA9CgMjZf63_RFwNBB9QqQ" title="Sendable 和 @Sendable 闭包代码实例详解" target="_blank" rel="noopener">Sendable 和 @Sendable 闭包 —— 代码实例详解</a></p><p><strong>摘要：</strong> Sendable 和 @Sendable 是 Swift 5.5 中的并发修改的一部分，解决了结构化的并发结构体和执行者消息之间传递的类型检查的挑战性问题。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/19+Swift+中的async:await+——代码实例详解.md" title="Swift 中的 async/await —— 代码实例详解" target="_blank" rel="noopener">Swift 中的 async/await —— 代码实例详解</a></p><p><strong>摘要：</strong> async-await 是在 WWDC 2021 期间的 Swift 5.5 中的结构化并发变化的一部分。Swift中的并发性意味着允许多段代码同时运行。这是一个非常简化的描述，但它应该让你知道 Swift 中的并发性对你的应用程序的性能是多么重要。有了新的 async 方法和 await 语句，我们可以定义方法来进行异步工作。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/20+Swift+AsyncSequence+——+代码实例详解.md" title="Swift AsyncSequence —— 代码实例详解" target="_blank" rel="noopener">Swift AsyncSequence —— 代码实例详解</a></p><p><strong>摘要：</strong> <code>AsyncSequence</code> 是并发性框架和 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md" title="SE-298" target="_blank" rel="noopener">SE-298</a> 提案的一部分。它的名字意味着它是一个提供异步、顺序和迭代访问其元素的类型。换句话说：它是我们在 Swift 中熟悉的常规序列的一个异步变体。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/21+Swift+AsyncThrowingStream+和+AsyncStream+———+代码实例详解.md" title="Swift AsyncThrowingStream 和 AsyncStream ——— 代码实例详解" target="_blank" rel="noopener">Swift AsyncThrowingStream 和 AsyncStream ——— 代码实例详解</a></p><p><strong>摘要：</strong> <code>AsyncThrowingStream</code> 和 <code>AsyncStream</code>是 Swift 5.5 中由 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0314-async-stream.md" title="SE-314" target="_blank" rel="noopener">SE-314</a> 引入的并发框架的一部分。异步流允许你替换基于闭包或 Combine 发布器的现有代码。</p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/22+Swift+中的+MainActor使用和主线程调度.md" title="Swift 中的 MainActor 使用和主线程调度" target="_blank" rel="noopener">Swift 中的 MainActor 使用和主线程调度</a></p><p><strong>摘要：</strong> MainActor 是 Swift 5.5 中引入的一个新属性，它是一个全局 actor，提供一个在主线程上执行任务的执行器。在构建应用程序时，在主线程上执行UI更新任务是很重要的，在使用几个后台线程时，这有时会很有挑战性。使用 <code>@MainActor</code> 属性将帮助你确保你的UI总是在主线程上更新。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>面对各厂新一轮裁员，你焦虑了吗？</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/298cf3a660c84134793cdbfa1886c079.png" alt=""></p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第六期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;果然，十一假期与新一轮疫情撞了个满怀，远方的你还好吗？&lt;strong&gt;Swift社区&lt;/strong&gt;愿与你携手，一起尖叫一起笑，一起撑伞一起闹！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：iPhone14 车祸检测功能摆乌龙 坐过山车自动报警&lt;/p&gt;
&lt;p&gt;提案：申请将 &lt;code&gt;sleep(for:)&lt;/code&gt; 添加到 &lt;code&gt;Clock&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swift 论坛：Bug &lt;code&gt;@available&lt;/code&gt; 在 &lt;code&gt;literal&lt;/code&gt; 初始化中没有效果&lt;/p&gt;
&lt;p&gt;推荐博文：&lt;code&gt;async/await&lt;/code&gt; 系列代码示例详解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; 面对各厂新一轮裁员，你焦虑了吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十四期/</id>
    <published>2022-09-26T03:56:55.000Z</published>
    <updated>2022-09-26T03:59:21.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第五期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>小时候幸福很简单，长大后简单很幸福。<strong>Swift社区</strong>有你未领取的小幸福，等你简简单单来开启！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone灵动岛无法适配大部分应用</p><p>提案：Swift 5.8 实现的提案</p><p>Swift 论坛：<code>conformance</code> 关键字</p><p>推荐博文：SwiftUI 新功能 Layout 协议</p><p><strong>话题讨论：</strong> 大厂养老，你会选择谁</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="iPhone-灵动岛无法适配大部分应用"><a href="#iPhone-灵动岛无法适配大部分应用" class="headerlink" title="iPhone 灵动岛无法适配大部分应用"></a>iPhone 灵动岛无法适配大部分应用</h3><p>近日，有海外程序员小哥哥曝光了灵动岛的开发代码，并配文称原本想安装完 Xcode 14.1 Beta 版（iOS 开发程序）去了解下 iPhone 14 Pro 的灵动岛 API 接口情况，但没想到，苹果并未开放 API，也就是说第三方开发人员很难自行适配灵动岛这个系统级的交互功能。如果想要适配灵动岛恐怕只能向苹果官方申请开放 API 接口。这也是为什么很多 App 至今都没能适配灵动岛的情况出现。（新浪数码）</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/f12e107a5e43e5852d5a2c820448799a.gif" alt=""></p><h3 id="App-和-App-内购买项目即将实行价格和税率调整"><a href="#App-和-App-内购买项目即将实行价格和税率调整" class="headerlink" title="App 和 App 内购买项目即将实行价格和税率调整"></a>App 和 App 内购买项目即将实行价格和税率调整</h3><p>最早于 2022 年 10 月 5 日起，下列地区 App Store 上的 App 及 App 内购买项目 (自动续期订阅除外) 价格将有所提高：智利、埃及、日本、马来西亚、巴基斯坦、波兰、韩国、瑞典、越南和所有使用欧元货币的地区。在越南，相关的价格提升反映了要求 Apple 代扣代缴适用税款的新规定，其中适用税款包括 5% 的增值税 (VAT) 和 5% 的企业所得税 (CIT)。</p><p>您的收益将随之进行调整，并会根据不含税的价格来进行计算。《付费 App 协议》的附录 B 将会更新，表明 Apple 在越南征收和汇付适用税款。</p><p>以上调整生效后，在“我的 App”中“价格与销售范围”部分会随即更新。您可以随时在 App Store Connect 中更改您的 App 和 App 内购买项目的价格 (包括自动续期订阅)。如果您有提供订阅项目，您可以选择为现有订阅者保留当前价格。</p><h3 id="苹果确认-iOS16-存漏洞影响新机激活"><a href="#苹果确认-iOS16-存漏洞影响新机激活" class="headerlink" title="苹果确认 iOS16 存漏洞影响新机激活"></a>苹果确认 iOS16 存漏洞影响新机激活</h3><p>据 MacRumors 看到的一份备忘录，苹果称，“iOS 16 有一个已知的问题，可能会影响到使用开放的 Wi-Fi 网络的设备激活”。为了解决这个问题，苹果表示，用户应该在初始化 iOS 时，在提示连接到 Wi-Fi 网络时选择“用 iTunes 连接到 Mac 或 PC”，然后返回到之前的屏幕，使用 Wi-Fi 再次尝试，直到激活成功。</p><h3 id="使用-iOS-16-1-Beta-版和-Xcode-14-1-Beta-版，开发实时活动功能"><a href="#使用-iOS-16-1-Beta-版和-Xcode-14-1-Beta-版，开发实时活动功能" class="headerlink" title="使用 iOS 16.1 Beta 版和 Xcode 14.1 Beta 版，开发实时活动功能"></a>使用 iOS 16.1 Beta 版和 Xcode 14.1 Beta 版，开发实时活动功能</h3><p>新的 ActivityKit 框架现已在 iOS 16.1 Beta 版和 Xcode 14.1 Beta 版中推出，探索如何通过这一框架为您的 App 构建实时活动。借由实时更新，实时活动能帮助用户跟踪您的 App 内容。App 的实时活动会显示在锁定屏幕和灵动岛中 — “灵动岛”作为一项全新设计，可以让用户直观、愉悦地体验 iPhone 14 Pro 和 iPhone 14 Pro Max。</p><p>实时活动功能和 ActivityKit 将包含在今年晚些时候推出的 iOS 16.1 中。当 iOS 16.1 发布候选版本可用时，您即可将配置了实时活动功能的 App 提交至 App Store。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="Swift-5-8-实现的提案"><a href="#Swift-5-8-实现的提案" class="headerlink" title="Swift 5.8 实现的提案"></a>Swift 5.8 实现的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0372-document-sorting-as-stable.md" title="SE-0372" target="_blank" rel="noopener">SE-0372</a> <strong>更新稳定排序文档</strong> 该提案已在 十三期周报 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0369-add-customdebugdescription-conformance-to-anykeypath.md" title="SE-0369" target="_blank" rel="noopener">SE-0369</a> <strong>同步 CustomDebugString 协议到 AnyKeyPath</strong> </p><p>此提案主要目的是将 <code>CustomDebugStringConvertible</code> 的协议添加到 <code>AnyKeyPath</code>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0367-conditional-attributes.md" title="SE-0367" target="_blank" rel="noopener">SE-0367</a> <strong>优化新属性的条件编译</strong> 。该提案已在 十二期周报 已通过的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) Swift 5.7 发布! 🥳 新增功能详见：<a href="https://www.swift.org/blog/swift-5.7-released/" title="Swift Evolution" target="_blank" rel="noopener">Swift Evolution</a> </p><p>2) <a href="https://forums.swift.org/t/initiative-swift-platform-work-group/60340" title="Swift Platform Work Group" target="_blank" rel="noopener">Swift Platform Work Group</a></p><p>Swift community 工作组将努力提高 Swift 的平台可用性</p><p>工作组内容包括：</p><ul><li>拓展 Swift 可用的目标平台</li><li>拓展 Swift 可用的主机平台</li><li>提高 Swift 现有平台上的 Toolchain</li><li>让 Swift 编译器可以在现有的平台上工作比如 Linux 和 Windows</li><li>努力打造更好的跨平台 Swift 生态系统</li></ul><p>工作组不涉及的内容有：</p><ul><li>涉及 Apple 已经支持的平台</li><li>涉及低资源和裸机平台</li></ul><p>3) 提议<a href="https://forums.swift.org/t/pre-pitch-explicit-protocol-fulfilment-with-the-conformance-keyword/60246" title="使用 conformance 关键字的让协议符合要求" target="_blank" rel="noopener">使用 conformance 关键字的让协议符合要求</a></p><p><code>conformance</code> 关键字的意思是：<strong>此声明由程序员定义并满足协议要求</strong>。<code>conformance</code> 不是 protocol 必须有的关键字。 但是，当 conformance 存在时，除非声明确实符合协议要求，否则程序格式错误。</p><p>栗子🌰：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HelloWorld</span>: <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    conformance <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// error: function crash() does not fulfill any requirement of the protocol 'Program'.</span></span><br><span class="line">    conformance <span class="function"><span class="keyword">func</span> <span class="title">crash</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4) 提议<a href="https://forums.swift.org/t/pitch-clock-sleep-for/60376" title="clock.sleep(for:)" target="_blank" rel="noopener">clock.sleep(for:)</a></p><p>5) 框架<a href="https://forums.swift.org/t/html-framework-for-swift/60241" title="用于web和swift server交互的框架" target="_blank" rel="noopener">用于web和swift server交互的框架</a></p><ul><li><a href="https://github.com/vapor/leaf" target="_blank" rel="noopener">vapor/leaf 8</a></li><li><a href="https://github.com/vapor-community/HTMLKit" target="_blank" rel="noopener">vapor-community/HTMLKit 9</a></li><li><a href="https://github.com/JohnSundell/Plot" target="_blank" rel="noopener">Plot 13</a></li></ul><p>6) 讨论<a href="https://forums.swift.org/t/call-an-async-function-in-an-initializer/60396" title="在init方法中使用async function" target="_blank" rel="noopener">在init方法中使用async function</a></p><p>7）讨论<a href="https://forums.swift.org/t/asyncsequence-stream-version-of-passthroughsubject-or-currentvaluesubject/60395" title="PassthroughSubject 和 CurrentValueSubject" target="_blank" rel="noopener">PassthroughSubject 和 CurrentValueSubject</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftui-lab.com/layout-protocol-part-1/" title="SwiftUI Layout 协议——第 1 部分" target="_blank" rel="noopener">SwiftUI Layout 协议——第 1 部分</a></p><p><strong>摘要：</strong> 今年 SwiftUI 新增比较实用的功能当属 Layout 协议。本篇文章主要介绍 Layout 协议的基础知识和常用功能使用。</p><p><a href="https://swiftui-lab.com/layout-protocol-part-2/" title="SwiftUI Layout 协议——第 2 部分" target="_blank" rel="noopener">SwiftUI Layout 协议——第 2 部分</a></p><p><strong>摘要：</strong> 本篇文章是 SwiftUI Layout 协议的第二部分介绍，主要讲述 Layout 协议的高级布局包含自定义动画、递归布局等功能。</p><p><a href="https://mp.weixin.qq.com/s/C739cypR-npGt7F8NLtQgQ" target="_blank" rel="noopener">SwiftUI 之 HStack 和 VStack 的切换</a></p><p><strong>摘要：</strong> 本文介绍了当涉及到水平和垂直的变体时( HStack 和 VStack )，我们需要如何在这两者之间动态的切换。</p><p><a href="https://mp.weixin.qq.com/s/QOB5alijsV5Gg8pi4lg03g" target="_blank" rel="noopener">App Store 已上架项目打开瞬闪问题</a></p><p><strong>摘要：</strong> 用户反馈 iPhone11 iOS14.7 下载安装 App Store 已上架项目后，点击图标，App 闪一下就回到了桌面。</p><p><a href="https://mp.weixin.qq.com/s/8fPJbPNA7kIZhnv3I8m4tg" target="_blank" rel="noopener">实现模块化应用的本地化</a></p><p><strong>摘要：</strong> 本文详细的介绍了本地化上线的过程，建议收藏，以后新开项目作为参考。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第五期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;欢迎投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;小时候幸福很简单，长大后简单很幸福。&lt;strong&gt;Swift社区&lt;/strong&gt;有你未领取的小幸福，等你简简单单来开启！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：iPhone灵动岛无法适配大部分应用&lt;/p&gt;
&lt;p&gt;提案：Swift 5.8 实现的提案&lt;/p&gt;
&lt;p&gt;Swift 论坛：&lt;code&gt;conformance&lt;/code&gt; 关键字&lt;/p&gt;
&lt;p&gt;推荐博文：SwiftUI 新功能 Layout 协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; 大厂养老，你会选择谁&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>实现模块化应用的本地化</title>
    <link href="https://fanbaoying.github.io/%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    <id>https://fanbaoying.github.io/实现模块化应用的本地化/</id>
    <published>2022-09-26T03:56:33.000Z</published>
    <updated>2022-09-26T03:59:50.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我已经有一段时间没有从头开始一个需要支持多种语言的新项目了。当然不是从头开始，而是在代码库中通过使用 Swift 包将代码分成不同模块。</p><p>我想提醒自己记住许多在本地化实行中的过程，所以我认为最好写一篇文章，以便下次开始同类型项目时可以参考。</p><a id="more"></a><h2 id="开始吧！"><a href="#开始吧！" class="headerlink" title="开始吧！"></a>开始吧！</h2><p>让我们看看代码库的一个简化版本。它包含一个 Xcode 项目，一个单独的 app target（即将运行的那个）和一个名为 <code>Features</code> 的 Swift 包。后者将包含 app 中所有页面的代码，每一页将被定义为自己的产品：</p><p><strong>Package.swift</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift-tools-version: 5.6</span></span><br><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"Features"</span>,</span><br><span class="line">    products: [</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">"Home"</span>,</span><br><span class="line">            targets: [<span class="string">"Home"</span>]),</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">"Detail"</span>,</span><br><span class="line">            targets: [<span class="string">"Detail"</span>]</span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"Home"</span></span><br><span class="line">        ),</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"Detail"</span></span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个 app target 将会作为 app 的组合层，其唯一的目的是导入每个功能，实例化它们并协调导航。所有的 UI ，演示和业务逻辑将留在各自的 “模块” 中（<code>Features Swift Package</code> 中的一个 target）。这将允许每个功能独立开发并完全的与其他功能隔离。</p><p>为了简单起见，这个例子里仅有两个功能：主页和详情，他们代表 app 中仅有的两个页面。</p><p>主页有一个按钮允许用户导航到详情页面，还有一个标签展示用户当前所在区域的语言代码。详情页只展示一个标签，和主页标签展示的信息一致：</p><p><img src="https://www.polpiella.dev/assets/posts/modularised-app-localisation/detail-home-en.png" alt="Images of both screens with english selected as the language"></p><h2 id="添加字符串！"><a href="#添加字符串！" class="headerlink" title="添加字符串！"></a>添加字符串！</h2><p>看起来不错，但是现在展示的信息是用英文通过硬编码编写的字符串。app 需要内容被翻译成另外两种语言：加泰罗尼亚语和西班牙语。</p><p>虽然有多种实现方式，我更倾向每个功能（或页面）只包含它所需要的本地化字符串，这样可以增加功能的可移植性和可重用性。</p><p>这可以在 Swift 包中完成，通过将所有必需的 <code>.lproj</code> 文件和所有需要本地化的内容（当前例子中只有 <code>Localizable.strings</code> 文件）放在目标文件夹下 - 我的习惯是放在父 <code>Resources/</code> 文件夹下，并将这些资源定义为 <code>Package.swift</code> 的特定 target。</p><p>添加文件之后构建该功能将导致编译器抛出如下错误：</p><p><img src="https://www.polpiella.dev/assets/posts/modularised-app-localisation/default-localisation-error.png" alt="Error thrown by Xcode when no default localisation is set"></p><p>这是因为 <code>defaultLocalization</code> 必须由 <code>Package.swift</code> 提供。所有功能的 target 来自一个包，所以只能有一个 <code>defaultLocalization</code> 。以下是 <code>Package.swift</code> 添加本地化内容之后的样子：</p><p><strong>Package.swift</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift-tools-version: 5.6</span></span><br><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"Features"</span>,</span><br><span class="line">    defaultLocalization: <span class="string">"en"</span>,</span><br><span class="line">    platforms: [.iOS(.v15)],</span><br><span class="line">    products: [</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">"Home"</span>,</span><br><span class="line">            targets: [<span class="string">"Home"</span>]),</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">"Detail"</span>,</span><br><span class="line">            targets: [<span class="string">"Detail"</span>]</span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"Home"</span>,</span><br><span class="line">            dependencies: [],</span><br><span class="line">            resources: [.process(<span class="string">"Resources/"</span>)]</span><br><span class="line">        ),</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"Detail"</span>,</span><br><span class="line">            resources: [.process(<span class="string">"Resources/"</span>)]</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果没有为默认的本地化代码提供本地化的内容，编译器会显示警告。这对于确保你不会发布包含基本本地化内容的软件包版本非常有帮助。</p><p><img src="https://www.polpiella.dev/assets/posts/modularised-app-localisation/missing-default-localisation.png" alt="Xcode warning shown when default localisation is missing."></p></blockquote><h2 id="支持本地化"><a href="#支持本地化" class="headerlink" title="支持本地化"></a>支持本地化</h2><p>可能与你的想法正好相反，把设备系统语言设置为加泰罗尼亚语或西班牙语并且运行 app 内容仍然用英文展示。原因是 Swift 包需要额外的信息去决定使用哪些本地化的内容，就目前来看，如果包里有目标内容，它们将只使用目标的基本本地化，否则使用包的默认本地化。</p><p>现在有两种方式我们可以实现本地化：使新的本地化在 app target 中可用或启用混合本地化。</p><h3 id="在-app-target-中添加新的本地化内容"><a href="#在-app-target-中添加新的本地化内容" class="headerlink" title="在 app target 中添加新的本地化内容"></a>在 app target 中添加新的本地化内容</h3><p>在 <code>Features</code>  Swift 包中启用新的本地化的一种方式是将它们添加到导入功能的 Xcode 项目中。这可以通过进入 Xcode 项目，在项目设置中的 “Info” 一栏，添加本地化支持：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/dfb90c005ba10bc3797eddaf4032e348.gif" alt=""></p><blockquote><p>需要注意的是，本地化需要至少一个文件（例如一个空的 <code>Localizable.strings</code> 文件）。在本例中，因为 app target 是用 UIKit 构建的，并且在添加新的本地化时选择了启动 storyboard 进行本地化（如上视频所示），所以已经有一个本地化文件。</p></blockquote><p>现在这将允许包从主包中获取支持的本地化，并选择相应的要使用的资源。</p><p>值得注意的是，如果设备有被 app 支持但是包不支持的语言，则后者将会回退到 <code>Package.swift</code> 中提供的 <code>defaultLocalization</code> .</p><p>同样的，如果 app 不支持该语言，同样会回退到相同的值。这也是为什么将 <code>defaultLocalization</code> 设置为与主目标基础语言相同，以确保所有页面上的一致性是非常重要的。这也是我更倾向于所有功能分组在一个 Swift 包之下的原因，这样所有页面上的 <code>defaultLocalization</code> 就有了单一真正的来源。</p><h3 id="允许混合本地化"><a href="#允许混合本地化" class="headerlink" title="允许混合本地化"></a>允许混合本地化</h3><p>虽然采用 app target 的本地化是首选方法，因为他确保了所有页面的一致性，并且只允许少数受支持的地方使用，但还有另一种方法允许包内容被本地化，而不必在主项目之外。</p><p>可以通过将 app 的 <code>Info.plist</code> 文件中的 <code>CFBundleAllowMixedLocalizations</code> 值设置为 <code>YES</code> 来实现。</p><p>这个设置将会告诉 app target 在不同的 target 或功能使用不同本地化是可以的，当添加新的本地化资源时， app 本地化会自动工作。</p><p><img src="https://www.polpiella.dev/assets/posts/modularised-app-localisation/enable-mixed-localizations.png" alt="Enabling mixed localisations in the app target"></p><p>使用这种方法需要注意以下几点：</p><p>1.不再需要将本地化添加到 app target，添加带有本地化内容的 <code>lproj</code> 到包资源就可以了。当用户修改区域时，如果你的资源包存在该语言包或默认提供 <code>Package.swift</code> ，软件包也会展示该区域的语言内容。</p><p>2.支持多少个区域就会有多少个本地化资源。这意味着没有一个单一的真实来源来确定整个 app 支持哪些本地化。这可能会导致一些问题，例如，某个功能有本地化资源内容，而该内容的本地化资源还未被应用。在本例中，除了删除资源，没有办法隐藏它。</p><video autoplay loop><br>  <source src="https://www.polpiella.dev/assets/posts/modularised-app-localisation/mixed-localisations.mp4" type="video/mp4"><br></video><p>第二点如上面的视频中所示，当用户把设备语言设置为法语。混合来源导致了不一致，因为主屏幕没有 <code>fr.lproj</code> –因此它又回到了默认本地化资源，英语。另一方面，在详情页面，有可用的本地化内容，这是正确翻译字符串的原因，正是这个原因，我喜欢将 app target 作为所有支持本地化的真实来源。</p><h2 id="额外提示-自动化"><a href="#额外提示-自动化" class="headerlink" title="额外提示 - 自动化"></a>额外提示 - 自动化</h2><p>我一直鼓励尽可能地自动化检索特定包的本地化字符串的流程。如果你的 app 有很多页面，希望使添加本地化字符串的过程尽可能简单和简便。</p><p>我一直在使用的一款工具 <a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener">SwiftGen</a>，它可以为各种资源生成 Swift 接口，例如 <code>Localizable.strings</code> 文件。</p><p>创建一个利用这个可执行文件的构建工具插件，可以使支持新本地化过程变得容易一点，并在各功能之间保持一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我已经有一段时间没有从头开始一个需要支持多种语言的新项目了。当然不是从头开始，而是在代码库中通过使用 Swift 包将代码分成不同模块。&lt;/p&gt;
&lt;p&gt;我想提醒自己记住许多在本地化实行中的过程，所以我认为最好写一篇文章，以便下次开始同类型项目时可以参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
