<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2021-11-22T06:31:33.856Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode -</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%20#4%20%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E9%97%B4%E5%80%BC/"/>
    <id>https://fanbaoying.github.io/LeetCode - #4 求两个有序数组的中间值/</id>
    <published>2021-11-22T06:31:18.000Z</published>
    <updated>2021-11-22T06:31:33.856Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>已知两个有序数组 <code>nums1</code> 和 <code>nums2</code>，他们的数据长度分别是 <code>n</code> 和 <code>m</code>，将两个数组合并成一个新数组，返回新数组的中间值。</p><p>整体的运行时间复杂度应该是 <code>O(log (m+n))</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">说明：合并后的新数组为 [1,2,3]，中间值为 2</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">说明：合并后的新数组为 [1,2,3,4]，中间值为 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0,0], nums2 = [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [], nums2 = [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2], nums2 = []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>nums1.length == m</li><li>nums2.length == n</li><li>0 &lt;= m &lt;= 1000</li><li>0 &lt;= n &lt;= 1000</li><li>1 &lt;= m + n &lt;= 2000</li><li>-106 &lt;= nums1[i], nums2[i] &lt;= 106</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="number">_</span> nums1: [Int], <span class="number">_</span> nums2: [Int])</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> m = nums1.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> n = nums2.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> m &gt; n &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> halfLength: <span class="type">Int</span> = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">0</span>, e = m</span><br><span class="line">        <span class="keyword">var</span> maxOfLeft = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> minOfRight = <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> b &lt;= e &#123;</span><br><span class="line">            <span class="keyword">let</span> mid1 = (b + e) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">let</span> mid2 = halfLength - mid1</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid1 &gt; <span class="number">0</span> &amp;&amp; mid2 &lt; n &amp;&amp; nums1[mid1 - <span class="number">1</span>] &gt; nums2[mid2] &#123;</span><br><span class="line">                e = mid1 - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid2 &gt; <span class="number">0</span> &amp;&amp; mid1 &lt; m &amp;&amp; nums1[mid1] &lt; nums2[mid2 - <span class="number">1</span>] &#123;</span><br><span class="line">                b = mid1 + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> mid1 == <span class="number">0</span> &#123;</span><br><span class="line">                    maxOfLeft = nums2[mid2 - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid2 == <span class="number">0</span> &#123;</span><br><span class="line">                    maxOfLeft = nums1[mid1 - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxOfLeft = <span class="built_in">max</span>(nums1[mid1 - <span class="number">1</span>], nums2[mid2 - <span class="number">1</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="type">Double</span>(maxOfLeft)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> mid1 == m &#123;</span><br><span class="line">                    minOfRight = nums2[mid2]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid2 == n &#123;</span><br><span class="line">                    minOfRight = nums1[mid1]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    minOfRight = <span class="built_in">min</span>(nums1[mid1], nums2[mid2])</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Double</span>(maxOfLeft + minOfRight) / <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log(n + m))</li><li>空间复杂度：O(1)</li><li>主要思想：** 对于 m 和 n 数字的数组，<code>nums1</code> 和 <code>nums2</code>，其中 <code>m &lt;= n</code>。要在 <code>nums1</code> 中找到 <code>mid1</code> 的索引，将数组分成左右部分：</li></ul><p><code>nums1[0, 1, ..., mid1 - 1]</code> | <code>nums1[mid1, mid1 + 1, ..., m]</code></p><p><code>nums2[0, 1, ..., mid2 - 1]</code> | <code>nums2[mid2, mid2 + 1, ..., n]</code></p><p>数组分后的左右部分要确保：</p><ul><li>左数 = 右数</li><li>左边的最大值 &lt;= 右边的最小值</li></ul><p>点击前往 <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">LeetCode</a> 练习 </p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode -</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%20#3%20%E6%9C%80%E9%95%BF%E6%9C%AA%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://fanbaoying.github.io/LeetCode - #3 最长未重复子字符串/</id>
    <published>2021-11-22T06:29:18.000Z</published>
    <updated>2021-11-22T06:29:41.228Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区从本期开始会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长)</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。</p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个字符串 <code>s</code>, 找出最长未重复的子字符串的长度.</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;abcabcbb&quot;</span><br><span class="line">输出： 3</span><br><span class="line">解释： 最长为重复的子字符串答案是 &quot;abc&quot;, 长度为 3.</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;bbbbb&quot;</span><br><span class="line">输出： 1</span><br><span class="line">解释： 最长为重复的子字符串答案是 &quot;b&quot;, 长度为 1.</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;pwwkew&quot;</span><br><span class="line">输出： 3</span><br><span class="line">解释： 最长为重复的子字符串答案是 &quot;wke&quot;, 长度为 3.</span><br><span class="line">注意答案必须是自字符串,“pwke” 是一个子列,而不是一个自字符串.</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;&quot;</span><br><span class="line">输出： 0</span><br></pre></td></tr></table></figure><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">0</span>, startIdx = <span class="number">0</span>, charToPos = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">let</span> sChars = <span class="type">Array</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i, char) <span class="keyword">in</span> sChars.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> pos = charToPos[char] &#123;</span><br><span class="line">                startIdx = <span class="built_in">max</span>(startIdx, pos)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// update to next valid position</span></span><br><span class="line">            charToPos[char] = i + <span class="number">1</span></span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, i - startIdx + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用字典存储非重复子字符串的下一个可能有效字符的位置,然后迭代字符串更新 maxLen、dictionary 和遇到重复时的 startIdx .</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(n)</li></ul><p>点击前往 <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区从本期开始会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长)&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode -</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%20#2%20Add%20Two%20Numbers/"/>
    <id>https://fanbaoying.github.io/LeetCode - #2 Add Two Numbers/</id>
    <published>2021-11-22T06:27:18.000Z</published>
    <updated>2021-11-22T06:28:25.834Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区从本期开始会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。</p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>已知两个非负整数（<code>例如：l1 = 342，l2 = 465</code>），将数字分别按相反的顺序存储到链表中（<code>例如：l1 = [2,4,3]，l2 = [5,6,4]</code>），每个节点都包含一个数字，将两个数字相加并将总和作为链表返回（<code>例如：[7,0,8]</code>）。</p><p>假设这两个数字不包含任何前导零(<code>例如：</code><del>012</del>)，除了数字 0 本身。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e825f8225274c4888fb02183f163807~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3]，l2 = [5,6,4]</span><br><span class="line">产出：[7,0,8]</span><br><span class="line">说明：342 + 465 = 807</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0]，l2 = [0]</span><br><span class="line">产出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">产出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>每个链表中的节点数在 [1, 100] 范围内</li><li>0 &lt;= 节点值 &lt;= 9</li><li>保证列表中没有前导零的数字</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var next: ListNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.next = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> l1 = l1 <span class="keyword">else</span> &#123;<span class="keyword">return</span> l2&#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> l2 = l2 <span class="keyword">else</span> &#123;<span class="keyword">return</span> l1&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> outputNode = <span class="type">ListNode</span>((l1.val + l2.val)%<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> l1.val + l2.val &gt; <span class="number">9</span> &#123;</span><br><span class="line">            outputNode.next = addTwoNumbers(addTwoNumbers(l1.next, l2.next),</span><br><span class="line">                                            <span class="type">ListNode</span>(<span class="number">1</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputNode.next = addTwoNumbers(l1.next, l2.next)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputNode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用进位并遍历两个链表</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>点击前往 <a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区从本期开始会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 1 Two Sum</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%20#1%20Two%20Sum/"/>
    <id>https://fanbaoying.github.io/LeetCode - #1 Two Sum/</id>
    <published>2021-11-22T06:26:18.000Z</published>
    <updated>2021-11-22T06:40:47.020Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区从本期开始会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。</p><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>已知一个整数数组 <code>nums</code> 和一个整数 <code>target</code>，取数组中任意两个值相加的和等 整数 <code>target</code>，返回这两个值在数组中的索引。</p><a id="more"></a><p><strong>假设：</strong></p><ol><li>只有一个有效答案</li><li>同一个值不能重复取两次</li><li>可以按任意顺序返回答案</li></ol><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15]，target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9，所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4]，target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3]，target = 6</span><br><span class="line">输出： [0,1]</span><br></pre></td></tr></table></figure><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (i, num) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastIndex = dict[target - num] &#123;</span><br><span class="line">                <span class="keyword">return</span> [lastIndex, i]</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            dict[num] = i</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"No valid outputs"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：遍历数组并在字典中存储目标 - nums[i]</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>该算法题解的 github 仓库地址是：<a href="https://github.com/soapyigu/LeetCode-Swift" target="_blank" rel="noopener">https://github.com/soapyigu/LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区从本期开始会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;/p&gt;
&lt;h2 id=&quot;1-描述&quot;&gt;&lt;a href=&quot;#1-描述&quot; class=&quot;headerlink&quot; title=&quot;1. 描述&quot;&gt;&lt;/a&gt;1. 描述&lt;/h2&gt;&lt;p&gt;已知一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;target&lt;/code&gt;，取数组中任意两个值相加的和等 整数 &lt;code&gt;target&lt;/code&gt;，返回这两个值在数组中的索引。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第六期/</id>
    <published>2021-10-25T03:27:35.000Z</published>
    <updated>2021-11-08T07:28:00.149Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png" alt=""></p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>译者言：周日立冬，北方多地迎来 2021 年的第一场雪，上海也降下大雨，此时你所在的城市降温了吗？记得添衣保暖，避免感冒生病影响工作和生活。</p><p><a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-13_2-release-notes#Swift" target="_blank" rel="noopener">Xcode 13.2 Beta</a> 版已具备并发支持，该特性将有助于解决很多 Swift 开发者的某些痛点。或许 Swift 内置的并发系统最重要的好处是，它允许以更简单的方式，并行执行多异步任务。可以想像，通过增加执行任务的速度这将节省我们更多时间。</p><a id="more"></a><p><a href="https://twitter.com/fassko" target="_blank" rel="noopener">Kristaps Grinbergs</a> Swift 周报负责人在本期周报中公开自己将不再领导 Swift 周报项目，原文如下：</p><p>我非常高兴地编写这么优秀并且已经运营了三年的 Swift 新闻周报。我遇到了很多了不起的人，并且感谢你们所有人，我已经收获了很多！ 这是为什么打出下面这句话，让我感慨万千的原因。第 200 期周报将是我运营的最后一期。我已经决定不再领导这个项目，并且怀着愉悦的兴奋，我正在寻找愿意继续管理 Swift 周报的人。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15408</strong> [Swift-DocC] <a href="https://bugs.swift.org/browse/SR-15408" title="Building documentation with a fallback display name that includes a space produces a broken-looking article" target="_blank" rel="noopener">用含有空格的回调显示名称构建文档会产生一篇无法阅读的文章</a> </p><p><strong>译者注：</strong> 如果将带有空格的回调显示名称（如 –fallback-display-name “My Display Name”）以及有效的符号图传递给 DocC，DocC 会生成一篇以“我的显示名称”作为 H1 的文章标题并将其组织在顶级框架页面上的“文章”主题组下。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p>新的 <a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-13_2-release-notes#Swift" target="_blank" rel="noopener">Xcode 13.2 Beta</a> 增加了对 macOS 10.15、iOS 13、tvOS 13 和 watchOS 6 或更高版本的 Swift 并发支持。 这种支持包括<code>async/await</code>、<a href="https://developer.apple.com/documentation/swift/actor" target="_blank" rel="noopener">actor</a>、全局 <code>actor</code>，结构化的并发及其任务 API。</p><p><strong>Tim Condon</strong> 发布了 <a href="https://forums.swift.org/t/async-await-has-arrived-in-vapor/53077" title="Async/await has arrived in Vapor" target="_blank" rel="noopener">Vapor</a> 已经支持 <code>async/await</code>。</p><p><strong>Konrad ktoso Malawski</strong> 写了一篇介绍 <a href="https://www.swift.org/blog/distributed-actors/" title="Introducing Swift Distributed Actors" target="_blank" rel="noopener">Swift Distributed Actors</a> 的文章。</p><p><strong>Marc Aupont</strong> 将加入 Diversity in Swift 工作组。</p><p>Swift 下载链接已移至新位置以提供更快的下载速度！ 工具链将托管在 <a href="https://www.swift.org/download/" target="_blank" rel="noopener">download.swift.org</a>，它将使用与当前 URL 类似的模式。 要使用新 URL，请将 <strong>swift.org/builds/</strong> 替换为 <strong>download.swift.org/</strong>。 从 2021 年 10 月 26 日开始，<strong>swift.org/builds</strong> URL 已重定向到新的子域。</p><p><strong>Sarun Wongpatcharapakorn</strong> 写了一篇博文解释 Swift 中的 <a href="https://sarunw.com/posts/what-is-keypath-in-swift/" title="What is a KeyPath in Swift" target="_blank" rel="noopener">KeyPath</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>Erik Eckstein</strong> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39902" title="First prototype of Performance Annotations" target="_blank" rel="noopener">实现了性能注释的原型</a>，如 Swift 中的 <code>@_noLocks</code> 和 <code>@_noAllocation</code>。</p><p><strong>Slava Pestov</strong> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39918" title="RequirementMachine: Improved handling of identity conformances" target="_blank" rel="noopener">改进了对“身份一致性”的处理 [P].[P] =&gt; [P]</a>。</p><p><strong>John McCall</strong> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39829" title="Fix the alignment of future fragments for highly-aligned result types" target="_blank" rel="noopener">修复了高度对齐的结果类型的未来片段的对齐方式</a></p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><strong>SE-0325</strong> <a href="https://forums.swift.org/t/accepted-with-modifications-se-0325-additional-package-plugin-apis/53086" title="[Accepted with Modifications] SE-0325: Additional Package Plugin APIs" target="_blank" rel="noopener">附加包插件 API</a> 提案已被修改并同意。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SE-0326</strong>: <a href="https://forums.swift.org/t/se-0326-multi-statement-closure-parameter-result-type-inference/52964" title="Multi-statement closure parameter/result type inference" target="_blank" rel="noopener">多语句闭包参数/结果类型推断</a>正在审查中.</p><p><strong>Kristaps Grinbergs</strong> 建议通过启用闭包体的参数和结果类型推断，来改进多语句闭包推断行为。 这将令类型推断更符合开发者的预期，并且移除现存的行为壁垒，即向闭包添加一个表达式或语句会导致编译失败的结果。</p><p><strong>SE-0327</strong>: <a href="https://forums.swift.org/t/se-0327-on-actors-and-initialization/53053" title="On Actors and Initialization" target="_blank" rel="noopener">On Actors and Initialization</a>正在审查中。</p><p><strong>Actors</strong> 是 Swift 中相对较新的名义类型，为其可变态提供了数据竞争安全性。数据保护是通过将每个 <code>actor</code> 实例可变状态一次最多隔离一个任务来实现的。引入 <code>actor</code>（<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md" title="Actors" target="_blank" rel="noopener">SE-0306</a>）的提案非常庞大和详细，但忽略了创建和销毁 <code>actor</code> 隔离状态的一些细微之处。 该提案旨在支持一个 <code>actor</code> 的定义，为了弄清一个 <code>actor</code> 实例的数据隔离何时开始和结束，以及在一个 <code>actor</code> 的 <code>init</code> 和 <code>deinit</code> 函数声明中能够做什么。</p><p><strong>SE-0328</strong>：<a href="https://forums.swift.org/t/se-0328-structural-opaque-result-types/53248" title="SE-0328: Structural opaque result types" target="_blank" rel="noopener">Structural opaque result</a> 类型正在审查中。</p><p><strong>Opaque</strong> 结果类型可以用作函数的结果类型、变量的类型或者下标的结果类型。在所有情况下， <strong>Opaque</strong> 结果类型必须是整个类型。该提案建议解除该限制，并且在“结构性”的位置中允许使用 <strong>Opaque</strong> 结果类型。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>一个来自 <strong>@justkwin</strong> 关于 <code>Foundation</code> 如何使用 <code>URL</code> 结束来表示 <code>file.paths</code> 的小历史<a href="https://forums.swift.org/t/get-folders-number-of-elements/" title="Get Folder’s Number of Elements" target="_blank" rel="noopener">教训</a>。</p><h3 id="II"><a href="#II" class="headerlink" title="II"></a>II</h3><p><strong>Anders Bertelrud</strong> 提出了添加<a href="https://forums.swift.org/t/pitch-package-manager-command-plugins/53172" title="[Pitch] Package Manager Command Plugins" target="_blank" rel="noopener">包管理器命令插件的提案</a>。</p><p><strong>SE-0303</strong> 引入了第一种 SwiftPM 插件，专注于使用自定义构建工具调用扩展构建系统的能力（特别是为了生成源代码）。 那些插件一直计划成为第一种被 SwiftPM 支持的插件。</p><p><strong>Kristaps Grinbergs</strong> 想提出一个提案草案，为 SwiftPM 添加另一种更通用目的的“命令插件”。 这些类型的插件可以由用户直接调用，用于源代码格式化、文档生成、测试报告生成等。命令插件不一定与构建系统有任何关系。</p><p>这些自定义命令插件一个重要的方面是它们可以要求插件主机（SwiftPM 或支持包的 IDE）按需生成专门的信息，或着初始化构建或测试运行。 这是提案草案中最需要仔细审查的部分。 在使 API 足够丰富以令其尽可能有用，同时也使其足够通用以不仅在 SwiftPM 中而且 IDE 中支持 Swift 包，这里有一个相悖的因素。</p><h3 id="III"><a href="#III" class="headerlink" title="III"></a>III</h3><p><strong>Guillaume Lessard</strong> 提出了一项提案，该提案将实现<a href="https://forums.swift.org/t/pitch-pointer-family-initialization-improvements/53168" title="[Pitch] Pointer family initialization improvements" target="_blank" rel="noopener">指针族初始化改进</a>。</p><p><code>UnsafeMutablePointer</code> 系列中的类型通常需要手动管理内存分配，包括对其初始化状态的管理。 涉及的状态是在分配后:</p><ol><li>未绑定和未初始化时（当在 <code>UnsafeMutableRawPointer.allocate()</code> 返回）</li><li>绑定到一个类型，并且未初始化（从 <code>UnsafeMutablePointer&lt;T&gt;.allocate()</code> 返回）</li><li>绑定到一个类型，并且初始化</li></ol><p>无论何时它未曾被初始化，内存都能够安全地销毁。</p><p>不幸的是，不是每一个 <code>UnsafeMutablePointer</code> 系列中的类型有这个必要功能，以用于全面管理它内存初始化的状态。 我们打算在本提案中解决这个问题，并提供在各种更广泛的情况下管理初始化状态的功能。</p><h3 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h3><p><strong>Kelvin Ma</strong> 展开了一个关于 <code>AsyncStream</code> 构造函数的<a href="https://forums.swift.org/t/asyncstream-constructor-which-also-returns-its-continuation/53251" title="AsyncStream constructor which also returns its Continuation" target="_blank" rel="noopener">讨论</a>，该构造函数也返回其 <code>Continuation</code>。</p><p>有没有什么方法我们可以向 <code>AsyncStream</code> 添加一个 API，它直接返回 <code>Continuation</code>，从而我们就不必把它的闭包“调来调去”？</p><p>一般来说，我也觉得 <code>AsyncStream</code> 真的很难使用，因为迭代在创建了 <code>AsyncStream</code> 的同一个任务中发生，甚至是没有并发迭代时曾出现。 这使“订阅” <code>actor</code> 对象生成的事件变得困难，即使订阅方法被标记为 <code>nonisolated</code>。</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p><strong>Adam Fowler</strong> 积极将 <code>MQTTNIO</code> 库<a href="https://forums.swift.org/t/mqttnio/53238" title="Mqttnio" target="_blank" rel="noopener">加入 SSWG 包列表中</a>.</p><p>MQTT 是一种通常用于与 IoT（物联网）设备进行通信的消息传递协议。 它是一种轻量级的发布/订阅消息传输，旨在具有较小的代码占用空间和网络带宽。</p><h3 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h3><p><strong>Cory Benfield</strong> 向我们<a href="https://forums.swift.org/t/swiftnio-swift-version-support/53232" title="SwiftNIO Swift version support" target="_blank" rel="noopener">更新了</a>关于 <code>SwiftNIO Swift</code> 版本支持。</p><p>SwiftNIO 团队已将其作为我们工作流程的主要支柱，以尝试在相当长的时间内支持 Swift 版本。大多数用户没有利用这一点，更愿意继续使用最新版本的 Swift，但我们认为重要的是你要有信心，新编写的应用程序将在未来获得一些有意义的支持。</p><h3 id="VII"><a href="#VII" class="headerlink" title="VII"></a>VII</h3><p><strong>Victoria Mitchell</strong> <a href="https://forums.swift.org/t/extending-swift-docc-to-support-objective-c-documentation/53243" title="Extending Swift-DocC to support Objective-C documentation" target="_blank" rel="noopener">写了一篇</a>关于扩展 <code>Swift-DocC</code> 以支持 <code>Objective-C</code> 的文档。</p><p><code>DocC</code> 的架构目前仅支持 <code>Swift</code> 一个语言的渲染符号文档。然而，有些跨语言项目可以从将多个“语言变体”收集到同一组文档中受益，例如可以被 <code>Swift</code> 中调用的 <code>Objective-C</code> API，反之亦然。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><div align="center"><br><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;译者言：周日立冬，北方多地迎来 2021 年的第一场雪，上海也降下大雨，此时你所在的城市降温了吗？记得添衣保暖，避免感冒生病影响工作和生活。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/xcode-release-notes/xcode-13_2-release-notes#Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xcode 13.2 Beta&lt;/a&gt; 版已具备并发支持，该特性将有助于解决很多 Swift 开发者的某些痛点。或许 Swift 内置的并发系统最重要的好处是，它允许以更简单的方式，并行执行多异步任务。可以想像，通过增加执行任务的速度这将节省我们更多时间。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第五期/</id>
    <published>2021-10-25T03:27:35.000Z</published>
    <updated>2021-10-25T06:51:47.647Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png" alt=""></p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Apple 举办了 <code>Unleashed</code> 活动发布了新品，借助超强的 <code>M1 Pro</code> 或 <code>M1 Max</code> 芯片，不管是基于新款的 <code>MacBook Pro</code> 开发应用，还是开发 <code>MacBook Pro</code> 下的应用，新机都将给我们带来突破性的性能和惊人的电池使用时长。</p><p>再加上强大的神经引擎，用于增强机器学习和升级的支持 <code>ProRes</code> 的媒体引擎，新款 <code>MacBook Pro</code> 能让我们的 App 做前所未有的事情。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15312</strong> [Swift-DocC] <a href="https://bugs.swift.org/browse/SR-15312" title="Add &#39;version&#39; command to docc command line tool" target="_blank" rel="noopener">添加 “version” 命令到 docc 命令行工具中</a> </p><p><strong>SR-15312</strong> [Swift-DocC] <a href="https://bugs.swift.org/browse/SR-15313" title="Primary tutorial navigation dropdown fails to bold the current tutorial when browser URL is not lowercased" target="_blank" rel="noopener">当浏览器 URL 不是小写时，主教程导航下拉菜单无法将当前教程字体加粗</a> </p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Franklin Schrans</strong> 宣布 <a href="https://swift.org/blog/swift-docc/" title="Swift-DocC is Now Open Source" target="_blank" rel="noopener">Swift-DocC</a> 将要开源.</p><p><strong>Marin Todorov</strong> 终于披露了他关于 <a href="https://github.com/apple/swift-markdown" title="Swift Markdown" target="_blank" rel="noopener"><code>Swift Markdown</code></a> 的工作.</p><p><strong>Federico Zanetello</strong> 写了一篇<a href="https://www.fivestars.blog/articles/warn_unqualified_access/" title="warn_unqualified_access" target="_blank" rel="noopener">文章</a>来说明 <code>@warn_unqualified_access</code> 的使用.</p><p><strong>Dave DeLong</strong> 解释了如何<a href="https://davedelong.com/blog/2021/10/09/simplifying-backwards-compatibility-in-swift/" title="Simplifying Backwards Compatibility in Swift" target="_blank" rel="noopener">简化 Swift 中的向后兼容性</a>。</p><p><code>Swift-DocC</code> 的文档现在已经发布在 <a href="https://swift.org/documentation/docc/" title="Docc" target="_blank" rel="noopener">Swift.org</a> (使用 <a href="https://forums.swift.org/t/documentation-for-swift-docc-is-now-on-swift-org/52914" title="Documentation for Swift-DocC is now on Swift.org" target="_blank" rel="noopener">Swift-DocC!</a>).</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SE-0325</strong> <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0325-swiftpm-additional-plugin-apis.md" title="Additional Package Plugin APIs" target="_blank" rel="noopener">附加包插件 API</a> 正在审查中。</p><p><strong>SE-0303</strong> 在 <code>SwiftPM</code> 中引入了定义构建工具插件的能力, 允许自定义工具在构建打包时被调用。为了支持该特性， <strong>SE-0303</strong> 引入了最小初始 API，插件能够通过该接口获取那些被唤起构建的 Target 的相关信息。</p><p>该提案扩展了插件 API 以提供更多上下文，包括更丰富的包图表示。 这是为将来支持新类型的插件做准备。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>1. Nuri Amari</strong> 提出了<a href="https://forums.swift.org/t/pitch-improved-clangimporter-diagnostics/52687" title="Improved ClangImporter Diagnostics" target="_blank" rel="noopener">改进 ClangImporter</a> 的建议。</p><p>提出对 <code>ClangImporter</code> 的改进建议，当导入 <code>C</code> 或 <code>Objective-C</code> 实体发生错误时提供更详细的反馈。 就目前而言，当 <code>ClangImporter</code> 无法完全或部分导入实体（函数、类型、宏等）时，出现错误是不会提示的。当前的 Swift 编译错误大部分情况下会提示<strong>从未定义过实体</strong>。</p><p><strong>2. Frederick Kellison-Linn</strong> 提出了<a href="https://forums.swift.org/t/pitch-generalize-keypath-to-function-conversions/52681" title="Generalize keypath-to-function conversions" target="_blank" rel="noopener">关键路径到函数转换</a>的想法。</p><p>该提案介绍了在允许 <code>(Root) -&gt; Value</code> 函数的情况下使用键路径表达式 <code>\Root.value</code> 的能力。</p><p><code>Swift-evolution</code> 线程：<a href="https://forums.swift.org/t/key-path-expressions-as-functions/19587" title="Key Path Expressions as Functions" target="_blank" rel="noopener">关键路径表达式作为函数</a></p><p><strong>3. Patrick Pijnappel</strong> 提出了为 <a href="https://forums.swift.org/t/pitch-exhaustive-pattern-matching-for-non-open-classes/52718" title="Exhaustive pattern matching for non-open classes" target="_blank" rel="noopener">non-open 类实现详尽模式匹配</a>的建议。</p><p>由于现在区分了开放类和非开放类，非开放类层次结构应该能够完全匹配。对于添加新子类，不需要添加任何语法就可以完成。</p><p><strong>4. Guillaume Lessard</strong> 提出了对<a href="https://forums.swift.org/t/pitch-pointer-usability-improvements/52736" title="Pointer Usability Improvements" target="_blank" rel="noopener">指针可用性</a>的改进。</p><p>该提案为 <code>UnsafePointer</code>、<code>Mutable</code> 和 <code>Raw</code> 引入了一些 quality-of-life 改进。</p><ol><li>添加 API 获取一个 <code>UnsafeRawPointer</code> 实例，这是一个从起点推进到给定对齐的实例</li><li>在给定 <code>UnsafePointer&lt;T&gt;</code> 的情况下，添加一个 API 获取指向聚合的存储属性的指针 T</li><li>将<code>Unsafe[Mutable]Pointer</code> 未选中的下标重命名为包含 <code>unchecked</code> 标签</li><li>添加比较任意两种类型的指针的能力</li></ol><p><strong>5. Pavel Yaskevich</strong> 提出了改进<a href="https://forums.swift.org/t/pitch-light-weight-same-type-constraint-syntax/52889" title="Light-weight same-type constraint syntax" target="_blank" rel="noopener">相同类型约束语法</a>的建议。</p><p>为了实现改进泛型 UI 的目标，我们提出几项改进措施，为了解决协议和泛型类型之间的语法差距，在<strong>关联类型</strong>和<strong>泛型类型</strong>参数相同类型的约束上，隐藏了一些复杂性（视觉上和认知上）。</p><p><strong>6. Holly Borla</strong> 开始讨论如何<a href="https://forums.swift.org/t/discussion-easing-the-learning-curve-for-introducing-generic-parameters/52891" title="Easing the learning curve for introducing generic parameters" target="_blank" rel="noopener">简化引入泛型参数的学习曲线</a>。</p><p>Swift 的泛型系统具有很强的表达能力，但是要理解具有相关类型的协议、带有 where 子句的泛型签名以及其他泛型特性的完整通用性，是将泛型引入 Swift 项目的一个重大障碍。泛型系统的主要目标是通过改进在 Swift 中编写泛型代码的人体工程学，将具体API抽象为泛型API的学习曲线。本次讨论目的是就实现这一目标的可能方向征求意见，并收集在社区中提出的其他想法。欢迎在文末留言提出问题、评论和想法！</p><p>本帖中的许多想法都是由 <strong>@Joe_Groff</strong> 在<a href="https://forums.swift.org/t/improving-the-ui-of-generics/22814" title="Improving the UI of generics" target="_blank" rel="noopener">改进泛型 UI</a> 中提出的。</p><p><strong>7. Nate Cook</strong> 提出了一个<a href="https://forums.swift.org/t/pitch-character-classes-for-string-processing/52920" title="Character Classes for String Processing" target="_blank" rel="noopener">用于字符串处理的字符类</a>的想法。</p><p><a href="https://forums.swift.org/t/declarative-string-processing-overview/52459" title="Declarative String Processing Overview" target="_blank" rel="noopener">声明性字符串处理概述</a>讲述了正则表达式支持的匹配，但没有关于语法和语义的详细信息，将澄清留给后续介绍。</p><p><a href="https://forums.swift.org/t/pitch-regular-expression-literals/52820" title="Regular Expression Literals" target="_blank" rel="noopener">正则表达式的文本</a>提供了关于正则表达式语法的更多细节，例如分隔符和 <code>PCRE-syntax</code> 内部结构，省略了对正则表达式语义的讨论。本帖的目的旨在解决正则表达式语义的目标子集：<strong>字符类的定义</strong>。我们建议直接在现有的 <code>Character</code> 和 <code>Unicode.Scalar</code> 上和新提出的 API 背景下来处理。</p><p>正则表达式中的字符类包括元字符，例如匹配数字的 <code>\d</code>、匹配空格的 <code>\s</code> 和 匹配任何字符的 <code>.</code>。单个文字字符也可以被认为是字符类，因为它们至少与自己匹配，并且在不区分大小写的匹配中，与大小写切换的对应字符匹配。因此，将字符类视为正则表达式字面量的任何部分，该部分可以匹配字符串的实际组件。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://mp.weixin.qq.com/s/vjC45D5249397bfUCXfhLg" target="_blank" rel="noopener">Swift 5 从零到精通 iOS 开发训练营</a></p><p>《Swift 5 从零到精通 iOS 开发训练营》是一本从基础到 iOS 项目开发的实战教程，由资深 iOS 开发程序员珲少亲自操刀编撰而成。<code>文末有送书抽奖，抽奖为 Swift社区 额外福利</code></p><p><a href="**https://mp.weixin.qq.com/s/qM4O-wBCZgvn0oFCR7kIbA**">iOS UI 自动化测试原理以及在 Trip.com 的应用实践</a></p><p>来自携程 IBU 公共无线倪瑶的实战分享： iOS UI 自动化测试实战以及原理总结。</p><p><a href="https://mp.weixin.qq.com/s/7-QlpcfhTaw4D_SmQYbmfA" target="_blank" rel="noopener">一文带你读懂 Swift 社区最新开源的算法库</a></p><p>最近 Swift 社区动作频频，又是登陆 Windows，又是推出底层基础库。现在又推出了 Swift 算法库，现在让我们看看里面到底有什么内容，是否值得现在在生产中应用，面对内容丰富的 <code>raywenderlich/swift-algorithm-club</code> 是否有足够的竞争力呢。</p><p><a href="https://mp.weixin.qq.com/s/aoQuDd58LQRSbJty5Tyjfw" target="_blank" rel="noopener">多角度体会 Swift 方法派发</a></p><p>我们知道 Swift 有三种方法派发方式：静态派发（直接派发）、VTable 派发（函数表派发）、消息派发。下面我们分别从 SIL 中间语言，以及汇编的角度体会 Swift 的方法派发方式。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><div align="center"><br><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Apple 举办了 &lt;code&gt;Unleashed&lt;/code&gt; 活动发布了新品，借助超强的 &lt;code&gt;M1 Pro&lt;/code&gt; 或 &lt;code&gt;M1 Max&lt;/code&gt; 芯片，不管是基于新款的 &lt;code&gt;MacBook Pro&lt;/code&gt; 开发应用，还是开发 &lt;code&gt;MacBook Pro&lt;/code&gt; 下的应用，新机都将给我们带来突破性的性能和惊人的电池使用时长。&lt;/p&gt;
&lt;p&gt;再加上强大的神经引擎，用于增强机器学习和升级的支持 &lt;code&gt;ProRes&lt;/code&gt; 的媒体引擎，新款 &lt;code&gt;MacBook Pro&lt;/code&gt; 能让我们的 App 做前所未有的事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四期/</id>
    <published>2021-10-22T07:19:18.000Z</published>
    <updated>2021-10-22T07:20:03.353Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 Swift.org 进行了一些非常好的改进，包括对 <code>dark mode</code> 的支持。 对于在 iOS 上使用 <code>dark mode</code> 的用户，该网站将自动切换模式以匹配。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15271</strong> [Compiler] <a href="https://bugs.swift.org/browse/SR-15271" title="Improve Codable Diagnostics When CodingKeys Do Not Match Properties" target="_blank" rel="noopener">当 CodingKeys 与属性不匹配时改进可编码诊断</a></p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Ted Kremenek</strong> 写了一篇关于 <a href="https://swift.org/blog/swift-5-5-released/" title="Swift 5.5 Released" target="_blank" rel="noopener">Swift 5.5 版本</a>的文章。</p><p><strong>Bruno Rocha</strong> 发表了一篇优秀的文章，解释了 <a href="https://swiftrocks.com/how-asyncsequence-works-internally-in-swift" title="How AsyncSequence works internally in Swift" target="_blank" rel="noopener">AsyncSequence 在 Swift 内部是如何工作</a>的。</p><p><strong>Lee Kah Seng</strong> 写了一篇文章，描述了 <a href="https://swiftsenpai.com/swift/actor-reentrancy-problem/" title="The Actor Reentrancy Problem in Swift" target="_blank" rel="noopener">Swift 中的 Actor Reentrancy 问题</a>。</p><p><strong>Amritpan Kaur</strong> 解释了她如何参与首届 <a href="https://forums.swift.org/t/swift-mentorship-compiler-language-design/52522" title="Swift Mentorship - Compiler &amp; Language Design" target="_blank" rel="noopener">Swift 导师，并致力于编译器开发和语言设计</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>Michael Ilseman</strong> 合并了一个为 <a href="https://github.com/apple/swift/pull/38922" title="[stdlib] Implement native normalization for String" target="_blank" rel="noopener">String 实现原生规范化</a>的 pull request。</p><p><strong>Doug Gregor</strong> 创建了一个 pull request，<a href="https://github.com/apple/swift/pull/39609" title="Back-deploy @objc actor types" target="_blank" rel="noopener">向后兼容  @objc actor 类型</a>。</p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><strong>SE-0322</strong> <a href="https://forums.swift.org/t/accepted-with-modifications-se-0322-temporary-uninitialized-buffers/52532" title="Temporary Uninitialized Buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>已接受修改。</p><p><strong>SE-0323</strong> <a href="https://forums.swift.org/t/accepted-se-0323-asynchronous-main-semantics/52531" title="Asynchronous Main Semantics" target="_blank" rel="noopener">Asynchronous Main 语义</a>已接受。</p><p><strong>SE-0324</strong> 接受了<a href="https://forums.swift.org/t/accepted-se-0324-relax-diagnostics-for-pointer-arguments-to-c-functions/52599" title="Relax diagnostics for pointer arguments to C functions" target="_blank" rel="noopener">对 C 函数的指针参数放宽诊断</a>提案。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SSWG-0017</strong>：<a href="https://forums.swift.org/t/sswg-0017-multipartkit/52586" title="MultipartKit" target="_blank" rel="noopener">MultipartKit</a> 正在审查中。</p><p><code>MultipartKit</code> 提供 <code>Multipart</code> 数据的低级解析和序列化，以及对 <code>Multipart</code> 表单数据的编码和解码的高级 <code>Codable</code> 支持。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>1. Karoy Lorentey</strong> 询问什么时候将 <code>ManagedAtomic/UnsafeAtomic</code> 标记为 <code>Sendable</code>？</p><p>刚刚提交了<a href="https://github.com/apple/swift-atomics/issues/45" title="The constructs provided by this package need to be marked Sendable" target="_blank" rel="noopener">问题 #45</a>，要求将 <code>UnsafeAtomic</code>、<code>ManagedAtomic</code> 和朋友标记为 <code>Sendable</code>，这反映了它们可以安全地跨并发域传输。</p><p><strong>2. Kavon Farvardin</strong> 提议定义 <a href="https://forums.swift.org/t/proposal-actor-initializers-and-deinitializers/52322" title="[proposal] Actor Initializers and Deinitializers" target="_blank" rel="noopener">actor 初始化器</a>在 <code>Swift</code> 中的工作方式。</p><p>目前，本提案中描述的一些问题的建议解决方案通过警告反映在 <code>Swift 5.5</code> 中，但是审查 <code>Swift 6</code> 的这些更改很重要。此外，该提案为 <code>MainActor</code> 隔离类的 <code>deinit</code> 增加了额外的功能，这样可以更容易、更安全地编写。如果有新的想法和评论可以在<a href="https://github.com/kavon/swift-evolution/blob/actor-init-proposal2/proposals/nnnn-actor-initializers.md" title="Actor Initializers and Deinitializers" target="_blank" rel="noopener">这里提出来</a>。</p><p><strong>3. Kelvin Ma</strong> 发现 <a href="https://forums.swift.org/t/swift-5-5-has-serious-stack-corruption-bugs/52344" title="Swift 5.5 has serious stack corruption bugs!" target="_blank" rel="noopener">Swift 5.5 存在严重的堆栈损坏错误</a>。</p><p>我发现了几个与 async/await 相关的堆栈损坏错误，这些错误可以在使用最近的夜间工具链编译的简单测试程序中重现。 我已经确认 5.5-RELEASE 工具链中存在这些错误中的两个三四个。</p><p>我发现了几个与 <code>async/await</code> 相关的堆栈损坏错误，可以在 <code>recent nightly toolchains</code> 的简单测试程序中重现问题。<strong>我已确认 <code>5.5-RELEASE toolchain</code> 中存在多个错误</strong>。</p><p><strong>4. Becca Royal-Gordon</strong> 提出了在<a href="https://forums.swift.org/t/pitch-2-staging-in-sendable-checking/52413" title="Staging in Sendable checking" target="_blank" rel="noopener">Sendable 检查中添加暂存</a>的建议。</p><p>几周前，<strong>@Douglas_Gregor</strong> <a href="https://forums.swift.org/t/pitch-staging-in-sendable-checking/51341" title="[Pitch] Staging in Sendable checking" target="_blank" rel="noopener">提出了一些更改</a>，试图解决在一些客户端或依赖项可能尚未更新时在模块中采用 Sendable 检查所涉及的一些问题。当模块最终更新时，这种方法可能会出现问题和隐藏的 BUG，以及 <code>Objective-C</code> 库如何能够控制其类型的可发送性。</p><p><strong>5. YR Chen</strong> 开始讨论<a href="https://forums.swift.org/t/upon-swift-6-solve-inconsistency-within-the-language/52437" title="Upon Swift 6: Solve inconsistency within the language" target="_blank" rel="noopener">解决 Swift 6 发布时的不一致问题</a>。</p><p>一些 API 破损的语言设计可以在 3 年后 <code>Swift 6</code> 的发布中修复。这是一个相当长的时间，通过 <code>Swift 3.2</code> 和 <code>Swift 4.2</code> 事实证明，过渡到 Swift 突破性发布要顺畅的多。</p><p>建议我们选择一些延迟的断点，目的是消除语言中的不一致。这些想法已经得到了社区的积极反馈，但是还是没有开始实施。</p><p><strong>6. Philippe Hausler</strong> 提出了<a href="https://forums.swift.org/t/pitch-clock-instant-date-and-duration/52451" title="[Pitch] Clock, Instant, Date, and Duration" target="_blank" rel="noopener">定义 Clock, Instant, Date 和 Duration </a>的提案。</p><p><strong>时间的概念可以分为三个不同的部分：</strong></p><ul><li>提供现在概念的项目加上一个在给定时间点后醒来的方法，* 时间点的概念</li><li>时间测量的概念</li></ul><p>这三项分别是时钟、瞬间和持续时间。时间的测量可用于许多类型的 API，从高级网络连接超时概念到休眠任务的时间量。目前，测量时间类型的 API 采用 <code>NSTimeInterval</code> 又名 <code>TimeInterval</code>、<code>DispatchTimeInterval</code>，甚至像 <code>timespec</code> 这样的类型。</p><p><strong>7. Michael Ilseman</strong> 提出了<a href="https://forums.swift.org/t/declarative-string-processing-overview/52459" title="Declarative String Processing Overview" target="_blank" rel="noopener">实现声明性字符串处理</a> API 的想法。</p><p>字符串处理很困难，Swift 标准库目前提供的功能不足。我们建议添加两个新的声明性字符串处理 API，一个是熟悉的 <code>Regex</code> 文本，一个是更强大的 <code>Pattern</code> 结果生成器，以便 Swift 字符串处理起来更快速简便。</p><p>这是一个大型功能，最终将分为多个 <code>Swift Evolution</code> 提案。主要目的在于推动高级方向的讨论，并介绍该功能的关键点及其相互关系。</p><p><strong>8. Kelvin Ma</strong> 开始讨论<a href="https://forums.swift.org/t/we-need-long-term-support-lts-releases/52462" title="long-term-support (“LTS”) releases." target="_blank" rel="noopener">长期支持 (“LTS”) 版本</a>。</p><p>对于那些没有关注开发主题的人，@mickeyl，@timdecode，我最近在 <code>Swift 5.5</code> 发布工具链中发现了数量惊人的高危险的堆栈损坏 BUG。</p><p>撇开 <code>Swift 5.5</code> 中堆栈损坏问题的技术方面不谈，在我们发布周期中采用某种形式的<a href="https://forums.swift.org/t/we-need-long-term-support-lts-releases/52462" title="“Long-Term Support” (LTS) release 8 " target="_blank" rel="noopener">“长期支持”（LTS）版本8</a>的概念是否值得，就像 Ubuntu 一直以来所做的那样。</p><p><strong>9. Anders Bertelrud</strong> 提出了扩展插件 <a href="https://forums.swift.org/t/pitch-additional-api-available-to-swiftpm-plugins/52494" title="pitch additional api available to swiftpm plugins" target="_blank" rel="noopener">SwiftPM 插件 API </a>以提供更多上下文的提案。</p><p><code>SE-0303</code> 引入了 SwiftPM 插件，特别关注构建工具插件（尤其是那些生成源代码的插件）。为了保持该提案的界限，插件可用的信息类型和数量针对生成构建命令的任务。</p><p>在开始考虑新类型的插件之前，扩展所有类型插件可用的信息似乎是明智的。未来的提案可能会为特定类型的插件添加特定的 API，但在此之前，一个好的起点似乎是让所有插件访问 SwiftPM 内部已经拥有的包图的提炼形式。这应该允许任何特定插件有很大的自由度。</p><p>我提出一份提案草案，用于扩展可用于 SwiftPM 插件的 API，并且很想听听大家的想法。在 SwiftPM 存储库中的 PR 中有一个实现。</p><p><strong>10. Guillaume Lessard</strong> 提出了一项<a href="https://forums.swift.org/t/pitch-expand-usability-of-withmemoryrebound/52500" title="expand usability of withMemoryRebound" target="_blank" rel="noopener">扩大 withMemoryRebound 可用性</a>的提案。</p><p>函数 <code>withMemoryRebound(to:capacity:_ body:)</code> 执行一个闭包，同时将一定范围的内存临时绑定到与被调用者绑定的类型不同的类型。</p><p>我们建议解除 <code>withMemoryRebound</code> 的一些显着限制，并启用重新绑定到更大的类型集，以及从原始内存指针和缓冲区重新绑定。</p><p><strong>11. Tim Condon</strong> 向我们介绍了 <a href="https://forums.swift.org/t/async-await-and-the-future-of-vapor/52590" title="async/await and the future of Vapor." target="_blank" rel="noopener">async/await 和 Vapor 的未来</a>。</p><p><strong>12. Drew McCormack</strong> 提出了一项提案，该提案将创建用于<a href="https://forums.swift.org/t/proposal-a-standard-library-type-for-working-with-shared-data-in-a-concurrent-system/52603" title="standard library data structures designed for working with shared data in a concurrent system." target="_blank" rel="noopener">在并发系统中处理共享数据的标准库数据结构</a>。</p><p>我想在这里提出这样一种类型：分支资源。</p><p><code>BranchingResource</code> 将是一种类型，其携带的有效负载（即资源）具有通用参数。 资源将从单个分支开始，称为“<code>main</code>”或“<code>trunk</code>”或“<code>truth</code>”。 该应用程序可以添加任意数量的辅助命名分支。</p><p><strong>13. Pavel Yaskevich</strong> 提出了<a href="https://forums.swift.org/t/pitch-enable-multi-statement-closure-parameter-result-type-inference/52619" title="enable multi-statement closure parameter/result type" target="_blank" rel="noopener">启用 multi-statement closure parameter/result type 推断</a>的想法。</p><p>我建议通过从闭包主体中启用参数和结果类型推断来改进多语句闭包的推理行为。</p><p>这将使开发人员的类型推断不那么令人惊讶，并消除了在闭包中添加多一个表达式或语句可能会导致编译失败的问题。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><h3 id="iOS-系列"><a href="#iOS-系列" class="headerlink" title="iOS 系列"></a>iOS 系列</h3><p><a href="https://mp.weixin.qq.com/s/ZprPxK8NbMqpP9flmWRagg" target="_blank" rel="noopener">百度一面总结（含答案）</a></p><p><a href="https://mp.weixin.qq.com/s/PYzQN5HYXLU1JuXBAZNyhQ" target="_blank" rel="noopener">使用 Swift 实现 Promise</a></p><p>我最近在找如何使用 Swift 实现 <code>Promise</code> 的资料，因为没找到好的文章，所以我想自己写一篇。通过本文，我们将实现自己的 <code>Promise</code> 类型，以便明了其背后的逻辑。</p><p><a href="https://mp.weixin.qq.com/s/8_utYi3y7I3ukh4VpnIM3A" target="_blank" rel="noopener">用 Swift 实现轻量的属性监听系统</a></p><p>本文的主要目的是解决客户端开发中对“模型的一处修改，UI 要多处更新”的问题。当然，我们要知晓解决方案的细节和思考过程，以及看到其能达到的效果。我们会用到函数式编程的思想，以及伟大的“泛型”。</p><h3 id="SwiftUI-系列"><a href="#SwiftUI-系列" class="headerlink" title="SwiftUI 系列"></a>SwiftUI 系列</h3><p><a href="https://mp.weixin.qq.com/s/hfe1m5bNiA0DzdFTEvi9sQ" target="_blank" rel="noopener">用 SwiftUI 实现 3D Scroll 效果</a></p><p>学完本教程后，你就可以在你的 App 中把这种 <code>3D</code> 效果加入任何自定义的 SwiftUI 视图。</p><p><a href="https://mp.weixin.qq.com/s/TD0I96HSUoTNmOmfySCtYQ" target="_blank" rel="noopener">如何让 SwiftUI 的列表变得更加灵活</a></p><p><code>List</code> 可能是 <code>SwiftUI</code> 附带的内置视图中最常用的一种，它使我们能够在任何 <code>Apple</code> 平台上呈现“类似于表格视图”的用户界面。今年，<code>List</code> 获得了许多非常重要的升级，使其更加灵活和易于定制。让我们看看都有哪些新功能。</p><p><a href="https://mp.weixin.qq.com/s/snJJi9KYViFErdJAP1HEPQ" target="_blank" rel="noopener">使用 SwiftUI 创建万花尺</a></p><p>为了完成一些真正意义上的绘图工作，我将带您通过创建一个简单的带 SwiftUI 的 <code>spirograph</code>。“Spirograph”是一种玩具的商标名称，你把一支铅笔放在一个圆圈里，然后绕着另一个圆圈的圆周旋转，创造出各种几何图案，称为轮盘赌——就像赌场游戏一样。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近 Swift.org 进行了一些非常好的改进，包括对 &lt;code&gt;dark mode&lt;/code&gt; 的支持。 对于在 iOS 上使用 &lt;code&gt;dark mode&lt;/code&gt; 的用户，该网站将自动切换模式以匹配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三期/</id>
    <published>2021-10-22T07:18:12.000Z</published>
    <updated>2021-10-22T07:18:59.097Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本期周报开始，将会引入<strong>推荐博文</strong>模块，主要为大家分享展示优秀的 iOS 技术博文，如果大家阅读到优秀的文章欢迎在文末留言告诉小编，大家资源共享共同进步。</p><p>iPhone 13 新品上架，你们都买了吗？苹果声称，iPhone 13 拥有全新的双摄像头系统，采用超快的 <code>A15</code> 芯片，提高电池的续航能力。</p><p>我们不仅要关注新的 iPhone 13，几天前，<code>Xcode 13</code> 与 <a href="https://forums.swift.org/t/swift-5-5-released/52247" title="Swift 5.5" target="_blank" rel="noopener">Swift 5.5</a> 也一起发布了。这是 Swift 5.5 更新的<a href="https://twitter.com/simjp/status/1440318174856036354" title="列表" target="_blank" rel="noopener">列表</a>，这个版本发布了很多新功能。Xcode 13 的发布说明可以在这里找到：<a href="https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes" title="iOS &amp; iPadOS 15 Release Notes" target="_blank" rel="noopener">iOS &amp; iPadOS 15 Release Notes</a>。</p><p>现在已经开始将<strong>并发</strong>功能向后部署到旧的 Swift 版本上。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Cory Benfield</strong> 告诉我们 <a href="https://forums.swift.org/t/swift-crypto-2-0-0/52308" title="Swift Crypto 2.0.0" target="_blank" rel="noopener">Swift Crypto 2.0.0 已经发布</a>。</p><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15218</strong>: [Compiler] <a href="https://bugs.swift.org/browse/SR-15218" title="Enhance interchangeable CGFloat/Double to allow interchange between optional" target="_blank" rel="noopener">增强 CGFloat/Double 之间的可互转，允许 optional 之间的互转</a></p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>salinas-miguel</strong> 的 PR 已合并：<a href="https://github.com/apple/swift/pull/39216" title="Remove Foundation dependency" target="_blank" rel="noopener">删除了 Swift 项目对 macOS 上的 Foundation 的依赖</a>。</p><p>Doug Gregor 创建了一个 <code>pull request</code> <a href="https://github.com/apple/swift/pull/39342" title="Back-deployment support for Swift concurrency" target="_blank" rel="noopener">对 Swift 向后部署支持并发</a>。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SE-0323</strong>：<a href="https://forums.swift.org/t/se-0323-asynchronous-main-semantics/52022" title="Asynchronous Main Semantics" target="_blank" rel="noopener">Asynchronous Main 语义</a> 正在审查中。</p><p>程序设置通常发生在 <code>main</code> 函数中，开发人员希望在程序的其他部分运行之前执行操作。<code>Objective-C</code>、<code>c++</code> 和 <code>C</code> 都有初始化，这些初始化在 <code>main</code> 入口点执行之前运行，并且可以与   Swift 的并发系统交互。在 Swift 并发模型中，开发人员编写的异步 <code>main</code> 函数被包装在一个任务中，并在 <code>main</code> 入口点运行时被放入到主队列中。如果初始化时在主队列中插入了一个任务，那么该任务可能会在 <code>main</code> 函数之前执行，所以设置是在初始化任务运行之后执行的。</p><p><strong>SE-0324</strong>：<a href="https://forums.swift.org/t/se-0324-relax-diagnostics-for-pointer-arguments-to-c-functions/52019" title="Relax diagnostics for pointer arguments to C functions" target="_blank" rel="noopener">对 C 函数的指针参数放宽诊断</a>正在审查中。</p><p><code>C</code> 有特殊的指针别名规则，例如允许 <code>char *</code> 为其他指针类型别名，并允许指向有符号和无符号类型的指针别名。 某些 <code>C</code> <code>API</code> 的可用性依赖于在这些规则的边界内轻松转换指针的能力。 Swift 通常不允许类型化指针转换。请参阅<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0107-unsaferawpointer.md" title="UnsafeRawPointer API" target="_blank" rel="noopener">SE-0107 UnsafeRawPointer API</a>。让 Swift 编译器在调用从 <code>C</code> 头文件导入的函数时允许在 <code>C</code> 规则内进行指针转换将显著提高互操作性，而不会对类型安全产生负面影响。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>Ashley Garland</strong> 介绍一些新实验出来的 <a href="https://forums.swift.org/t/swift-snippets/51947" title="Swift Snippets" target="_blank" rel="noopener">Swift Package Manager 代码段</a>。</p><p>我们都知道通过示例学习是很棒的，尤其是对于代码。 我想创建最小、最简单的方法来为 <code>Swift packages</code> 提供示例代码，我刚刚在 <a href="https://github.com/apple/swift-package-manager/commit/a0ffd92a2c80f2c4677d696e248f4cfbec9d6540" title="Swift Package Manager" target="_blank" rel="noopener">Swift Package Manager</a> 中完成了一些正在进行的工作。</p><p><strong>Filip Sakel</strong> 提出了一项<a href="https://forums.swift.org/t/pitch-refining-property-wrapper-related-initialization/52049" title="Refining Property wrapper  related Initialization" target="_blank" rel="noopener">改进 Property-wrapper-related 的初始化</a>的提案。</p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" title="SE 0258" target="_blank" rel="noopener">SE 0258</a> 引入了 <code>property wrappers</code>，<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0293-extend-property-wrappers-to-function-and-closure-parameters.md#detailed-design" title="SE 0293" target="_blank" rel="noopener">SE 0293</a> 使用类似函数的声明对其进行了扩展。 今天，<code>property wrappers</code> 初始化由于其日益增长的多功能性而表现出不一致。 具体来说，成员初始化使用复杂的、记录不足的规则，并且 <code>projection</code> 初始化仍然有限。该提案将简化具有包装属性的类型的合成成员初始化，并扩展 <code>projection</code> 值初始化以包括全局、类型和局部包装属性。</p><p><strong>Jordan Rose</strong> 开始讨论<a href="https://forums.swift.org/t/pre-pitch-remove-the-implicit-initialization-of-optional-variables/52300" title="remove the implicit initialization of Optional variables" target="_blank" rel="noopener">删除 Optional 变量的隐式初始化</a>。</p><p>在 Swift 6 中，可选变量与所有其他变量一样，默认情况下不会初始化。 局部变量和全局变量得到修复，添加 <code>= nil</code>。 属性仅在附加到有关未初始化变量的错误的注释中修复，这显然不是正确的做法，只有 Swift 5 中需要这么做。 不过，迁移者也可以自动应用该修复程序。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><h3 id="iOS-系列"><a href="#iOS-系列" class="headerlink" title="iOS 系列"></a>iOS 系列</h3><p><a href="https://mp.weixin.qq.com/s/vkbN_d3tR_Ym_gJYBVGCOw" target="_blank" rel="noopener">如何在 Swift 中实现状态机？</a></p><p>简言之：我们通常称作的状态机是有限状态机的简称，它是一种<strong>数学计算模型</strong>。</p><p><a href="https://mp.weixin.qq.com/s/DawFZMOuU5jbaw0Bi0gOhw" target="_blank" rel="noopener">避免 Swift 单元测试中的强制解析</a></p><p>强制解析（使用 <code>!</code>）是 Swift 语言中不可或缺的一个重要特点（特别是和 Objective-C 的接口混合使用时）。它回避了一些其他问题，使得 Swift 语言变得更加优秀。</p><p><a href="https://mp.weixin.qq.com/s/ZbZ4pFzzyfrQifmLewrxsw" target="_blank" rel="noopener">iOS 识别虚拟定位调研</a></p><p>最近业务开发中，有遇到我们的项目 app 定位被篡改的情况，在 android 端表现的尤为明显。为了防止这种黑产使用虚拟定位薅羊毛，iOS 也不得不进行虚拟定位的规避。</p><h3 id="实时文讯"><a href="#实时文讯" class="headerlink" title="实时文讯"></a>实时文讯</h3><p><a href="https://mp.weixin.qq.com/s/DwClglO_fOYDfLsINU_hdw" target="_blank" rel="noopener">Xcode 13 更新了哪些内容</a></p><p><a href="https://mp.weixin.qq.com/s/E5vTD9QDgKfVErWxCv4wjg" target="_blank" rel="noopener">开发者需要了解的 iOS 15</a></p><p><a href="https://mp.weixin.qq.com/s/4OGxPn-dgDc-jjtM-DtqGQ" target="_blank" rel="noopener">Xcode 13 正式版发布，来看看有什么新特性</a></p><h3 id="SwiftUI-系列"><a href="#SwiftUI-系列" class="headerlink" title="SwiftUI 系列"></a>SwiftUI 系列</h3><p><a href="https://mp.weixin.qq.com/s/K_i8bvcaHDfVMUsQTv3MOw" target="_blank" rel="noopener">为什么 SwiftUI 的修饰符顺序很重要</a></p><p>每当我们将修饰符应用于 <code>SwiftUI</code> 视图时，我们实际上都会创建一个，应用了更改的新视图 —— 我们不仅仅是修改现有的视图。</p><p><a href="https://mp.weixin.qq.com/s/gSeFOMrjze6KE_X6WwWAZQ" target="_blank" rel="noopener">为什么 SwiftUI 的视图使用结构体</a></p><p>如果您曾经为 <code>UIKit</code> 或 <code>AppKit</code>（Apple 的 iOS 和 macOS 原始用户界面框架）编程，您会知道它们使用类而非结构体来构造视图。<code>SwiftUI</code> 更喜欢将结构体用于整体视图。</p><p><a href="https://mp.weixin.qq.com/s/ZQSbu7dzwC-XbGcUcBkjAw" target="_blank" rel="noopener">如何结合 Core Data 和 SwiftUI</a></p><p><code>SwiftUI</code> 和 <code>Core Data</code> 之间相差将近十年。尽管时间相距遥远，Apple 还是投入了大量工作以确保这两种强大的技术能够完美地相互配合使用，这意味着 <code>Core Data</code> 就像始终以这种方式设计一样，已集成到 SwiftUI 中。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本期周报开始，将会引入&lt;strong&gt;推荐博文&lt;/strong&gt;模块，主要为大家分享展示优秀的 iOS 技术博文，如果大家阅读到优秀的文章欢迎在文末留言告诉小编，大家资源共享共同进步。&lt;/p&gt;
&lt;p&gt;iPhone 13 新品上架，你们都买了吗？苹果声称，iPhone 13 拥有全新的双摄像头系统，采用超快的 &lt;code&gt;A15&lt;/code&gt; 芯片，提高电池的续航能力。&lt;/p&gt;
&lt;p&gt;我们不仅要关注新的 iPhone 13，几天前，&lt;code&gt;Xcode 13&lt;/code&gt; 与 &lt;a href=&quot;https://forums.swift.org/t/swift-5-5-released/52247&quot; title=&quot;Swift 5.5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 5.5&lt;/a&gt; 也一起发布了。这是 Swift 5.5 更新的&lt;a href=&quot;https://twitter.com/simjp/status/1440318174856036354&quot; title=&quot;列表&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;列表&lt;/a&gt;，这个版本发布了很多新功能。Xcode 13 的发布说明可以在这里找到：&lt;a href=&quot;https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes&quot; title=&quot;iOS &amp;amp; iPadOS 15 Release Notes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS &amp;amp; iPadOS 15 Release Notes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在已经开始将&lt;strong&gt;并发&lt;/strong&gt;功能向后部署到旧的 Swift 版本上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二期/</id>
    <published>2021-10-22T07:16:35.000Z</published>
    <updated>2021-10-22T07:17:56.669Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.apple.com/apple-events/" title="California streaming" target="_blank" rel="noopener">California streaming</a>. 我们都知道这意味着什么：马上将迎来重要的一天 —— <code>Apple</code> 宣布了 <strong>9 月 14 日</strong>的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— <a href="https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/" title="一种隐藏的 AR 体验" target="_blank" rel="noopener">一种隐藏的 AR 体验</a>，看起来很酷。 这也让全球的粉丝们纷纷猜测 <code>Apple</code> 即将发布的产品。</p><p>过去两周 <code>Swift 社区</code>非常活跃。 许多提案正在 <code>Swift</code> 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 <code>Swift</code> 保持现代语言的地位，所以让我们继续努力吧！</p><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释  <a href="https://www.swiftbysundell.com/articles/conditional-compilation-within-swift-expressions/" title="Conditional compilation within Swift expressions" target="_blank" rel="noopener">Swift 表达式中的条件编译</a>。</p><p><a href="https://twitter.com/gabtheodor" title="Gabriel Theodoropoulos" target="_blank" rel="noopener">Gabriel Theodoropoulos</a> 写了一篇博文解释了如何<a href="https://serialcoder.dev/text-tutorials/swift-tutorials/using-variadic-parameters-in-swift/" title="Using Variadic Parameters in Swift" target="_blank" rel="noopener">在 Swift 中使用可变参数</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39051" title="Add an option to build the concurrency library for back deployment" target="_blank" rel="noopener">添加了一个选项来构建并发库以进行后端部署</a>。</p><p><a href="https://github.com/fwcd" title="FW" target="_blank" rel="noopener">FW</a> 合并了一个<a href="https://github.com/apple/sourcekit-lsp/pull/414" title="Implement semantic highlighting for Swift" target="_blank" rel="noopener">为 Swift 实现语义高亮</a> 的 <code>pull request</code>。</p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a> Package Registry Service - Publish Endpoint 已被<a href="https://forums.swift.org/t/accepted-se-0321-package-registry-service-publish-endpoint/51660" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">接受</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md" title="SE-0304" target="_blank" rel="noopener">SE-0304</a> Structured Concurrency <a href="https://forums.swift.org/t/se-0304-4th-review-structured-concurrency/50281" title="SE-0304 (4th review): Structured Concurrency" target="_blank" rel="noopener">第四次</a>审查被<a href="https://forums.swift.org/t/accepted-with-modifications-se-0304-structured-concurrency/51850" title="[Accepted with modifications] SE-0304: Structured Concurrency" target="_blank" rel="noopener">接受</a>。</p><h2 id="拒绝的提案"><a href="#拒绝的提案" class="headerlink" title="拒绝的提案"></a>拒绝的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a> 已返回进行<a href="https://forums.swift.org/t/returned-for-revision-se-0320-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51706" title="[Returned for revision] SE-0320: Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">修订</a>。</p><p>审查的反馈是积极的，社区成员建议作者和核心团队认为可以采用以下几项改进：</p><ol><li>在 <code>CodingKeyRepresentable</code> 中添加 <code>String</code> 和 <code>Int</code> 的一致性，这将允许在 <code>CodingKeyRepresentable</code> 用作通用约束时主动使用 <code>String</code> 和 <code>Int</code> 键。</li><li>使 <code>CodingKeyRepresentable</code> 协议的初始化通用。</li><li>为 <code>RawRepresentable</code> 的一致性提供默认实现（带有 <code>String</code> 和 <code>Int</code> 原始值）。</li><li>使内部 <code>_DictionaryCodingKey</code> 的初始值设定项 non-failable。</li></ol><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a>：允许将非 <code>String</code> / <code>Int</code> 键值 <code>Dictionary</code> 编码到 <code>KeyedContainer</code> 中 正在<a href="https://forums.swift.org/t/se-0320-2nd-review-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51710" title="SE-0320 (2nd review): Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">接受第二次审查</a>。</p><ul><li>第二次审查的重点是社区在第一次审查期间提出的改进建议，并通过 <a href="https://github.com/apple/swift-evolution/pull/1435" title="swift-evolution#1435" target="_blank" rel="noopener">swift-evolution#1435</a> 进行讨论。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0292-package-registry-service.md" title="SE-0292" target="_blank" rel="noopener">SE-0292</a>：Package Registry Service 修正<a href="https://github.com/apple/swift-evolution/pull/1410" title="修正 SE-0292 #1410" target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://forums.swift.org/t/amendment-se-0303-package-manager-extensible-build-tools/51763" title="SE-0303: Package Manager Extensible Build Tools" target="_blank" rel="noopener">SE-0303</a>：包管理器可扩展构建工具修正<a href="https://github.com/apple/swift-evolution/pull/1434" title="Amend SE-0303 to use @main for plugin entry point and adjust API accordingly #1434 " target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md" title="SE-0322" target="_blank" rel="noopener">SE-0322</a>：正在审查<a href="https://forums.swift.org/t/se-0322-temporary-uninitialized-buffers/51848" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>。</p><ul><li>该提案引入了新的标准库功能，用于操作临时缓冲区，这些缓冲区优先分配给堆栈，而不是堆。</li><li><code>Swift-evolution</code> 线程：[Pitch] <a href="https://forums.swift.org/t/pitch-temporary-uninitialized-buffers/48954" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a></li></ul><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://github.com/maustinstar" title="Michael Verges" target="_blank" rel="noopener">Michael Verges</a> 提出了<a href="https://forums.swift.org/t/pitching-optional-throws-in-swift/51650" title="Pitching Optional Throws in Swift" target="_blank" rel="noopener">在 Swift 中添加可选 <code>throws</code> 的提案</a>。</p><ul><li>在许多情况下，错误处理的权限不明确。开发者可能会质疑是处理还是传播错误。</li><li>选择抛出错误可以让调用者灵活地处理问题。</li><li>选择不抛出错误是为用户提供了简化语法（没有 <code>do-try-catch</code>）。</li></ul><p><a href="https://forums.swift.org/t/api-changes-for-0-2-0/51647" title="Karl" target="_blank" rel="noopener">Karl</a> 向社区通报了 <a href="https://karwa.github.io/swift-url/" title="WebURL" target="_blank" rel="noopener">WebURL</a> 0.2.0 版。</p><ul><li>我正准备发布 <code>WebURL 0.2.0</code> 版本 。 这将是一个非常重要的版本，包括用于与 <code>System.framework</code> 和 <code>swift-system</code> 包集成的 <code>WebURLSystemExtras</code> 模块，并使项目与 <code>URL</code> 标准的最新版本保持一致。</li></ul><p><a href="https://forums.swift.org/categories" title="Patrick Goley" target="_blank" rel="noopener">Patrick Goley</a> 提出了<a href="https://forums.swift.org/t/pitch-destructuring-assignment-of-structs-and-classes/51593" title="Destructuring Assignment of Structs and Classes" target="_blank" rel="noopener">添加结构和类的析构赋值</a>的建议。</p><ul><li>析构赋值是一项语言功能，允许你提取值的多个部分，并将其分配给单个赋值语句中的多个变量。</li></ul><p><a href="https://twitter.com/stephentyrone" title="Steve Canon" target="_blank" rel="noopener">Steve Canon</a> 宣布 <a href="https://forums.swift.org/t/1-0-0-release-notes/51641" title="Swift Numerics" target="_blank" rel="noopener">Swift Numerics</a> 的第一个稳定版本现已发布。</p><p>Austin 开始讨论 <a href="https://forums.swift.org/t/netlink-socket-support-in-swiftnio/51651" title="Netlink socket support in SwiftNIO" target="_blank" rel="noopener">SwiftNIO 中的 netlink 套接字支持</a>。</p><p><a href="https://forums.swift.org/categories" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 提出了一项实施 <a href="https://forums.swift.org/t/pitch-distributed-actors/51669" title="Distributed Actors" target="_blank" rel="noopener">Distributed Actors</a> 的提案。 </p><ul><li>随着最近 <code>Swift</code> 并发的引入，特别是该语言的参与者，<code>Swift</code> 在表达线程安全的并发程序方面获得了强大的基础构建。该提案旨在通过引入分布式参与者和与他们相关的位置透明度，扩大 <code>Swift</code>的参与者在分布式系统方面同样出色的工作能力。</li></ul><p><a href="https://twitter.com/maxdesiatov" title="Max Desiatov" target="_blank" rel="noopener">Max Desiatov</a> 告诉我们 <a href="https://forums.swift.org/t/swiftwasm-5-4-0-has-been-released/51753" title="SwiftWasm 5.4.0 has been released" target="_blank" rel="noopener">SwiftWasm 5.4.0</a> 已经发布。</p><ul><li>此版本与 <code>upstream</code> <code>Swift 5.4</code> 匹配，并允许您将 <code>Swift</code> 应用程序（只要它们不使用特定于其他平台的代码）编译到 <code>WebAssembly</code>，甚至可以在浏览器中运行。</li></ul><p><a href="https://forums.swift.org/categories" title="elsh" target="_blank" rel="noopener">elsh</a> 提出了添加<a href="https://forums.swift.org/t/pitch-module-aliasing/51737" title="Module Aliasing" target="_blank" rel="noopener">模块别名</a>支持的建议。</p><p>随着 <code>Swift</code> 库和软件包分布更加广泛，模块名称有时会发生冲突。由于 <code>Swift</code> 中还没有模块命名空间，在这种情况下，库经常被迫重命名或固定在旧的非冲突版本上。这使得以下用例具有挑战性：</p><ul><li><p>添加新的依赖项或升级，因为它可能会引入冲突：一个新的（或升级的）模块可以与依赖关系图中已经存在的另一个模块具有相同的名称。模块名称 <code>Logging</code> 是一个常见示例。</p></li><li><p>从上游库固定的旧版本升级到软件包的更新版本：考虑这样一个场景，其中 <code>MyApp</code> 依赖于模块 <code>Lib</code>，而 <code>Lib</code> 依赖于模块 <code>Logging</code>。 <code>MyApp</code> 还依赖于 <code>Logging</code>。 如果 <code>Lib</code> 固定到 <code>Logging 1.0.0</code>，则 <code>MyApp</code> 会停留在同一版本 <code>1.0.0</code>。</p></li></ul><p>2021年9月3日，服务器工作组的 <code>Swift</code> 宣布了一项<a href="https://forums.swift.org/t/september-3rd-2021-special-update/51766" title="September 3rd, 2021 Special Update" target="_blank" rel="noopener">特别更新</a>。</p><p><a href="https://forums.swift.org/t/pitch-introduce-expanded-parameters/51885" title="Introduce Expanded Parameters" target="_blank" rel="noopener">Isabel Lima</a> 向我们更新了有关<a href="https://forums.swift.org/t/add-shared-storage-to-property-wrappers/49898" title="Add shared storage to property wrappers " target="_blank" rel="noopener">添加 Property Wrappers 共享存储</a>的状态。</p><ul><li><code>Swift</code> 是一种允许我们编写富有表现力的 <code>API</code> 接口语言。通过<strong>约束泛型</strong>、<strong>方法重载</strong>、<strong>尾随闭包</strong>和<strong>默认参数</strong>等功能，您可以在实现相当灵活的 <code>API</code>的同时减少代码重复。本提案旨在使用 <code>@expanded</code>（函数参数的新属性）增加语言的这一部分。</li></ul><p><a href="https://github.com/johnno1962" title="John Holdsworth" target="_blank" rel="noopener">John Holdsworth</a> 提议引入 <a href="https://forums.swift.org/t/introducing-an-unwrap-or-throw-operator/51905" title="Introducing an “Unwrap or Throw” operator" target="_blank" rel="noopener"> Unwrap 或 Throw 运算符</a>。</p><ul><li><p>该提议是之前 <a href="https://forums.swift.org/t/pitch-introducing-the-unwrap-or-die-operator-to-the-standard-library/6207" title="[Pitch] Introducing the “Unwrap or Die” operator to the standard library" target="_blank" rel="noopener">[Pitch] Introducing the “Unwrap or Die” operator to the standard library</a> 以及最近 <a href="https://forums.swift.org/t/moving-toward-deprecating-force-unwrap-from-swift/43455" title="Moving toward deprecating force unwrap from Swift?" target="_blank" rel="noopener">Moving toward deprecating force unwrap from Swift?</a> 两个有争议提议的延伸。 后一个提议除了被锁定之外没有得出结论，这个提议在前一个提议上取而代之，建议使用 “<code>Unwrap or Throw</code>” 运算符可能是解决 <code>Swift</code> 中强制解包问题的更好解决方案，这让我很疑惑，我相信当用户的应用程序崩溃时，会影响到用户使用。</p></li><li><h1 id="总之，我想提出一个-运算符，强制打开和-nil-并之间的交叉，如果可选是-nil，则抛出。"><a href="#总之，我想提出一个-运算符，强制打开和-nil-并之间的交叉，如果可选是-nil，则抛出。" class="headerlink" title="总之，我想提出一个 !! 运算符，强制打开和 nil 并之间的交叉，如果可选是 nil，则抛出。"></a>总之，我想提出一个 <code>!!</code> 运算符，强制打开和 <code>nil</code> 并之间的交叉，如果可选是 <code>nil</code>，则抛出。</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2></li></ul><p><a href="https://www.apple.com/apple-events/" title="California streaming" target="_blank" rel="noopener">California streaming</a>. 我们都知道这意味着什么：马上将迎来重要的一天 —— <code>Apple</code> 宣布了 <strong>9 月 14 日</strong>的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— <a href="https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/" title="一种隐藏的 AR 体验" target="_blank" rel="noopener">一种隐藏的 AR 体验</a>，看起来很酷。 这也让全球的粉丝们纷纷猜测 <code>Apple</code> 即将发布的产品。</p><p>过去两周 <code>Swift 社区</code>非常活跃。 许多提案正在 <code>Swift</code> 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 <code>Swift</code> 保持现代语言的地位，所以让我们继续努力吧！</p><h2 id="新闻和社区-1"><a href="#新闻和社区-1" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释  <a href="https://www.swiftbysundell.com/articles/conditional-compilation-within-swift-expressions/" title="Conditional compilation within Swift expressions" target="_blank" rel="noopener">Swift 表达式中的条件编译</a>。</p><p><a href="https://twitter.com/gabtheodor" title="Gabriel Theodoropoulos" target="_blank" rel="noopener">Gabriel Theodoropoulos</a> 写了一篇博文解释了如何<a href="https://serialcoder.dev/text-tutorials/swift-tutorials/using-variadic-parameters-in-swift/" title="Using Variadic Parameters in Swift" target="_blank" rel="noopener">在 Swift 中使用可变参数</a>。</p><h2 id="Commits-和-pull-requests-1"><a href="#Commits-和-pull-requests-1" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39051" title="Add an option to build the concurrency library for back deployment" target="_blank" rel="noopener">添加了一个选项来构建并发库以进行后端部署</a>。</p><p><a href="https://github.com/fwcd" title="FW" target="_blank" rel="noopener">FW</a> 合并了一个<a href="https://github.com/apple/sourcekit-lsp/pull/414" title="Implement semantic highlighting for Swift" target="_blank" rel="noopener">为 Swift 实现语义高亮</a> 的 <code>pull request</code>。</p><h2 id="同意的提案-1"><a href="#同意的提案-1" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a> Package Registry Service - Publish Endpoint 已被<a href="https://forums.swift.org/t/accepted-se-0321-package-registry-service-publish-endpoint/51660" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">接受</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md" title="SE-0304" target="_blank" rel="noopener">SE-0304</a> Structured Concurrency <a href="https://forums.swift.org/t/se-0304-4th-review-structured-concurrency/50281" title="SE-0304 (4th review): Structured Concurrency" target="_blank" rel="noopener">第四次</a>审查被<a href="https://forums.swift.org/t/accepted-with-modifications-se-0304-structured-concurrency/51850" title="[Accepted with modifications] SE-0304: Structured Concurrency" target="_blank" rel="noopener">接受</a>。</p><h2 id="拒绝的提案-1"><a href="#拒绝的提案-1" class="headerlink" title="拒绝的提案"></a>拒绝的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a> 已返回进行<a href="https://forums.swift.org/t/returned-for-revision-se-0320-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51706" title="[Returned for revision] SE-0320: Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">修订</a>。</p><p>审查的反馈是积极的，社区成员建议作者和核心团队认为可以采用以下几项改进：</p><ol><li>在 <code>CodingKeyRepresentable</code> 中添加 <code>String</code> 和 <code>Int</code> 的一致性，这将允许在 <code>CodingKeyRepresentable</code> 用作通用约束时主动使用 <code>String</code> 和 <code>Int</code> 键。</li><li>使 <code>CodingKeyRepresentable</code> 协议的初始化通用。</li><li>为 <code>RawRepresentable</code> 的一致性提供默认实现（带有 <code>String</code> 和 <code>Int</code> 原始值）。</li><li>使内部 <code>_DictionaryCodingKey</code> 的初始值设定项 non-failable。</li></ol><h2 id="正在审查的提案-1"><a href="#正在审查的提案-1" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a>：允许将非 <code>String</code> / <code>Int</code> 键值 <code>Dictionary</code> 编码到 <code>KeyedContainer</code> 中 正在<a href="https://forums.swift.org/t/se-0320-2nd-review-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51710" title="SE-0320 (2nd review): Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">接受第二次审查</a>。</p><ul><li>第二次审查的重点是社区在第一次审查期间提出的改进建议，并通过 <a href="https://github.com/apple/swift-evolution/pull/1435" title="swift-evolution#1435" target="_blank" rel="noopener">swift-evolution#1435</a> 进行讨论。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0292-package-registry-service.md" title="SE-0292" target="_blank" rel="noopener">SE-0292</a>：Package Registry Service 修正<a href="https://github.com/apple/swift-evolution/pull/1410" title="修正 SE-0292 #1410" target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://forums.swift.org/t/amendment-se-0303-package-manager-extensible-build-tools/51763" title="SE-0303: Package Manager Extensible Build Tools" target="_blank" rel="noopener">SE-0303</a>：包管理器可扩展构建工具修正<a href="https://github.com/apple/swift-evolution/pull/1434" title="Amend SE-0303 to use @main for plugin entry point and adjust API accordingly #1434 " target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md" title="SE-0322" target="_blank" rel="noopener">SE-0322</a>：正在审查<a href="https://forums.swift.org/t/se-0322-temporary-uninitialized-buffers/51848" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>。</p><ul><li>该提案引入了新的标准库功能，用于操作临时缓冲区，这些缓冲区优先分配给堆栈，而不是堆。</li><li><code>Swift-evolution</code> 线程：[Pitch] <a href="https://forums.swift.org/t/pitch-temporary-uninitialized-buffers/48954" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a></li></ul><h2 id="Swift-论坛-1"><a href="#Swift-论坛-1" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://github.com/maustinstar" title="Michael Verges" target="_blank" rel="noopener">Michael Verges</a> 提出了<a href="https://forums.swift.org/t/pitching-optional-throws-in-swift/51650" title="Pitching Optional Throws in Swift" target="_blank" rel="noopener">在 Swift 中添加可选 <code>throws</code> 的提案</a>。</p><ul><li>在许多情况下，错误处理的权限不明确。开发者可能会质疑是处理还是传播错误。</li><li>选择抛出错误可以让调用者灵活地处理问题。</li><li>选择不抛出错误是为用户提供了简化语法（没有 <code>do-try-catch</code>）。</li></ul><p><a href="https://forums.swift.org/t/api-changes-for-0-2-0/51647" title="Karl" target="_blank" rel="noopener">Karl</a> 向社区通报了 <a href="https://karwa.github.io/swift-url/" title="WebURL" target="_blank" rel="noopener">WebURL</a> 0.2.0 版。</p><ul><li>我正准备发布 <code>WebURL 0.2.0</code> 版本 。 这将是一个非常重要的版本，包括用于与 <code>System.framework</code> 和 <code>swift-system</code> 包集成的 <code>WebURLSystemExtras</code> 模块，并使项目与 <code>URL</code> 标准的最新版本保持一致。</li></ul><p><a href="https://forums.swift.org/categories" title="Patrick Goley" target="_blank" rel="noopener">Patrick Goley</a> 提出了<a href="https://forums.swift.org/t/pitch-destructuring-assignment-of-structs-and-classes/51593" title="Destructuring Assignment of Structs and Classes" target="_blank" rel="noopener">添加结构和类的析构赋值</a>的建议。</p><ul><li>析构赋值是一项语言功能，允许你提取值的多个部分，并将其分配给单个赋值语句中的多个变量。</li></ul><p><a href="https://twitter.com/stephentyrone" title="Steve Canon" target="_blank" rel="noopener">Steve Canon</a> 宣布 <a href="https://forums.swift.org/t/1-0-0-release-notes/51641" title="Swift Numerics" target="_blank" rel="noopener">Swift Numerics</a> 的第一个稳定版本现已发布。</p><p>Austin 开始讨论 <a href="https://forums.swift.org/t/netlink-socket-support-in-swiftnio/51651" title="Netlink socket support in SwiftNIO" target="_blank" rel="noopener">SwiftNIO 中的 netlink 套接字支持</a>。</p><p><a href="https://forums.swift.org/categories" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 提出了一项实施 <a href="https://forums.swift.org/t/pitch-distributed-actors/51669" title="Distributed Actors" target="_blank" rel="noopener">Distributed Actors</a> 的提案。 </p><ul><li>随着最近 <code>Swift</code> 并发的引入，特别是该语言的参与者，<code>Swift</code> 在表达线程安全的并发程序方面获得了强大的基础构建。该提案旨在通过引入分布式参与者和与他们相关的位置透明度，扩大 <code>Swift</code>的参与者在分布式系统方面同样出色的工作能力。</li></ul><p><a href="https://twitter.com/maxdesiatov" title="Max Desiatov" target="_blank" rel="noopener">Max Desiatov</a> 告诉我们 <a href="https://forums.swift.org/t/swiftwasm-5-4-0-has-been-released/51753" title="SwiftWasm 5.4.0 has been released" target="_blank" rel="noopener">SwiftWasm 5.4.0</a> 已经发布。</p><ul><li>此版本与 <code>upstream</code> <code>Swift 5.4</code> 匹配，并允许您将 <code>Swift</code> 应用程序（只要它们不使用特定于其他平台的代码）编译到 <code>WebAssembly</code>，甚至可以在浏览器中运行。</li></ul><p><a href="https://forums.swift.org/categories" title="elsh" target="_blank" rel="noopener">elsh</a> 提出了添加<a href="https://forums.swift.org/t/pitch-module-aliasing/51737" title="Module Aliasing" target="_blank" rel="noopener">模块别名</a>支持的建议。</p><p>随着 <code>Swift</code> 库和软件包分布更加广泛，模块名称有时会发生冲突。由于 <code>Swift</code> 中还没有模块命名空间，在这种情况下，库经常被迫重命名或固定在旧的非冲突版本上。这使得以下用例具有挑战性：</p><ul><li><p>添加新的依赖项或升级，因为它可能会引入冲突：一个新的（或升级的）模块可以与依赖关系图中已经存在的另一个模块具有相同的名称。模块名称 <code>Logging</code> 是一个常见示例。</p></li><li><p>从上游库固定的旧版本升级到软件包的更新版本：考虑这样一个场景，其中 <code>MyApp</code> 依赖于模块 <code>Lib</code>，而 <code>Lib</code> 依赖于模块 <code>Logging</code>。 <code>MyApp</code> 还依赖于 <code>Logging</code>。 如果 <code>Lib</code> 固定到 <code>Logging 1.0.0</code>，则 <code>MyApp</code> 会停留在同一版本 <code>1.0.0</code>。</p></li></ul><p>2021年9月3日，服务器工作组的 <code>Swift</code> 宣布了一项<a href="https://forums.swift.org/t/september-3rd-2021-special-update/51766" title="September 3rd, 2021 Special Update" target="_blank" rel="noopener">特别更新</a>。</p><p><a href="https://forums.swift.org/t/pitch-introduce-expanded-parameters/51885" title="Introduce Expanded Parameters" target="_blank" rel="noopener">Isabel Lima</a> 向我们更新了有关<a href="https://forums.swift.org/t/add-shared-storage-to-property-wrappers/49898" title="Add shared storage to property wrappers " target="_blank" rel="noopener">添加 Property Wrappers 共享存储</a>的状态。</p><ul><li><code>Swift</code> 是一种允许我们编写富有表现力的 <code>API</code> 接口语言。通过<strong>约束泛型</strong>、<strong>方法重载</strong>、<strong>尾随闭包</strong>和<strong>默认参数</strong>等功能，您可以在实现相当灵活的 <code>API</code>的同时减少代码重复。本提案旨在使用 <code>@expanded</code>（函数参数的新属性）增加语言的这一部分。</li></ul><p><a href="https://github.com/johnno1962" title="John Holdsworth" target="_blank" rel="noopener">John Holdsworth</a> 提议引入 <a href="https://forums.swift.org/t/introducing-an-unwrap-or-throw-operator/51905" title="Introducing an “Unwrap or Throw” operator" target="_blank" rel="noopener"> Unwrap 或 Throw 运算符</a>。</p><ul><li><p>该提议是之前 <a href="https://forums.swift.org/t/pitch-introducing-the-unwrap-or-die-operator-to-the-standard-library/6207" title="[Pitch] Introducing the “Unwrap or Die” operator to the standard library" target="_blank" rel="noopener">[Pitch] Introducing the “Unwrap or Die” operator to the standard library</a> 以及最近 <a href="https://forums.swift.org/t/moving-toward-deprecating-force-unwrap-from-swift/43455" title="Moving toward deprecating force unwrap from Swift?" target="_blank" rel="noopener">Moving toward deprecating force unwrap from Swift?</a> 两个有争议提议的延伸。 后一个提议除了被锁定之外没有得出结论，这个提议在前一个提议上取而代之，建议使用 “<code>Unwrap or Throw</code>” 运算符可能是解决 <code>Swift</code> 中强制解包问题的更好解决方案，这让我很疑惑，我相信当用户的应用程序崩溃时，会影响到用户使用。</p></li><li><p>总之，我想提出一个 <code>!!</code> 运算符，强制打开和 <code>nil</code> 并之间的交叉，如果可选是 <code>nil</code>，则抛出。</p></li></ul><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.apple.com/apple-events/&quot; title=&quot;California streaming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;California streaming&lt;/a&gt;. 我们都知道这意味着什么：马上将迎来重要的一天 —— &lt;code&gt;Apple&lt;/code&gt; 宣布了 &lt;strong&gt;9 月 14 日&lt;/strong&gt;的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— &lt;a href=&quot;https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/&quot; title=&quot;一种隐藏的 AR 体验&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一种隐藏的 AR 体验&lt;/a&gt;，看起来很酷。 这也让全球的粉丝们纷纷猜测 &lt;code&gt;Apple&lt;/code&gt; 即将发布的产品。&lt;/p&gt;
&lt;p&gt;过去两周 &lt;code&gt;Swift 社区&lt;/code&gt;非常活跃。 许多提案正在 &lt;code&gt;Swift&lt;/code&gt; 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 &lt;code&gt;Swift&lt;/code&gt; 保持现代语言的地位，所以让我们继续努力吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第一期/</id>
    <published>2021-10-22T07:14:13.000Z</published>
    <updated>2021-10-22T07:17:18.773Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从本周开始，我们 Swift 社区公众号将开始与 SwiftWeekly 合作更新关于 Swift 社区最新的进展与动向。让我们乘着社区的风帆，一起荡起双桨，让 Swift 成为世界上最好的语言。</p><a id="more"></a><h2 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h2><p>在 Swift by Sundell 播客的<a href="https://www.swiftbysundell.com/podcast/103/" title="Swift by Sundell 第 103 期" target="_blank" rel="noopener">第 103 期</a>中，SwiftLee 的创建者 <a href="https://twitter.com/twannl" title="Antoine van der Lee" target="_blank" rel="noopener">Antoine van der Lee</a> 加入了 <a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a>。</p><p>他们从新的 concurrency 系统到 convenience 特性以及各种改进等方向讨论了 Swift 5.5 新引入的一部分功能。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p>Xcode 各版本的 <a href="https://developer.apple.com/cn/support/xcode/" title="最低要求和支持的 SDK" target="_blank" rel="noopener">最低要求和支持的 SDK</a></p><p><a href="https://twitter.com/twannl" title="Antoine van der Lee" target="_blank" rel="noopener">Antoine van der Lee</a> 写了一篇博文，<a href="https://www.avanderlee.com/swift/unwrap-or-throw/" title="Unwrap or throw: Exploring solutions in Swift" target="_blank" rel="noopener">探讨在 Swift 中解包或 throw 的解决方案</a>。</p><p><a href="https://twitter.com/Leo_Pugliese" title="Leonardo Maia Pugliese" target="_blank" rel="noopener">Leonardo Maia Pugliese</a> 写了一篇关于<a href="https://holyswift.app/how-to-do-apis-constraints-with-available-in-swift" title="How to do APIs constraints with @Available in Swift" target="_blank" rel="noopener">如何在 Swift 中使用 @available 进行 API 约束</a>的博客文章。</p><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释了如何<a href="https://www.swiftbysundell.com/articles/using-an-unknown-default-case-within-a-switch-statement/" title="Using ‘@unknown default’ within switch statements" target="_blank" rel="noopener">在 switch 语句中使用 @unknown default</a>。</p><p><a href="https://twitter.com/basthomas" title="Bas Broek" target="_blank" rel="noopener">Bas Broek</a> 写了一篇博文，探讨如何在 Swift 中<a href="https://www.basbroek.nl/deprecating-workarounds" title="Deprecating Workarounds" target="_blank" rel="noopener">弃用 Workarounds</a>。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a>: Package Registry Service - Publish Endpoint 正在<a href="https://forums.swift.org/t/se-0321-package-registry-service-publish-endpoint/51286" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">审查中</a></p><p>软件包注册表负责确定哪些软件包版本可提供给消费者使用。</p><p>目前，软件包版本的可用性由 <code>out-of-band</code> 流程决定。例如，注册表可以查询公共 Swift 软件包的索引，并为每个标签提供具有有效版本号的版本。</p><p>拥有发布新版本到软件包注册表的标准端点将增强维护者分发其软件的能力，并促进服务提供商之间的互操作性。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://forums.swift.org/categories" title="Dimitri Racordon" target="_blank" rel="noopener">Dimitri Racordon</a> 提出了一个<a href="https://forums.swift.org/t/pitch-protocols-with-private-fields/51209" title="Protocols with private fields" target="_blank" rel="noopener">用私有字段实现协议的想法</a>。</p><p>在协议中，所有字段（<code>properties</code> 和 <code>methods</code>）都将获得符合条件类型的访问可见性。例如，符合具有公共类型的协议将提示其所有要求都是公共的。</p><p><a href="https://forums.swift.org/categories" title="Evan Wilde" target="_blank" rel="noopener">Evan Wilde</a> 提出了一项<a href="https://forums.swift.org/t/pitch-revisit-the-semantics-of-async-main/51254" title="Revisit the semantics of async main" target="_blank" rel="noopener">重新审视 async main 语义</a>的提案。</p><ul><li>main 函数应该同步运行到第一个暂停点</li><li>main 函数应该在 <code>main actor</code> 上运行</li><li>MainActor 应该为默认的 <code>runloop</code> 行为提供用户指定的替代方案。</li><li>main 任务应该从 <code>getCurrentThreadPriority</code> 拉取优先级，而不是 <code>hard-coded</code> 默认优先级</li></ul><p><a href="https://forums.swift.org/u/abertelrud" title="Anders Bertelrud" target="_blank" rel="noopener">Anders Bertelrud</a> 提议修改 SE-0303：插件 API，使用 @main 作为插件入口点。</p><p>我想提议修改 <code>SE-0303</code>，<code>SwiftPM</code> 插件使用 <code>@main</code> 作为入口点，而不是 <code>top-level</code> 作为入口点。 虽然这样做有点冗长，但是可以为每种插件定制入口点，并且还可以更加清楚地说明每个插件的输入和预期输出是什么。</p><p><a href="https://forums.swift.org/u/saklad5" title="Jeremy Saklad" target="_blank" rel="noopener">Jeremy Saklad</a> 提出了一项提案，该提案将<a href="https://forums.swift.org/t/allow-use-of-concrete-associated-type-of-protocols/51277" title="Allow use of concrete associated type of protocols" target="_blank" rel="noopener">允许使用具体的相关协议类型</a>。</p><p><a href="https://twitter.com/lorentey" title="Karoy Lorentey" target="_blank" rel="noopener">Karoy Lorentey</a> 发布了 <a href="https://forums.swift.org/t/announcement-planning-for-swift-collections-v1-0/51321" title="Planning for Swift Collections v1.0" target="_blank" rel="noopener">Swift Collections 1.0 版</a>。</p><p><a href="https://forums.swift.org/u/ktoso" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 发布了 Swift Server Workgroup <a href="https://forums.swift.org/t/august-4th-2021/51315" title="August 4th 2021" target="_blank" rel="noopener">2021 年 8 月 4 日的会议记录</a>。</p><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 提出了 <a href="https://forums.swift.org/t/pitch-staging-in-sendable-checking/51341" title="Staging in Sendable checking" target="_blank" rel="noopener">在 Sendable 检查中实施 Staging</a> 的提案。</p><p><code>SE-0302</code> 引入了 Sendable 协议，该协议明确地指出哪些类型的值可以安全地跨过 <code>actors</code> 进行复制。通俗的讲，就是拷贝的值和原始值可以同时在上下文使用。</p><p>Sendable 检查在所有 Swift 代码中应用，消除了由 <code>shared mutable state</code> 引起的大量数据竞争。Swift 5.5 没有完全实现 Sendable 检查，因为这样做会导致太多的编译器 <code>errors</code> 和 <code>diagnostics</code>，从而导致该功能不可用。</p><p>我认为可以逐步采用 Sendable 检查来提高数据竞争的安全性。我们提出了两个想法分段完成 Sendable 检查:</p><ul><li>增量采用并发并且引入更多的 Sendable 检查。</li><li>不能让用户模块之外的 Sendable 问题阻挡进度，防止过度的注释</li></ul><p><a href="https://forums.swift.org/categories" title="Aura Lily Vulcano" target="_blank" rel="noopener">Aura Lily Vulcano</a> 推荐了一个 <a href="https://forums.swift.org/t/pitch-the-cstdlib-module/51373" title="The CStdlib module" target="_blank" rel="noopener">Swift 默认提供的新模块</a>。</p><p>该模块将重新导出包含当前平台的 <code>POSIX</code> 或类似 <code>POSIX</code> 的 C 标准库的正确模块（如果有的话）。</p><p>默认情况该模块不会被导入，但是允许 “reasonably cross-platform” 代码，以避免使用冗长的 <code>#if canImport(…)</code> 链来访问所有的标准库，因为它们在不同的操作系统上有不同的名称。</p><p>例如，模块可以命名为 CStdlib。</p><p>Robert Widmann（<a href="https://twitter.com/CodaFi_" title="CodaFi_" target="_blank" rel="noopener">@CodaFi_</a>）提出了一个关于<a href="https://forums.swift.org/t/pitching-the-start-of-variadic-generics/51467" title="The Start of Variadic Generics" target="_blank" rel="noopener">开始可变参数泛型</a>的想法。</p><p>作为改进泛型系统的人体工程学的一部分，以及为使用 tuples 抽象提供更好的支持，我想用 surface syntax 和 preliminary semantics 来实现这个想法。 由于这是一个很大的主题领域，对语言和后续提案的方向都有很大影响，因此你的反馈在此阶段对于塑造此功能集的方向至关重要。</p><p>我要感谢 <strong>Alejandro Alonso</strong>, <strong>Doug Gregor</strong> 和 <strong>Slava Pestov</strong>，感谢他们为我在这个问题上的思考奠定了基础。</p><p>可以在这里看到原文的链接 <a href="https://gist.github.com/CodaFi/a461aca155b16cd4d05a2635e7d7a361" title="TypeSequences.md · GitHub" target="_blank" rel="noopener">TypeSequences.md · GitHub</a></p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从本周开始，我们 Swift 社区公众号将开始与 SwiftWeekly 合作更新关于 Swift 社区最新的进展与动向。让我们乘着社区的风帆，一起荡起双桨，让 Swift 成为世界上最好的语言。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>如何将 Swift 代码添加为自定义 LLDB 命令</title>
    <link href="https://fanbaoying.github.io/%E5%A6%82%E4%BD%95%E5%B0%86-Swift-%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89-LLDB-%E5%91%BD%E4%BB%A4/"/>
    <id>https://fanbaoying.github.io/如何将-Swift-代码添加为自定义-LLDB-命令/</id>
    <published>2021-06-07T12:59:57.000Z</published>
    <updated>2021-06-07T13:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://swiftsenpai.com/testing/add-custom-lldb/" title="Adding Swift Code as Custom LLDB Command" target="_blank" rel="noopener">Adding Swift Code as Custom LLDB Command</a></p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 <code>po</code>。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？</p><p>在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：</p><ul><li>添加你的第一个 LLDB 命令</li><li>添加带参数的 LLDB 命令</li><li>将复杂的 Swift 代码转换为 LLDB 命令</li></ul><a id="more"></a><h2 id="2-添加您的第一个-LLDB-命令"><a href="#2-添加您的第一个-LLDB-命令" class="headerlink" title="2. 添加您的第一个 LLDB 命令"></a>2. 添加您的第一个 LLDB 命令</h2><h3 id="2-1-了解-LLDB-命令结构"><a href="#2-1-了解-LLDB-命令结构" class="headerlink" title="2.1 了解 LLDB 命令结构"></a>2.1 了解 LLDB 命令结构</h3><p>为了添加自定义 LLDB 命令，我们必须利用 <code>command alias</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias [command_name] expr -l Swift -O -- [swift_code]</span><br></pre></td></tr></table></figure><p><strong>对命令进行详细分解：</strong></p><ul><li><code>command alias</code>：使用名称为 Swift 代码添加别名的 LLDB 命令</li><li><code>[command_name]</code>: 自定义命令名称</li><li><code>expr -l Swift -O --</code>: 要求 LLDB 调试器将后面的所有内容解释为 Swift 代码</li><li><code>[swift_code]</code>：定义自定义命令逻辑的 Swift 代码</li></ul><p>举例说明，如果我们要添加一个别名为 <code>greet</code> 的自定义命令，在控制台上打印结果为 “Hello World！” ，LLDB 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias greet expr -l Swift -O -- print(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-2-添加自定义命令"><a href="#2-2-添加自定义命令" class="headerlink" title="2.2 添加自定义命令"></a>2.2 添加自定义命令</h3><p>现在已经构造了别名为 <code>greet</code> 的命令，然后添加到 LLDB 调试器中。</p><p>将 <code>greet</code> 命令添加到 LLDB 调试器的最直接方法是在 Xcode 控制台中执行别名命令。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a9a2981a3d603298.gif?imageMogr2/auto-orient/strip" alt=""></p><p>但是，这样做只会使 <code>greet</code> 命令在当前特定调试会话中可用。 也就是说，每当开始新的调试会话时，我们就需要重新键入相同的别名命令。</p><p>为了避免这种情况发生，我们可以利用位于主目录中的 <code>.lldbinit</code> 文件。 <strong>请注意</strong>，这是一个隐藏文件，如果看不到该文件，可以使用以下快捷方式在你的查找器中显示隐藏文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift + command + .</span><br></pre></td></tr></table></figure><p>如果在 finder 中启用了显示隐藏文件，仍然没有找到该文件，可以在根目录下使用下面的终端命令创建一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.lldbinit</span><br></pre></td></tr></table></figure><p>之后，打开 <code>.lldbinit</code> 文件将整个别名命令粘贴到文件中。这样，Xcode 将在每次启动新的调试会话时执行别名命令。</p><blockquote><p><strong>Pro Tip:</strong> 如果不想在每次更新 <code>.lldbinit</code> 文件时都重新启动调试会话，可以使用以下命令重新加载它：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command source ~/.lldbinit</span><br></pre></td></tr></table></figure><h2 id="3-添加带参数的-LLDB-命令"><a href="#3-添加带参数的-LLDB-命令" class="headerlink" title="3. 添加带参数的 LLDB 命令"></a>3. 添加带参数的 LLDB 命令</h2><p>接着，让我们尝试添加一个能够接受参数的命令。 在上面 greet 命令的基础上进行修改，使其能够接受一个字符串并且打印出问候消息。</p><p>这一次，我们将使用 <code>command regex</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex [command_name] &apos;s/[regex]/expr -l Swift -O -- [swift_code]/&apos;</span><br></pre></td></tr></table></figure><p>这里对 regex 命令的工作原理不做详细描述。 通常，是将 [regex] 替换为正则表达式语句 (.+)，然后在 Swift 代码中使用 %1 表示参数。</p><p>更新 <code>greet</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+)/expr -l Swift -O -- print(&quot;Hello \(%1)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name = &quot;Swift Senpai&quot;</code> 执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name</span><br><span class="line">Hello Swift Senpai!</span><br></pre></td></tr></table></figure><p>到这里，你可能会问：如果我需要传入多个参数怎么办？ 答案其实很简单。</p><p>首先，将多个 <code>(.+)</code> 添加到正则表达式语句并用空格分隔每个 <code>(.+)</code>。 之后，使用 <code>%2</code>, <code>%3</code>, <code>%4</code>… 来表示 Swift 代码中的每个参数。</p><p>将 <code>greet</code> 命令更新为支持两个参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+) (.+)/expr -l Swift -O -- print(&quot;Hello (%1) and (%2)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name1 = &quot;Swift Senpai&quot;</code> 和 <code>name2 = &quot;iOS developers&quot;</code>，使用该命令，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name1 name2</span><br><span class="line">Hello Swift Senpai and iOS developers!</span><br></pre></td></tr></table></figure><p>到这里，我们已经了解了如何添加带有多个参数的自定义 LLDB 命令。 下面，将向你展示如何将多行 Swift 函数转换为自定义 LLDB 命令。</p><h2 id="将复杂的-Swift-代码转换为-LLDB-命令"><a href="#将复杂的-Swift-代码转换为-LLDB-命令" class="headerlink" title="将复杂的 Swift 代码转换为 LLDB 命令"></a>将复杂的 Swift 代码转换为 LLDB 命令</h2><p>通过前面的介绍，我们知道添加自定义 Swift 代码作为 LLDB 命令，必须在一行中完成。因此，如果有一个多行的 Swift 函数，我们必须先将其转换为单行，然后才能将其添加到 <code>.lldbinit</code> 文件中。</p><p>比如要添加下面这个将 RGB 值转换为十六进制值的 Swift 函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hex</span><span class="params">(r: Int, g: Int, b: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(hex)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面的代码注释使用的是 <code>/* */</code> 而不是 <code>//</code>,这是为了确保将 Swift 代码转换为单行后不会中断。</p><p>下面我们需要将 Swift 代码转换为一行，操作流程如下：</p><ol><li>为每个函数参数定义一个变量。</li><li>将 <code>%1</code>、<code>%2</code>、<code>%3</code>… 分配给每个定义的变量。</li><li>在每个语句的末尾添加 <code>;</code>。</li></ol><p>更新后的 Swift 代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = %<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> g = %<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> b = %<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line"><span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(hex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们需要将 Swift 代码转换为一行，我比较喜欢使用这个<a href="https://www.textfixer.com/tools/paragraph-to-lines.php" title="代码单行转换工具" target="_blank" rel="noopener">免费在线工具</a>进行单行转换</p><p>将代码转换为单行后，就可以进行构造正则表达式命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex hex &apos;s/(.+) (.+) (.+)/expr -l Swift -O -- let r = %1; let g = %2; let b = %3; if (r &gt;= 0 &amp;&amp; r &lt;= 255) &amp;&amp; (g &gt;= 0 &amp;&amp; g &lt;= 255) &amp;&amp; (b &gt;= 0 &amp;&amp; b &lt;= 255) &#123; let rgb:Int = r&lt;&lt;16 | g&lt;&lt;8 | b&lt;&lt;0; let hex = String(format:&quot;#%06x&quot;, rgb); print(hex); &#125; else &#123; print(&quot;Invalid input value&quot;); &#125;/&apos;</span><br></pre></td></tr></table></figure><p>将命令粘贴到 <code>.lldbinit</code> 文件中，然后就可以使用了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-28714c53ef002c05.gif?imageMogr2/auto-orient/strip" alt=""></p><h2 id="实用的自定义-LLDB-命令"><a href="#实用的自定义-LLDB-命令" class="headerlink" title="实用的自定义 LLDB 命令"></a>实用的自定义 LLDB 命令</h2><p>在学会了如何向 LLDB 调试器中添加自定义命令，那么添加什么样的自定义 LLDB 命令最实用呢？</p><p>我个人认为下面的自定义命令非常实用。可以在 Xcode 控制台中将任何 JSON 可序列化类型（例如字典、数组、数据等）打印为 JSON 字符串。 可以参考<a href="https://soffes.blog/debugging-json-data-in-lldb" title="Debugging JSON Data in LLDB" target="_blank" rel="noopener">这篇文章</a>。</p><p>另外，我也很喜欢<a href="https://diamantidis.github.io/2018/10/14/modifying-ui-elements-with-xcode-and-lldb-v2" title="Modifying UI elements with Xcode and LLDB v2" target="_blank" rel="noopener">本文</a>讨论的一系列自定义命令，我们可以使用它们来动态修改 UI 元素的颜色，而无需重新构建项目。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是对 LLDB 调试器功能做了简单介绍。如果你是刚刚接触到 LLDB，希望这篇文章能帮助你开始探索这个神奇的调试工具。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://swiftsenpai.com/testing/add-custom-lldb/&quot; title=&quot;Adding Swift Code as Custom LLDB Command&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Adding Swift Code as Custom LLDB Command&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 &lt;code&gt;po&lt;/code&gt;。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？&lt;/p&gt;
&lt;p&gt;在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加你的第一个 LLDB 命令&lt;/li&gt;
&lt;li&gt;添加带参数的 LLDB 命令&lt;/li&gt;
&lt;li&gt;将复杂的 Swift 代码转换为 LLDB 命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>探索 SwiftUI 基本手势.md</title>
    <link href="https://fanbaoying.github.io/%E6%8E%A2%E7%B4%A2-SwiftUI-%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%8A%BF-md/"/>
    <id>https://fanbaoying.github.io/探索-SwiftUI-基本手势-md/</id>
    <published>2021-06-07T12:40:07.000Z</published>
    <updated>2021-06-07T12:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。</p><p>今天，我们将回顾<span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span>基本手势：</p><ul><li>TapGesture</li><li>长按手势</li><li>拖动手势</li><li>放大手势</li><li>旋转手势</li></ul><a id="more"></a><h2 id="TapGesture"><a href="#TapGesture" class="headerlink" title="TapGesture"></a>TapGesture</h2><p>轻击手势使我们能够识别 <span style="background-color:rgba(27,31,35,.05);color:orangered;">View</span> 上的一个或多个轻击。<br>我们有几种方法可以添加点击手势。</p><p>第一个是直接使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onTapGesture</span> 修饰符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">  .onTapGesture &#123;</span><br><span class="line">    <span class="comment">// Respond to Tap Gesture </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 文档中使用的其他选项是通过创建手势并将其配置为属性，然后将其与 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.gesture（_：include :)</span> 修饰符一起使用。</p><p><strong>注意：</strong> 为了执行某项操作或响应轻击，我们需要使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭，该操作在手势结束时触发。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SingleTapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">      <span class="type">TapGesture</span>()</span><br><span class="line">          .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">              <span class="comment">// Respond to Tap Gesture</span></span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">Circle</span>()</span><br><span class="line">          .gesture(singleTap)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我更喜欢第二种方法，因为这样我们可以创建不同的手势并通过我们的代码重复使用它们。</p><p>因此，如果我们将代码放在一起，就可以开始编写类似的东西。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-7c948aec7b7e9c3f.image?imageMogr2/auto-orient/strip" alt="giphy.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped1x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>()</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped1x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 1X: <span class="subst">\(tapped1x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"1X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(singleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，我们只需使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">TapGesture(count：Int)</span> 初始化程序就可以控制要响应的数量。</p><p>在这种情况下，您需要点击3次才能触发 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-49af6400b2230e18.image?imageMogr2/auto-orient/strip" alt="2.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGesture3xView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped3x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> multipleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>(<span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped3x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 3X: <span class="subst">\(tapped3x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"3X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(multipleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长按手势"><a href="#长按手势" class="headerlink" title="长按手势"></a>长按手势</h2><p>长按手势可让我们在用户长按定义的时间后以及在用户长按的时间内执行操作。</p><p>我们可以设置一个最小持续时间，以识别我们的长按手势。 可以在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">LongPressGesture</span> 初始化程序中进行设置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>然后，我们可以使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.updating</span> 方法在长按期间执行操作，并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 在识别到我们的手势时执行操作。</p><p>在此示例中，我将在长按操作期间更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 的大小和颜色，并且当识别出手势时，我将显示“文本已完成”。</p><p>另外，我在这里使用的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">GestureState</span> 属性包装器，该包装器在长按期间设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">true</span> ，在手势结束时设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">false</span> 。 我正在将此属性包装器用于示例动画。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-4a9fe52ce65b10a1.image?imageMogr2/auto-orient/strip" alt="3.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LongPressGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">GestureState</span> <span class="keyword">private</span> <span class="keyword">var</span> isLongPressDetected = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isDone = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> longPress: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br><span class="line">            .updating($isLongPressDetected) &#123; currentState, gestureState, transaction <span class="keyword">in</span></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    isDone = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                gestureState = currentState</span><br><span class="line">                transaction.animation = <span class="type">Animation</span>.easeIn(duration: <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; done <span class="keyword">in</span></span><br><span class="line">                isDone = done</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">10</span>, height: <span class="number">10</span>)</span><br><span class="line">                .foregroundColor(isLongPressDetected ? .orange : .primary)</span><br><span class="line">                .scaleEffect(<span class="type">CGSize</span>(</span><br><span class="line">                                width: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>,</span><br><span class="line">                                height: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="keyword">if</span> isLongPressDetected &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Updating..."</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isDone &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Long Press 2 sec"</span>)</span><br><span class="line">                .padding()</span><br><span class="line">                .background(isLongPressDetected ? <span class="type">Color</span>.green : <span class="type">Color</span>.orange)</span><br><span class="line">                .cornerRadius(<span class="number">16</span>)</span><br><span class="line">                .gesture(longPress)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拖动手势"><a href="#拖动手势" class="headerlink" title="拖动手势"></a>拖动手势</h2><p>拖动手势允许我们在拖动视图时执行操作。</p><p>我们可以利用并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 关闭方法来执行某些操作。 这两种方法都为我们提供了出色的属性 <span style="background-color:rgba(27,31,35,.05);color:orangered;">DragGesture.Value</span>，该属性存储以下拖动动作信息：</p><ul><li>location</li><li>predictedEndLocation</li><li>predictedEndTranslation</li><li>startLocation</li><li>time</li><li>translation</li></ul><p>我们可以使用该属性来创建可移动视图。 在当前示例中，我使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 方法更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-9d805e7489eb15e5.image?imageMogr2/auto-orient/strip" alt="4.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，添加了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 方法，以在拖动结束后重置 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-f1710b2656cab2f4.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                withAnimation(.easeOut) &#123;</span><br><span class="line">                    location = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放大手势"><a href="#放大手势" class="headerlink" title="放大手势"></a>放大手势</h2><p>当我们在View上应用放大动作时，放大手势允许做出一些动作。</p><p>在这里，还有 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，我们可以使用它们来在放大动作期间或结束时进行响应。 作为属性，接收到的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">CGFloat</span> 的 <span style="background-color:rgba(27,31,35,.05);color:orangered;">MagnificationGesture.Value</span> 。 我们可以以此为例来更改视图大小。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b3ac91417d23226f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MagnificationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> magnifiedValue: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> magnification: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">MagnificationGesture</span>()</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = value</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = <span class="number">1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span> * magnifiedValue, height: <span class="number">100</span> * magnifiedValue)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .gesture(magnification)</span><br><span class="line">            .animation(.easeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转手势"><a href="#旋转手势" class="headerlink" title="旋转手势"></a>旋转手势</h2><p>旋转手势允许旋转视图，并在旋转过程中和旋转结束时以某些动作做出响应。</p><p>它还为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，这些闭包为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">RotationGesture.Value</span>，它表示手势 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Angle</span> 值。 我们可以使用该值旋转视图。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-0939ef2e20c537bf.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RotationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> angle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> backgroundAngle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rotation: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">RotationGesture</span>()</span><br><span class="line">            .onChanged &#123; angle <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.angle = angle</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; angle <span class="keyword">in</span></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.spring()) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.backgroundAngle = angle</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span>()</span><br><span class="line">            .frame(width: <span class="number">150</span>, height: <span class="number">150</span>, alignment: .center)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .rotationEffect(<span class="keyword">self</span>.angle)</span><br><span class="line">            .gesture(rotation)</span><br><span class="line">            .background(</span><br><span class="line">                <span class="type">Rectangle</span>()</span><br><span class="line">                    .shadow(color: .primary, radius: <span class="number">10</span>, x: <span class="number">0.0</span>, y: <span class="number">0.01</span>)</span><br><span class="line">                    .foregroundColor(.secondary)</span><br><span class="line">                    .rotationEffect(backgroundAngle)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是对  <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 基本手势的总结。我们可以实现更多的交互使我们的 App 变得更生动。</p><p>对于高级的使用，可以将手势组合或者同时使用以做出响应，或者可以实现自己的自定义手势。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt; 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。&lt;/p&gt;
&lt;p&gt;今天，我们将回顾&lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt;基本手势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TapGesture&lt;/li&gt;
&lt;li&gt;长按手势&lt;/li&gt;
&lt;li&gt;拖动手势&lt;/li&gt;
&lt;li&gt;放大手势&lt;/li&gt;
&lt;li&gt;旋转手势&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>解决 iOS 14.5 UDP广播 sendto 返回 -1</title>
    <link href="https://fanbaoying.github.io/%E8%A7%A3%E5%86%B3-iOS-14-5-UDP%E5%B9%BF%E6%92%AD-sendto-%E8%BF%94%E5%9B%9E-1/"/>
    <id>https://fanbaoying.github.io/解决-iOS-14-5-UDP广播-sendto-返回-1/</id>
    <published>2021-06-07T12:37:18.000Z</published>
    <updated>2021-06-07T12:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h3><ol><li>手机系统升级到 iOS 14.5 之后，UDP 广播发送失败</li><li>项目中老版本使用到 socket </li><li>项目中新版本使用 CocoaAsyncSocket</li><li>两种 UDP 发包方式都会报错 No route to host</li></ol><p><strong>报错具体内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendto: -1</span><br><span class="line">client: sendto fail, but just ignore it</span><br><span class="line">: No route to host</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><h5 id="2-1-sendto-返回-1-问题排查"><a href="#2-1-sendto-返回-1-问题排查" class="headerlink" title="2.1  sendto 返回 -1 问题排查"></a>2.1  sendto 返回 -1 问题排查</h5><p>我们知道发送广播 sendto 返回 -1，正常情况sendto 返回值大于 0 。<br>首先判断 socket 连接是否建立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._sck_fd4 = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">if (DEBUG_ON) &#123;</span><br><span class="line">     NSLog(@&quot;client init() _sck_fd4=%d&quot;,self._sck_fd4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>self._sck_fd4 打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server init(): _sck_fd4=12</span><br></pre></td></tr></table></figure><p>socket 连接正常，接下来判断数据发包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto(self._sck_fd4, bytes, dataLen, 0, (struct sockaddr*)&amp;target_addr, addr_len) = -1</span><br></pre></td></tr></table></figure><p>数据发送失败</p><h5 id="2-2-增加-NSLocalNetworkUsageDescription-权限"><a href="#2-2-增加-NSLocalNetworkUsageDescription-权限" class="headerlink" title="2.2  增加 NSLocalNetworkUsageDescription 权限"></a>2.2  增加 NSLocalNetworkUsageDescription 权限</h5><ol><li><p>Info.plist 添加 <strong>NSLocalNetworkUsageDescription</strong></p></li><li><p>发送一次UDP广播，触发权限弹框，让用户点击好，允许访问本地网络。</p></li></ol><p>发现问题依旧存在</p><h5 id="2-3-发送单播排查"><a href="#2-3-发送单播排查" class="headerlink" title="2.3 发送单播排查"></a>2.3 发送单播排查</h5><p>由于项目中发送广播设置的 hostName 为 255.255.255.255，为了排查决定先发送单播看是否能成功。</p><p>将单播地址改为 192.168.0.101 之后发现是可以发送成功的，然后在新版本 CocoaAsyncSocket 库中发送单播也是可以成功的。</p><p>UDP 广播推荐使用 192.168.0.255 ，将广播地址改了之后，问题解决了，设备可以收到 UDP 广播数据。</p><h3 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3. 问题解决"></a>3. 问题解决</h3><p>由于 192.168.0.255 广播地址只是当前本地地址，App 中需要动态改变前三段 192.168.0 本地地址，解决方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *localInetAddr4 = [ESP_NetUtil getLocalIPv4];</span><br><span class="line"><span class="built_in">NSArray</span> *arr = [localInetAddr4 componentsSeparatedByString:<span class="string">@"."</span>];</span><br><span class="line"><span class="built_in">NSString</span> *deviceAddress4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.%@.%@.255"</span>,arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]];</span><br></pre></td></tr></table></figure><p>发包过滤，只需要过滤地址最后一段是否为 255</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isBroadcast = [targetHostName hasSuffix:@&quot;255&quot;];</span><br></pre></td></tr></table></figure><p>本文已在公众号「<strong>网罗开发</strong>」发布，如需转载请加微信：FBY-fan，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题背景&quot;&gt;&lt;a href=&quot;#1-问题背景&quot; class=&quot;headerlink&quot; title=&quot;1. 问题背景&quot;&gt;&lt;/a&gt;1. 问题背景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;手机系统升级到 iOS 14.5 之后，UDP 广播发送失败&lt;/li&gt;
&lt;li&gt;项目中老版本使用到 socket &lt;/li&gt;
&lt;li&gt;项目中新版本使用 CocoaAsyncSocket&lt;/li&gt;
&lt;li&gt;两种 UDP 发包方式都会报错 No route to host&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;报错具体内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sendto: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client: sendto fail, but just ignore it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;: No route to host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>提升工作效率 Mac 上的必备工具</title>
    <link href="https://fanbaoying.github.io/%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87-Mac-%E4%B8%8A%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    <id>https://fanbaoying.github.io/提升工作效率-Mac-上的必备工具/</id>
    <published>2021-05-02T14:19:35.000Z</published>
    <updated>2021-05-02T16:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。</p><p><strong>1. UI调试神器–Reveal</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-b5b7a9d2be34f95e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Reveal是一个界面调试工具。使用Reveal，我们可以在iOS开发时动态地查看和修改应用程序的界面。</p><p>它类似Chrome的“审查元素”功能，我们不但可以在运行时看到iOS程序的界面层级关系，还可以实时地修改程序界面，不用重新运行程序就可以看到修改之后的效果。</p><p><strong>2. 接口调试–Postman</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-a5a8702aaf98cb9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>在我们平时开发中，特别是需要与接口打交道时，无论是写接口还是用接口，拿到接口后肯定都得提前测试一下，这样的话就非常需要有一个比较给力的 Http 请求模拟工具。</p><p>Postman 就是一种网页调试与发送网页 http 请求的 chrome 插件。我们可以用来很方便的模拟 get 或者 post 或者其他方式的请求来调试接口。</p><p><strong>3. 网络拦截–Charles</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-63b1ffa7970c6be1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Charles是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p><p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。很多iOS的高仿应用都是用Charles来拦截获取网络数据的。</p><p><strong>4. 取色工具–Sip</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-5eb2a353d61b4fe4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Sip 是全栈开发人员的利器，用户只需轻点鼠标便可快速取得屏幕当前位置的颜色值，并将数据自动存到剪切板，方便随时粘贴出来。支持 CSS、UIColor 等多种格式。</p><p><strong>5. JSON 生成数据模型工具–JSONExport</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-e6767b6bbec4d27d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>JSONExport 是一个 Mac OS X 应用，用 Swift 编写。它可以将 JSON 自动生成指定语言的 Model 类代码，包括属性，属性的getters和setters方法等。</p><p>不管你 json 数据多复杂，里面嵌套多少层，该工具都可以将它转换出来，这对于我们开发生成数据模型节省了不少时间。JSONExport 支持 OC、Swift、Java 等语言。</p><p><strong>6. Git 代码界面管理工具–SourceTree</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-33833817fdc9e7f9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>SourceTree 是 Windows 和 Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。</p><p>同时它也是 Mercurial 和 Subversion 版本控制系统工具。支持创建、提交、clone、push、pull 和 merge 等操作。</p><p><strong>7. Svn 代码界面管理工具–Cornerstone</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-f5d236668488ba03?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>CornerStone 是 Mac OS X 系统下非常好用的一款 svn 软件管理工具，当然还有 Versions 也是可以用的，但是使用起来不如 CornerStone 好用、强大。</p><p><strong>注意：</strong>CornerStone 是收费，如果是公司需要使用到，建议让公司购买软件使用版权，支持正版。本人所用的是公司购买了使用权的版本。当然网上也是有破解版本的。</p><p><div align="center"></div></p><p><strong style="font-size: 20px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">软 件 链 接</span></strong></p><p><img width="150" height="150" src="https://upload-images.jianshu.io/upload_images/2829694-2fd9a02d886dd857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><section><span style="font-size: 15px;">进入上方<strong><span style="color: rgb(255, 0, 0);">▲</span></strong><span style="background-color: rgb(255, 255, 255);letter-spacing: 1px;">二维码内，回复：<strong style="font-size: 16px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">427</span></strong></span></span></section><br><br><br></p><p><strong><img src="https://upload-images.jianshu.io/upload_images/19359146-e6227bdef1fb12f8?imageMogr2/auto-orient/strip" alt=""></strong> </p><h5 id="分享-6-个百度出品的免费工具，你用过几个？"><a href="#分享-6-个百度出品的免费工具，你用过几个？" class="headerlink" title="分享 6 个百度出品的免费工具，你用过几个？"></a><a href="https://mp.weixin.qq.com/s/SCcQjGgdohHsEaD3m5aegw" target="_blank" rel="noopener">分享 6 个百度出品的免费工具，你用过几个？</a></h5><h5 id="「ApowerREC」一款功能强大的录屏软件"><a href="#「ApowerREC」一款功能强大的录屏软件" class="headerlink" title="「ApowerREC」一款功能强大的录屏软件"></a><a href="https://mp.weixin.qq.com/s/Iq4WccudqFg_0wKJ6UvrnQ" target="_blank" rel="noopener">「ApowerREC」一款功能强大的录屏软件</a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. UI调试神器–Reveal&lt;/strong&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;im
      
    
    </summary>
    
      <category term="软件工具库" scheme="https://fanbaoying.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
    
      <category term="工具" scheme="https://fanbaoying.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 支付宝支付开发（最新版）</title>
    <link href="https://fanbaoying.github.io/iOS-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/iOS-支付宝支付开发（最新版）/</id>
    <published>2021-04-28T14:00:30.000Z</published>
    <updated>2021-04-28T14:05:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。</p><p>今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。</p><p>在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。<br>其实如果接入的多的话，那些套路都可以绕着走。<br>网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。</p><a id="more"></a><h2 id="2-交互流程"><a href="#2-交互流程" class="headerlink" title="2. 交互流程"></a>2. 交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是交互流程这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8688fd141e5c4425b1e07ef6d5363447~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115b15944b364a15a6948eb180f086b1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>支付宝支付的功能流程相比较微信支付来说简单的很，如上面两张图展示的，我们的 App（也就是商户客户端）所做的大概只有三个步骤：</p><ul><li>生成订单</li><li>调用支付宝接口，发送订单</li><li>返回订单支付结果并处理</li></ul><h2 id="3-下载支付宝-SDK"><a href="#3-下载支付宝-SDK" class="headerlink" title="3. 下载支付宝 SDK"></a>3. 下载支付宝 SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了最新的 SDK 地址<br><strong>注意</strong>的是下载出来的 SDK 包里面并没有传说中的开发文档，需要其他地方找或者看网页上的。</p><p>公钥、私钥、PID、sellerID、key这些东西的用途和获取方式在文档上都有详细的说明，这里不再赘述，一定要把概念分清楚再去做，不然一会就乱了。如果遇到问题的话咱们可以再一起探讨。</p><h2 id="4-导入库集成SDK"><a href="#4-导入库集成SDK" class="headerlink" title="4.  导入库集成SDK"></a>4.  导入库集成SDK</h2><h3 id="4-1-导入文件和关键库"><a href="#4-1-导入文件和关键库" class="headerlink" title="4.1 导入文件和关键库"></a>4.1 导入文件和关键库</h3><p><strong>通过 CocoaPods 导入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod  &apos;AlipaySDK-iOS&apos;</span><br></pre></td></tr></table></figure><p><strong>手动导入</strong></p><p>官方 demo 截图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36fb998958da4664a3cb2fca96a24958~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>添加 framework 和其他文件<br>打开 iOS 工程，新版本 SDK 文件 Order 文件，你需要复制粘贴到自己工程里的有：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li><li>Until 文件夹</li><li>openssl 文件夹</li><li>libcrypto.a 和 libssl.a</li></ul><p>上面的一部分文件在打开的项目中是看不到的，需要打开项目文件夹找到。</p><p>在 Build Phases 选项卡的 Link Binary With Libraries 中，增加以下依赖：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e052992193d427e91285f9187bddff7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>其中，需要注意的是：</p><ul><li>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；</li><li>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib（如下图）。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b43efaeb56c4339af14127460fcd0c4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>此时，假如你启动工程，很大几率上你会发现报 error 的情况。</p><h3 id="4-2-引入头文件"><a href="#4-2-引入头文件" class="headerlink" title="4.2 引入头文件"></a>4.2 引入头文件</h3><p>在需要调用 AlipaySDK 的文件中，增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在支付宝的接入文档中，是将生成一个订单这步放在客户端来做了，但这个最好是放在服务器端来做。</p><p>后台生成订单然后拼接，签名，然后服务器端直接给客户端传一个加密签名过的参数就可以了，这样比较安全。</p><p>所有的订单信息，商户信息等都掌握在自己的手中，这样的话APP端就不怕被拦截数据，并且调用起来也就特别简单了，只需要调用支付的接口。</p><p>如果只需要发送订单和处理支付返回结果，只需要添加 AlipaySDK.bundle 和AlipaySDK.framework 这两个就行了，下载的SDK中很容易发现。<br>快捷支付方法是这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)payOrder:(NSString *)orderStr fromScheme:(NSString *)schemeStr callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure><p>在支付的按钮中，使用支付宝这个类，再调用这个方法就行啦！如下如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="4-4-配置支付宝客户端返回-url-处理方法"><a href="#4-4-配置支付宝客户端返回-url-处理方法" class="headerlink" title="4.4 配置支付宝客户端返回 url 处理方法"></a>4.4 配置支付宝客户端返回 url 处理方法</h3><p>如示例 AliSDKDemo\APAppDelegate.m 文件中，增加引用代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><p>在 <em>@</em>implementation  AppDelegate 中以下代码中的 NSLog 改为实际业务处理代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-项目配置"><a href="#4-5-项目配置" class="headerlink" title="4.5 项目配置"></a>4.5 项目配置</h3><p>最后，不要忘了还要写一个 URL Scheme，在 Targets -&gt; Info 下最后一个即可找到，<br>点击 “Info” 选项卡，在 “URL Types ”选项中，点击 “+”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/743ffb1092bb4cc4ab6f845a7cb7bd55~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="5-常见问题汇总"><a href="#5-常见问题汇总" class="headerlink" title="5. 常见问题汇总"></a>5. 常见问题汇总</h2><h3 id="5-1-支付后无法返回-App"><a href="#5-1-支付后无法返回-App" class="headerlink" title="5.1 支付后无法返回 App"></a>5.1 支付后无法返回 App</h3><p>一般是由于白名单没有设置正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上方代码中 appScheme 参数需要和文章 <strong>4.5 项目配置</strong>中设置的 URL Schemes 相同，这样才能对应返回 App。</p><h3 id="5-2-include-not-find"><a href="#5-2-include-not-find" class="headerlink" title="5.2 #include  not find"></a>5.2 #include <openssl opensslconf.h=""> not find</openssl></h3><p>这是一个神奇的大坑，我Google了好久，也不得其解，然后经网友提醒之后想起来#import “”和#import &lt;&gt;的区别。</p><p><strong>解决方法</strong>：Targets -&gt; Build Settings 下的 Header Search Paths。<br>添加如下目录 “$(SRCROOT)/项目名称/文件的绝对地址”<br>如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40f0b9ba81d48bc8ded85bf2fe6ae1e~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p><h3 id="5-3-‘openssl-asn1-h’-file-not-found"><a href="#5-3-‘openssl-asn1-h’-file-not-found" class="headerlink" title="5.3 ‘openssl/asn1.h’ file not found"></a>5.3 ‘openssl/asn1.h’ file not found</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae746bcaf0c4c32ae80ed76429b6b2b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>由于在项目中引入 openssl 库，出现这个问题是因为库文件项目无法找到，只需要在 Header Search Paths 中加入 $(PROJECT_DIR)/项目名称/openssl 即可，如下图操作：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5732304211a5473b9b1ed4edf5e61b32~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-4-Undefined-symbol-OBJCMETACLASS-WKWebView"><a href="#5-4-Undefined-symbol-OBJCMETACLASS-WKWebView" class="headerlink" title="5.4 Undefined symbol: _OBJCMETACLASS$_WKWebView"></a>5.4 Undefined symbol: _OBJC<em>METACLASS</em>$_WKWebView</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15de4c63d16e49ba831d344be0e19e3c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>出现上面的问题，需要在项目配置中添加系统类库：WebKit.framework</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8cff9e3b44418cbb2979ec0e9a2de5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-5-如果遇到运行后报错，类似于以下提示信息："><a href="#5-5-如果遇到运行后报错，类似于以下提示信息：" class="headerlink" title="5.5 如果遇到运行后报错，类似于以下提示信息："></a>5.5 如果遇到运行后报错，类似于以下提示信息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot find interface declaration for &apos;NSObject&apos;, superclass of &apos;Base64&apos;</span><br></pre></td></tr></table></figure><p>那么需要打开报错了的文件，增加头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br></pre></td></tr></table></figure><h3 id="5-6-Swift-中接入-SDK-遇到的问题"><a href="#5-6-Swift-中接入-SDK-遇到的问题" class="headerlink" title="5.6 Swift 中接入 SDK 遇到的问题"></a>5.6 Swift 中接入 SDK 遇到的问题</h3><p>如果项目使用 Swift 为开发语言，需要添加桥接文件，如 Bridging-Header.h</p><p>同时，在项目 Build Settings 中设置桥接文件的位置。</p><p>运行时如果发生以下报错，则在桥接文件中，写入#import <uikit uikit.h=""></uikit></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d474efcd7f487887e925a06627a0b7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-7-点击支付跳转至支付宝卡在启动页面"><a href="#5-7-点击支付跳转至支付宝卡在启动页面" class="headerlink" title="5.7 点击支付跳转至支付宝卡在启动页面"></a>5.7 点击支付跳转至支付宝卡在启动页面</h3><p>出现这个情况被卡在的页面会出现相应错误提示，一般有以下几种情况：</p><ul><li>商品信息拼接字符串错误</li><li>支付账号过期待续费状态</li><li>商户 ID 错误</li><li>订单信息验签失败</li></ul><p>获取源码方式：关注「<strong>网罗开发</strong>」回复 “<strong>支付宝支付</strong>” 即可获取</p><p>本文已在公众号「<strong>网罗开发</strong>」发布，如果转载长白请加微信：FBY-fan，备注<strong>转载长白</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-d0f9c79727486cae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。&lt;/p&gt;
&lt;p&gt;今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。&lt;/p&gt;
&lt;p&gt;在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。&lt;br&gt;其实如果接入的多的话，那些套路都可以绕着走。&lt;br&gt;网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native视频播放器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native视频播放器插件/</id>
    <published>2018-12-16T10:00:59.000Z</published>
    <updated>2018-12-16T10:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生视频播放器插件的开发与使用。</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生视频播放器插件是需要实现打开js端调用播放方法传入的视频链接URL，具体的实现思路如下：</p><ol><li><p>新建mediaPlay类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>创建一个视频播放控制器</p></li><li><p>创建一个视频播放图层</p></li><li><p>将视频播放图层添加到父控件图层</p></li><li><p>JavaScript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建mediaPlay类，实现RCTBridgeModule协议"><a href="#1-新建mediaPlay类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建mediaPlay类，实现RCTBridgeModule协议"></a>1. 新建mediaPlay类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的mediaPlay类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface mediaPlay : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，mediaPlay的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“MediaPlay”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">RCT_EXPORT_METHOD(mediaPlayer:(NSDictionary*)arguments</span><br><span class="line">                           :(RCTResponseSenderBlock)sucessCallback</span><br><span class="line">                           :(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起原声视频播放器的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-创建一个视频播放控制器"><a href="#5-创建一个视频播放控制器" class="headerlink" title="5. 创建一个视频播放控制器"></a>5. 创建一个视频播放控制器</h5><p>视频播放器是使用iOS原声<avfoundation avfoundation.h="">来实现视频的播放，创建一个视频播放控制器代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(AVPlayerViewController *)playerVC</span><br><span class="line">&#123;</span><br><span class="line">    if (_playerVC == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个视频播放控制器</span><br><span class="line">        _playerVC = [[AVPlayerViewController alloc] init];</span><br><span class="line">        //获取视频URL（远程、本地视频URL都可以）</span><br><span class="line">        NSURL * url = [NSURL URLWithString:self.vedioURL];</span><br><span class="line">        //根据URL创建播放曲目</span><br><span class="line">        AVPlayerItem * item = [AVPlayerItem playerItemWithURL:url];</span><br><span class="line">        //创建一个视频播放器</span><br><span class="line">        AVPlayer * player = [AVPlayer playerWithPlayerItem:item];</span><br><span class="line">    &#125;</span><br><span class="line">    return _playerVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></avfoundation></p><h5 id="6-创建一个视频播放图层"><a href="#6-创建一个视频播放图层" class="headerlink" title="6. 创建一个视频播放图层"></a>6. 创建一个视频播放图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个视频播放图层</span><br><span class="line"> AVPlayerLayer * playLayer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br></pre></td></tr></table></figure><h5 id="7-将视频播放图层添加到父控件图层"><a href="#7-将视频播放图层添加到父控件图层" class="headerlink" title="7. 将视频播放图层添加到父控件图层"></a>7. 将视频播放图层添加到父控件图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将视频播放图层添加到父控件图层</span><br><span class="line"> [_playerVC.view.layer addSublayer:playLayer];</span><br><span class="line"> //设置视频播放控制器的播放器为player</span><br><span class="line"> _playerVC.player = player;</span><br></pre></td></tr></table></figure><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const MediaPlayPlugin = NativeModules.MediaPlay;</span><br><span class="line">MediaPlayPlugin.mediaPlayer(&#123;filePath:&quot;http://static.tripbe.com/videofiles/20121214/9533522808.f4v.mp4&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native FMDB数据库插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native-FMDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native-FMDB数据库插件/</id>
    <published>2018-12-16T09:59:40.000Z</published>
    <updated>2018-12-16T10:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍FMDB数据库插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>FMDB数据库插件是需要实现数据的新增、查询、修改、删除等功能，通过querySQLite方法来实现数据的查询，并将接口提供给Javascript开发使用</p><p>打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建DataBasePlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>判断数据库语句，适合使用那个数据库方法</p></li><li><p>创建数据库DataBase.db</p></li><li><p>打开数据库</p></li><li><p>执行sql语句</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建DataBasePlugin类，实现RCTBridgeModule协议"><a href="#1-新建DataBasePlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建DataBasePlugin类，实现RCTBridgeModule协议"></a>1. 新建DataBasePlugin类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的DataBasePlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface DataBasePlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，DataBasePlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“DataBasePlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(execSQLite:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;数据库常用语句执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(querySQLite:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;数据库查询语句执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-判断数据库语句，适合使用那个数据库方法"><a href="#5-判断数据库语句，适合使用那个数据库方法" class="headerlink" title="5. 判断数据库语句，适合使用那个数据库方法"></a>5. 判断数据库语句，适合使用那个数据库方法</h5><p>由于数据库查询语句中的查询参数，需要通过接口传入，并不是和sql语句一起传入，所以需要进行拼接，这就需要用到数据库查询方法querySQLite，因为查询语句中包含select字符串，因此作出如下判断：<br>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if([arguments[@&quot;sql&quot;] rangeOfString:@&quot;select&quot;].location !=NSNotFound)</span><br><span class="line">    &#123;</span><br><span class="line">        failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;请使用查询方法querySQLite进行查询&quot;&#125;]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="6-创建数据库DataBase-db"><a href="#6-创建数据库DataBase-db" class="headerlink" title="6. 创建数据库DataBase.db"></a>6. 创建数据库DataBase.db</h5><p>在导入第三方FMDB库之后，需要在DataBasePlugin.m引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FMDatabase.h&quot;</span><br></pre></td></tr></table></figure></p><p>实现数据库的第一步，创建数据表，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (FMDatabase *)db</span><br><span class="line">&#123;</span><br><span class="line">    if (!_db) &#123;</span><br><span class="line">        NSString *path = [[self getDocumentPath] stringByAppendingPathComponent:@&quot;DataBase.db&quot;];</span><br><span class="line">        _db = [FMDatabase databaseWithPath:path];</span><br><span class="line">    &#125;</span><br><span class="line">    return _db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-打开数据库"><a href="#7-打开数据库" class="headerlink" title="7. 打开数据库"></a>7. 打开数据库</h5><p>判断数据库表是否已创建，如果创建成功，或者已经存在数据表，即可打开数据库，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (self.db) &#123;</span><br><span class="line">            if ([self.db open]) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;打开数据库失败&quot;&#125;]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;数据库创建失败&quot;&#125;]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-执行sql语句"><a href="#8-执行sql语句" class="headerlink" title="8. 执行sql语句"></a>8. 执行sql语句</h5><p>在创建数据表和打开数据库成功之后，对Javascript传入的sql数据库语句进行处理执行，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL result = [self.db executeUpdate:sqlString];</span><br><span class="line">if (result) &#123;</span><br><span class="line">    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;执行SQL成功&quot;&#125;]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;执行SQL失败&quot;&#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-Javascript调用浏览器方法"><a href="#9-Javascript调用浏览器方法" class="headerlink" title="9. Javascript调用浏览器方法"></a>9. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const DataBasePlugin = NativeModules.DataBasePlugin;</span><br><span class="line">DataBasePlugin.execSQLite(&#123;sql:&quot;CREATE TABLE IF NOT EXISTS NotificatonTable (id integer PRIMARY KEY AUTOINCREMENT, status text NOT NULL, title text NOT NULL, content text NOT NULL, url text NOT NULL, time text NOT NULL, remark text NOT NULL)&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native手势密码插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E6%89%8B%E5%8A%BF%E5%AF%86%E7%A0%81%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native手势密码插件/</id>
    <published>2018-12-16T09:56:29.000Z</published>
    <updated>2018-12-16T10:02:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍手势密码插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>手势密码插件是需要实现可视页面控制器、设置手势密码、验证手势密码、密码sm3加密、密码本地保存等功能，这些功能加通过在PwdLockPlugin类中封装的SetPwdLock方法和DecryptLock方法来提供给Javascript开发使用。</p><p>具体的实现思路如下：</p><ol><li><p>新建PwdLockPlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>新建设置密码控制器</p></li><li><p>新建验证密码控制器</p></li><li><p>设置手势密码</p></li><li><p>验证手势密码</p></li><li><p>密码sm3加密</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>实现源码分析是根据上面列出的具体实现思路来为大家解刨内部的实现流程及核心代码分析。</p><h4 id="1-新建PwdLockPlugin类，实现RCTBridgeModule协议"><a href="#1-新建PwdLockPlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建PwdLockPlugin类，实现RCTBridgeModule协议"></a>1. 新建PwdLockPlugin类，实现RCTBridgeModule协议</h4><p>新建继承NSObject的PwdLockPlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface PwdLockPlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h4><p>为了实现RCTBridgeModule协议，PwdLockPlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“PwdLockPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &quot;PwdLockPlugin.h&quot;</span><br><span class="line">@implementation PwdLockPlugin</span><br><span class="line">RCT_EXPORT_MODULE(PwdLockPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h4><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h4 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h4><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。下面通过举例来展示声明的方法，通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &quot;PwdLockPlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation PwdLockPlugin</span><br><span class="line">RCT_EXPORT_MODULE(PwdLockPlugin);</span><br><span class="line">//设置手势密码</span><br><span class="line">RCT_EXPORT_METHOD(SetPwdLock:(RCTResponseSenderBlock)sucessCallback failCallback:(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">        NSLog(@&quot;调起设置密码方法&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">[CLLockVC showSettingLockVCInVC:RCTPresentedViewController() successBlock:^(CLLockVC *lockVC, NSString *pwd) &#123;</span><br><span class="line">[lockVC dismiss:0.0f];</span><br><span class="line">sucessCallback(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;密码设置成功&quot;&#125;]);</span><br><span class="line">                CIBNSLog(@&quot;%@&quot;,[self jsonStringWithDict:@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;密码设置成功&quot;&#125;]);</span><br><span class="line">//存储密码</span><br><span class="line">                pwd = [CLLockVC sm3:pwd];</span><br><span class="line">[CoreArchive setStr:pwd key:CoreLockPWDKey];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//验证手势密码</span><br><span class="line">RCT_EXPORT_METHOD(DecryptLock:(RCTResponseSenderBlock)sucessCallback failCallback:(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">        NSLog(@&quot;调起验证密码方法&quot;);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[CLLockVC showVerifyLockVCInVC:RCTPresentedViewController() forgetPwdBlock:^&#123;</span><br><span class="line">failCallback(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;手势密码三次验证失败&quot;&#125;]);</span><br><span class="line">&#125; successBlock:^(CLLockVC *lockVC, NSString *pwd) &#123;</span><br><span class="line">[lockVC dismiss:0.0f];</span><br><span class="line">sucessCallback(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;手势密码验证成功&quot;&#125;]);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="5-新建设置密码控制器"><a href="#5-新建设置密码控制器" class="headerlink" title="5. 新建设置密码控制器"></a>5. 新建设置密码控制器</h4><p>设置密码控制器是由3乘3的9个可触摸按钮实现，用户可以通过滑动屏幕来触动屏幕按钮，每个按钮有自己特有的编号（编号为0-9），通过触动按钮的先后顺序来记录手势密码，并将密码存储在本地。</p><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)showSettingLockVCInVC:(UIViewController *)vc successBlock:(void(^)(CLLockVC *lockVC,NSString *pwd))successBlock&#123;</span><br><span class="line">    CLLockVC *lockVC = [self lockVC:vc];</span><br><span class="line">    lockVC.title = @&quot;设置密码&quot;;</span><br><span class="line">    lockVC.type = CoreLockTypeSetPwd;</span><br><span class="line">    lockVC.successBlock = successBlock;</span><br><span class="line">    return lockVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-cad7f3f2a337dff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="1.png"></p><h4 id="6-新建验证密码控制器"><a href="#6-新建验证密码控制器" class="headerlink" title="6. 新建验证密码控制器"></a>6. 新建验证密码控制器</h4><p>验证密码控制器是由3乘3的9个可触摸按钮实现，用户可以通过滑动屏幕来触动屏幕按钮，每个按钮有自己特有的编号（编号为0-9），通过触动按钮的先后顺序来记录手势密码，通过和本地存储的密码进行对比验证是否一致，判断是否通过验证。</p><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)showVerifyLockVCInVC:(UIViewController *)vc forgetPwdBlock:(void(^)())forgetPwdBlock successBlock:(void(^)(CLLockVC *lockVC, NSString *pwd))successBlock&#123;</span><br><span class="line">    CLLockVC *lockVC = [self lockVC:vc];</span><br><span class="line">    lockVC.title = @&quot;手势解锁&quot;;</span><br><span class="line">    lockVC.type = CoreLockTypeVeryfiPwd;</span><br><span class="line">    lockVC.successBlock = successBlock;</span><br><span class="line">    lockVC.forgetPwdBlock = forgetPwdBlock;</span><br><span class="line">    return lockVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-8eac35c9db483377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="2.png"></p><h4 id="7-设置手势密码"><a href="#7-设置手势密码" class="headerlink" title="7. 设置手势密码"></a>7. 设置手势密码</h4><p>设置手势密码的滑动实现流程如下：</p><ul><li><ol><li>第一次滑动设置</li></ol></li><li><ol><li>再次确认滑动设置</li></ol></li><li><ol><li>检测密码长度是否符合要求（至少为四个点）</li></ol></li><li><ol><li>判断两次设置的密码是否一致</li></ol></li><li><ol><li>如果密码一致提示设置成功</li></ol></li><li><ol><li>如果不一致提示再次输入</li></ol></li><li><ol><li>将密码存储在本地</li></ol></li></ul><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//第一次滑动设置</span><br><span class="line">self.lockView.setPWBeginBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleFirst];</span><br><span class="line">&#125;;</span><br><span class="line">//再次确认滑动设置</span><br><span class="line">self.lockView.setPWConfirmlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleConfirm];</span><br><span class="line">&#125;;</span><br><span class="line">//检测密码长度是否符合要求（至少为四个点）</span><br><span class="line">self.lockView.setPWSErrorLengthTooShortBlock = ^(NSUInteger currentCount)&#123;</span><br><span class="line">    [self.label showWarnMsg:[NSString stringWithFormat:@&quot;请连接至少%@个点&quot;,@(CoreLockMinItemCount)]];</span><br><span class="line">&#125;;</span><br><span class="line">//判断两次设置的密码是否一致</span><br><span class="line">self.lockView.setPWSErrorTwiceDiffBlock = ^(NSString *pwd1,NSString *pwdNow)&#123;</span><br><span class="line">    [self.label showWarnMsg:CoreLockPWDDiffTitle];</span><br><span class="line">    self.navigationItem.rightBarButtonItem = self.resetItem;</span><br><span class="line">&#125;;</span><br><span class="line">//如果密码一致提示设置成功</span><br><span class="line">self.lockView.setPWFirstRightBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleConfirm];</span><br><span class="line">&#125;;</span><br><span class="line">//如果不一致提示再次输入</span><br><span class="line">self.lockView.setPWTwiceSameBlock = ^(NSString *pwd)&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWSuccessTitle];</span><br><span class="line">    //将密码存储在本地</span><br><span class="line">    [CoreArchive setStr:pwd key:CoreLockPWDKey];</span><br><span class="line">    self.view.userInteractionEnabled = NO;</span><br><span class="line">    if(_successBlock != nil) _successBlock(self,pwd);</span><br><span class="line">    if(CoreLockTypeModifyPwd == _type)&#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-验证手势密码"><a href="#8-验证手势密码" class="headerlink" title="8. 验证手势密码"></a>8. 验证手势密码</h4><p>验证手势密码的滑动实现流程如下：</p><ul><li><ol><li>滑动输入密码</li></ol></li><li><ol><li>检测密码长度是否符合要求（至少为四个点）</li></ol></li><li><ol><li>取出本地存储的密码</li></ol></li><li><ol><li>判断输入的密码和本地密码是否一致</li></ol></li><li><ol><li>如果一致返回验证成功</li></ol></li><li><ol><li>如果不一致提示重新验证</li></ol></li></ul><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//滑动输入密码</span><br><span class="line">self.lockView.verifyPWBeginBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockVerifyNormalTitle];</span><br><span class="line">&#125;;</span><br><span class="line">//检测密码长度是否符合要求（至少为四个点）</span><br><span class="line">self.lockView.verifyPwdBlock = ^(NSString *pwd)&#123;</span><br><span class="line">    //取出本地存储的密码</span><br><span class="line">    NSString *pwdLocal = [CoreArchive strForKey:CoreLockPWDKey];</span><br><span class="line">    BOOL res = [pwdLocal isEqualToString:pwd];</span><br><span class="line">    //判断输入的密码和本地密码是否一致</span><br><span class="line">    if(res)&#123;</span><br><span class="line">        [self.label showNormalMsg:CoreLockVerifySuccesslTitle];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [self.label showWarnMsg:CoreLockVerifyErrorPwdTitle];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9-密码sm3加密"><a href="#9-密码sm3加密" class="headerlink" title="9. 密码sm3加密"></a>9. 密码sm3加密</h4><p>对密码进行sm3加密，可以保证密码在传输过程中安全传输，实现源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *) sm3:(NSString *) input</span><br><span class="line">&#123;</span><br><span class="line">    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSData *outputData = [PwdLockSM3Coded sm3_hashWithPainData:inputData];</span><br><span class="line">    NSString *outputString = [CLLockVC convertDataToHexStr:outputData];</span><br><span class="line">    NSString *upper = [outputString uppercaseString];</span><br><span class="line">    return upper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-Javascript调用浏览器方法"><a href="#10-Javascript调用浏览器方法" class="headerlink" title="10. Javascript调用浏览器方法"></a>10. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const PwdLockPlugin = NativeModules.PwdLockPlugin;</span><br><span class="line">//设置手势密码</span><br><span class="line">PwdlockPlugin.SetPwdLock((msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br><span class="line">//验证手势密码</span><br><span class="line">PwdlockPlugin.DecryptLock((msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native浏览器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native浏览器插件/</id>
    <published>2018-12-16T09:34:19.000Z</published>
    <updated>2018-12-16T10:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生浏览器插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生浏览器插件是需要实现打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建WebviewManager类，实现自定义浏览器</p></li><li><p>新建Webview类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>URL规范检测</p></li><li><p>根据传参打开浏览器</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建WebviewManager类，实现自定义浏览器"><a href="#1-新建WebviewManager类，实现自定义浏览器" class="headerlink" title="1. 新建WebviewManager类，实现自定义浏览器"></a>1. 新建WebviewManager类，实现自定义浏览器</h5><p>新建继承UIViewController的WebviewManager类，并在.h声明webURL变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface WebviewManager : UIViewController</span><br><span class="line">@property(nonatomic,strong)NSString *webURL;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>通过webURL调用NSURLRequest 封装的requestWithURL方法打开浏览器，并在视图中显示，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.m</span><br><span class="line">#import &quot;WebviewManager.h&quot;</span><br><span class="line">#import&lt;WebKit/WebKit.h&gt;</span><br><span class="line">@interface WebviewManager ()</span><br><span class="line">@property(nonatomic,strong)WKWebView *webView;</span><br><span class="line">@end</span><br><span class="line">@implementation WebviewManager</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    btn.frame = CGRectMake(20, 30, 40, 24);</span><br><span class="line">    [btn setTitle:@&quot;返回&quot; forState:UIControlStateNormal];</span><br><span class="line">    [btn addTarget:self action:@selector(backAction)</span><br><span class="line">              forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    btn.titleLabel.font = [UIFont systemFontOfSize:15];</span><br><span class="line">    [btn setTitleColor:[UIColor blackColor]  forState:UIControlStateNormal];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line">    self.webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 64, [[UIScreen mainScreen]bounds].size.width, [[UIScreen mainScreen]bounds].size.height-64)];</span><br><span class="line">    [self.view addSubview:self.webView];</span><br><span class="line">    [self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:self.webURL]]];   </span><br><span class="line">&#125;</span><br><span class="line">- (void)backAction&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-新建Webview类，实现RCTBridgeModule协议"><a href="#2-新建Webview类，实现RCTBridgeModule协议" class="headerlink" title="2. 新建Webview类，实现RCTBridgeModule协议"></a>2. 新建Webview类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的Webview类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface Webview : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加RCT-EXPORT-MODULE-宏"><a href="#3-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="3. 添加RCT_EXPORT_MODULE()宏"></a>3. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，Webview的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“WebviewPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="4-添加React-Native跟控制器"><a href="#4-添加React-Native跟控制器" class="headerlink" title="4. 添加React Native跟控制器"></a>4. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="5-声明被JavaScript-调用的方法"><a href="#5-声明被JavaScript-调用的方法" class="headerlink" title="5. 声明被JavaScript 调用的方法"></a>5. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起打开浏览器方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="6-URL规范检测"><a href="#6-URL规范检测" class="headerlink" title="6. URL规范检测"></a>6. URL规范检测</h5><p>arguments字典是JavaScript调用方法传参用的，arguments字典里面的具体字段可以和JavaScript约定好，打开浏览器的url就是通过arguments字典传过来的，传过来的url字段还不能直接使用，需要检测是否符合url规范，否则是不能正常打开网页的。<br>URL规范检测代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)smartURLForString:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    NSString *     result;</span><br><span class="line">    NSString *  trimmedStr;</span><br><span class="line">    NSRange     schemeMarkerRange;</span><br><span class="line">    NSString *  scheme;</span><br><span class="line">    assert(str != nil);</span><br><span class="line">    result = nil;</span><br><span class="line">    trimmedStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br><span class="line">    if ( (trimmedStr != nil) &amp;&amp; (trimmedStr.length != 0) ) &#123;</span><br><span class="line">        schemeMarkerRange = [trimmedStr rangeOfString:@&quot;://&quot;];</span><br><span class="line">        if (schemeMarkerRange.location == NSNotFound) &#123;</span><br><span class="line">            result = [NSString stringWithFormat:@&quot;http://%@&quot;, trimmedStr];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scheme = [trimmedStr substringWithRange:NSMakeRange(0, schemeMarkerRange.location)];</span><br><span class="line">            assert(scheme != nil);</span><br><span class="line">            if ( ([scheme compare:@&quot;http&quot;  options:NSCaseInsensitiveSearch] == NSOrderedSame)</span><br><span class="line">                || ([scheme compare:@&quot;https&quot; options:NSCaseInsensitiveSearch] == NSOrderedSame) ) &#123;</span><br><span class="line">                result = trimmedStr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // It looks like this is some unsupported URL scheme.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-根据传参打开浏览器"><a href="#7-根据传参打开浏览器" class="headerlink" title="7. 根据传参打开浏览器"></a>7. 根据传参打开浏览器</h5><p>此浏览器插件支持打开自定义浏览器和打开默认浏览器，具体使用哪种方法打开浏览器，需要JavaScript通过arguments字典以字段的形式传过来，这里就使用openType字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    if ([arguments.allKeys containsObject:@&quot;url&quot;]) &#123;</span><br><span class="line">        NSString *url = [NSString stringWithFormat:@&quot;%@&quot;,arguments[@&quot;url&quot;]];</span><br><span class="line">        NSString *openURL = [self smartURLForString:url];</span><br><span class="line">        NSString *openType = arguments[@&quot;openType&quot;];</span><br><span class="line">        if (!ValidStr(url)&amp;&amp;!ValidStr(openType)) &#123;</span><br><span class="line">            CIBNSLog(@&quot;参数错误&quot;);</span><br><span class="line">            failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if ([openType isEqualToString:[NSString stringWithFormat:@&quot;0&quot;]]) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    WebviewManager *manager = [[WebviewManager alloc]init];</span><br><span class="line">                    manager.webURL = openURL;</span><br><span class="line">                    UIViewController *vc = RCTPresentedViewController();</span><br><span class="line">                    [vc presentViewController:manager animated:YES completion:nil];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSURL *urlStr = [NSURL URLWithString:openURL];</span><br><span class="line">                    [[UIApplication sharedApplication] openURL:urlStr];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const WebviewPlugin = NativeModules.WebviewPlugin;</span><br><span class="line">WebviewPlugin.open(&#123;url:&quot;http://www.baidu.com&quot;,openType:&quot;1&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native网络请求插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native网络请求插件/</id>
    <published>2018-12-16T09:11:01.000Z</published>
    <updated>2018-12-16T10:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍网络请求插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>网络请求插件是需要实现前端与服务端的数据交互，其中包括GET请求、POST请求、文件上传、单/多张图片上传、文件下载等功能。这些功能将通过封装后的方法暴漏出来，通过RN接口提供给Javascript开发使用。</p><p>具体的实现思路如下：</p><ol><li><p>新建NetWorkPlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>导入AFNetworking请求库</p></li><li><p>新建NetworkHelper类，封装实现网络请求功能</p></li><li><p>实现GET请求</p></li><li><p>实现POST请求</p></li><li><p>实现文件上传</p></li><li><p>实现单/多张图片上传</p></li><li><p>实现文件下载</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建NetWorkPlugin类，实现RCTBridgeModule协议"><a href="#1-新建NetWorkPlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建NetWorkPlugin类，实现RCTBridgeModule协议"></a>1. 新建NetWorkPlugin类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的NetWorkPlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface NetWorkPlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，NetWorkPlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“NetWorkPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。下面通过举例来展示声明的方法，通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(post:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;POST网络请求执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-导入AFNetworking请求库"><a href="#5-导入AFNetworking请求库" class="headerlink" title="5. 导入AFNetworking请求库"></a>5. 导入AFNetworking请求库</h5><p>网络请求使用的第三方库是AFNetworking，这个库很常见，也比较常用，就不做过多的描述，可手动导入也可使用cocoapods自动导入，导入之后在.m文件中引入头文件。</p><h5 id="6-新建NetworkHelper类，封装实现网络请求功能"><a href="#6-新建NetworkHelper类，封装实现网络请求功能" class="headerlink" title="6. 新建NetworkHelper类，封装实现网络请求功能"></a>6. 新建NetworkHelper类，封装实现网络请求功能</h5><p>新建继承NSObject的NetworkHelper类，定义枚举类型来判断网络状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NetworkStatusType) &#123;</span><br><span class="line">    /** 未知网络*/</span><br><span class="line">    NetworkStatusUnknown,</span><br><span class="line">    /** 无网络*/</span><br><span class="line">    NetworkStatusNotReachable,</span><br><span class="line">    /** 手机网络*/</span><br><span class="line">    NetworkStatusReachableViaWWAN,</span><br><span class="line">    /** WIFI网络*/</span><br><span class="line">    NetworkStatusReachableViaWiFi</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定义网络状态的Block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^NetworkStatus)(NetworkStatusType status);</span><br></pre></td></tr></table></figure></p><p>实时获取网络状态,通过Block回调实时获取(此方法可多次调用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkStatusWithBlock:(NetworkStatus)networkStatus;</span><br></pre></td></tr></table></figure></p><h5 id="7-实现GET请求"><a href="#7-实现GET请求" class="headerlink" title="7. 实现GET请求"></a>7. 实现GET请求</h5><p>声明GET请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)GET:(NSString *)URL</span><br><span class="line">                        parameters:(id)parameters</span><br><span class="line">                           success:(HttpRequestSuccess)success</span><br><span class="line">                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><h5 id="8-实现POST请求"><a href="#8-实现POST请求" class="headerlink" title="8. 实现POST请求"></a>8. 实现POST请求</h5><p>声明POST请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                         parameters:(id)parameters</span><br><span class="line">                            success:(HttpRequestSuccess)success</span><br><span class="line">                            failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>POST请求具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                parameters:(id)parameters</span><br><span class="line">                   success:(HttpRequestSuccess)success</span><br><span class="line">                   failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    [self setAFHTTPSessionManagerProperty:^(AFHTTPSessionManager *sessionManager) &#123;</span><br><span class="line">        [sessionManager.requestSerializer setQueryStringSerializationWithBlock:^NSString * _Nonnull(NSURLRequest * _Nonnull request, id  _Nonnull parameters, NSError * _Nullable __autoreleasing * _Nullable error) &#123;</span><br><span class="line">            return parameters;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-实现文件上传"><a href="#9-实现文件上传" class="headerlink" title="9. 实现文件上传"></a>9. 实现文件上传</h5><p>声明文件上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param names       文件对应服务器上的字段</span><br><span class="line"> *  @param filePaths   文件本地的沙盒路径</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                            names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                                        filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                                        progress:(HttpProgress)progress</span><br><span class="line">                                         success:(HttpRequestSuccess)success</span><br><span class="line">                                         failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>文件上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                             parameters:(id)parameters</span><br><span class="line">                                  names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                              filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                               progress:(HttpProgress)progress</span><br><span class="line">                                success:(HttpRequestSuccess)success</span><br><span class="line">                                failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; filePaths.count; i++) &#123;</span><br><span class="line">            NSString *name = names[i];</span><br><span class="line">            NSString *filePath = filePaths[i];</span><br><span class="line">            [formData appendPartWithFileURL:[NSURL fileURLWithPath:filePath] name:name error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        (failure &amp;&amp; error) ? failure(error) : nil;</span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        //上传进度</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="10-实现单-多张图片上传"><a href="#10-实现单-多张图片上传" class="headerlink" title="10. 实现单/多张图片上传"></a>10. 实现单/多张图片上传</h5><p>声明单/多张图片上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param name       图片对应服务器上的字段</span><br><span class="line"> *  @param images     图片数组</span><br><span class="line"> *  @param fileNames  图片文件名数组, 可以为nil, 数组内的文件名默认为当前日期时间&quot;yyyyMMddHHmmss&quot;</span><br><span class="line"> *  @param imageScale 图片文件压缩比 范围 (0.f ~ 1.f)</span><br><span class="line"> *  @param imageType  图片文件的类型,例:png、jpg(默认类型)....</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                                        parameters:(id)parameters</span><br><span class="line">                                              name:(NSString *)name</span><br><span class="line">                                            images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                         fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                                        imageScale:(CGFloat)imageScale</span><br><span class="line">                                         imageType:(NSString *)imageType</span><br><span class="line">                                          progress:(HttpProgress)progress</span><br><span class="line">                                           success:(HttpRequestSuccess)success</span><br><span class="line">                                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>图片经过等比压缩后得到的二进制文件，默认图片的文件名, 若fileNames为nil就使用，单/多张图片上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                               parameters:(id)parameters</span><br><span class="line">                                     name:(NSString *)name</span><br><span class="line">                                   images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                               imageScale:(CGFloat)imageScale</span><br><span class="line">                                imageType:(NSString *)imageType</span><br><span class="line">                                 progress:(HttpProgress)progress</span><br><span class="line">                                  success:(HttpRequestSuccess)success</span><br><span class="line">                                  failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line"></span><br><span class="line">        for (NSUInteger i = 0; i &lt; images.count; i++) &#123;</span><br><span class="line">            NSData *imageData = UIImageJPEGRepresentation(images[i], imageScale ?: 1.f);</span><br><span class="line"></span><br><span class="line">            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">            formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;</span><br><span class="line">            NSString *str = [formatter stringFromDate:[NSDate date]];</span><br><span class="line">            NSString *imageFileName = NSStringFormat(@&quot;%@%ld.%@&quot;,str,i,imageType?:@&quot;jpg&quot;);</span><br><span class="line"></span><br><span class="line">            [formData appendPartWithFileData:imageData</span><br><span class="line">                                        name:name</span><br><span class="line">                                    fileName:fileNames ? NSStringFormat(@&quot;%@.%@&quot;,fileNames[i],imageType?:@&quot;jpg&quot;) : imageFileName</span><br><span class="line">                                    mimeType:NSStringFormat(@&quot;image/%@&quot;,imageType ?: @&quot;jpg&quot;)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="11-实现文件下载"><a href="#11-实现文件下载" class="headerlink" title="11. 实现文件下载"></a>11. 实现文件下载</h5><p>声明文件下载方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL      请求地址</span><br><span class="line"> *  @param fileDir  文件存储目录(默认存储目录为Download)</span><br><span class="line"> *  @param progress 文件下载的进度信息</span><br><span class="line"> *  @param success  下载成功的回调(回调参数filePath:文件的路径)</span><br><span class="line"> *  @param failure  下载失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回NSURLSessionDownloadTask实例，可用于暂停继续，暂停调用suspend方法，开始下载调用resume方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                                       fileDir:(NSString *)fileDir</span><br><span class="line">                                      progress:(HttpProgress)progress</span><br><span class="line">                                       success:(void(^)(NSString *filePath))success</span><br><span class="line">                                       failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>在下载过程中可以获取到下载进度，下载流程为：缓存目录拼接完成，打开文件管理器，创建Download目录，拼接文件路径，返回文件位置的URL路径。文件下载具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                              fileDir:(NSString *)fileDir</span><br><span class="line">                             progress:(HttpProgress)progress</span><br><span class="line">                              success:(void(^)(NSString *))success</span><br><span class="line">                              failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:AllReplaceURL]];</span><br><span class="line">    __block NSURLSessionDownloadTask *downloadTask = [_sessionManager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(downloadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">        NSString *downloadDir = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileDir ? fileDir : @&quot;Download&quot;];</span><br><span class="line"></span><br><span class="line">        NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">        [fileManager createDirectoryAtPath:downloadDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line"></span><br><span class="line">        NSString *filePath = [downloadDir stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line"></span><br><span class="line">        return [NSURL fileURLWithPath:filePath];</span><br><span class="line"></span><br><span class="line">    &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        [[self allSessionTask] removeObject:downloadTask];</span><br><span class="line">        if(failure &amp;&amp; error) &#123;failure(error) ; return ;&#125;;</span><br><span class="line">        success ? success(filePath.absoluteString /** NSURL-&gt;NSString*/) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    [downloadTask resume];</span><br><span class="line">    downloadTask ? [[self allSessionTask] addObject:downloadTask] : nil ;</span><br><span class="line"></span><br><span class="line">    return downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="12-Javascript调用浏览器方法"><a href="#12-Javascript调用浏览器方法" class="headerlink" title="12. Javascript调用浏览器方法"></a>12. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const NetWorkPlugin = NativeModules.NetWorkPlugin;</span><br><span class="line">NetworkPlugin.post(&#123;url:&quot;http://192.168.1.1:8080/ApiSystem/login&quot;,params:&#123;name:&quot;15842137500&quot;,login_type:&quot;0&quot;,password:&quot;000000&quot;&#125;,headers:&#123;&#125;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
