<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2022-03-31T02:07:26.125Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 中的抽象类型和方法</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://fanbaoying.github.io/Swift-中的抽象类型和方法/</id>
    <published>2022-03-31T02:03:26.000Z</published>
    <updated>2022-03-31T02:07:26.125Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象的编程中，抽象类型提供了一个基础实现，其他类型可以从中继承，以获得某种共享的、共同的功能。抽象类型与普通类型的区别在于，它们永远不会被当作原样使用（事实上，一些编程语言甚至阻止抽象类型被直接实例化），因为它们的唯一目的是作为一组相关类型的共同父类。</p><p>例如，假设我们想统一我们通过网络加载某些类型的模型的方式，通过提供一个共享的API，我们将能够用来分离关注点，使<a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift" target="_blank" rel="noopener">依赖注入</a>和<a href="https://www.swiftbysundell.com/articles/mocking-in-swift" target="_blank" rel="noopener">模拟</a>变得容易，并在我们的项目中保持方法名称的一致性。</p><a id="more"></a><p>一个基于抽象类型的方法是使用一个基类，它将作为我们所有模型加载类型的共享、统一的接口。因为我们不希望这个类被直接使用，所以我们要让它在基类的实现被错误调用时触发一个<code>fatalError</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loadable</span>&lt;<span class="title">Model</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"load(from:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，每个<code>Loadable</code>子类将重载上述<code>load</code>方法，以提供其加载功，如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果上述模式看起来很熟悉，那可能是因为它本质上与我们在<a href="https://www.swiftbysundell.com/basics/protocols" target="_blank" rel="noopener">Swift中通常使用的协议</a>的多态性完全相同。也就是说，当我们想定义一个接口，一个契约，多个类型可以通过不同的实现来遵守。</p><p>不过，协议确实比抽象类有一个显着的优势，因为编译器将强制它们的所有需求都得到正确实现——这意味着我们不再需要依赖运行时错误（例如 <code>fatalError</code>）来防止不当使用，因为我们无法实例化协议。</p><p>因此，如果我们采用面向协议的方案，而不是使用抽象基类，那么我们之前的 <code>Loadable</code> 和 <code>UserLoader</code> 类型可能看起来像这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Loadable</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Model</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意我们现在是如何使用一个相关的类型来使每个<code>Loadable</code>实现决定它想要加载的确切<code>Model</code>的——这给了我们一个在完全类型安全和巨大灵活性之间的很好的综合。</p><p>所以，一般来说，协议肯定是在Swift中声明抽象类型的首选方式，但这并不意味着它们是完美的。事实上，我们基于协议的<code>Loadable</code>实现目前有两个主要缺点:</p><ul><li><p>首先，由于我们不得不为我们的协议添加一个相关的类型，以保持我们的设计是泛型的和类型安全的，这意味着<code>Loadable</code>不能再<a href="https://www.swiftbysundell.com/questions/referencing-generic-protocols" target="_blank" rel="noopener">被直接引用了</a>。</p></li><li><p>其次，由于协议不能包含任何形式的存储。如果我们想添加任何存储属性，让所有的<code>Loadable</code>实现都能使用，我们就必须在每一个具体的实现中重新声明这些属性。</p></li></ul><p>这个属性存储方面确实是我们以前基于抽象类设计的一个巨大优势。因此，如果我们将<code>Loadable</code>还原成一个类，那么我们就能够将我们的子类所需要的所有对象直接存储在我们的基类中——不再需要在多种类型中重复声明这些属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loadable</span>&lt;<span class="title">Model</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> networking: <span class="type">Networking</span></span><br><span class="line"><span class="keyword">let</span> cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(networking: <span class="type">Networking</span>, cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.networking = networking</span><br><span class="line">        <span class="keyword">self</span>.cache = cache</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"load(from:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedUser = cache.value(forKey: url) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedUser</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> await networking.data(from: url)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>所以，我们在这里处理的基本上是一个典型的权衡方案，两种方法（抽象类与协议）都给我们带来了不同的优点和缺点。但是，如果我们能把这两种方法结合起来，得到两个方案的优点，会怎么样呢？</strong></p><p>如果我们仔细想想，基于抽象类的方法唯一真正的问题是，我们必须在每个子类需要实现的方法中加入<code>fatalError</code>，那么如果我们只为这个特定的方法使用一个协议呢？那么我们仍然可以在基类中保留我们的<code>networking</code>和<code>cache</code>属性——像这样:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Model</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadableBase</span>&lt;<span class="title">Model</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> networking: <span class="type">Networking</span></span><br><span class="line"><span class="keyword">let</span> cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(networking: <span class="type">Networking</span>, cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.networking = networking</span><br><span class="line">        <span class="keyword">self</span>.cache = cache</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但这种方法的主要缺点是，所有的具体实现现在都必须对<code>LoadableBase</code>进行子类化，并声明它们符合我们新的<code>LoadableProtocol</code>协议：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">LoadableBase</span>&lt;<span class="title">User</span>&gt;, <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这可能不是一个巨大的问题，但可以说它确实使我们的代码不那么优雅。不过，好消息是，我们实际上可以通过使用通用类型别名来解决这个问题。由于Swift的组合运算符<code>&amp;</code>支持将一个类和一个协议结合起来，我们可以将我们的<code>Loadable</code>类型作为<code>LoadableBase</code>和<code>LoadableProtocol</code>之间的组合重新引入：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Loadable</span>&lt;<span class="type">Model</span>&gt; = <span class="type">LoadableBase</span>&lt;<span class="type">Model</span>&gt; &amp; <span class="type">LoadableProtocol</span></span><br></pre></td></tr></table></figure></p><p>这样，具体的类型（如<code>UserLoader</code>）可以简单地声明它们是基于<code>Loadable</code>的，而编译器将确保所有这些类型实现我们协议的<code>load</code>方法——同时仍然使这些类型能够使用我们基类中声明的属性:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedUser = cache.value(forKey: url) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedUser</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> await networking.data(from: url)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很好! 上述方法的唯一真正的缺点是，<code>Loadable</code>仍然不能被直接引用，因为它仍然是部分的泛型协议。但这实际上可能不是一个问题——如果这成为一种情况，那么我们总是可以使用诸如<a href="https://xiaozhuanlan.com/topic/8295601734" target="_blank" rel="noopener">类型擦除</a>的技术来解决这些问题。</p><p>对于我们新的基于类型别名的<code>Loadable</code>设计方案，另一个轻微的警告是这种组合类型别名不能被扩展，如果我们想提供一些我们不想（或不能）在<code>LoadableBase</code>类中直接实现的便利API，这可能会成为一个问题。</p><p>不过，解决这个问题的一个方法是，在我们的协议中声明实现这些便利API所需要的一切，这将使我们能够自行扩展该协议：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Model</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> networking: <span class="type">Networking</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadWithCaching</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedModel = cache.value(forKey: url) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedModel</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> model = <span class="keyword">try</span> await load(from: url)</span><br><span class="line">        cache.insert(model, forKey: url)</span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是在Swift中使用抽象类型和方法的几种不同方式。子类化目前可能不像以前那样流行（在其他编程语言中也是如此），但我仍然认为这些技术在我们整个Swift开发工具箱中是非常好的。</p><p>感谢您的阅读 🚀</p><blockquote><p>译自 John Sundell 的 <a href="https://www.swiftbysundell.com/articles/abstract-types-and-methods/" target="_blank" rel="noopener">Abstract types and methods in Swift</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象的编程中，抽象类型提供了一个基础实现，其他类型可以从中继承，以获得某种共享的、共同的功能。抽象类型与普通类型的区别在于，它们永远不会被当作原样使用（事实上，一些编程语言甚至阻止抽象类型被直接实例化），因为它们的唯一目的是作为一组相关类型的共同父类。&lt;/p&gt;
&lt;p&gt;例如，假设我们想统一我们通过网络加载某些类型的模型的方式，通过提供一个共享的API，我们将能够用来分离关注点，使&lt;a href=&quot;https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;依赖注入&lt;/a&gt;和&lt;a href=&quot;https://www.swiftbysundell.com/articles/mocking-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模拟&lt;/a&gt;变得容易，并在我们的项目中保持方法名称的一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中风味各异的类型擦除</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E9%A3%8E%E5%91%B3%E5%90%84%E5%BC%82%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <id>https://fanbaoying.github.io/Swift-中风味各异的类型擦除/</id>
    <published>2022-03-31T02:03:18.000Z</published>
    <updated>2022-03-31T02:06:26.201Z</updated>
    
    <content type="html"><![CDATA[<p>Swift的总体目标是既强大到可以用于底层系统编程，又足够容易让初学者学习，这有时会导致相当有趣的情况——当Swift的类型系统的力量要求我们部署相当高级的技术来解决乍一看可能更微不足道的问题。</p><p>大多数Swift开发人员会在某一时刻或另一时刻（通常是马上，而不是日后）会遇到这样一种情况，即需要某种形式的类型擦除才能引用通用协议。从本周开始，让我们看一下是什么使类型擦除在Swift中成为必不可少的技术，然后继续探索实现它的不同 <em>“风味(Flavors)”</em>，以及每种风味为何各有优缺点。</p><a id="more"></a><h2 id="什么时候需要类型擦除？"><a href="#什么时候需要类型擦除？" class="headerlink" title="什么时候需要类型擦除？"></a>什么时候需要类型擦除？</h2><p>一开始，<em>“类型擦除”</em>一词似乎与 Swift 给我们的关注类型和编译时类型安全性的第一感觉相反，因此，最好将其描述为<em>隐藏类型</em>，而不是完全擦除它们。目的是使我们能够更轻松地与通用协议进行交互，因为这些通用协议对将要实现它们的各种类型具有特定的要求。</p><p>以标准库中的<code>Equatable</code>协议为例。由于所有目的都是为了根据相等性比较两个相同类型的值，因此<code>Self</code>元类型为其唯一要求的参数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码使任何类型都可以符合<code>Equatable</code>，同时仍然需要<code>==</code>运算符两侧的值都为同一类型，因为在实现上述方法时符合协议的每种类型都必须“填写”自己的类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">User</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: User, rhs: User)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.id == rhs.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的优点在于，它不可能意外地比较两个不相关的相等类型（例如 <code>User</code> 和 <code>String</code> ），但是，它也导致不可能将<code>Equatable</code>引用为独立协议（例如创建 <code>[Equatable]</code> ），因为编译器需要知道实际上确切符合协议的确切类型才能使用它。</p><p>当协议包含关联的类型时，也是如此。例如，在这里我们定义了一个<code>Request</code>协议，使我们可以在一个统一的实现中隐藏各种形式的数据请求（例如网络调用，数据库查询和缓存提取）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Response</span></span><br><span class="line">    associatedtype <span class="type">Error</span>: <span class="type">Swift</span>.<span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Handler</span> = (<span class="type">Result</span>&lt;<span class="type">Response</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(then handler: @escaping Handler)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的方法为我们提供了与<code>Equatable</code>相同的权衡方法——它非常强大，因为它使我们能够为任何类型的请求创建通用抽象，但也使得无法直接引用<code>Request</code>协议本身，例如这：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 报错: protocol 'Request' can only be used as a generic</span></span><br><span class="line">    <span class="comment">// constraint because it has Self or associated type requirements</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> request: Request,</span></span></span><br><span class="line"><span class="function"><span class="params">             handler: @escaping Request.Handler)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决上述问题的一种方法是完全按照报错消息的内容进行操作，即不直接引用<code>Request</code>，而是将其用作一般约束：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;R: Request&gt;<span class="params">(<span class="number">_</span> request: R,</span></span></span><br><span class="line"><span class="function"><span class="params">                         handler: @escaping R.Handler)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的方法起作用了，因为现在编译器能够保证所传递的处理程序确实与作为请求传递的<code>Request</code>实现兼容——因为它们都基于泛型<code>R</code>，而后者又被限制为符合<code>Request</code>协议。</p><p><strong>但是</strong>，尽管我们解决了方法的签名问题，但仍然无法对传递的请求进行实际的处理，因为我们无法将其存储为<code>Request</code>属性或<code>[Request]</code>数组，这将使继续构建我们的<code>RequestQueue</code>变得困难。也就是说，除非我们开始进行类型擦除。</p><h2 id="通用包装器类型擦除"><a href="#通用包装器类型擦除" class="headerlink" title="通用包装器类型擦除"></a>通用包装器类型擦除</h2><p>我们将探讨的第一种类型擦除实际上并没有涉及擦除任何类型，而是将它们包装在一个我们可以更容易引用的通用类型中。继续从之前的<code>RequestQueue</code>示例开始，我们首先创建该包装器类型——该包装器类型将捕获每个请求的<code>perform</code>方法作为闭包，以及在请求完成后应调用的处理程序：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将使我们将 Request 协议的实现包装在一个</span></span><br><span class="line"><span class="comment">// 与 Request 协议具有相同的响应和错误类型的泛型中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyRequest</span>&lt;<span class="title">Response</span>, <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Handler</span> = (<span class="type">Result</span>&lt;<span class="type">Response</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> perform: (@escaping <span class="type">Handler</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">let</span> handler: <span class="type">Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们还将把<code>RequestQueue</code>本身转换为相同的<code>Response</code>和<code>Error</code>类型的泛型——使得编译器可以保证所有关联的类型和泛型类型对齐，从而使我们可以将请求存储为独立的引用并作为数组的一部分——像这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span>&lt;<span class="title">Response</span>, <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">typealias</span> <span class="type">TypeErasedRequest</span> = <span class="type">AnyRequest</span>&lt;<span class="type">Response</span>, <span class="type">Error</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = [<span class="type">TypeErasedRequest</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ongoing: <span class="type">TypeErasedRequest</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们修改了'add'方法，以包含一个'where'子句，</span></span><br><span class="line">    <span class="comment">// 该子句确保传递的请求已关联的类型与队列的通用类型匹配。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;R: Request&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> request: R,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: @escaping R.Handler</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> <span class="keyword">where</span> <span class="type">R</span>.<span class="type">Response</span> == <span class="type">Response</span>, <span class="type">R</span>.<span class="type">Error</span> == <span class="type">Error</span> &#123;</span><br><span class="line">        <span class="comment">//要执行类型擦除，我们只需创建一个实例'AnyRequest'，</span></span><br><span class="line">        <span class="comment">//然后将其传递给基础请求将“perform”方法与处理程序一起作为闭包。</span></span><br><span class="line">        <span class="keyword">let</span> typeErased = <span class="type">AnyRequest</span>(</span><br><span class="line">            perform: request.perform,</span><br><span class="line">            handler: handler</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于我们要实现队列，因此我们不想一次有两个请求，</span></span><br><span class="line">        <span class="comment">// 所以将请求保存下拉，以防稍后有一个正在执行的请求。</span></span><br><span class="line">        <span class="keyword">guard</span> ongoing == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.append(typeErased)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perform(typeErased)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> request: TypeErasedRequest)</span></span> &#123;</span><br><span class="line">        ongoing = request</span><br><span class="line"></span><br><span class="line">        request.perform &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">            request.handler(result)</span><br><span class="line">            <span class="keyword">self</span>?.ongoing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果队列不为空，则执行下一个请求</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>请注意，上面的示例以及本文中的其他示例代码都不是线程安全的——为了使事情变得简单。有关线程安全的更多信息，请查看<a href="https://www.swiftbysundell.com/articles/avoiding-race-conditions-in-swift" target="_blank" rel="noopener">“避免在Swift 中竞争条件”</a>。</p></blockquote><p>上面的方法效果很好，但有一些缺点。我们不仅引入了新的<code>AnyRequest</code>类型，还需要将<code>RequestQueue</code>转换为泛型。这给我们带来了一点灵活性，因为我们现在只能将任何给定的队列用于具有相同 响应/错误类型 组合的请求。具有讽刺意味的是，如果我们想组成多个实例，将来可能还需要我们自己实现队列擦除。</p><h2 id="闭包类型擦除"><a href="#闭包类型擦除" class="headerlink" title="闭包类型擦除"></a>闭包类型擦除</h2><p>我们不引入包装类型，而是让我们看一下如何使用闭包来实现相同的类型擦除，同时还要使我们的<code>RequestQueue</code>非泛型且通用，足以用于不同类型的请求。</p><p>使用闭包擦除类型时，其思想是捕获在闭包内部执行操作所需的所有类型信息，并使该闭包仅接受非泛型（甚至是<code>Void</code>）输入。这样一来，我们就可以引用，存储和传递该功能，而无需实际知道功能内部会发生什么，从而为我们提供了更强大的灵活性。</p><p>更新<code>RequestQueue</code>以使用基于闭包的类型擦除的方法如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = [() -&gt; <span class="type">Void</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPerformingRequest = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;R: Request&gt;<span class="params">(<span class="number">_</span> request: R,</span></span></span><br><span class="line"><span class="function"><span class="params">                         handler: @escaping R.Handler)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 此闭包将同时捕获请求及其处理程序，而不会暴露任何类型信息</span></span><br><span class="line">        <span class="comment">// 在其外部，提供完全的类型擦除。</span></span><br><span class="line">        <span class="keyword">let</span> typeErased = &#123;</span><br><span class="line">            request.perform &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">                handler(result)</span><br><span class="line">                <span class="keyword">self</span>?.isPerformingRequest = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">self</span>?.performNextIfNeeded()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.append(typeErased)</span><br><span class="line">        performNextIfNeeded()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">performNextIfNeeded</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !isPerformingRequest &amp;&amp; !queue.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isPerformingRequest = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> closure = queue.removeFirst()</span><br><span class="line">        closure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然过分依赖闭包来捕获功能和状态有时会使我们的代码难以调试，但也可能使完全封装类型信息成为可能——使得像<code>RequestQueue</code>这样的对象可以在没有真正了解在底层工作的类型的任何细节的情况下进行工作。</p><blockquote><p>有关基于闭包的类型擦除及其更多不同方法的更多信息，请查看<a href="https://www.jianshu.com/p/8464cea6abb5" target="_blank" rel="noopener">“Swift 使用闭包实现类型擦除”</a>。</p></blockquote><h2 id="外部特化（External-specialization）"><a href="#外部特化（External-specialization）" class="headerlink" title="外部特化（External specialization）"></a>外部特化（External specialization）</h2><p>到目前为止，我们已经在<code>RequestQueue</code>本身中执行了所有类型擦除，这有一些优点——它可以让任何外部代码使用我们的队列，而不需要知道我们使用什么类型的类型擦除。然而，有时在将协议实现传递给API之前进行一些轻量级转换，既可以使事情变得更简单，又可以巧妙地封装类型擦除代码本身。</p><p>对于我们的<code>RequestQueue</code>，一种方法是要求在将每个<code>Request</code>实现添加到队列之前对其进行特化——这将把它转换为<code>RequestOperation</code>，如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RequestOperation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> closure: (@escaping () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(then handler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        closure(handler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与我们之前使用闭包在<code>RequestQueue</code>中执行类型擦除的方式类似，上面的<code>RequestOperation</code>类型将使我们能够在扩展<code>Request</code>时执行该操作：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeOperation</span><span class="params">(with handler: @escaping Handler)</span></span> -&gt; <span class="type">RequestOperation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">RequestOperation</span> &#123; finisher <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 我们其实想在这里捕获'self'，因为不这样话</span></span><br><span class="line">            <span class="comment">// 我们将冒着无法保留基本请求的风险。</span></span><br><span class="line">            <span class="keyword">self</span>.perform &#123; result <span class="keyword">in</span></span><br><span class="line">                handler(result)</span><br><span class="line">                finisher()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法的优点在于，无论是公共API还是内部实现，它都让我们的<code>RequestQueue</code>更加简单。它现在可以完全专注于作为一个队列，而不必关心任何类型的类型擦除：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = [<span class="type">RequestOperation</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ongoing: <span class="type">RequestOperation</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为类型擦除现在发生在request被传递给 queue 之前，</span></span><br><span class="line">    <span class="comment">// 它可以简单地接受一个具体的“RequestOperation”的实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> operation: RequestOperation)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> ongoing == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.append(operation)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perform(operation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> operation: RequestOperation)</span></span> &#123;</span><br><span class="line">        ongoing = operation</span><br><span class="line"></span><br><span class="line">        operation.perform &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.ongoing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果队列不为空，则执行下一个请求</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，这里的缺点是，在将每个请求添加到队列之前，我们必须手动将其转换为<code>RequestOperation</code>——虽然这不会在每个调用点添加大量代码，但这取决于必须完成相同转换的次数，它最终可能会有点像样板。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管 Swift 提供了一个功能强大得难以置信的类型系统，可以帮助我们避免大量的bug，但有时它会让人觉得我们必须与系统抗争，才能使用通用协议之类的功能。必须进行类型擦除最初看起来像是一件不必要的杂务，但它也带来了一些好处——比如从不需要关心这些类型的代码中隐藏特定类型信息。</p><p>在未来，我们可能还会看到 Swift 中添加了新的特性，可以自动化创建类型擦除包装类型的过程，也可以通过使协议也被用作适当的泛型（例如能够定义像<code>Request&lt;Response，Error&gt;</code>这样的协议）来消除对它的大量需求，而不仅仅依赖于相关的类型）。</p><p>什么样的类型擦除是最合适的——无论是现在还是将来——当然很大程度上取决于上下文，以及我们的功能是否可以在闭包中轻松地执行，或者完整包装器类型或泛型是否更适合这个问题。</p><p>感谢阅读！🚀</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift的总体目标是既强大到可以用于底层系统编程，又足够容易让初学者学习，这有时会导致相当有趣的情况——当Swift的类型系统的力量要求我们部署相当高级的技术来解决乍一看可能更微不足道的问题。&lt;/p&gt;
&lt;p&gt;大多数Swift开发人员会在某一时刻或另一时刻（通常是马上，而不是日后）会遇到这样一种情况，即需要某种形式的类型擦除才能引用通用协议。从本周开始，让我们看一下是什么使类型擦除在Swift中成为必不可少的技术，然后继续探索实现它的不同 &lt;em&gt;“风味(Flavors)”&lt;/em&gt;，以及每种风味为何各有优缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中风味各异的依赖注入</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E9%A3%8E%E5%91%B3%E5%90%84%E5%BC%82%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>https://fanbaoying.github.io/Swift-中风味各异的依赖注入/</id>
    <published>2022-03-31T02:03:09.000Z</published>
    <updated>2022-03-31T02:07:11.672Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，我们看了一些使用依赖注入的不同方法，以实现Swift应用中更多的解耦和可测试架构。例如， <a href="https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift" target="_blank" rel="noopener">“在Swift中使用工厂的依赖注入”</a>中把依赖注入和工厂模式结合起来，以及<em><a href="https://www.swiftbysundell.com/articles/avoiding-singletons-in-swift" target="_blank" rel="noopener">“在Swift中避免使用单例”</a></em> 中利用依赖注入取代单利。</p><p>到目前为止，我的大部分文章和例子都使用了基于初始化器的依赖注入。然而，就像大多数编程技术一样，依赖注入有多种“风味(Flavors)”，每一种都有自己的优点和缺点。本周，让我们来看看三种不同方式的依赖注入，以及它们如何在Swift中使用。</p><a id="more"></a><h1 id="基于初始化器"><a href="#基于初始化器" class="headerlink" title="基于初始化器"></a>基于初始化器</h1><p>让我们先快速回顾一下最常见的依赖注入方式——基于初始化器的依赖注入，即对象在被初始化时应该被赋予它所需要的依赖关系。这种方式的最大好处是，它保证我们的对象拥有它们所需要的一切，以便立即开展工作。</p><p>假设我们正在构建一个从磁盘上加载文件的<code>FileLoader</code>。为了做到这一点，它使用了两个依赖项——一个是系统提供的<code>FileManager</code>的实例，另一个是<code>Cache</code>。使用基于初始化器的依赖注入，可以这样实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> fileManager: <span class="type">FileManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> cache: <span class="type">Cache</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(fileManager: <span class="type">FileManager</span> = .<span class="keyword">default</span>,</span><br><span class="line">         cache: <span class="type">Cache</span> = .<span class="keyword">init</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fileManager = fileManager</span><br><span class="line">        <span class="keyword">self</span>.cache = cache</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面是如何使用默认参数的，以避免在使用单例或新实例时总是创建依赖关系。这使我们能够在生产代码中使用<code>FileLoader()</code>简单地创建一个文件加载器，同时仍然能够通过在测试代码中注入模拟数据或显式实例进行测试。</p><h1 id="基于属性"><a href="#基于属性" class="headerlink" title="基于属性"></a>基于属性</h1><p>虽然基于初始化器的依赖注入通常很适合你自己的自定义类，但有时当你必须从系统类继承时，它就有点难用了。一个例子是在构建视图控制器时，特别是当你使用 XIBs 或 Storyboards 来定义它们时，因为这样你就无法再控制你的类的初始化器了。</p><p>对于这些类型的情况，基于属性的依赖注入可以是一个很好的选择。与其在对象的初始化器中注入对象的依赖关系，不如在之后简单地将其分配。这种依赖注入的方式也可以帮助你减少模板文件，特别是当有一个好的默认值不一定需要注入的时候。</p><p>让我们来看看另一个例子——在这个例子中，我们要建立一个<code>PhotoEditorViewController</code>，让用户编辑他们库中的一张照片。为了发挥作用，这个视图控制器需要一个系统提供的<code>PHPhotoLibrary</code>类的实例（它是一个单例），以及一个我们自己的<code>PhotoEditorEngine</code>类的实例。为了在没有自定义初始化器的情况下实现依赖性注入，我们可以创建两个都有默认值的可变属性，就像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoEditorViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> library: <span class="type">PhotoLibrary</span> = <span class="type">PHPhotoLibrary</span>.shared()</span><br><span class="line">    <span class="keyword">var</span> engine = <span class="type">PhotoEditorEngine</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 <em><a href="https://www.swiftbysundell.com/articles/testing-swift-code-that-uses-system-singletons-in-3-easy-steps" target="_blank" rel="noopener">“通过 3 个简单的步骤测试使用了系统单例的 Swift 代码”</a></em>中的技术是如何通过使用协议来为系统照片库类提供一个更抽象的<code>PhotoLibrary</code>接口。这将使测试和数据模拟变得更加容易!</p><p>上述做法的好处是，我们仍然可以很容易地在测试中注入模拟数据，只需重新分配视图控制器的属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoEditorViewControllerTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testApplyingBlackAndWhiteFilter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">PhotoEditorViewController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配一个模拟照片库以完全控制里面存储了哪些照片</span></span><br><span class="line">        <span class="keyword">let</span> library = <span class="type">PhotoLibraryMock</span>()</span><br><span class="line">        library.photos = [<span class="type">TestPhotoFactory</span>.photoWithColor(.red)]</span><br><span class="line">        viewController.library = library</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行我们的测试命令</span></span><br><span class="line">        viewController.selectPhoto(atIndex: <span class="number">0</span>)</span><br><span class="line">        viewController.apply(<span class="built_in">filter</span>: .blackAndWhite)</span><br><span class="line">        viewController.savePhoto()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言结果是正确的</span></span><br><span class="line">        <span class="type">XCTAssertTrue</span>(photoIsBlackAndWhite(library.photos[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于参数"><a href="#基于参数" class="headerlink" title="基于参数"></a>基于参数</h1><p>最后，让我们看一下基于参数的依赖注入。当你想轻松地使遗留代码变得更容易测试且不必过多地改变其现有结构时，这种类型特别有用。</p><p>很多时候，我们只需要一个特定的依赖关系一次，或者我们只需要在某些条件下模拟它。我们不需要改变对象的初始化器或将属性暴露为可变的（这并不总是一个好方式），而是可以开放某个API来接受一个依赖关系作为参数。</p><p>让我们来看看一个<code>NoteManager</code>类，它是一个记事应用程序的一部分。它的工作是管理用户所写的所有笔记，并提供一个API用于根据查询来搜索笔记。由于这是一个可能需要一段时间的操作（如果用户有很多笔记的话，这是很有可能的），我们通常在一个后台队列中执行，像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadNotes</span><span class="params">(matching query: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                   completionHandler: @escaping <span class="params">([Note])</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">            <span class="keyword">let</span> database = <span class="keyword">self</span>.loadDatabase()</span><br><span class="line">            <span class="keyword">let</span> notes = database.<span class="built_in">filter</span> &#123; note <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> note.matches(query: query)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completionHandler(notes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述方法对我们的生产代码来说是一个很好的解决方案，但在测试中，我们通常希望尽可能地避免异步代码和并行性，以<a href="https://www.swiftbysundell.com/articles/reducing-flakiness-in-swift-tests" target="_blank" rel="noopener">避免片状现象</a>。虽然使用初始化器或基于属性的依赖注入来指定<code>NoteManager</code>应始终使用的显式队列会很好，但这可能需要对类进行大的修改，而我们现在还不能/不愿意这样做。</p><p>这就是基于参数的依赖性注入的作用。与其重构我们的整个类，不如直接注入要在哪个队列上运行<code>loadNotes</code>操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadNotes</span><span class="params">(matching query: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                   on queue: DispatchQueue = .global<span class="params">(qos: .userInitiated)</span></span></span>,</span><br><span class="line">                   completionHandler: @escaping ([<span class="type">Note</span>]) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            <span class="keyword">let</span> database = <span class="keyword">self</span>.loadDatabase()</span><br><span class="line">            <span class="keyword">let</span> notes = database.<span class="built_in">filter</span> &#123; note <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> note.matches(query: query)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completionHandler(notes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使我们能够在测试代码中轻松地使用一个自定义队列，我们可以在上面等待。这几乎可以让我们在测试中把上述API变成一个同步的API，这让事情变得更容易和更可预测。</p><p>基于参数的依赖注入的另一个用例是当你想测试静态API的时候。对于静态API，我们没有初始化器，而且我们最好也不要静态地保持任何状态，所以基于参数的依赖注入成为一个很好的选择。让我们看一个当前依赖单例的静态<code>MessageSender</code> 类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> message: Message, to user: User)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="type">Database</span>.shared.insert(message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data: <span class="type">Data</span> = <span class="keyword">try</span> wrap(message)</span><br><span class="line">        <span class="keyword">let</span> endpoint = <span class="type">Endpoint</span>.sendMessage(to: user)</span><br><span class="line">        <span class="type">NetworkManager</span>.shared.post(data, to: endpoint.url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然理想的长期解决方案可能是重构<code>MessageSender</code>，使其成为非静态的，并在其使用的任何地方正确注入，但为了方便测试（例如，为了重现/验证一个错误），我们可以简单地将其依赖性作为参数注入，而不是依赖单例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> message: Message,</span></span></span><br><span class="line"><span class="function"><span class="params">                     to user: User,</span></span></span><br><span class="line"><span class="function"><span class="params">                     database: Database = .shared,</span></span></span><br><span class="line"><span class="function"><span class="params">                     networkManager: NetworkManager = .shared)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        database.insert(message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data: <span class="type">Data</span> = <span class="keyword">try</span> wrap(message)</span><br><span class="line">        <span class="keyword">let</span> endpoint = <span class="type">Endpoint</span>.sendMessage(to: user)</span><br><span class="line">        networkManager.post(data, to: endpoint.url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次使用默认参数，除去为了方便的原因，但这里更重要的是为了能够在我们的代码中添加测试支持，同时仍然保持100%的向后兼容性👍。</p><p>感谢您的阅读 🚀</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，我们看了一些使用依赖注入的不同方法，以实现Swift应用中更多的解耦和可测试架构。例如， &lt;a href=&quot;https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“在Swift中使用工厂的依赖注入”&lt;/a&gt;中把依赖注入和工厂模式结合起来，以及&lt;em&gt;&lt;a href=&quot;https://www.swiftbysundell.com/articles/avoiding-singletons-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“在Swift中避免使用单例”&lt;/a&gt;&lt;/em&gt; 中利用依赖注入取代单利。&lt;/p&gt;
&lt;p&gt;到目前为止，我的大部分文章和例子都使用了基于初始化器的依赖注入。然而，就像大多数编程技术一样，依赖注入有多种“风味(Flavors)”，每一种都有自己的优点和缺点。本周，让我们来看看三种不同方式的依赖注入，以及它们如何在Swift中使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 23 合并 K 个升序链表（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-23-合并-K-个升序链表（Top-100）/</id>
    <published>2022-03-25T10:23:17.000Z</published>
    <updated>2022-03-31T02:12:21.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:<a href="https://m.weibo.cn/u/1827884772" title="@故胤道长" target="_blank" rel="noopener">@故胤道长</a></strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 22 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeKSortedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists: [ListNode?])</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> lists.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = lists.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> lists = lists</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">right</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                lists[<span class="keyword">left</span>] = _mergeTwoLists(lists[<span class="keyword">left</span>], lists[<span class="keyword">right</span>])</span><br><span class="line">                <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_mergeTwoLists</span><span class="params">(l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> node = dummy</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> l1 = l1</span><br><span class="line">        <span class="keyword">var</span> l2 = l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> l1!.val &lt; l2!.val &#123;</span><br><span class="line">                node.next = l1</span><br><span class="line">                l1 = l1!.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = l2</span><br><span class="line">                l2 = l2!.next</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.next!</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.next = l1 ?? l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：Dummy Node来遍历两个列表，比较两个节点并指向右边的一个。</li><li>时间复杂度： O(mlogn) m 表示一个列表的长度，n 表示列表的个数。</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/merge-k-sorted-lists/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:&lt;a href=&quot;https://m.weibo.cn/u/1827884772&quot; title=&quot;@故胤道长&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@故胤道长&lt;/a&gt;&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 22 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 22 括号生成（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-22-括号生成（Top-100）/</id>
    <published>2022-03-25T10:23:02.000Z</published>
    <updated>2022-03-31T02:12:25.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 21 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。 </p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateParentheses</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">String</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> paths = [<span class="type">String</span>](), path = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        dfs(&amp;paths, path, n, n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> paths</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> paths: <span class="keyword">inout</span> [String], <span class="number">_</span> path: String, <span class="number">_</span> leftRemaining: Int, <span class="number">_</span> rightRemaining: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rightRemaining == <span class="number">0</span> &#123;</span><br><span class="line">            paths.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftRemaining &gt; <span class="number">0</span> &#123;</span><br><span class="line">            dfs(&amp;paths, path + <span class="string">"("</span>, leftRemaining - <span class="number">1</span>, rightRemaining)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rightRemaining &gt; leftRemaining &#123;</span><br><span class="line">            dfs(&amp;paths, path + <span class="string">")"</span>, leftRemaining, rightRemaining - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：Dummy Node来遍历两个列表，比较两个节点并指向右边的一个。</li><li>时间复杂度： O(2^n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/generate-parentheses/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 21 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 21 合并两个有序链表（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-21-合并两个有序链表（Top-100）/</id>
    <published>2022-03-25T10:22:35.000Z</published>
    <updated>2022-03-31T02:12:28.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 20 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/3f183bac013b76804ef04a6f77930be5.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var next: ListNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.next = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeTwoSortedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> node = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> l1 = l1</span><br><span class="line">        <span class="keyword">var</span> l2 = l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> l1!.val &lt; l2!.val &#123;</span><br><span class="line">                node.next = l1</span><br><span class="line">                l1 = l1!.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = l2</span><br><span class="line">                l2 = l2!.next</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next!</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.next = l1 ?? l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：Dummy Node来遍历两个列表，比较两个节点并指向右边的一个。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/merge-two-sorted-lists/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 20 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 20 有效的括号</title>
    <link href="https://fanbaoying.github.io/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://fanbaoying.github.io/LeetCode-20-有效的括号/</id>
    <published>2022-03-24T02:36:23.000Z</published>
    <updated>2022-03-31T02:12:06.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 19 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-bb33acfd8ecc9401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsPhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(<span class="number">_</span> digits: String)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> digits.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">String</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> combinations = [<span class="type">String</span>](), combination = <span class="string">""</span></span><br><span class="line">        <span class="keyword">let</span> numberToStr = [<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]</span><br><span class="line">        </span><br><span class="line">        dfs(&amp;combinations, &amp;combination, numberToStr, digits, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> combinations</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> combinations: <span class="keyword">inout</span> [String], <span class="number">_</span> combination: <span class="keyword">inout</span> String, <span class="number">_</span> numberToStr: [String], <span class="number">_</span> digits: String, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> combination.<span class="built_in">count</span> == digits.<span class="built_in">count</span> &#123;</span><br><span class="line">            combinations.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentStr = fetchCurrentStr(from: digits, at: index, numberToStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> currentStr &#123;</span><br><span class="line">            combination.append(char)</span><br><span class="line">            dfs(&amp;combinations, &amp;combination, numberToStr, digits, index + <span class="number">1</span>)</span><br><span class="line">            combination.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchCurrentStr</span><span class="params">(from digits: String, at index: Int, <span class="number">_</span> numberToStr: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; digits.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid index"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentDigitChar = digits[digits.index(digits.startIndex, offsetBy: index)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> currentDigit = <span class="type">Int</span>(<span class="type">String</span>(currentDigitChar)), currentDigit &gt;= <span class="number">0</span>, currentDigit &lt; numberToStr.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid digits"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numberToStr[currentDigit]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索，首先创建电话板</li><li>时间复杂度： O(4^n)， n 表示数字长度</li><li>空间复杂度： O(n)， n 表示数字长度</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 19 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 19 删除链表的倒数第 N 个结点</title>
    <link href="https://fanbaoying.github.io/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://fanbaoying.github.io/LeetCode-19-删除链表的倒数第-N-个结点/</id>
    <published>2022-03-24T02:36:10.000Z</published>
    <updated>2022-03-31T02:12:38.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 18 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(<span class="number">_</span> head: ListNode?, <span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        <span class="keyword">var</span> prev: <span class="type">ListNode</span>? = dummy</span><br><span class="line">        <span class="keyword">var</span> post: <span class="type">ListNode</span>? = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move post</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">            post = post!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move prev and post at the same time</span></span><br><span class="line">        <span class="keyword">while</span> post!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">            prev = prev!.next</span><br><span class="line">            post = post!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prev!.next = prev!.next!.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：运动员技术</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 18 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 18 四数之和</title>
    <link href="https://fanbaoying.github.io/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://fanbaoying.github.io/LeetCode-18-四数之和/</id>
    <published>2022-03-24T02:35:56.000Z</published>
    <updated>2022-03-31T02:12:42.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 17 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code>（若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted(by: &lt;)</span><br><span class="line">        <span class="keyword">var</span> threeSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> twoSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt;= <span class="number">4</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            threeSum = target - nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> j == i + <span class="number">1</span> || nums[j] != nums[j - <span class="number">1</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                twoSum = threeSum - nums[j]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">left</span> = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] == twoSum &#123;</span><br><span class="line">                        res.append([nums[i], nums[j], nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>]])</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">repeat</span> &#123;</span><br><span class="line">                                <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] &lt; twoSum &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对数组进行排序并遍历，根据它们的和大于或小于等于目标，向左递增或向右递减</li><li>时间复杂度： O(n^3)</li><li>空间复杂度： O(nC4)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/4sum" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 17 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 17 电话号码的字母组合</title>
    <link href="https://fanbaoying.github.io/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://fanbaoying.github.io/LeetCode-17-电话号码的字母组合/</id>
    <published>2022-03-24T02:35:41.000Z</published>
    <updated>2022-03-31T02:12:46.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 16 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/21d738a264fa4c03aea3249c52eefcb9.image" alt=""></p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字</li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsPhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(<span class="number">_</span> digits: String)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> digits.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">String</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> combinations = [<span class="type">String</span>](), combination = <span class="string">""</span></span><br><span class="line">        <span class="keyword">let</span> numberToStr = [<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]</span><br><span class="line">        </span><br><span class="line">        dfs(&amp;combinations, &amp;combination, numberToStr, digits, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> combinations</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> combinations: <span class="keyword">inout</span> [String], <span class="number">_</span> combination: <span class="keyword">inout</span> String, <span class="number">_</span> numberToStr: [String], <span class="number">_</span> digits: String, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> combination.<span class="built_in">count</span> == digits.<span class="built_in">count</span> &#123;</span><br><span class="line">            combinations.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentStr = fetchCurrentStr(from: digits, at: index, numberToStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> currentStr &#123;</span><br><span class="line">            combination.append(char)</span><br><span class="line">            dfs(&amp;combinations, &amp;combination, numberToStr, digits, index + <span class="number">1</span>)</span><br><span class="line">            combination.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchCurrentStr</span><span class="params">(from digits: String, at index: Int, <span class="number">_</span> numberToStr: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; digits.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid index"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentDigitChar = digits[digits.index(digits.startIndex, offsetBy: index)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> currentDigit = <span class="type">Int</span>(<span class="type">String</span>(currentDigitChar)), currentDigit &gt;= <span class="number">0</span>, currentDigit &lt; numberToStr.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid digits"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numberToStr[currentDigit]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索，首先创建电话板</li><li>时间复杂度： O(4^n)， n 表示数字长度</li><li>空间复杂度： O(n)， n 表示数字长度</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 16 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 16 最接近的三数之和</title>
    <link href="https://fanbaoying.github.io/LeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://fanbaoying.github.io/LeetCode-16-最接近的三数之和/</id>
    <published>2022-03-24T02:33:38.000Z</published>
    <updated>2022-03-31T02:12:49.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 15 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0], target = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 1000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSumClosest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> minDiff = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted()</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">let</span> twoSum = target - nums[i]</span><br><span class="line">                <span class="keyword">var</span> <span class="keyword">left</span> = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">var</span> <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> diff = nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] - twoSum</span><br><span class="line">        </span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(diff) &lt; <span class="built_in">abs</span>(minDiff) &#123;</span><br><span class="line">                        minDiff = diff</span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="keyword">if</span> diff == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> target</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> diff &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> target + minDiff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对数组进行排序，并在更新 diff 时对其进行迭代，根据它们的和大于或小于目标而向左递增或向右递减</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(nC3)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/3sum-closest" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 15 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 15 三数之和（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-15-三数之和（Top-100）/</id>
    <published>2022-03-24T02:33:16.000Z</published>
    <updated>2022-03-31T02:12:53.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 14 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt;= <span class="number">3</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> firstNum = nums[i], remainingSum = -firstNum</span><br><span class="line">            <span class="keyword">var</span> m = i + <span class="number">1</span>, n = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> m &lt; n &#123;</span><br><span class="line">                <span class="keyword">if</span> nums[m] + nums[n] == remainingSum &#123;</span><br><span class="line">                    res.append([firstNum, nums[m], nums[n]])</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">repeat</span> &#123;</span><br><span class="line">                        m += <span class="number">1</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> nums[m] == nums[m - <span class="number">1</span>] &amp;&amp; m &lt; n</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">repeat</span> &#123;</span><br><span class="line">                        n -= <span class="number">1</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> nums[n] == nums[n + <span class="number">1</span>] &amp;&amp; m &lt; n</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[m] + nums[n] &lt; remainingSum &#123;</span><br><span class="line">                    m += <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n -= <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对数组进行排序并遍历，根据它们的和大于或不大于目标，向左递增或向右递减</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(nC3)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/3sum" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 14 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 14 最长公共前缀</title>
    <link href="https://fanbaoying.github.io/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://fanbaoying.github.io/LeetCode-14-最长公共前缀/</id>
    <published>2022-03-11T03:43:13.000Z</published>
    <updated>2022-03-11T03:46:01.330Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 13 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestCommonPrefix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="number">_</span> strs: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> firstStr = strs.first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> res = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i, char) <span class="keyword">in</span> firstStr.enumerated() &#123;</span><br><span class="line">            <span class="comment">// dropFirst(_ k: Int = 1) returns a Substring struct</span></span><br><span class="line">            <span class="keyword">for</span> str <span class="keyword">in</span> strs.<span class="built_in">dropFirst</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> i == str.<span class="built_in">count</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Another easy way: Array(str)[i], time complexity is linear though</span></span><br><span class="line">                <span class="keyword">let</span> currentStrChar = str[str.index(str.startIndex, offsetBy: i)]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> char != currentStrChar &#123;</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(char)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：首先使用第一个字符串作为结果，在迭代数组时修改</li><li>时间复杂度： O(nm)</li><li>空间复杂度： O(m)</li></ul><blockquote><p> <code>m</code> 为最长前缀长度</p></blockquote><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/longest-common-prefix/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 13 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 13  罗马数字转整数</title>
    <link href="https://fanbaoying.github.io/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://fanbaoying.github.io/LeetCode-13-罗马数字转整数/</id>
    <published>2022-03-11T03:43:00.000Z</published>
    <updated>2022-03-11T03:45:17.026Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 12 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr><tr><td>I</td><td>1 </td></tr><tr><td>V</td><td>5 </td></tr><tr><td>X</td><td>10 </td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500 </td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li><li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况</li><li><code>IL</code> 和 <code>IM</code> 这样的例子并不符合题目要求，<code>49</code> 应该写作 <code>XLIX</code>，<code>999</code> 应该写作 <code>CMXCIX</code> </li><li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article" title="罗马数字 - Mathematics" target="_blank" rel="noopener">罗马数字 - Mathematics</a></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomanToInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dict = initDict()</span><br><span class="line">        <span class="keyword">let</span> chars = [<span class="type">Character</span>](s.characters.<span class="built_in">reverse</span>())</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;chars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> current = dict[<span class="type">String</span>(chars[i])] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; current &lt; dict[<span class="type">String</span>(chars[i - <span class="number">1</span>])] &#123;</span><br><span class="line">                res -= current</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += current</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">initDict</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>: <span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">String</span>: <span class="type">Int</span>]()</span><br><span class="line">        </span><br><span class="line">        dict[<span class="string">"I"</span>] = <span class="number">1</span></span><br><span class="line">        dict[<span class="string">"V"</span>] = <span class="number">5</span></span><br><span class="line">        dict[<span class="string">"X"</span>] = <span class="number">10</span></span><br><span class="line">        dict[<span class="string">"L"</span>] = <span class="number">50</span></span><br><span class="line">        dict[<span class="string">"C"</span>] = <span class="number">100</span></span><br><span class="line">        dict[<span class="string">"D"</span>] = <span class="number">500</span></span><br><span class="line">        dict[<span class="string">"M"</span>] = <span class="number">1000</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dict</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：从头到尾进行迭代，根据不同情况进行添加或减去</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/roman-to-integer/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 12 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 12 整数转罗马数字</title>
    <link href="https://fanbaoying.github.io/LeetCode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://fanbaoying.github.io/LeetCode-12-整数转罗马数字/</id>
    <published>2022-03-11T03:42:47.000Z</published>
    <updated>2022-03-11T03:44:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 11 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr><tr><td>I</td><td>1 </td></tr><tr><td>V</td><td>5 </td></tr><tr><td>X</td><td>10 </td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500 </td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= num &lt;= 3999</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerToRoman</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(<span class="number">_</span> num: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> num &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nums = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> symbols = [<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>]</span><br><span class="line">        <span class="keyword">var</span> res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">var</span> digit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> number = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> current = number / nums[digit]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;current &#123;</span><br><span class="line">                res += symbols[digit]</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            number -= current * nums[digit]</span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alternate solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerToRomanWithDictionaries</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(<span class="number">_</span> num: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> num &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="string">""</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> thousands = [<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>]</span><br><span class="line">        <span class="keyword">let</span> hundreds = [<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>]</span><br><span class="line">        <span class="keyword">let</span> tens = [<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>]</span><br><span class="line">        <span class="keyword">let</span> ones = [<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + hundreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：符号由大到小相加，同时减去相对数</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/integer-to-roman" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 11 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 11 盛最多水的容器（前100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E5%89%8D100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-11-盛最多水的容器（前100）/</id>
    <published>2022-03-11T03:42:31.000Z</published>
    <updated>2022-03-11T03:44:08.132Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定 <code>n</code> 个非负整数 <code>a1, a2, ..., an</code> ，其中每个代表坐标 <code>(i, ai)</code> 处的一个点。 绘制 <code>n</code> 条垂直线，使得线 <code>i</code> 的两个端点位于 <code>(i, ai)</code> 和 <code>(i, 0)</code>。 找出两条线，它们与 <code>x</code> 轴一起形成一个容器，这样容器中的水最多。</p><p><strong>注意</strong>：不能倾斜容器。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2aee331defa4c29b9965d7b876b42a7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：  height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：  49</span><br><span class="line">说明：  上述垂直线由数组 [1,8,6,2,5,4,8,3,7] 表示。 在这种情况下，容器可以容纳的最大水面积（蓝色部分）为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：  height = [1,1]</span><br><span class="line">输出：  1</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： height = [4,3,2,1,4]</span><br><span class="line">输出： 16</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： height = [1,2,1]</span><br><span class="line">输出： 2</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>n == height.length</li><li>2 &lt;= n &lt;= 10^5</li><li>0 &lt;= height[i] &lt;= 10^4</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerMostWater</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(<span class="number">_</span> height: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxRes = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = height.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> minHeight = <span class="built_in">min</span>(height[<span class="keyword">left</span>], height[<span class="keyword">right</span>])</span><br><span class="line">        </span><br><span class="line">            maxRes = <span class="built_in">max</span>(maxRes, (<span class="keyword">right</span> - <span class="keyword">left</span>) * minHeight)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> minHeight == height[<span class="keyword">left</span>] &#123;</span><br><span class="line">                <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxRes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：首先给定最大宽度，然后在宽度减小的同时，向高度增加方向前进。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/container-with-most-water/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>[译]解决 iOS 15 上 APP 莫名其妙地退出登录</title>
    <link href="https://fanbaoying.github.io/%E8%AF%91-%E8%A7%A3%E5%86%B3-iOS-15-%E4%B8%8A-APP-%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95-1/"/>
    <id>https://fanbaoying.github.io/译-解决-iOS-15-上-APP-莫名其妙地退出登录-1/</id>
    <published>2022-03-10T06:13:32.000Z</published>
    <updated>2022-03-10T06:18:34.233Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png" alt=""></p><p>在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：在打开我们的应用程序(Cookpad) 时他们被莫名其妙的反复退出到登录页。非常令人惊讶的是，这并不是我们在测试 iOS 15 beta 版的时候发现的问题。</p><p>如果你是来找修复方法的，那就直接向下滚动到结论，但如果你想了解更多关于我们如何调试这个特定问题，那就开始吧。</p><h2 id="复现反馈的问题"><a href="#复现反馈的问题" class="headerlink" title="复现反馈的问题"></a>复现反馈的问题</h2><p>用户报告中的具体信息有限，我们唯一知道的是：从 iOS 15 开始，用户打开程序后会发现自己已经退出登录。</p><p>我们没有视频，也没有具体的步骤来重现这个问题，所以我努力尝试以各种方式启动应用程序，希望能亲眼看到它。我试着重新安装应用程序，我试着在有网络连接和没有网络连接的情况下启动，我试着强制退出，经过30分钟的努力，我放弃了，我开始回复用户说我没找到具体问题。</p><p>直到我再次解锁手机，没有做任何操作，就启动了 Cookpad，我发现APP就像我们的用户所反馈的那样，直接退出到了登录界面!</p><p>在那之后，我无法准确的复现该问题，但似乎与暂停使用手机一段时间后再次使用它有关。</p><h2 id="缩小问题范围"><a href="#缩小问题范围" class="headerlink" title="缩小问题范围"></a>缩小问题范围</h2><p>我担心从 Xcode 重新安装应用程序可能会影响问题的复现，所以在这样做之前，是时候查看代码并试图缩小问题的范围。根据我们的实现，我想出了三个潜在的原因。</p><ul><li>1、<code>UserDefaults</code> 中的数据被清除。</li><li>2、一个意外的API调用返回HTTP 401并触发退出登录。</li><li>3、<code>Keychain</code> 抛出了一个错误。</li></ul><p>我能够排除前两个潜在的原因，这要归功于我在自己重现该问题后观察到的一些微妙行为。</p><ul><li>登录界面没有要求我选择地区——这表明<code>UserDefaults</code>中的数据没有问题，因为我们的 “已显示地区选择 “偏好设置仍然生效。</li><li>主用户界面没有显示，即使是短暂的也没有——这表明没有尝试进行网络请求，所以 API 是问题原因可能还为时过早。</li></ul><p>这就把<code>Keychain</code>留给了我们，指引我进入下一个问题。是什么发生了改变以及为什么它如此难以复现？</p><h2 id="是什么发生了改变以及为什么它如此难以复现？"><a href="#是什么发生了改变以及为什么它如此难以复现？" class="headerlink" title="是什么发生了改变以及为什么它如此难以复现？"></a>是什么发生了改变以及为什么它如此难以复现？</h2><p>我粗略地看了一下发布说明，在谷歌上快速搜索了一下，我找不到任何东西，所以我不得不继续挖掘以更好地了解这个问题。</p><p>对<code>Keychain</code>数据的访问是通过 <a href="https://developer.apple.com/documentation/security" target="_blank" rel="noopener"><em>Security</em></a> 框架提供的，这是一个众所周知的棘手的问题。虽然有很多第三方库来包装这个框架以使事情变得更容易，但我们还是基于一些苹果的示例代码来维护我们自己的简单封装。</p><p>看一下这段代码，我们调用 <a href="https://developer.apple.com/documentation/security/1398306-secitemcopymatching?language=objc" target="_blank" rel="noopener"><em>SecItemCopyMatching</em></a> 方法来加载我们的访问令牌，它返回数据以及描述结果的 <a href="https://osstatus.com/" target="_blank" rel="noopener"><em>OSStatus</em></a> 代码。然而，不幸的是，虽然我们的封装器会将不成功的结果与状态代码一起抛出，用于调试，但我们在下一层中却抛弃了这些信息，只是将错误视为 <code>nil</code>。</p><p>我们实行了每周一次的发布计划，多亏了大量的自动化。此时，我们即将发布的下一个截止点（代码冻结）是在第二天。因为我们还没有完全了解这个问题有多普遍，而且我们也不确定是否能够在代码冻结前发布一个修复程序，所以我利用这个机会通过使用Crashlytics(崩溃日志记录工具) 增加一些额外的非致命性日志来解决缺乏可观察性的问题。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/64e699daa0417f6a10ae4e9fa861008b.png" alt="虽然我们无法改变加载会话的行为，但我们能够开始记录错误并更好地记录我们实现的当前行为。"></p><p>这个结果给了我们一些很好的观察点，然后我们可以在接下来的几周内观察。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/8af9cb1ce53fdb1ab4cda921451c34cc.png" alt="在10.58.0和10.59.0版本中，受影响的用户数量慢慢减少，这是由于我们在努力确定根本原因时引入了一项缓解措施，该措施在10.60.0中得到了修复。"></p><p>此时，我能够捕捉到返回的确切错误代码。罪魁祸首是<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>：</p><blockquote><p>不允许与 <em>Security Server</em> 交互。</p></blockquote><p>这个错误告诉我们，我们正试图在数据不可用的时间点上从<code>Keychain</code>中读取数据。这通常会发生在你试图读取已存储的数据，并将其可访问性设置为<a href="https://developer.apple.com/documentation/security/ksecattraccessiblewhenunlocked" target="_blank" rel="noopener"><em>kSecAttrAccessibleWhenUnlocked</em></a>，而设备仍处于锁定状态。</p><p>现在这完全说得通了，但唯一的问题是，在 Cookpad 中，我们只在应用启动时从<code>Keychain</code>中读取信息，而我的假设是，用户一定是点击了应用图标来启动应用，因此设备在这时应该总是解锁的，对吗？</p><p>那么，究竟发生了什么变化呢？即使我能够重现这个问题，我也100%确定我的手机在我点击应用图标的时候是解锁的，所以我不明白为什么会出现这个<code>Keychain</code>错误。</p><p>我决心找到原因，用一个调试工具替换了我们的应用程序的实现，该工具将尝试并记录其生命周期中不同节点的<code>Keychain</code>读取。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/d58d7a078b6141c722ff3efe698953d3.png" alt=""></p><p>在能够复现问题的场景中，我观察到以下结果：</p><ul><li><code>main.swift</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.init()</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.applicationProtectedDataDidBecomeAvailable(_:)</code><br>— 成功</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 成功</li><li><code>ViewController.viewDidAppear(_:)</code> — 成功</li></ul><p>所以这（一半）解释了它。为了避免在我们的AppDelegate上持有一些隐式解包的可选属性，我们在<code>init()</code>方法中进行了一些设置，其中一部分涉及从<code>Keychain</code>中读取访问令牌。这就是为什么读取会失败，以及最终为什么一些用户会发现自己被登出了。</p><p>我在这里学到了重要的一课，即我不应该假设受保护的数据在<code>AppDelegate</code>初始化时是可用的，但说实话，我还是不高兴，因为我不明白为什么它不可用。毕竟，我们已经很多年没有改变过这部分代码了，而且它在iOS 12、13和14系统中一直运行良好，那么是什么原因呢？</p><h2 id="寻找根本原因"><a href="#寻找根本原因" class="headerlink" title="寻找根本原因"></a>寻找根本原因</h2><p>我的调试界面很有用，但它缺少了一些有助于回答所有问题的重要信息：<strong>时间</strong>。</p><p>我知道在<code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code>之前，“受保护的数据” 是不可用的，但它仍然没有意义，因为为了重现这个问题，我正在执行以下操作：</p><p>1、启动应用程序<br>2、简单使用<br>3、强制退出应用<br>4、锁定我的设备并将其放置约 30 分钟<br>5、解锁设备<br>6、再次启动应用</p><p>每当我在第 6 步中再次启动应用程序时，我 100% 确定设备已解锁，因此我坚信我应该能够从 <code>AppDelegate.init()</code>中的<code>Keychain</code>读取数据。</p><p>直到我看了所有这些步骤的时间，事情才开始变得有点意义。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/ffa4e4a3730d3fd5ed1891fa73539f24.png" alt=""></p><p>再次仔细查看时间戳：</p><ul><li><code>main.swift</code> — 11:38:47</li><li><code>AppDelegate.init()</code> — 11:38:47</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 12:03:04</li><li><code>ViewController.viewDidAppear(_:)</code> — 12:03:04</li></ul><p>在我真正解锁手机并点击应用图标之前的25分钟，应用程序本身就已经启动了!</p><p>现在，我实际上从未想过有这么大的延迟，实际上是<a href="https://twitter.com/_saagarjha" target="_blank" rel="noopener">@_saagarjha</a>建议我检查时间戳，之后，他指给我看这条推特。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/6ea72a16b7326fe97fcdfd33c4758f6d.png" alt="Twitter：Apple开发人员文档的首页"></p><blockquote><p>推特翻译：<br>有趣的iOS 15优化。Duet 现在试图先发制人地 “预热” 第三方应用程序，在你点击一个应用程序图标前几分钟，通过dyld和预主静态初始化器运行它们。然后，该应用程序被暂停，随后的 “启动”似乎更快。</p></blockquote><p>现在一切都说得通了。我们最初没有测试到它，因为我们很可能没有给 iOS 15 beta 版足够的时间来 “学习” 我们的使用习惯，所以这个问题只在现实世界的场景中再现，即设备认为我很快就要启动应用程序。我仍然不知道这种预测是如何形成的，但我只想把它归结为 “Siri智能”，然后就到此为止了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从iOS 15开始，系统可能决定在用户实际尝试打开你的应用程序之前对其进行 “预热”，这可能会增加受保护的数据在你认为应该无法使用的时候的被访问概率。</p><p>通过等待<code>application(_:didFinishLaunchingWithOptions:)</code>委托回调来保护自己，如果可能的话，留意<code>UIApplication.isProtectedDataAvailable</code>（或对应委托的回调/通知）并相应处理。</p><p>我们仍然发现了非常少的非致命问题，在<code>application(_:didFinishLaunchingWithOptions:)</code>中报告<code>isProtectedDataAvailable</code>为<code>false</code>，在我们可以推迟从钥匙串阅读的访问令牌之外，这将是一个大规模的任务，现在它不值得进行进一步调查。</p><p>这是一个相当难调试的bug，而且行为的变化似乎完全没有记录，这对我来说真的没有帮助。如果你也被这个问题所困扰，请考虑复制<a href="https://openradar.appspot.com/FB9780579" target="_blank" rel="noopener">FB9780579</a>。</p><p>我从中学到了很多东西，我希望你也一样！</p><p><strong>更新：</strong> 自从发表这篇文章以来，实际上很多人都向我指出了<a href="https://developer.apple.com/documentation/uikit/app_and_environment/responding_to_the_launch_of_your_app/about_the_app_launch_sequence#3894431" target="_blank" rel="noopener">苹果公司关于预热行为的相对完善的文档</a>。然而，其他人也告诉我，他们仍然观察到与某些场景中记录的行为不同的行为，因此请谨慎行事。</p><blockquote><p>译自：<a href="https://sourcediving.com/solving-mysterious-logout-issues-on-ios-15-8b818c089466" target="_blank" rel="noopener">Solving Mysterious Logout Issues on iOS 15</a></p></blockquote><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的各种交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量，排名不分先后：</p><ul><li><a href="https://blog.csdn.net/mobanchengshuang" title="张安宇" target="_blank" rel="noopener">张安宇@微软</a></li><li><a href="https://github.com/niyaoyao" title="倪瑶" target="_blank" rel="noopener">倪瑶@Trip.com</a></li><li><a href="https://ming1016.github.io" title="戴铭" target="_blank" rel="noopener">戴铭@快手</a></li><li><a href="https://github.com/fanbaoying" title="展菲" target="_blank" rel="noopener">展菲@ESP</a></li><li><a href="https://weibo.com/u/3878455011" title="杜鑫瑶" target="_blank" rel="noopener">杜鑫瑶@新浪</a></li><li><a href="https://www.jianshu.com/u/855d6ea2b3d1" title="韦弦" target="_blank" rel="noopener">韦弦@Gwell</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：
      
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 10 正则表达式匹配（前100）</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%2010%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E5%89%8D100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode - 10 正则表达式匹配（前100）/</id>
    <published>2022-03-10T06:13:13.000Z</published>
    <updated>2022-03-10T06:35:12.679Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 9 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>已知一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot; p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;mississippi&quot; p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 30</code></li><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegularExpressionMatching</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> p: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sChars = <span class="type">Array</span>(s), pChars = <span class="type">Array</span>(p)</span><br><span class="line">        <span class="keyword">var</span> dp = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: <span class="literal">false</span>, <span class="built_in">count</span>: pChars.<span class="built_in">count</span> + <span class="number">1</span>), <span class="built_in">count</span>: sChars.<span class="built_in">count</span> + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...pChars.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="comment">// jump over "" vs. "x*" case</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = i == <span class="number">0</span> || i &gt; <span class="number">1</span> &amp;&amp; dp[<span class="number">0</span>][i - <span class="number">2</span>] &amp;&amp; pChars[i - <span class="number">1</span>] == <span class="string">"*"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...sChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>...pChars.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> j &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> pCurrent = pChars[j - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> pCurrent != <span class="string">"*"</span> &#123;</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (pCurrent == <span class="string">"."</span> || pCurrent == sChars[i - <span class="number">1</span>])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">1</span> &amp;&amp; (sChars[i - <span class="number">1</span>] == pChars[j - <span class="number">2</span>] || pChars[j - <span class="number">2</span>] == <span class="string">"."</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[sChars.<span class="built_in">count</span>][pChars.<span class="built_in">count</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典二维动态规划</li><li>时间复杂度： O(mn)</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>前往 <a href="https://leetcode.com/problems/regular-expression-matching" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="往期回顾"><a href="#往期回顾" class="headerlink" title="往期回顾"></a>往期回顾</h2><p>已发布的文章中有 <strong>5 篇高频题</strong></p><p><a href="https://mp.weixin.qq.com/s/BwUa6IN4O3DWLmoMAzoFeg" target="_blank" rel="noopener">LeetCode - #1 两数之和</a> </p><p>难度水平：<strong>容易</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★★★★★ </td></tr><tr><td>Facebook</td><td>★★★★★ </td></tr><tr><td>Airbnb</td><td>★★★★★  </td></tr><tr><td>Microsoft</td><td>★★★★★</td></tr><tr><td>LinkedIn</td><td>★★★★ </td></tr></tbody></table><p><a href="https://mp.weixin.qq.com/s/wFUafzkwiLe7GtP7Uyz9Eg" target="_blank" rel="noopener">LeetCode - #2 两数相加</a> </p><p>难度水平：<strong>中等</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Microsoft</td><td>★★★★</td></tr><tr><td>Amazon</td><td>★★ </td></tr><tr><td>Airbnb</td><td>★★  </td></tr></tbody></table><p><a href="https://mp.weixin.qq.com/s/bHLoloSfGphlBQsPXkH6pg" target="_blank" rel="noopener">LeetCode - #3 最长未重复子字符串</a> </p><p>难度水平：<strong>中等</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr></tbody></table><p><a href="https://mp.weixin.qq.com/s/QKO2sD2T1H-tFUcakgHUwA" target="_blank" rel="noopener">LeetCode - #4 求两个有序数组的中间值</a> </p><p>难度水平：<strong>困难</strong></p><p><a href="https://mp.weixin.qq.com/s/XUY2DCQfRVPmt-5cXRvRag" target="_blank" rel="noopener">LeetCode - #5 求最长的镜像字符串</a> </p><p>难度水平：<strong>中等</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr></tbody></table><blockquote><p>难度水平：容易、中等、困难<br>公司使用频率：1 ～ 6 颗 ★</p></blockquote><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 9 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 9 判断回文数字</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%209%20%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/"/>
    <id>https://fanbaoying.github.io/LeetCode - 9 判断回文数字/</id>
    <published>2022-03-10T06:12:47.000Z</published>
    <updated>2022-03-10T06:35:03.505Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个整数 <code>x</code>，如果 <code>x</code> 是回文整数，则返回 <code>true</code>。</p><p>当一个整数向后读与向前读相同时，它就是<strong>回文</strong>。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：  x = 121</span><br><span class="line">输出：  真</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：  x = -121</span><br><span class="line">输出：  假</span><br><span class="line">说明：  从左到右依次为 -121。 从右到左，它变成 121-。 因此它不是回文。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： x = 10</span><br><span class="line">输出： 假</span><br><span class="line">说明： 从右到左读取 01。 因此它不是回文。</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： x = -101</span><br><span class="line">输出： 假</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>-$2^31$ &lt;= x &lt;= $2^31$ - 1</code></li></ul><p><strong>跟进：</strong>你能在不将整数转换为字符串的情况下解决它吗？</p><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PalindromeNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> x = x</span><br><span class="line">        <span class="keyword">var</span> div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            div = div * <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">left</span> = x / div</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">right</span> = x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">left</span> != <span class="keyword">right</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            x = (x % div) / <span class="number">10</span></span><br><span class="line">            div = div / <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：负数不是回文。</li><li>时间复杂度： O(1)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/palindrome-number/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 8 字符串转换整数(atoi)</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%208%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/"/>
    <id>https://fanbaoying.github.io/LeetCode - 8 字符串转换整数-atoi/</id>
    <published>2022-03-10T06:12:25.000Z</published>
    <updated>2022-03-10T06:34:54.832Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>实现一个 <code>func myAtoi(_ str: String) -&gt; Int</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 <code>C/C++</code> 中的 <code>atoi</code> 函数）。</p><p>函数 <code>func myAtoi(_ str: String) -&gt; Int</code> 的算法如下：</p><ul><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，<code>&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32</code>）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−2^31,  2^31 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2^31</code> 的整数应该被固定为 <code>−2^31</code> ，大于 <code>2^31 − 1</code> 的整数应该被固定为 <code>2^31 − 1</code> 。</li><li>返回整数作为最终结果。</li></ul><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li><li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &apos;-&apos; 或者 &apos;+&apos;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;-42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &apos;-&apos; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &apos;-&apos; 或者 &apos;+&apos;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;words and 987&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &apos;-&apos; 或者 &apos;+&apos;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;words and 987&quot;（由于当前字符 &apos;w&apos; 不是一个数字，所以读入停止）</span><br><span class="line">         ^</span><br><span class="line">解析得到整数 0 ，因为没有读入任何数字。</span><br><span class="line">由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;-91283472332&quot;</span><br><span class="line">输出：-2147483648</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;-91283472332&quot;（读入 &apos;-&apos; 字符，所以结果应该是负数）</span><br><span class="line">          ^</span><br><span class="line">第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）</span><br><span class="line">                     ^</span><br><span class="line">解析得到整数 -91283472332 。</span><br><span class="line">由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。</span><br></pre></td></tr></table></figure><p>约束条件：</p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Atoi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span>, flag = <span class="number">1</span>, index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> intMax = <span class="number">2147483647</span>, intMin = -<span class="number">2147483648</span>, strChars = <span class="type">Array</span>(str)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// trim</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; strChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> currentChar = strChars[index]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// trim</span></span><br><span class="line">            <span class="keyword">guard</span> currentChar.isWhitespace <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> index &lt; strChars.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// handle flag</span></span><br><span class="line">        <span class="keyword">if</span> strChars[index] == <span class="string">"-"</span> &#123;</span><br><span class="line">            flag = -<span class="number">1</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> strChars[index] == <span class="string">"+"</span> &#123;</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cast to number</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; strChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> currentChar = strChars[index]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> currentChar.isNumber <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res = res * <span class="number">10</span> + currentChar.wholeNumberValue!</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> res &gt;= intMax &#123;</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> intMax</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag == -<span class="number">1</span> &amp;&amp; res &gt; intMax &#123;</span><br><span class="line">                    <span class="keyword">return</span> intMin</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> flag * res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：修剪，正和负，整数溢出，是字符数字</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/string-to-integer-atoi/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
