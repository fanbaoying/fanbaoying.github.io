<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2022-03-08T09:59:11.599Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode - 5 求最长的镜像字符串</title>
    <link href="https://fanbaoying.github.io/LeetCode-5-%E6%B1%82%E6%9C%80%E9%95%BF%E7%9A%84%E9%95%9C%E5%83%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://fanbaoying.github.io/LeetCode-5-求最长的镜像字符串/</id>
    <published>2022-03-08T09:57:50.000Z</published>
    <updated>2022-03-08T09:59:11.599Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个字符串 <code>s</code>, 返回 <code>s</code> 中的最长回文子字符串.</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;babad&quot;</span><br><span class="line">输出： &quot;bab&quot;</span><br><span class="line">解释： &quot;aba&quot; 同样是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;cbbd&quot;</span><br><span class="line">输出： &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;a&quot;</span><br><span class="line">输出： &quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;ac&quot;</span><br><span class="line">输出： &quot;a&quot;</span><br></pre></td></tr></table></figure><p>约束条件：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成。</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> s.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> sChars = <span class="type">Array</span>(s)</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">0</span>, start = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;sChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            searchPalindrome(sChars, i, i, &amp;start, &amp;maxLen)</span><br><span class="line">            searchPalindrome(sChars, i, i + <span class="number">1</span>, &amp;start, &amp;maxLen)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(sChars[start..&lt;start + maxLen])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">searchPalindrome</span><span class="params">(<span class="number">_</span> chars: [Character], <span class="number">_</span> l: Int, <span class="number">_</span> r: Int, <span class="number">_</span> start: <span class="keyword">inout</span> Int, <span class="number">_</span> maxLen: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> l = l, r = r</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> &amp;&amp; r &lt; chars.<span class="built_in">count</span> &amp;&amp; chars[l] == chars[r] &#123;</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> maxLen &lt; r - l - <span class="number">1</span> &#123;</span><br><span class="line">            start = l + <span class="number">1</span></span><br><span class="line">            maxLen = r - l - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：从中心的每个索引中找到最长的镜像字符串。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的 github 仓库是：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/longest-palindromic-substring/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>京东七鲜一面总结</title>
    <link href="https://fanbaoying.github.io/%E4%BA%AC%E4%B8%9C%E4%B8%83%E9%B2%9C%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
    <id>https://fanbaoying.github.io/京东七鲜一面总结/</id>
    <published>2022-01-19T09:57:31.000Z</published>
    <updated>2022-01-19T09:58:28.777Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanbaoying/FBYInterview-iOS" target="_blank" rel="noopener">面试资源库</a><br>如有帮助请点个 Star。</p><h2 id="1-http-链接到断开的过程？"><a href="#1-http-链接到断开的过程？" class="headerlink" title="1. http 链接到断开的过程？"></a>1. http 链接到断开的过程？</h2><h3 id="第一步：TCP建立连接：三次握手"><a href="#第一步：TCP建立连接：三次握手" class="headerlink" title="第一步：TCP建立连接：三次握手"></a>第一步：TCP建立连接：三次握手</h3><p>   HTTP 是应用层协议，他的工作还需要数据层协议的支持，最常与它搭配的就是 TCP 协议（应用层、数据层是 <code>OSI</code> 七层模型中的，以后有机会会说到的）。TCP 协议称为数据传输协议，是可靠传输，面向连接的，并且面向字节流的。</p><p><strong>面向连接</strong>：通信之前先建立连接，确保双方在线。<br><strong>可靠传输</strong>：在网络正常的情况下，数据不会丢失。<br><strong>面向字节流</strong>：传输灵活，但是 TCP 的传输存在粘包问题，没有明显的数据约定。</p><p>在正式发送请求之前，需要先建立 TCP 连接。建立 TCP 连接的过程简单地来说就是客户端和服务端之间发送三次消息来确保连接的建立，这个过程称为<strong>三次握手</strong>。</p><a id="more"></a><h3 id="第二步：浏览器发送请求命令"><a href="#第二步：浏览器发送请求命令" class="headerlink" title="第二步：浏览器发送请求命令"></a>第二步：浏览器发送请求命令</h3><p><strong>TCP 连接建立完成后，客户端就可以向服务端发送请求报文来请求了</strong></p><p>请求报文分为请求行、请求头、空行、请求体，服务端通过请求行和请求头中的内容获取客户端的信息，通过请求体中的数据获取客户端的传递过来的数据。</p><h3 id="第三步：应答响应"><a href="#第三步：应答响应" class="headerlink" title="第三步：应答响应"></a>第三步：应答响应</h3><p><strong>在接收到客户端发来的请求报文并确认完毕之后。服务端会向客户端发送响应报文</strong></p><p>响应报文是有状态行、响应头、空行和响应体组成，服务端通过状态行和响应头告诉客户端请求的状态和如何对数据处理等信息，真正的数据则在响应体中传输给客户端。</p><h3 id="第四步：断开-TCP-连接"><a href="#第四步：断开-TCP-连接" class="headerlink" title="第四步：断开 TCP 连接"></a>第四步：断开 TCP 连接</h3><p><strong>当请求完成后，还需要断开 tcp 连接，断开的过程</strong></p><p>断开的过程简单地说就算客户端和服务端之间发送四次信息来确保连接的断开，所以称为四次挥手。</p><h2 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h2><p>一、<strong>单向请求</strong> HTTP 请求是单向的，是只能由客户端发起请求，由服务端响应的<strong>请求-响应模式</strong>。（如果你需要双向请求，可以用 socket）</p><p>二、<strong>基于 TCP 协议</strong> HTTP 是应用层协议，所以其数据传输部分是基于 TCP 协议实现的。</p><p>三、<strong>无状态</strong> HTTP 请求是无状态的，即没有记忆功能，不能获取之前请求或响应的内容。起初这种简单的模式，能够加快处理速度，保证协议的稳定，但是随着应用的发展，这种无状态的模式会使我们的业务实现变得麻烦，比如说需要保存用户的登录状态，就得专门使用数据库来实现。于是乎，为了实现状态的保持，引入了 Cookie 技术来管理状态。</p><p>四、<strong>无连接</strong> HTTP 协议不能保存连接状态，每次连接只处理一个请求，用完即断，从而达到节约传输时间、提高并发性。在 TCP 连接断开之后，客户端和服务端就像陌生人一样，下次再发送请求，就得重新建立连接了。有时候，当我们需要发送一段频繁的请求时，这种无连接的状态反而会耗费更多的请求时间（因为建立和断开连接本身也需要时间），于是乎，<code>HTTP1.1</code> 中提出了持久连接的概念，可以在请求头中设置 <code>Connection: keep-alive</code> 来实现。</p><h2 id="2-深拷贝、浅拷贝"><a href="#2-深拷贝、浅拷贝" class="headerlink" title="2. 深拷贝、浅拷贝"></a>2. 深拷贝、浅拷贝</h2><blockquote><p>深拷贝、浅拷贝实例说明？</p></blockquote><p><strong>深拷贝</strong>：是对对象本身的拷贝；<br><strong>浅拷贝</strong>：是对指针的拷贝；</p><p>在 oc 中父类的指针可以指向子类的对象，这是多态的一个特性<br>声明一个 NSString 对象，让它指向一个 <code>NSMutableString</code> 对象，这一点是完全可以的，因为 <code>NSMutableString</code> 的父类就是 NSString。<code>NSMutableString</code> 是一个可以改变的对象，如果我们用 <code>strong</code> 修饰，NSString 对象强引用了 <code>NSMutableString</code> 对象。假如我们在其他的地方修改了这个 <code>NSMutableString</code> 对象，那么 NSString 的值会随之改变。</p><p><strong>关于copy修饰相关</strong></p><p>1、<strong>对 NSString 进行 copy</strong> -&gt;  这是一个浅拷贝，但是因为是不可变对象，后期值也不会改变；</p><p>2、<strong>对 NSString 进行 mutableCopy</strong>  -&gt; 这是一个深拷贝，但是拷贝出来的是一个可变的对象 NSMutableString；</p><p>3、<strong>对 NSMutableString 进行 copy</strong>  -&gt; 这是一个深拷贝，拷贝出来一个不可变的对象；</p><p>4、<strong>对 NSmutableString 进行 mutableCopy</strong> -&gt; 这是一个深拷贝，拷贝出来一个可变的对象；</p><p><strong>总结：</strong></p><p>对对象进行 <code>mutableCopy</code>，不管对象是可变的还是不可变的都是深拷贝，并且拷贝出来的对象都是可变的；</p><p>对对象进行 <code>copy</code>，copy 出来的都是不可变的。</p><p>对于系统的非容器类对象，我们可以认为，如果对一不可变对象复制，copy 是指针复制（浅拷贝）和 <code>mutableCopy</code> 就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是 copy 返回的对象是不可变的。</p><p>指 <code>NSArray</code>，<code>NSDictionary</code> 等。对于容器类本身，上面讨论的结论也是适用的，需要探讨的是复制后容器内对象的变化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy返回不可变对象，mutablecopy返回可变对象</span></span><br><span class="line"><span class="built_in">NSArray</span> *array1 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *arrayCopy1 = [array1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="comment">//arrayCopy1是和array同一个NSArray对象（指向相同的对象），包括array里面的元素也是指向相同的指针</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array1 retain count: %d"</span>,[array1 retainCount]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array1 retain count: %d"</span>,[arrayCopy1 retainCount]);</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArrayCopy1 = [array1 mutableCopy];</span><br></pre></td></tr></table></figure><p><code>mArrayCopy1</code> 是 <code>array1</code> 的可变副本，指向的对象和 <code>array1</code> 不同，但是其中的元素和 <code>array1</code> 中的元素指向的是同一个对象。</p><p><code>mArrayCopy1</code> 还可以修改自己的对象 <code>[mArrayCopy1 addObject:@&quot;de&quot;]</code>;</p><p><code>[mArrayCopy1 removeObjectAtIndex:0];</code> <code>array1</code> 和 <code>arrayCopy1</code> 是指针复制，而 <code>mArrayCopy1</code> 是对象复制，<code>mArrayCopy1</code> 还可以改变期内的元素：删除或添加。但是注意的是，容器内的元素内容都是指针复制。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *mArray1 = [<span class="built_in">NSArray</span> arrayWithObjects:[<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"a"</span>],<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *mArrayCopy2 = [mArray1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArrayMCopy1 = [mArray1 mutableCopy];</span><br><span class="line"><span class="built_in">NSMutableString</span> *testString = [mArray1 objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[testString appendString:<span class="string">@" tail"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@-%@-%@"</span>,mArray1,mArrayMCopy1,mArrayCopy2);</span><br><span class="line">结果：mArray1,mArrayMCopy1,mArrayCopy2三个数组的首元素都发生了变化！</span><br></pre></td></tr></table></figure><p><strong>补充：来自开发者留言</strong> </p><p>面试时我有时会问说说 <code>copy</code> 和 <code>mutableCopy</code>，候选人几乎 100% 说你是说深拷贝和浅拷贝啊 ….，我会说不是！</p><p>&gt; 下面用 <code>NSArray</code>、<code>NSMutableArray</code> 举例，因为 <code>NSString</code>、<code>NSMutableString</code> 并不会再引用其它对象，因此不足以说明问题。</p><p>1、<code>NSArray</code> 等类型的 <code>copy</code> 实际并没有 <code>copy</code>，或者最多只能说 <code>copy</code> 了引用，因为 <code>copy</code> 方法只返回了 <code>self</code>，这是对内存的优化；</p><p>2、而 <code>NSMutableArray</code> 的 <code>copy</code> 确实 <code>copy</code> 了，得到的是新的 <code>NSArray</code> 对象，但并不是所谓的深拷贝，因为它只浅浅地 <code>copy</code> 了一个 <code>NSArray</code>，其中的内容仍然是 <code>NSMutableArray</code> 的内容，可以用 == 直接判等；</p><p>3、<code>NSArray</code> 和 <code>NSMutableArray</code> 的 <code>mutableCopy</code> 与 2 相似，只是结果是个 <code>NSMutableArray</code>；</p><p>4、以上说法一般只适用于 Foundation 提供的一些类型，很多时候并不适用于自己写的类 —— 思考一下你自己写的类是怎么实现 <code>NSCopying</code> 协议的？有实现 <code>NSMutableCopying</code> 协议吗？</p><p>所以 ObjC 并没有所谓的深拷贝，要想实现真正的深拷贝，基本上只能依赖序列化+反序列化，这样得到的结果才是深到见底的深拷贝。</p><p>如果你说道理大家都懂，深拷贝、浅拷贝只是一种叫法而已，那我只能说你太不严谨了，官方文档从来没这么教过；而且这种说法也不利于初学者理解，以及再学习其它语言时触类旁通，比如 Java。</p><p>所以建议严谨一点可以叫引用拷贝和浅拷贝，深拷贝很少用到；或者非要两个互为反义词，可以叫真拷贝和假拷贝。</p><h2 id="3-load-和-initialize-区别"><a href="#3-load-和-initialize-区别" class="headerlink" title="3. load 和 initialize 区别"></a>3. load 和 initialize 区别</h2><blockquote><p><code>load</code> 方法和 <code>initialize</code> 方法区别，以及在子类、父类、分类中调用顺序？</p></blockquote><h3 id="void-load"><a href="#void-load" class="headerlink" title="+(void)load"></a>+(void)load</h3><p>1、<code>+load</code> 方法加载顺序：父类&gt; 子类&gt; 分类 （<code>load</code> 方法都会加载）注意：（如果分类中有 <code>A</code>, <code>B</code>,顺序要看 <code>A</code>, <code>B</code> 加入工程中顺序） ，可能结果：<code>（ 父类&gt; 子类&gt; 分类A&gt; 分类B ）</code> 或者<code>（ 父类&gt; 子类&gt; 分类B&gt; 分类A ）</code></p><p>2、<code>+load</code> 方法不会被覆盖（比如有父类，子类，分类A，分类B,这四个 <code>load</code> 方法都会加载）。</p><p>3、<code>+load</code> 方法调用在 <code>main</code>函数前</p><h3 id="void-initialize"><a href="#void-initialize" class="headerlink" title="+(void)initialize"></a>+(void)initialize</h3><p>1、分类 （子类没有 <code>initialize</code> 方法，父类存在或者没有 1<code>initialize</code> 方法）</p><p>2、分类&gt; 子类 （多个分类就看编译顺序，只有存在一个）</p><p>3、父类&gt; 子类 （分类没有 <code>initialize</code> 方法）</p><p>4、父类 (子类，分类都没有 <code>initialize</code> 方法)</p><h3 id="总结-initialize："><a href="#总结-initialize：" class="headerlink" title="总结 +initialize："></a>总结 +initialize：</h3><p>1、当调用子类的 <code>+ initialize</code> 方法时候,先调用父类的,如果父类有分类, 那么分类的 <code>+ initialize</code> 会覆盖掉父类的</p><p>2、分类的 <code>+ initialize</code> 会覆盖掉父类的</p><p>3、子类的 <code>+ initialize</code> 不会覆盖分类的</p><p>4、父类的 <code>+ initialize</code> 不一定会调用, 因为有可能父类的分类重写了它</p><p>5、发生在main函数后。</p><h2 id="4-同名方法调用顺序"><a href="#4-同名方法调用顺序" class="headerlink" title="4. 同名方法调用顺序"></a>4. 同名方法调用顺序</h2><blockquote><p>同名方法在子类、父类、分类的调用顺序？</p></blockquote><p><a href="https://www.jianshu.com/p/e5c89e9045cf" title="load,initialize方法调用源码分析" target="_blank" rel="noopener">load,initialize方法调用源码分析</a></p><p><strong>注意</strong>：<code>+load</code> 方法是根据方法地址直接调用，并不是经过 <code>objc_msgSend</code> 函数调用（通过 <code>isa</code> 和 <code>superclass</code> 找方法），所以不会存在方法覆盖的问题。</p><h2 id="5-事件响应链"><a href="#5-事件响应链" class="headerlink" title="5. 事件响应链"></a>5. 事件响应链</h2><blockquote><p>事件响应链（同一个控制器有三个view，如何判断是否拥有相同的父视图）</p></blockquote><p>iOS 系统检测到手指触摸( <code>Touch</code> )操作时会将其打包成一个 <code>UIEvent</code> 对象，并放入当前活动 <code>Application</code> 的事件队列，单例的 <code>UIApplication</code> 会从事件队列中取出触摸事件并传递给单例的 <code>UIWindow</code> 来处理，<code>UIWindow</code> 对象首先会使用 <code>hitTest:withEvent:</code> 方法寻找此次 <code>Touch</code> 操作初始点所在的视图(<code>View</code>)，即需要将触摸事件传递给其处理的视图，这个过程称之为 <code>hit-test view</code>。</p><p><code>UIAppliction</code> –&gt; <code>UIWiondw</code> –&gt;递归找到最适合处理事件的控件–&gt;控件调用 <code>touches</code> 方法–&gt;判断是否实现 <code>touches</code> 方法–&gt;没有实现默认会将事件传递给上一个响应者–&gt;找到上一个响应者。</p><p><code>UIResponder</code> 是所有响应对象的基类，在 <code>UIResponder</code> 类中定义了处理上述各种事件的接口。我们熟悉的 <code>UIApplication</code>、 <code>UIViewController</code>、 <code>UIWindow</code> 和所有继承自 <code>UIView</code> 的 <code>UIKit</code> 类都直接或间接的继承自 <code>UIResponder</code>，所以它们的实例都是可以构成响应者链的响应者对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何获取父视图</span></span><br><span class="line"><span class="built_in">UIResponder</span> *nextResponder = gView.nextResponder;</span><br><span class="line"><span class="built_in">NSMutableString</span> *p = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"--"</span>];</span><br><span class="line"><span class="keyword">while</span> (nextResponder) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@%@"</span>, p, <span class="built_in">NSStringFromClass</span>([nextResponder <span class="keyword">class</span>]));</span><br><span class="line">    [p appendString:<span class="string">@"--"</span>];</span><br><span class="line">    nextResponder = nextResponder.nextResponder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有父视图则 <code>nextResponder</code> 指向父视图如果是控制器根视图则指向控制器；</p><p>控制器如果在导航控制器中则指向导航控制器的相关显示视图最后指向导航控制器；</p><p>如果是根控制器则指向 <code>UIWindow</code>；</p><p><code>UIWindow</code> 的 <code>nexResponder</code> 指向 <code>UIApplication</code> 最后指向 <code>AppDelegate</code>。</p><h2 id="6-TCP丢包"><a href="#6-TCP丢包" class="headerlink" title="6.TCP丢包"></a>6.TCP丢包</h2><blockquote><p>TCP 会不会丢包？该怎么处理？网络断开会断开链接还是一直等待，如果一直网络断开呢？</p></blockquote><p>TCP 在不可靠的网络上实现可靠的传输，必然会有丢包。TCP 是一个“<strong>流</strong>”协议，一个详细的包将会被 TCP 拆分为好几个包上传，也是将会把小的封裝成大的上传，这就是说 TCP 粘包和拆包难题。</p><p><a href="https://blog.csdn.net/weixin_41563161/article/details/105310459" title="TCP丢包总结" target="_blank" rel="noopener">TCP丢包总结</a></p><h2 id="7-自动释放池"><a href="#7-自动释放池" class="headerlink" title="7.自动释放池"></a>7.自动释放池</h2><blockquote><p>自动释放池创建和释放的时机，在子线程是什么时候创建释放的？</p></blockquote><p>默认主线程的运行循环（<code>runloop</code>）是开启的，子线程的运行循环(<code>runloop</code>)默认是不开启的，也就意味着子线程中不会创建 <code>autoreleasepool</code>，所以需要我们自己在子线程中创建一个自动释放池。（子线程里面使用的类方法都是 <code>autorelease</code>,就会没有池子可释放，也就意味着后面没有办法进行释放，造成内存泄漏。）</p><p>在主线程中如果产生事件那么 <code>runloop</code> 才回去创建 <code>autoreleasepool</code>，通过这个道理我们就知道为什么子线程中不会创建自动释放池了，因为子线程的 <code>runloop</code> 默认是关闭的，所以他不会自动创建 <code>autoreleasepool</code>，需要我们手动添加。</p><p>如果你生成一个子线程的时候，要在线程开始执行的时候，尽快创建一个自动释放池，否则会内存泄露。因为子线程无法访问主线程的自动释放池。</p><h2 id="8-计算机编译流程"><a href="#8-计算机编译流程" class="headerlink" title="8.计算机编译流程"></a>8.计算机编译流程</h2><p><strong>源文件：</strong> 载入<code>.h</code>、<code>.m</code>、<code>.cpp</code> 等文件</p><p><strong>预处理：</strong> 替换宏，删除注释，展开头文件，产生 <code>.i</code> 文件</p><p><strong>编译：</strong> 将 <code>.i</code> 文件转换为汇编语言，产生 <code>.s</code> 文件</p><p><strong>汇编：</strong> 将汇编文件转换为机器码文件，产生 <code>.o</code> 文件</p><p><strong>链接：</strong> 对 <code>.o</code> 文件中引用其他库的地方进行引用，生成最后的可执行文件</p><p><a href="https://www.jianshu.com/p/db765ff4e36a" title="dyld加载流程" target="_blank" rel="noopener">dyld加载流程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanbaoying/FBYInterview-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试资源库&lt;/a&gt;&lt;br&gt;如有帮助请点个 Star。&lt;/p&gt;
&lt;h2 id=&quot;1-http-链接到断开的过程？&quot;&gt;&lt;a href=&quot;#1-http-链接到断开的过程？&quot; class=&quot;headerlink&quot; title=&quot;1. http 链接到断开的过程？&quot;&gt;&lt;/a&gt;1. http 链接到断开的过程？&lt;/h2&gt;&lt;h3 id=&quot;第一步：TCP建立连接：三次握手&quot;&gt;&lt;a href=&quot;#第一步：TCP建立连接：三次握手&quot; class=&quot;headerlink&quot; title=&quot;第一步：TCP建立连接：三次握手&quot;&gt;&lt;/a&gt;第一步：TCP建立连接：三次握手&lt;/h3&gt;&lt;p&gt;   HTTP 是应用层协议，他的工作还需要数据层协议的支持，最常与它搭配的就是 TCP 协议（应用层、数据层是 &lt;code&gt;OSI&lt;/code&gt; 七层模型中的，以后有机会会说到的）。TCP 协议称为数据传输协议，是可靠传输，面向连接的，并且面向字节流的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向连接&lt;/strong&gt;：通信之前先建立连接，确保双方在线。&lt;br&gt;&lt;strong&gt;可靠传输&lt;/strong&gt;：在网络正常的情况下，数据不会丢失。&lt;br&gt;&lt;strong&gt;面向字节流&lt;/strong&gt;：传输灵活，但是 TCP 的传输存在粘包问题，没有明显的数据约定。&lt;/p&gt;
&lt;p&gt;在正式发送请求之前，需要先建立 TCP 连接。建立 TCP 连接的过程简单地来说就是客户端和服务端之间发送三次消息来确保连接的建立，这个过程称为&lt;strong&gt;三次握手&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>百度一面总结</title>
    <link href="https://fanbaoying.github.io/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
    <id>https://fanbaoying.github.io/百度一面总结/</id>
    <published>2022-01-19T09:54:58.000Z</published>
    <updated>2022-01-19T09:57:09.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanbaoying/FBYInterview-iOS" target="_blank" rel="noopener">面试资源库</a><br>如有帮助请点个 Star。</p><h2 id="1-二进制重排"><a href="#1-二进制重排" class="headerlink" title="1. 二进制重排"></a>1. 二进制重排</h2><h3 id="1-1-clang-插桩具体如何做的"><a href="#1-1-clang-插桩具体如何做的" class="headerlink" title="1.1 clang 插桩具体如何做的"></a>1.1 clang 插桩具体如何做的</h3><h3 id="1-2-c-方法-clang-插桩能否取到？"><a href="#1-2-c-方法-clang-插桩能否取到？" class="headerlink" title="1.2 c++ 方法 clang 插桩能否取到？"></a>1.2 c++ 方法 clang 插桩能否取到？</h3><p>不能<br>可以取到 <code>c</code> 函数，<code>oc</code> 方法，<code>block</code>，<code>swift</code> 方法<br>但是可以用 <code>-finstrument-functions</code> 在编译期插桩 “<strong>hook</strong>”，或者使用并不完美但成本最低的静态扫描方案。</p><h3 id="1-3-除了二进制重排，还有哪些启动优化的方法"><a href="#1-3-除了二进制重排，还有哪些启动优化的方法" class="headerlink" title="1.3 除了二进制重排，还有哪些启动优化的方法"></a>1.3 除了二进制重排，还有哪些启动优化的方法</h3><a id="more"></a><h4 id="1-3-1-pre-main-阶段"><a href="#1-3-1-pre-main-阶段" class="headerlink" title="1.3.1 pre main 阶段"></a>1.3.1 pre main 阶段</h4><ol><li>Load dylibs </li></ol><ul><li>尽量不使用内嵌（<code>embedded</code>）的 <code>dylib</code>，加载内嵌 <code>dylib</code> 性能开销较大</li><li>合并已有的 <code>dylib</code> 和使用静态库（<code>static archives</code>），减少 <code>dylib</code> 的使用个数</li><li>懒加载 <code>dylib</code>，但是要注意 <code>dlopen()</code> 可能造成一些问题，且实际上懒加载做的工作会更多</li></ul><ol><li>Rebase/Bind</li></ol><p>在 <code>dylib</code> 的加载过程中，系统为了安全考虑，引入了 <code>ASLR</code>（Address Space Layout Randomization）技术和代码签名。由于ASLR的存在，镜像（<code>Image</code>，包括可执行文件、<code>dylib</code> 和 <code>bundle</code>）会在随机的地址上加载，和之前指针指向的地址（<code>preferred_address</code>）会有一个偏差（<code>slide</code>），<code>dyld</code>需要修正这个偏差，来指向正确的地址。 </p><ul><li>减少 ObjC 类（<code>clas</code>s）、方法（<code>selector</code>）、分类（<code>category</code>）的数量</li><li>减少 <code>C++</code> 虚函数的数量（创建虚函数表有开销）</li><li>使用 <code>swiftStructs</code> (内部有优化，符号数量更少)</li></ul><ol><li><code>Objc setUp</code> </li><li><code>Initializers</code></li></ol><ul><li>少在类的 <code>+load</code>方法里做事情，尽量把这些事情推迟到 <code>+initiailize</code></li><li>减少构造器函数个数，在构造器函数里少做些事情</li><li>减少 <code>C++</code> 静态全局变量的个数</li></ul><h4 id="1-3-2-main-阶段"><a href="#1-3-2-main-阶段" class="headerlink" title="1.3.2 main 阶段"></a>1.3.2 main 阶段</h4><ol><li>梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器或 <code>tabBar</code> 控制器的 <code>viewDidAppear</code> 方法里，并且保证只执行一次（按项目结构，放在合适的地方）</li><li>梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。</li><li>避免复杂/多余的计算。</li><li>避免在用户看到的第一个界面（首页控制器或注册登录页面）的 <code>viewDidLoad</code> 和 <code>viewWillAppear</code> 做太多事情，这 2 个方法执行完，第一个页面才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理</li><li>首页控制器或注册登录页面用纯代码方式来构建</li></ol><h3 id="1-4-link-map数据结构"><a href="#1-4-link-map数据结构" class="headerlink" title="1.4 link map数据结构"></a>1.4 link map数据结构</h3><p><code>Link Map File</code> 中文直译为链接映射文件，它是在 Xcode 生成可执行文件的同时生成的链接信息文件，用于描述可执行文件的构造部分，包括了代码段和数据段的分布情况</p><h4 id="1-4-1-linkMapfile-的组成"><a href="#1-4-1-linkMapfile-的组成" class="headerlink" title="1.4.1 linkMapfile 的组成"></a>1.4.1 linkMapfile 的组成</h4><ol><li><strong>Path</strong>：<code>Path</code> 是生成可执行文件的路径。 </li><li><strong>Arch</strong>：<code>Arch</code> 指代架构类型。 </li><li><strong>Object files</strong>：<code>Object Files</code> 列举了可执行文件里所有的 <code>obj</code> 以及 <code>tbd</code>。每一行代表对文件的编号。 </li><li><strong>Sections</strong>： 每个 <code>Section</code> 包含了 <code>Address</code>、<code>Size</code>、<code>Segment</code> 以及 <code>Section</code>。<code>Mach-O</code> 文件中的虚拟地址最终会被映射到物理地址上，这些地址会被分为不同的段类型：  <code>TEXT</code>、  <code>DATA</code> 以及 <code>LINKEDIT</code> 等。各个段的含义如下：  <blockquote><p><code>TEXT</code> 包含了被执行的代码。这些代码是只读、可执行<br><code>DATA</code> 包含了包含了将会被更改的数据，例如全局变量、静态变量等，可读写，但是不可执行<br><code>LINKEDIT</code> 包含了加载程序的元数据，比如函数名称和地址，只读。<br><code>Segment</code> 又被划分成了不同的 <code>Section</code>，不同的 <code>Section</code> 存储了不同的信息，例如 <code>objc _ methname</code> 为方法的名称</p></blockquote></li><li><strong>Symbols</strong> ：Symbols包含的信息有：</li></ol><ul><li><strong>Address</strong>：起始地址</li><li><strong>Size</strong>：所占内存大小，这里使用16进制表示。</li><li><strong>File</strong>：该Name所在的文件编号，也就是Object files部分的中括号的数字。 </li></ul><ol><li><code>Dead Stripped Symbols</code></li></ol><h3 id="1-5-具体的优化时间获取？有没有看过实际线上优化多少？"><a href="#1-5-具体的优化时间获取？有没有看过实际线上优化多少？" class="headerlink" title="1.5 具体的优化时间获取？有没有看过实际线上优化多少？"></a>1.5 具体的优化时间获取？有没有看过实际线上优化多少？</h3><ol><li><strong>pre-main阶段测量</strong>：<code>DYLD_PRINT_STATISTICS</code></li><li><strong>main()阶段测量</strong>：先在 <code>main()</code> 函数里用变量 <code>StartTime  didFinishLaunchingWithOptions</code> 再获取一下当前时间</li></ol><h2 id="2-VC生命周期"><a href="#2-VC生命周期" class="headerlink" title="2. VC生命周期"></a>2. VC生命周期</h2><ol><li><code>+load</code>: 程序启动后，在系统的 <code>main</code> 函数调用之前，系统就会加载所有的 <code>load</code> 方法，提前进行一些资源包的配置或者 <code>hook</code>，(可以打断点看看结果，本人亲测过) </li><li><code>+initialize</code>: 当前类或者其子类未被初始化过时会首次调用，若以后当前类或者子类再多次初始化时不会再调用，一般提前为初始化做一些工作 </li><li><code>+alloc</code>: 系统为当前类分配内存时调用，在C语言中就是 <code>malloc</code> 这一步 </li><li><code>-initWithCoder</code>: 通过 <code>storyBoard</code> 方式实例化的 vc，需要经过反序列化，这个方法会被调用 </li><li><code>-initWithNibName:bundle</code>: 通过 <code>xib</code> 文件或者 <code>init</code> 方法实例化的 vc，这个方法都会被调用，其实 <code>init</code> 方法最终都会走该方法 </li><li><code>-init</code>: 通过纯代码实例化Vc会调用，其最终会调用 <code>initWithNibName:bundle:</code> 方法 </li><li><code>-loadView</code>: 实例化Vc后，可以加载一些系统常规的View </li><li><code>-viewDidLoad</code>: 一般加载自定义的view或者初始化属性，视图加载完毕后会调用 </li><li><code>-viewWillAppear</code>: 视图即将出现会调用 </li><li><code>-viewWillDisappear</code>: 视图即将消失会调用 </li><li><code>-viewWillLayoutSubviews</code>: 视图加载完毕后即将要布局 </li><li><code>-viewDidLayoutSubviews</code>: 视图加载完毕后布局也完成了 </li><li><code>-didReceiveMemoryWarning</code>: 加载视图时，内存消耗太大，出现内存警告，会调用 </li><li><code>-dealloc</code>: 实例化被销毁，进行内存的回收会调用 </li></ol><h2 id="3-copy-mutableCopy"><a href="#3-copy-mutableCopy" class="headerlink" title="3. copy / mutableCopy"></a>3. copy / mutableCopy</h2><p><strong>可变对象复制：</strong></p><p>都是深拷贝，但是 <code>copy</code> 返回的对象是不可变的。</p><p>对于容器而言，其元素对象始终是指针复制。如果需要元素对象也是对象复制，就需要实现深拷贝。</p><h2 id="4-NSUserDefault存储位置"><a href="#4-NSUserDefault存储位置" class="headerlink" title="4. NSUserDefault存储位置"></a>4. NSUserDefault存储位置</h2><p><code>~/Library/Preferences</code> 下，用 <code>plist</code> 文件存储</p><h2 id="5-Https如何保证数据安全"><a href="#5-Https如何保证数据安全" class="headerlink" title="5. Https如何保证数据安全"></a>5. Https如何保证数据安全</h2><p>是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议</p><h3 id="公私钥加密之后是否还有加密"><a href="#公私钥加密之后是否还有加密" class="headerlink" title="公私钥加密之后是否还有加密"></a>公私钥加密之后是否还有加密</h3><p>对称加密+非对称加密这两种方式，我们可以用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据</p><h2 id="6-git-reset"><a href="#6-git-reset" class="headerlink" title="6. git reset"></a>6. git reset</h2><p>可以让 <code>HEAD</code> 这个指针指向其他的地方<br>它有三种模式，<code>soft</code>, <code>mixed</code>, <code>hard</code></p><h3 id="6-1-reset-soft"><a href="#6-1-reset-soft" class="headerlink" title="6.1 reset soft"></a>6.1 reset soft</h3><p>保留工作目录，并把重置 <code>HEAD</code> 所带来的新的差异放进暂存区<br><code>reset --soft</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 时，保留工作目录和暂存区中的内容，并把重置 <code>HEAD</code> 所带来的新的差异放进暂存区。</p><h3 id="6-2-reset-mixed"><a href="#6-2-reset-mixed" class="headerlink" title="6.2 reset mixed"></a>6.2 reset mixed</h3><p><code>reset</code> 不加参数(<code>mixed</code>)：保留工作目录，并清空暂存区<br><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code>参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 <code>reset</code> 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（<code>mixed</code>）放在工作目录中」。</p><h3 id="6-3-reset-hard"><a href="#6-3-reset-hard" class="headerlink" title="6.3 reset hard"></a>6.3 reset hard</h3><p>重置 <code>stage</code> 区和工作目录<br><code>reset --hard</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 的同时，重置 <code>stage</code> 区和工作目录里的内容。当你在 <code>reset</code> 后面加了 <code>--hard</code> 参数时，你的 <code>stage</code> 区和工作目录里的内容会被完全重置为和 <code>HEAD</code> 的新位置相同的内容。换句话说，就是你的没有 <code>commit</code> 的修改会被全部擦掉。</p><p>学无止境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanbaoying/FBYInterview-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试资源库&lt;/a&gt;&lt;br&gt;如有帮助请点个 Star。&lt;/p&gt;
&lt;h2 id=&quot;1-二进制重排&quot;&gt;&lt;a href=&quot;#1-二进制重排&quot; class=&quot;headerlink&quot; title=&quot;1. 二进制重排&quot;&gt;&lt;/a&gt;1. 二进制重排&lt;/h2&gt;&lt;h3 id=&quot;1-1-clang-插桩具体如何做的&quot;&gt;&lt;a href=&quot;#1-1-clang-插桩具体如何做的&quot; class=&quot;headerlink&quot; title=&quot;1.1 clang 插桩具体如何做的&quot;&gt;&lt;/a&gt;1.1 clang 插桩具体如何做的&lt;/h3&gt;&lt;h3 id=&quot;1-2-c-方法-clang-插桩能否取到？&quot;&gt;&lt;a href=&quot;#1-2-c-方法-clang-插桩能否取到？&quot; class=&quot;headerlink&quot; title=&quot;1.2 c++ 方法 clang 插桩能否取到？&quot;&gt;&lt;/a&gt;1.2 c++ 方法 clang 插桩能否取到？&lt;/h3&gt;&lt;p&gt;不能&lt;br&gt;可以取到 &lt;code&gt;c&lt;/code&gt; 函数，&lt;code&gt;oc&lt;/code&gt; 方法，&lt;code&gt;block&lt;/code&gt;，&lt;code&gt;swift&lt;/code&gt; 方法&lt;br&gt;但是可以用 &lt;code&gt;-finstrument-functions&lt;/code&gt; 在编译期插桩 “&lt;strong&gt;hook&lt;/strong&gt;”，或者使用并不完美但成本最低的静态扫描方案。&lt;/p&gt;
&lt;h3 id=&quot;1-3-除了二进制重排，还有哪些启动优化的方法&quot;&gt;&lt;a href=&quot;#1-3-除了二进制重排，还有哪些启动优化的方法&quot; class=&quot;headerlink&quot; title=&quot;1.3 除了二进制重排，还有哪些启动优化的方法&quot;&gt;&lt;/a&gt;1.3 除了二进制重排，还有哪些启动优化的方法&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>[译]解决 iOS 15 上 APP 莫名其妙地退出登录</title>
    <link href="https://fanbaoying.github.io/%E8%AF%91-%E8%A7%A3%E5%86%B3-iOS-15-%E4%B8%8A-APP-%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95/"/>
    <id>https://fanbaoying.github.io/译-解决-iOS-15-上-APP-莫名其妙地退出登录/</id>
    <published>2021-12-08T11:45:38.000Z</published>
    <updated>2021-12-08T11:46:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png" alt=""></p><p>在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：在打开我们的应用程序(Cookpad) 时他们被莫名其妙的反复退出到登录页。非常令人惊讶的是，这并不是我们在测试 iOS 15 beta 版的时候发现的问题。</p><p>如果你是来找修复方法的，那就直接向下滚动到结论，但如果你想了解更多关于我们如何调试这个特定问题，那就开始吧。</p><a id="more"></a><h2 id="复现反馈的问题"><a href="#复现反馈的问题" class="headerlink" title="复现反馈的问题"></a>复现反馈的问题</h2><p>用户报告中的具体信息有限，我们唯一知道的是：从 iOS 15 开始，用户打开程序后会发现自己已经退出登录。</p><p>我们没有视频，也没有具体的步骤来重现这个问题，所以我努力尝试以各种方式启动应用程序，希望能亲眼看到它。我试着重新安装应用程序，我试着在有网络连接和没有网络连接的情况下启动，我试着强制退出，经过30分钟的努力，我放弃了，我开始回复用户说我没找到具体问题。</p><p>直到我再次解锁手机，没有做任何操作，就启动了 Cookpad，我发现APP就像我们的用户所反馈的那样，直接退出到了登录界面!</p><p>在那之后，我无法准确的复现该问题，但似乎与暂停使用手机一段时间后再次使用它有关。</p><h2 id="缩小问题范围"><a href="#缩小问题范围" class="headerlink" title="缩小问题范围"></a>缩小问题范围</h2><p>我担心从 Xcode 重新安装应用程序可能会影响问题的复现，所以在这样做之前，是时候查看代码并试图缩小问题的范围。根据我们的实现，我想出了三个潜在的原因。</p><ul><li>1、<code>UserDefaults</code> 中的数据被清除。</li><li>2、一个意外的API调用返回HTTP 401并触发退出登录。</li><li>3、<code>Keychain</code> 抛出了一个错误。</li></ul><p>我能够排除前两个潜在的原因，这要归功于我在自己重现该问题后观察到的一些微妙行为。</p><ul><li>登录界面没有要求我选择地区——这表明<code>UserDefaults</code>中的数据没有问题，因为我们的 “已显示地区选择 “偏好设置仍然生效。</li><li>主用户界面没有显示，即使是短暂的也没有——这表明没有尝试进行网络请求，所以 API 是问题原因可能还为时过早。</li></ul><p>这就把<code>Keychain</code>留给了我们，指引我进入下一个问题。是什么发生了改变以及为什么它如此难以复现？</p><h2 id="是什么发生了改变以及为什么它如此难以复现？"><a href="#是什么发生了改变以及为什么它如此难以复现？" class="headerlink" title="是什么发生了改变以及为什么它如此难以复现？"></a>是什么发生了改变以及为什么它如此难以复现？</h2><p>我粗略地看了一下发布说明，在谷歌上快速搜索了一下，我找不到任何东西，所以我不得不继续挖掘以更好地了解这个问题。</p><p>对<code>Keychain</code>数据的访问是通过 <a href="https://developer.apple.com/documentation/security" title="Security" target="_blank" rel="noopener">Security</a> 框架提供的，这是一个众所周知的棘手的问题。虽然有很多第三方库来包装这个框架以使事情变得更容易，但我们还是基于一些苹果的示例代码来维护我们自己的简单封装。</p><p>看一下这段代码，我们调用 <a href="https://developer.apple.com/documentation/security/1398306-secitemcopymatching?language=objc" title="SecItemCopyMatching" target="_blank" rel="noopener">SecItemCopyMatching</a> 方法来加载我们的访问令牌，它返回数据以及描述结果的 <a href="https://osstatus.com/" target="_blank" rel="noopener"><em>OSStatus</em></a> 代码。然而，不幸的是，虽然我们的封装器会将不成功的结果与状态代码一起抛出，用于调试，但我们在下一层中却抛弃了这些信息，只是将错误视为 <code>nil</code>。</p><p>我们实行了每周一次的发布计划，多亏了大量的自动化。此时，我们即将发布的下一个截止点（代码冻结）是在第二天。因为我们还没有完全了解这个问题有多普遍，而且我们也不确定是否能够在代码冻结前发布一个修复程序，所以我利用这个机会通过使用Crashlytics(崩溃日志记录工具) 增加一些额外的非致命性日志来解决缺乏可观察性的问题。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/64e699daa0417f6a10ae4e9fa861008b.png" alt="虽然我们无法改变加载会话的行为，但我们能够开始记录错误并更好地记录我们实现的当前行为。"></p><p>这个结果给了我们一些很好的观察点，然后我们可以在接下来的几周内观察。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/8af9cb1ce53fdb1ab4cda921451c34cc.png" alt="在10.58.0和10.59.0版本中，受影响的用户数量慢慢减少，这是由于我们在努力确定根本原因时引入了一项缓解措施，该措施在10.60.0中得到了修复。"></p><p>此时，我能够捕捉到返回的确切错误代码。罪魁祸首是<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" title="errSecInteractionNotAllowed" target="_blank" rel="noopener">errSecInteractionNotAllowed</a>：</p><blockquote><p>不允许与 <em>Security Server</em> 交互。</p></blockquote><p>这个错误告诉我们，我们正试图在数据不可用的时间点上从<code>Keychain</code>中读取数据。这通常会发生在你试图读取已存储的数据，并将其可访问性设置为<a href="https://developer.apple.com/documentation/security/ksecattraccessiblewhenunlocked" title="kSecAttrAccessibleWhenUnlocked" target="_blank" rel="noopener">kSecAttrAccessibleWhenUnlocked</a>，而设备仍处于锁定状态。</p><p>现在这完全说得通了，但唯一的问题是，在 Cookpad 中，我们只在应用启动时从<code>Keychain</code>中读取信息，而我的假设是，用户一定是点击了应用图标来启动应用，因此设备在这时应该总是解锁的，对吗？</p><p>那么，究竟发生了什么变化呢？即使我能够重现这个问题，我也100%确定我的手机在我点击应用图标的时候是解锁的，所以我不明白为什么会出现这个<code>Keychain</code>错误。</p><p>我决心找到原因，用一个调试工具替换了我们的应用程序的实现，该工具将尝试并记录其生命周期中不同节点的<code>Keychain</code>读取。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/d58d7a078b6141c722ff3efe698953d3.png" alt=""></p><p>在能够复现问题的场景中，我观察到以下结果：</p><ul><li><code>main.swift</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.init()</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.applicationProtectedDataDidBecomeAvailable(_:)</code><br>— 成功</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 成功</li><li><code>ViewController.viewDidAppear(_:)</code> — 成功</li></ul><p>所以这（一半）解释了它。为了避免在我们的AppDelegate上持有一些隐式解包的可选属性，我们在<code>init()</code>方法中进行了一些设置，其中一部分涉及从<code>Keychain</code>中读取访问令牌。这就是为什么读取会失败，以及最终为什么一些用户会发现自己被登出了。</p><p>我在这里学到了重要的一课，即我不应该假设受保护的数据在<code>AppDelegate</code>初始化时是可用的，但说实话，我还是不高兴，因为我不明白为什么它不可用。毕竟，我们已经很多年没有改变过这部分代码了，而且它在iOS 12、13和14系统中一直运行良好，那么是什么原因呢？</p><h2 id="寻找根本原因"><a href="#寻找根本原因" class="headerlink" title="寻找根本原因"></a>寻找根本原因</h2><p>我的调试界面很有用，但它缺少了一些有助于回答所有问题的重要信息：<strong>时间</strong>。</p><p>我知道在<code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code>之前，“受保护的数据” 是不可用的，但它仍然没有意义，因为为了重现这个问题，我正在执行以下操作：</p><p>1、启动应用程序<br>2、简单使用<br>3、强制退出应用<br>4、锁定我的设备并将其放置约 30 分钟<br>5、解锁设备<br>6、再次启动应用</p><p>每当我在第 6 步中再次启动应用程序时，我 100% 确定设备已解锁，因此我坚信我应该能够从 <code>AppDelegate.init()</code>中的<code>Keychain</code>读取数据。</p><p>直到我看了所有这些步骤的时间，事情才开始变得有点意义。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/ffa4e4a3730d3fd5ed1891fa73539f24.png" alt=""></p><p>再次仔细查看时间戳：</p><ul><li><code>main.swift</code> — 11:38:47</li><li><code>AppDelegate.init()</code> — 11:38:47</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 12:03:04</li><li><code>ViewController.viewDidAppear(_:)</code> — 12:03:04</li></ul><p>在我真正解锁手机并点击应用图标之前的25分钟，应用程序本身就已经启动了!</p><p>现在，我实际上从未想过有这么大的延迟，实际上是<a href="https://twitter.com/_saagarjha" target="_blank" rel="noopener">@_saagarjha</a>建议我检查时间戳，之后，他指给我看这条推特。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/6ea72a16b7326fe97fcdfd33c4758f6d.png" alt="Twitter：Apple开发人员文档的首页"></p><blockquote><p>推特翻译：<br>有趣的iOS 15优化。Duet 现在试图先发制人地 “预热” 第三方应用程序，在你点击一个应用程序图标前几分钟，通过dyld和预主静态初始化器运行它们。然后，该应用程序被暂停，随后的 “启动”似乎更快。</p></blockquote><p>现在一切都说得通了。我们最初没有测试到它，因为我们很可能没有给 iOS 15 beta 版足够的时间来 “学习” 我们的使用习惯，所以这个问题只在现实世界的场景中再现，即设备认为我很快就要启动应用程序。我仍然不知道这种预测是如何形成的，但我只想把它归结为 “Siri智能”，然后就到此为止了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从iOS 15开始，系统可能决定在用户实际尝试打开你的应用程序之前对其进行 “预热”，这可能会增加受保护的数据在你认为应该无法使用的时候的被访问概率。</p><p>通过等待<code>application(_:didFinishLaunchingWithOptions:)</code>委托回调来保护自己，如果可能的话，留意<code>UIApplication.isProtectedDataAvailable</code>（或对应委托的回调/通知）并相应处理。</p><p>我们仍然发现了非常少的非致命问题，在<code>application(_:didFinishLaunchingWithOptions:)</code>中报告<code>isProtectedDataAvailable</code>为<code>false</code>，在我们可以推迟从钥匙串阅读的访问令牌之外，这将是一个大规模的任务，现在它不值得进行进一步调查。</p><p>这是一个相当难调试的bug，而且行为的变化似乎完全没有记录，这对我来说真的没有帮助。如果你也被这个问题所困扰，请考虑复制<a href="https://openradar.appspot.com/FB9780579" title="FB9780579" target="_blank" rel="noopener">FB9780579</a>。</p><p>我从中学到了很多东西，我希望你也一样！</p><p><strong>更新：</strong> 自从发表这篇文章以来，实际上很多人都向我指出了<a href="https://developer.apple.com/documentation/uikit/app_and_environment/responding_to_the_launch_of_your_app/about_the_app_launch_sequence#3894431" title="苹果公司关于预热行为的相对完善的文档" target="_blank" rel="noopener">苹果公司关于预热行为的相对完善的文档</a>。然而，其他人也告诉我，他们仍然观察到与某些场景中记录的行为不同的行为，因此请谨慎行事。</p><blockquote><p>译自：<a href="https://sourcediving.com/solving-mysterious-logout-issues-on-ios-15-8b818c089466" title="Solving Mysterious Logout Issues on iOS 15" target="_blank" rel="noopener">Solving Mysterious Logout Issues on iOS 15</a></p></blockquote><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的各种交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量，排名不分先后：</p><ul><li><a href="https://blog.csdn.net/mobanchengshuang" title="张安宇" target="_blank" rel="noopener">张安宇@微软</a></li><li><a href="https://github.com/niyaoyao" title="倪瑶" target="_blank" rel="noopener">倪瑶@Trip.com</a></li><li><a href="https://ming1016.github.io" title="戴铭" target="_blank" rel="noopener">戴铭@快手</a></li><li><a href="https://github.com/fanbaoying" title="展菲" target="_blank" rel="noopener">展菲@ESP</a></li><li><a href="https://weibo.com/u/3878455011" title="杜鑫瑶" target="_blank" rel="noopener">杜鑫瑶@新浪</a></li><li><a href="https://www.jianshu.com/u/855d6ea2b3d1" title="韦弦" target="_blank" rel="noopener">韦弦@Gwell</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：在打开我们的应用程序(Cookpad) 时他们被莫名其妙的反复退出到登录页。非常令人惊讶的是，这并不是我们在测试 iOS 15 beta 版的时候发现的问题。&lt;/p&gt;
&lt;p&gt;如果你是来找修复方法的，那就直接向下滚动到结论，但如果你想了解更多关于我们如何调试这个特定问题，那就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 4 求两个有序数组的中间值</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%204%20%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E9%97%B4%E5%80%BC/"/>
    <id>https://fanbaoying.github.io/LeetCode - 4 求两个有序数组的中间值/</id>
    <published>2021-11-22T06:31:18.000Z</published>
    <updated>2021-11-22T06:43:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>已知两个有序数组 <code>nums1</code> 和 <code>nums2</code>，他们的数据长度分别是 <code>n</code> 和 <code>m</code>，将两个数组合并成一个新数组，返回新数组的中间值。</p><p>整体的运行时间复杂度应该是 <code>O(log (m+n))</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">说明：合并后的新数组为 [1,2,3]，中间值为 2</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">说明：合并后的新数组为 [1,2,3,4]，中间值为 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0,0], nums2 = [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [], nums2 = [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [2], nums2 = []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>nums1.length == m</li><li>nums2.length == n</li><li>0 &lt;= m &lt;= 1000</li><li>0 &lt;= n &lt;= 1000</li><li>1 &lt;= m + n &lt;= 2000</li><li>-106 &lt;= nums1[i], nums2[i] &lt;= 106</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="number">_</span> nums1: [Int], <span class="number">_</span> nums2: [Int])</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> m = nums1.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> n = nums2.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> m &gt; n &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> halfLength: <span class="type">Int</span> = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">0</span>, e = m</span><br><span class="line">        <span class="keyword">var</span> maxOfLeft = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> minOfRight = <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> b &lt;= e &#123;</span><br><span class="line">            <span class="keyword">let</span> mid1 = (b + e) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">let</span> mid2 = halfLength - mid1</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid1 &gt; <span class="number">0</span> &amp;&amp; mid2 &lt; n &amp;&amp; nums1[mid1 - <span class="number">1</span>] &gt; nums2[mid2] &#123;</span><br><span class="line">                e = mid1 - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid2 &gt; <span class="number">0</span> &amp;&amp; mid1 &lt; m &amp;&amp; nums1[mid1] &lt; nums2[mid2 - <span class="number">1</span>] &#123;</span><br><span class="line">                b = mid1 + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> mid1 == <span class="number">0</span> &#123;</span><br><span class="line">                    maxOfLeft = nums2[mid2 - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid2 == <span class="number">0</span> &#123;</span><br><span class="line">                    maxOfLeft = nums1[mid1 - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxOfLeft = <span class="built_in">max</span>(nums1[mid1 - <span class="number">1</span>], nums2[mid2 - <span class="number">1</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="type">Double</span>(maxOfLeft)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> mid1 == m &#123;</span><br><span class="line">                    minOfRight = nums2[mid2]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid2 == n &#123;</span><br><span class="line">                    minOfRight = nums1[mid1]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    minOfRight = <span class="built_in">min</span>(nums1[mid1], nums2[mid2])</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Double</span>(maxOfLeft + minOfRight) / <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(log(n + m))</li><li>空间复杂度：O(1)</li><li>主要思想：** 对于 m 和 n 数字的数组，<code>nums1</code> 和 <code>nums2</code>，其中 <code>m &lt;= n</code>。要在 <code>nums1</code> 中找到 <code>mid1</code> 的索引，将数组分成左右部分：</li></ul><p><code>nums1[0, 1, ..., mid1 - 1]</code> | <code>nums1[mid1, mid1 + 1, ..., m]</code></p><p><code>nums2[0, 1, ..., mid2 - 1]</code> | <code>nums2[mid2, mid2 + 1, ..., n]</code></p><p>数组分后的左右部分要确保：</p><ul><li>左数 = 右数</li><li>左边的最大值 &lt;= 右边的最小值</li></ul><p>点击前往 <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">LeetCode</a> 练习 </p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 3 最长未重复子字符串</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%203%20%E6%9C%80%E9%95%BF%E6%9C%AA%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://fanbaoying.github.io/LeetCode - 3 最长未重复子字符串/</id>
    <published>2021-11-22T06:29:18.000Z</published>
    <updated>2021-11-22T06:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区从本期开始会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长)</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。</p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个字符串 <code>s</code>, 找出最长未重复的子字符串的长度.</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;abcabcbb&quot;</span><br><span class="line">输出： 3</span><br><span class="line">解释： 最长为重复的子字符串答案是 &quot;abc&quot;, 长度为 3.</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;bbbbb&quot;</span><br><span class="line">输出： 1</span><br><span class="line">解释： 最长为重复的子字符串答案是 &quot;b&quot;, 长度为 1.</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;pwwkew&quot;</span><br><span class="line">输出： 3</span><br><span class="line">解释： 最长为重复的子字符串答案是 &quot;wke&quot;, 长度为 3.</span><br><span class="line">注意答案必须是自字符串,“pwke” 是一个子列,而不是一个自字符串.</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;&quot;</span><br><span class="line">输出： 0</span><br></pre></td></tr></table></figure><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">0</span>, startIdx = <span class="number">0</span>, charToPos = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">let</span> sChars = <span class="type">Array</span>(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i, char) <span class="keyword">in</span> sChars.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> pos = charToPos[char] &#123;</span><br><span class="line">                startIdx = <span class="built_in">max</span>(startIdx, pos)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// update to next valid position</span></span><br><span class="line">            charToPos[char] = i + <span class="number">1</span></span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, i - startIdx + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用字典存储非重复子字符串的下一个可能有效字符的位置,然后迭代字符串更新 maxLen、dictionary 和遇到重复时的 startIdx .</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(n)</li></ul><p>点击前往 <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区从本期开始会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长)&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 2 Add Two Numbers</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%202%20Add%20Two%20Numbers/"/>
    <id>https://fanbaoying.github.io/LeetCode - 2 Add Two Numbers/</id>
    <published>2021-11-22T06:27:18.000Z</published>
    <updated>2021-11-22T06:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区从本期开始会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。</p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>已知两个非负整数（<code>例如：l1 = 342，l2 = 465</code>），将数字分别按相反的顺序存储到链表中（<code>例如：l1 = [2,4,3]，l2 = [5,6,4]</code>），每个节点都包含一个数字，将两个数字相加并将总和作为链表返回（<code>例如：[7,0,8]</code>）。</p><p>假设这两个数字不包含任何前导零(<code>例如：</code><del>012</del>)，除了数字 0 本身。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e825f8225274c4888fb02183f163807~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3]，l2 = [5,6,4]</span><br><span class="line">产出：[7,0,8]</span><br><span class="line">说明：342 + 465 = 807</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0]，l2 = [0]</span><br><span class="line">产出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">产出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>限制</strong></p><ul><li>每个链表中的节点数在 [1, 100] 范围内</li><li>0 &lt;= 节点值 &lt;= 9</li><li>保证列表中没有前导零的数字</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var next: ListNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.next = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> l1 = l1 <span class="keyword">else</span> &#123;<span class="keyword">return</span> l2&#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> l2 = l2 <span class="keyword">else</span> &#123;<span class="keyword">return</span> l1&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> outputNode = <span class="type">ListNode</span>((l1.val + l2.val)%<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> l1.val + l2.val &gt; <span class="number">9</span> &#123;</span><br><span class="line">            outputNode.next = addTwoNumbers(addTwoNumbers(l1.next, l2.next),</span><br><span class="line">                                            <span class="type">ListNode</span>(<span class="number">1</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputNode.next = addTwoNumbers(l1.next, l2.next)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outputNode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用进位并遍历两个链表</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>点击前往 <a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区从本期开始会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 1 Two Sum</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%201%20Two%20Sum/"/>
    <id>https://fanbaoying.github.io/LeetCode - 1 Two Sum/</id>
    <published>2021-11-22T06:26:18.000Z</published>
    <updated>2021-11-22T06:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区从本期开始会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。</p><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>已知一个整数数组 <code>nums</code> 和一个整数 <code>target</code>，取数组中任意两个值相加的和等 整数 <code>target</code>，返回这两个值在数组中的索引。</p><a id="more"></a><p><strong>假设：</strong></p><ol><li>只有一个有效答案</li><li>同一个值不能重复取两次</li><li>可以按任意顺序返回答案</li></ol><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15]，target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9，所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4]，target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3]，target = 6</span><br><span class="line">输出： [0,1]</span><br></pre></td></tr></table></figure><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (i, num) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastIndex = dict[target - num] &#123;</span><br><span class="line">                <span class="keyword">return</span> [lastIndex, i]</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            dict[num] = i</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"No valid outputs"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：遍历数组并在字典中存储目标 - nums[i]</li><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>该算法题解的 github 仓库地址是：<a href="https://github.com/soapyigu/LeetCode-Swift" target="_blank" rel="noopener">https://github.com/soapyigu/LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区从本期开始会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;/p&gt;
&lt;h2 id=&quot;1-描述&quot;&gt;&lt;a href=&quot;#1-描述&quot; class=&quot;headerlink&quot; title=&quot;1. 描述&quot;&gt;&lt;/a&gt;1. 描述&lt;/h2&gt;&lt;p&gt;已知一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;target&lt;/code&gt;，取数组中任意两个值相加的和等 整数 &lt;code&gt;target&lt;/code&gt;，返回这两个值在数组中的索引。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第五期/</id>
    <published>2021-10-25T03:27:35.000Z</published>
    <updated>2021-10-25T06:51:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png" alt=""></p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Apple 举办了 <code>Unleashed</code> 活动发布了新品，借助超强的 <code>M1 Pro</code> 或 <code>M1 Max</code> 芯片，不管是基于新款的 <code>MacBook Pro</code> 开发应用，还是开发 <code>MacBook Pro</code> 下的应用，新机都将给我们带来突破性的性能和惊人的电池使用时长。</p><p>再加上强大的神经引擎，用于增强机器学习和升级的支持 <code>ProRes</code> 的媒体引擎，新款 <code>MacBook Pro</code> 能让我们的 App 做前所未有的事情。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15312</strong> [Swift-DocC] <a href="https://bugs.swift.org/browse/SR-15312" title="Add &#39;version&#39; command to docc command line tool" target="_blank" rel="noopener">添加 “version” 命令到 docc 命令行工具中</a> </p><p><strong>SR-15312</strong> [Swift-DocC] <a href="https://bugs.swift.org/browse/SR-15313" title="Primary tutorial navigation dropdown fails to bold the current tutorial when browser URL is not lowercased" target="_blank" rel="noopener">当浏览器 URL 不是小写时，主教程导航下拉菜单无法将当前教程字体加粗</a> </p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Franklin Schrans</strong> 宣布 <a href="https://swift.org/blog/swift-docc/" title="Swift-DocC is Now Open Source" target="_blank" rel="noopener">Swift-DocC</a> 将要开源.</p><p><strong>Marin Todorov</strong> 终于披露了他关于 <a href="https://github.com/apple/swift-markdown" title="Swift Markdown" target="_blank" rel="noopener"><code>Swift Markdown</code></a> 的工作.</p><p><strong>Federico Zanetello</strong> 写了一篇<a href="https://www.fivestars.blog/articles/warn_unqualified_access/" title="warn_unqualified_access" target="_blank" rel="noopener">文章</a>来说明 <code>@warn_unqualified_access</code> 的使用.</p><p><strong>Dave DeLong</strong> 解释了如何<a href="https://davedelong.com/blog/2021/10/09/simplifying-backwards-compatibility-in-swift/" title="Simplifying Backwards Compatibility in Swift" target="_blank" rel="noopener">简化 Swift 中的向后兼容性</a>。</p><p><code>Swift-DocC</code> 的文档现在已经发布在 <a href="https://swift.org/documentation/docc/" title="Docc" target="_blank" rel="noopener">Swift.org</a> (使用 <a href="https://forums.swift.org/t/documentation-for-swift-docc-is-now-on-swift-org/52914" title="Documentation for Swift-DocC is now on Swift.org" target="_blank" rel="noopener">Swift-DocC!</a>).</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SE-0325</strong> <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0325-swiftpm-additional-plugin-apis.md" title="Additional Package Plugin APIs" target="_blank" rel="noopener">附加包插件 API</a> 正在审查中。</p><p><strong>SE-0303</strong> 在 <code>SwiftPM</code> 中引入了定义构建工具插件的能力, 允许自定义工具在构建打包时被调用。为了支持该特性， <strong>SE-0303</strong> 引入了最小初始 API，插件能够通过该接口获取那些被唤起构建的 Target 的相关信息。</p><p>该提案扩展了插件 API 以提供更多上下文，包括更丰富的包图表示。 这是为将来支持新类型的插件做准备。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>1. Nuri Amari</strong> 提出了<a href="https://forums.swift.org/t/pitch-improved-clangimporter-diagnostics/52687" title="Improved ClangImporter Diagnostics" target="_blank" rel="noopener">改进 ClangImporter</a> 的建议。</p><p>提出对 <code>ClangImporter</code> 的改进建议，当导入 <code>C</code> 或 <code>Objective-C</code> 实体发生错误时提供更详细的反馈。 就目前而言，当 <code>ClangImporter</code> 无法完全或部分导入实体（函数、类型、宏等）时，出现错误是不会提示的。当前的 Swift 编译错误大部分情况下会提示<strong>从未定义过实体</strong>。</p><p><strong>2. Frederick Kellison-Linn</strong> 提出了<a href="https://forums.swift.org/t/pitch-generalize-keypath-to-function-conversions/52681" title="Generalize keypath-to-function conversions" target="_blank" rel="noopener">关键路径到函数转换</a>的想法。</p><p>该提案介绍了在允许 <code>(Root) -&gt; Value</code> 函数的情况下使用键路径表达式 <code>\Root.value</code> 的能力。</p><p><code>Swift-evolution</code> 线程：<a href="https://forums.swift.org/t/key-path-expressions-as-functions/19587" title="Key Path Expressions as Functions" target="_blank" rel="noopener">关键路径表达式作为函数</a></p><p><strong>3. Patrick Pijnappel</strong> 提出了为 <a href="https://forums.swift.org/t/pitch-exhaustive-pattern-matching-for-non-open-classes/52718" title="Exhaustive pattern matching for non-open classes" target="_blank" rel="noopener">non-open 类实现详尽模式匹配</a>的建议。</p><p>由于现在区分了开放类和非开放类，非开放类层次结构应该能够完全匹配。对于添加新子类，不需要添加任何语法就可以完成。</p><p><strong>4. Guillaume Lessard</strong> 提出了对<a href="https://forums.swift.org/t/pitch-pointer-usability-improvements/52736" title="Pointer Usability Improvements" target="_blank" rel="noopener">指针可用性</a>的改进。</p><p>该提案为 <code>UnsafePointer</code>、<code>Mutable</code> 和 <code>Raw</code> 引入了一些 quality-of-life 改进。</p><ol><li>添加 API 获取一个 <code>UnsafeRawPointer</code> 实例，这是一个从起点推进到给定对齐的实例</li><li>在给定 <code>UnsafePointer&lt;T&gt;</code> 的情况下，添加一个 API 获取指向聚合的存储属性的指针 T</li><li>将<code>Unsafe[Mutable]Pointer</code> 未选中的下标重命名为包含 <code>unchecked</code> 标签</li><li>添加比较任意两种类型的指针的能力</li></ol><p><strong>5. Pavel Yaskevich</strong> 提出了改进<a href="https://forums.swift.org/t/pitch-light-weight-same-type-constraint-syntax/52889" title="Light-weight same-type constraint syntax" target="_blank" rel="noopener">相同类型约束语法</a>的建议。</p><p>为了实现改进泛型 UI 的目标，我们提出几项改进措施，为了解决协议和泛型类型之间的语法差距，在<strong>关联类型</strong>和<strong>泛型类型</strong>参数相同类型的约束上，隐藏了一些复杂性（视觉上和认知上）。</p><p><strong>6. Holly Borla</strong> 开始讨论如何<a href="https://forums.swift.org/t/discussion-easing-the-learning-curve-for-introducing-generic-parameters/52891" title="Easing the learning curve for introducing generic parameters" target="_blank" rel="noopener">简化引入泛型参数的学习曲线</a>。</p><p>Swift 的泛型系统具有很强的表达能力，但是要理解具有相关类型的协议、带有 where 子句的泛型签名以及其他泛型特性的完整通用性，是将泛型引入 Swift 项目的一个重大障碍。泛型系统的主要目标是通过改进在 Swift 中编写泛型代码的人体工程学，将具体API抽象为泛型API的学习曲线。本次讨论目的是就实现这一目标的可能方向征求意见，并收集在社区中提出的其他想法。欢迎在文末留言提出问题、评论和想法！</p><p>本帖中的许多想法都是由 <strong>@Joe_Groff</strong> 在<a href="https://forums.swift.org/t/improving-the-ui-of-generics/22814" title="Improving the UI of generics" target="_blank" rel="noopener">改进泛型 UI</a> 中提出的。</p><p><strong>7. Nate Cook</strong> 提出了一个<a href="https://forums.swift.org/t/pitch-character-classes-for-string-processing/52920" title="Character Classes for String Processing" target="_blank" rel="noopener">用于字符串处理的字符类</a>的想法。</p><p><a href="https://forums.swift.org/t/declarative-string-processing-overview/52459" title="Declarative String Processing Overview" target="_blank" rel="noopener">声明性字符串处理概述</a>讲述了正则表达式支持的匹配，但没有关于语法和语义的详细信息，将澄清留给后续介绍。</p><p><a href="https://forums.swift.org/t/pitch-regular-expression-literals/52820" title="Regular Expression Literals" target="_blank" rel="noopener">正则表达式的文本</a>提供了关于正则表达式语法的更多细节，例如分隔符和 <code>PCRE-syntax</code> 内部结构，省略了对正则表达式语义的讨论。本帖的目的旨在解决正则表达式语义的目标子集：<strong>字符类的定义</strong>。我们建议直接在现有的 <code>Character</code> 和 <code>Unicode.Scalar</code> 上和新提出的 API 背景下来处理。</p><p>正则表达式中的字符类包括元字符，例如匹配数字的 <code>\d</code>、匹配空格的 <code>\s</code> 和 匹配任何字符的 <code>.</code>。单个文字字符也可以被认为是字符类，因为它们至少与自己匹配，并且在不区分大小写的匹配中，与大小写切换的对应字符匹配。因此，将字符类视为正则表达式字面量的任何部分，该部分可以匹配字符串的实际组件。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://mp.weixin.qq.com/s/vjC45D5249397bfUCXfhLg" target="_blank" rel="noopener">Swift 5 从零到精通 iOS 开发训练营</a></p><p>《Swift 5 从零到精通 iOS 开发训练营》是一本从基础到 iOS 项目开发的实战教程，由资深 iOS 开发程序员珲少亲自操刀编撰而成。<code>文末有送书抽奖，抽奖为 Swift社区 额外福利</code></p><p><a href="**https://mp.weixin.qq.com/s/qM4O-wBCZgvn0oFCR7kIbA**">iOS UI 自动化测试原理以及在 Trip.com 的应用实践</a></p><p>来自携程 IBU 公共无线倪瑶的实战分享： iOS UI 自动化测试实战以及原理总结。</p><p><a href="https://mp.weixin.qq.com/s/7-QlpcfhTaw4D_SmQYbmfA" target="_blank" rel="noopener">一文带你读懂 Swift 社区最新开源的算法库</a></p><p>最近 Swift 社区动作频频，又是登陆 Windows，又是推出底层基础库。现在又推出了 Swift 算法库，现在让我们看看里面到底有什么内容，是否值得现在在生产中应用，面对内容丰富的 <code>raywenderlich/swift-algorithm-club</code> 是否有足够的竞争力呢。</p><p><a href="https://mp.weixin.qq.com/s/aoQuDd58LQRSbJty5Tyjfw" target="_blank" rel="noopener">多角度体会 Swift 方法派发</a></p><p>我们知道 Swift 有三种方法派发方式：静态派发（直接派发）、VTable 派发（函数表派发）、消息派发。下面我们分别从 SIL 中间语言，以及汇编的角度体会 Swift 的方法派发方式。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><div align="center"><br><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Apple 举办了 &lt;code&gt;Unleashed&lt;/code&gt; 活动发布了新品，借助超强的 &lt;code&gt;M1 Pro&lt;/code&gt; 或 &lt;code&gt;M1 Max&lt;/code&gt; 芯片，不管是基于新款的 &lt;code&gt;MacBook Pro&lt;/code&gt; 开发应用，还是开发 &lt;code&gt;MacBook Pro&lt;/code&gt; 下的应用，新机都将给我们带来突破性的性能和惊人的电池使用时长。&lt;/p&gt;
&lt;p&gt;再加上强大的神经引擎，用于增强机器学习和升级的支持 &lt;code&gt;ProRes&lt;/code&gt; 的媒体引擎，新款 &lt;code&gt;MacBook Pro&lt;/code&gt; 能让我们的 App 做前所未有的事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第六期/</id>
    <published>2021-10-25T03:27:35.000Z</published>
    <updated>2021-11-08T07:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png" alt=""></p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>译者言：周日立冬，北方多地迎来 2021 年的第一场雪，上海也降下大雨，此时你所在的城市降温了吗？记得添衣保暖，避免感冒生病影响工作和生活。</p><p><a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-13_2-release-notes#Swift" target="_blank" rel="noopener">Xcode 13.2 Beta</a> 版已具备并发支持，该特性将有助于解决很多 Swift 开发者的某些痛点。或许 Swift 内置的并发系统最重要的好处是，它允许以更简单的方式，并行执行多异步任务。可以想像，通过增加执行任务的速度这将节省我们更多时间。</p><a id="more"></a><p><a href="https://twitter.com/fassko" target="_blank" rel="noopener">Kristaps Grinbergs</a> Swift 周报负责人在本期周报中公开自己将不再领导 Swift 周报项目，原文如下：</p><p>我非常高兴地编写这么优秀并且已经运营了三年的 Swift 新闻周报。我遇到了很多了不起的人，并且感谢你们所有人，我已经收获了很多！ 这是为什么打出下面这句话，让我感慨万千的原因。第 200 期周报将是我运营的最后一期。我已经决定不再领导这个项目，并且怀着愉悦的兴奋，我正在寻找愿意继续管理 Swift 周报的人。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15408</strong> [Swift-DocC] <a href="https://bugs.swift.org/browse/SR-15408" title="Building documentation with a fallback display name that includes a space produces a broken-looking article" target="_blank" rel="noopener">用含有空格的回调显示名称构建文档会产生一篇无法阅读的文章</a> </p><p><strong>译者注：</strong> 如果将带有空格的回调显示名称（如 –fallback-display-name “My Display Name”）以及有效的符号图传递给 DocC，DocC 会生成一篇以“我的显示名称”作为 H1 的文章标题并将其组织在顶级框架页面上的“文章”主题组下。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p>新的 <a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-13_2-release-notes#Swift" target="_blank" rel="noopener">Xcode 13.2 Beta</a> 增加了对 macOS 10.15、iOS 13、tvOS 13 和 watchOS 6 或更高版本的 Swift 并发支持。 这种支持包括<code>async/await</code>、<a href="https://developer.apple.com/documentation/swift/actor" target="_blank" rel="noopener">actor</a>、全局 <code>actor</code>，结构化的并发及其任务 API。</p><p><strong>Tim Condon</strong> 发布了 <a href="https://forums.swift.org/t/async-await-has-arrived-in-vapor/53077" title="Async/await has arrived in Vapor" target="_blank" rel="noopener">Vapor</a> 已经支持 <code>async/await</code>。</p><p><strong>Konrad ktoso Malawski</strong> 写了一篇介绍 <a href="https://www.swift.org/blog/distributed-actors/" title="Introducing Swift Distributed Actors" target="_blank" rel="noopener">Swift Distributed Actors</a> 的文章。</p><p><strong>Marc Aupont</strong> 将加入 Diversity in Swift 工作组。</p><p>Swift 下载链接已移至新位置以提供更快的下载速度！ 工具链将托管在 <a href="https://www.swift.org/download/" target="_blank" rel="noopener">download.swift.org</a>，它将使用与当前 URL 类似的模式。 要使用新 URL，请将 <strong>swift.org/builds/</strong> 替换为 <strong>download.swift.org/</strong>。 从 2021 年 10 月 26 日开始，<strong>swift.org/builds</strong> URL 已重定向到新的子域。</p><p><strong>Sarun Wongpatcharapakorn</strong> 写了一篇博文解释 Swift 中的 <a href="https://sarunw.com/posts/what-is-keypath-in-swift/" title="What is a KeyPath in Swift" target="_blank" rel="noopener">KeyPath</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>Erik Eckstein</strong> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39902" title="First prototype of Performance Annotations" target="_blank" rel="noopener">实现了性能注释的原型</a>，如 Swift 中的 <code>@_noLocks</code> 和 <code>@_noAllocation</code>。</p><p><strong>Slava Pestov</strong> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39918" title="RequirementMachine: Improved handling of identity conformances" target="_blank" rel="noopener">改进了对“身份一致性”的处理 [P].[P] =&gt; [P]</a>。</p><p><strong>John McCall</strong> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39829" title="Fix the alignment of future fragments for highly-aligned result types" target="_blank" rel="noopener">修复了高度对齐的结果类型的未来片段的对齐方式</a></p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><strong>SE-0325</strong> <a href="https://forums.swift.org/t/accepted-with-modifications-se-0325-additional-package-plugin-apis/53086" title="[Accepted with Modifications] SE-0325: Additional Package Plugin APIs" target="_blank" rel="noopener">附加包插件 API</a> 提案已被修改并同意。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SE-0326</strong>: <a href="https://forums.swift.org/t/se-0326-multi-statement-closure-parameter-result-type-inference/52964" title="Multi-statement closure parameter/result type inference" target="_blank" rel="noopener">多语句闭包参数/结果类型推断</a>正在审查中.</p><p><strong>Kristaps Grinbergs</strong> 建议通过启用闭包体的参数和结果类型推断，来改进多语句闭包推断行为。 这将令类型推断更符合开发者的预期，并且移除现存的行为壁垒，即向闭包添加一个表达式或语句会导致编译失败的结果。</p><p><strong>SE-0327</strong>: <a href="https://forums.swift.org/t/se-0327-on-actors-and-initialization/53053" title="On Actors and Initialization" target="_blank" rel="noopener">On Actors and Initialization</a>正在审查中。</p><p><strong>Actors</strong> 是 Swift 中相对较新的名义类型，为其可变态提供了数据竞争安全性。数据保护是通过将每个 <code>actor</code> 实例可变状态一次最多隔离一个任务来实现的。引入 <code>actor</code>（<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md" title="Actors" target="_blank" rel="noopener">SE-0306</a>）的提案非常庞大和详细，但忽略了创建和销毁 <code>actor</code> 隔离状态的一些细微之处。 该提案旨在支持一个 <code>actor</code> 的定义，为了弄清一个 <code>actor</code> 实例的数据隔离何时开始和结束，以及在一个 <code>actor</code> 的 <code>init</code> 和 <code>deinit</code> 函数声明中能够做什么。</p><p><strong>SE-0328</strong>：<a href="https://forums.swift.org/t/se-0328-structural-opaque-result-types/53248" title="SE-0328: Structural opaque result types" target="_blank" rel="noopener">Structural opaque result</a> 类型正在审查中。</p><p><strong>Opaque</strong> 结果类型可以用作函数的结果类型、变量的类型或者下标的结果类型。在所有情况下， <strong>Opaque</strong> 结果类型必须是整个类型。该提案建议解除该限制，并且在“结构性”的位置中允许使用 <strong>Opaque</strong> 结果类型。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>一个来自 <strong>@justkwin</strong> 关于 <code>Foundation</code> 如何使用 <code>URL</code> 结束来表示 <code>file.paths</code> 的小历史<a href="https://forums.swift.org/t/get-folders-number-of-elements/" title="Get Folder’s Number of Elements" target="_blank" rel="noopener">教训</a>。</p><h3 id="II"><a href="#II" class="headerlink" title="II"></a>II</h3><p><strong>Anders Bertelrud</strong> 提出了添加<a href="https://forums.swift.org/t/pitch-package-manager-command-plugins/53172" title="[Pitch] Package Manager Command Plugins" target="_blank" rel="noopener">包管理器命令插件的提案</a>。</p><p><strong>SE-0303</strong> 引入了第一种 SwiftPM 插件，专注于使用自定义构建工具调用扩展构建系统的能力（特别是为了生成源代码）。 那些插件一直计划成为第一种被 SwiftPM 支持的插件。</p><p><strong>Kristaps Grinbergs</strong> 想提出一个提案草案，为 SwiftPM 添加另一种更通用目的的“命令插件”。 这些类型的插件可以由用户直接调用，用于源代码格式化、文档生成、测试报告生成等。命令插件不一定与构建系统有任何关系。</p><p>这些自定义命令插件一个重要的方面是它们可以要求插件主机（SwiftPM 或支持包的 IDE）按需生成专门的信息，或着初始化构建或测试运行。 这是提案草案中最需要仔细审查的部分。 在使 API 足够丰富以令其尽可能有用，同时也使其足够通用以不仅在 SwiftPM 中而且 IDE 中支持 Swift 包，这里有一个相悖的因素。</p><h3 id="III"><a href="#III" class="headerlink" title="III"></a>III</h3><p><strong>Guillaume Lessard</strong> 提出了一项提案，该提案将实现<a href="https://forums.swift.org/t/pitch-pointer-family-initialization-improvements/53168" title="[Pitch] Pointer family initialization improvements" target="_blank" rel="noopener">指针族初始化改进</a>。</p><p><code>UnsafeMutablePointer</code> 系列中的类型通常需要手动管理内存分配，包括对其初始化状态的管理。 涉及的状态是在分配后:</p><ol><li>未绑定和未初始化时（当在 <code>UnsafeMutableRawPointer.allocate()</code> 返回）</li><li>绑定到一个类型，并且未初始化（从 <code>UnsafeMutablePointer&lt;T&gt;.allocate()</code> 返回）</li><li>绑定到一个类型，并且初始化</li></ol><p>无论何时它未曾被初始化，内存都能够安全地销毁。</p><p>不幸的是，不是每一个 <code>UnsafeMutablePointer</code> 系列中的类型有这个必要功能，以用于全面管理它内存初始化的状态。 我们打算在本提案中解决这个问题，并提供在各种更广泛的情况下管理初始化状态的功能。</p><h3 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h3><p><strong>Kelvin Ma</strong> 展开了一个关于 <code>AsyncStream</code> 构造函数的<a href="https://forums.swift.org/t/asyncstream-constructor-which-also-returns-its-continuation/53251" title="AsyncStream constructor which also returns its Continuation" target="_blank" rel="noopener">讨论</a>，该构造函数也返回其 <code>Continuation</code>。</p><p>有没有什么方法我们可以向 <code>AsyncStream</code> 添加一个 API，它直接返回 <code>Continuation</code>，从而我们就不必把它的闭包“调来调去”？</p><p>一般来说，我也觉得 <code>AsyncStream</code> 真的很难使用，因为迭代在创建了 <code>AsyncStream</code> 的同一个任务中发生，甚至是没有并发迭代时曾出现。 这使“订阅” <code>actor</code> 对象生成的事件变得困难，即使订阅方法被标记为 <code>nonisolated</code>。</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p><strong>Adam Fowler</strong> 积极将 <code>MQTTNIO</code> 库<a href="https://forums.swift.org/t/mqttnio/53238" title="Mqttnio" target="_blank" rel="noopener">加入 SSWG 包列表中</a>.</p><p>MQTT 是一种通常用于与 IoT（物联网）设备进行通信的消息传递协议。 它是一种轻量级的发布/订阅消息传输，旨在具有较小的代码占用空间和网络带宽。</p><h3 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h3><p><strong>Cory Benfield</strong> 向我们<a href="https://forums.swift.org/t/swiftnio-swift-version-support/53232" title="SwiftNIO Swift version support" target="_blank" rel="noopener">更新了</a>关于 <code>SwiftNIO Swift</code> 版本支持。</p><p>SwiftNIO 团队已将其作为我们工作流程的主要支柱，以尝试在相当长的时间内支持 Swift 版本。大多数用户没有利用这一点，更愿意继续使用最新版本的 Swift，但我们认为重要的是你要有信心，新编写的应用程序将在未来获得一些有意义的支持。</p><h3 id="VII"><a href="#VII" class="headerlink" title="VII"></a>VII</h3><p><strong>Victoria Mitchell</strong> <a href="https://forums.swift.org/t/extending-swift-docc-to-support-objective-c-documentation/53243" title="Extending Swift-DocC to support Objective-C documentation" target="_blank" rel="noopener">写了一篇</a>关于扩展 <code>Swift-DocC</code> 以支持 <code>Objective-C</code> 的文档。</p><p><code>DocC</code> 的架构目前仅支持 <code>Swift</code> 一个语言的渲染符号文档。然而，有些跨语言项目可以从将多个“语言变体”收集到同一组文档中受益，例如可以被 <code>Swift</code> 中调用的 <code>Objective-C</code> API，反之亦然。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><div align="center"><br><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;译者言：周日立冬，北方多地迎来 2021 年的第一场雪，上海也降下大雨，此时你所在的城市降温了吗？记得添衣保暖，避免感冒生病影响工作和生活。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/xcode-release-notes/xcode-13_2-release-notes#Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xcode 13.2 Beta&lt;/a&gt; 版已具备并发支持，该特性将有助于解决很多 Swift 开发者的某些痛点。或许 Swift 内置的并发系统最重要的好处是，它允许以更简单的方式，并行执行多异步任务。可以想像，通过增加执行任务的速度这将节省我们更多时间。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四期/</id>
    <published>2021-10-22T07:19:18.000Z</published>
    <updated>2021-10-22T07:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 Swift.org 进行了一些非常好的改进，包括对 <code>dark mode</code> 的支持。 对于在 iOS 上使用 <code>dark mode</code> 的用户，该网站将自动切换模式以匹配。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15271</strong> [Compiler] <a href="https://bugs.swift.org/browse/SR-15271" title="Improve Codable Diagnostics When CodingKeys Do Not Match Properties" target="_blank" rel="noopener">当 CodingKeys 与属性不匹配时改进可编码诊断</a></p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Ted Kremenek</strong> 写了一篇关于 <a href="https://swift.org/blog/swift-5-5-released/" title="Swift 5.5 Released" target="_blank" rel="noopener">Swift 5.5 版本</a>的文章。</p><p><strong>Bruno Rocha</strong> 发表了一篇优秀的文章，解释了 <a href="https://swiftrocks.com/how-asyncsequence-works-internally-in-swift" title="How AsyncSequence works internally in Swift" target="_blank" rel="noopener">AsyncSequence 在 Swift 内部是如何工作</a>的。</p><p><strong>Lee Kah Seng</strong> 写了一篇文章，描述了 <a href="https://swiftsenpai.com/swift/actor-reentrancy-problem/" title="The Actor Reentrancy Problem in Swift" target="_blank" rel="noopener">Swift 中的 Actor Reentrancy 问题</a>。</p><p><strong>Amritpan Kaur</strong> 解释了她如何参与首届 <a href="https://forums.swift.org/t/swift-mentorship-compiler-language-design/52522" title="Swift Mentorship - Compiler &amp; Language Design" target="_blank" rel="noopener">Swift 导师，并致力于编译器开发和语言设计</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>Michael Ilseman</strong> 合并了一个为 <a href="https://github.com/apple/swift/pull/38922" title="[stdlib] Implement native normalization for String" target="_blank" rel="noopener">String 实现原生规范化</a>的 pull request。</p><p><strong>Doug Gregor</strong> 创建了一个 pull request，<a href="https://github.com/apple/swift/pull/39609" title="Back-deploy @objc actor types" target="_blank" rel="noopener">向后兼容  @objc actor 类型</a>。</p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><strong>SE-0322</strong> <a href="https://forums.swift.org/t/accepted-with-modifications-se-0322-temporary-uninitialized-buffers/52532" title="Temporary Uninitialized Buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>已接受修改。</p><p><strong>SE-0323</strong> <a href="https://forums.swift.org/t/accepted-se-0323-asynchronous-main-semantics/52531" title="Asynchronous Main Semantics" target="_blank" rel="noopener">Asynchronous Main 语义</a>已接受。</p><p><strong>SE-0324</strong> 接受了<a href="https://forums.swift.org/t/accepted-se-0324-relax-diagnostics-for-pointer-arguments-to-c-functions/52599" title="Relax diagnostics for pointer arguments to C functions" target="_blank" rel="noopener">对 C 函数的指针参数放宽诊断</a>提案。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SSWG-0017</strong>：<a href="https://forums.swift.org/t/sswg-0017-multipartkit/52586" title="MultipartKit" target="_blank" rel="noopener">MultipartKit</a> 正在审查中。</p><p><code>MultipartKit</code> 提供 <code>Multipart</code> 数据的低级解析和序列化，以及对 <code>Multipart</code> 表单数据的编码和解码的高级 <code>Codable</code> 支持。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>1. Karoy Lorentey</strong> 询问什么时候将 <code>ManagedAtomic/UnsafeAtomic</code> 标记为 <code>Sendable</code>？</p><p>刚刚提交了<a href="https://github.com/apple/swift-atomics/issues/45" title="The constructs provided by this package need to be marked Sendable" target="_blank" rel="noopener">问题 #45</a>，要求将 <code>UnsafeAtomic</code>、<code>ManagedAtomic</code> 和朋友标记为 <code>Sendable</code>，这反映了它们可以安全地跨并发域传输。</p><p><strong>2. Kavon Farvardin</strong> 提议定义 <a href="https://forums.swift.org/t/proposal-actor-initializers-and-deinitializers/52322" title="[proposal] Actor Initializers and Deinitializers" target="_blank" rel="noopener">actor 初始化器</a>在 <code>Swift</code> 中的工作方式。</p><p>目前，本提案中描述的一些问题的建议解决方案通过警告反映在 <code>Swift 5.5</code> 中，但是审查 <code>Swift 6</code> 的这些更改很重要。此外，该提案为 <code>MainActor</code> 隔离类的 <code>deinit</code> 增加了额外的功能，这样可以更容易、更安全地编写。如果有新的想法和评论可以在<a href="https://github.com/kavon/swift-evolution/blob/actor-init-proposal2/proposals/nnnn-actor-initializers.md" title="Actor Initializers and Deinitializers" target="_blank" rel="noopener">这里提出来</a>。</p><p><strong>3. Kelvin Ma</strong> 发现 <a href="https://forums.swift.org/t/swift-5-5-has-serious-stack-corruption-bugs/52344" title="Swift 5.5 has serious stack corruption bugs!" target="_blank" rel="noopener">Swift 5.5 存在严重的堆栈损坏错误</a>。</p><p>我发现了几个与 async/await 相关的堆栈损坏错误，这些错误可以在使用最近的夜间工具链编译的简单测试程序中重现。 我已经确认 5.5-RELEASE 工具链中存在这些错误中的两个三四个。</p><p>我发现了几个与 <code>async/await</code> 相关的堆栈损坏错误，可以在 <code>recent nightly toolchains</code> 的简单测试程序中重现问题。<strong>我已确认 <code>5.5-RELEASE toolchain</code> 中存在多个错误</strong>。</p><p><strong>4. Becca Royal-Gordon</strong> 提出了在<a href="https://forums.swift.org/t/pitch-2-staging-in-sendable-checking/52413" title="Staging in Sendable checking" target="_blank" rel="noopener">Sendable 检查中添加暂存</a>的建议。</p><p>几周前，<strong>@Douglas_Gregor</strong> <a href="https://forums.swift.org/t/pitch-staging-in-sendable-checking/51341" title="[Pitch] Staging in Sendable checking" target="_blank" rel="noopener">提出了一些更改</a>，试图解决在一些客户端或依赖项可能尚未更新时在模块中采用 Sendable 检查所涉及的一些问题。当模块最终更新时，这种方法可能会出现问题和隐藏的 BUG，以及 <code>Objective-C</code> 库如何能够控制其类型的可发送性。</p><p><strong>5. YR Chen</strong> 开始讨论<a href="https://forums.swift.org/t/upon-swift-6-solve-inconsistency-within-the-language/52437" title="Upon Swift 6: Solve inconsistency within the language" target="_blank" rel="noopener">解决 Swift 6 发布时的不一致问题</a>。</p><p>一些 API 破损的语言设计可以在 3 年后 <code>Swift 6</code> 的发布中修复。这是一个相当长的时间，通过 <code>Swift 3.2</code> 和 <code>Swift 4.2</code> 事实证明，过渡到 Swift 突破性发布要顺畅的多。</p><p>建议我们选择一些延迟的断点，目的是消除语言中的不一致。这些想法已经得到了社区的积极反馈，但是还是没有开始实施。</p><p><strong>6. Philippe Hausler</strong> 提出了<a href="https://forums.swift.org/t/pitch-clock-instant-date-and-duration/52451" title="[Pitch] Clock, Instant, Date, and Duration" target="_blank" rel="noopener">定义 Clock, Instant, Date 和 Duration </a>的提案。</p><p><strong>时间的概念可以分为三个不同的部分：</strong></p><ul><li>提供现在概念的项目加上一个在给定时间点后醒来的方法，* 时间点的概念</li><li>时间测量的概念</li></ul><p>这三项分别是时钟、瞬间和持续时间。时间的测量可用于许多类型的 API，从高级网络连接超时概念到休眠任务的时间量。目前，测量时间类型的 API 采用 <code>NSTimeInterval</code> 又名 <code>TimeInterval</code>、<code>DispatchTimeInterval</code>，甚至像 <code>timespec</code> 这样的类型。</p><p><strong>7. Michael Ilseman</strong> 提出了<a href="https://forums.swift.org/t/declarative-string-processing-overview/52459" title="Declarative String Processing Overview" target="_blank" rel="noopener">实现声明性字符串处理</a> API 的想法。</p><p>字符串处理很困难，Swift 标准库目前提供的功能不足。我们建议添加两个新的声明性字符串处理 API，一个是熟悉的 <code>Regex</code> 文本，一个是更强大的 <code>Pattern</code> 结果生成器，以便 Swift 字符串处理起来更快速简便。</p><p>这是一个大型功能，最终将分为多个 <code>Swift Evolution</code> 提案。主要目的在于推动高级方向的讨论，并介绍该功能的关键点及其相互关系。</p><p><strong>8. Kelvin Ma</strong> 开始讨论<a href="https://forums.swift.org/t/we-need-long-term-support-lts-releases/52462" title="long-term-support (“LTS”) releases." target="_blank" rel="noopener">长期支持 (“LTS”) 版本</a>。</p><p>对于那些没有关注开发主题的人，@mickeyl，@timdecode，我最近在 <code>Swift 5.5</code> 发布工具链中发现了数量惊人的高危险的堆栈损坏 BUG。</p><p>撇开 <code>Swift 5.5</code> 中堆栈损坏问题的技术方面不谈，在我们发布周期中采用某种形式的<a href="https://forums.swift.org/t/we-need-long-term-support-lts-releases/52462" title="“Long-Term Support” (LTS) release 8 " target="_blank" rel="noopener">“长期支持”（LTS）版本8</a>的概念是否值得，就像 Ubuntu 一直以来所做的那样。</p><p><strong>9. Anders Bertelrud</strong> 提出了扩展插件 <a href="https://forums.swift.org/t/pitch-additional-api-available-to-swiftpm-plugins/52494" title="pitch additional api available to swiftpm plugins" target="_blank" rel="noopener">SwiftPM 插件 API </a>以提供更多上下文的提案。</p><p><code>SE-0303</code> 引入了 SwiftPM 插件，特别关注构建工具插件（尤其是那些生成源代码的插件）。为了保持该提案的界限，插件可用的信息类型和数量针对生成构建命令的任务。</p><p>在开始考虑新类型的插件之前，扩展所有类型插件可用的信息似乎是明智的。未来的提案可能会为特定类型的插件添加特定的 API，但在此之前，一个好的起点似乎是让所有插件访问 SwiftPM 内部已经拥有的包图的提炼形式。这应该允许任何特定插件有很大的自由度。</p><p>我提出一份提案草案，用于扩展可用于 SwiftPM 插件的 API，并且很想听听大家的想法。在 SwiftPM 存储库中的 PR 中有一个实现。</p><p><strong>10. Guillaume Lessard</strong> 提出了一项<a href="https://forums.swift.org/t/pitch-expand-usability-of-withmemoryrebound/52500" title="expand usability of withMemoryRebound" target="_blank" rel="noopener">扩大 withMemoryRebound 可用性</a>的提案。</p><p>函数 <code>withMemoryRebound(to:capacity:_ body:)</code> 执行一个闭包，同时将一定范围的内存临时绑定到与被调用者绑定的类型不同的类型。</p><p>我们建议解除 <code>withMemoryRebound</code> 的一些显着限制，并启用重新绑定到更大的类型集，以及从原始内存指针和缓冲区重新绑定。</p><p><strong>11. Tim Condon</strong> 向我们介绍了 <a href="https://forums.swift.org/t/async-await-and-the-future-of-vapor/52590" title="async/await and the future of Vapor." target="_blank" rel="noopener">async/await 和 Vapor 的未来</a>。</p><p><strong>12. Drew McCormack</strong> 提出了一项提案，该提案将创建用于<a href="https://forums.swift.org/t/proposal-a-standard-library-type-for-working-with-shared-data-in-a-concurrent-system/52603" title="standard library data structures designed for working with shared data in a concurrent system." target="_blank" rel="noopener">在并发系统中处理共享数据的标准库数据结构</a>。</p><p>我想在这里提出这样一种类型：分支资源。</p><p><code>BranchingResource</code> 将是一种类型，其携带的有效负载（即资源）具有通用参数。 资源将从单个分支开始，称为“<code>main</code>”或“<code>trunk</code>”或“<code>truth</code>”。 该应用程序可以添加任意数量的辅助命名分支。</p><p><strong>13. Pavel Yaskevich</strong> 提出了<a href="https://forums.swift.org/t/pitch-enable-multi-statement-closure-parameter-result-type-inference/52619" title="enable multi-statement closure parameter/result type" target="_blank" rel="noopener">启用 multi-statement closure parameter/result type 推断</a>的想法。</p><p>我建议通过从闭包主体中启用参数和结果类型推断来改进多语句闭包的推理行为。</p><p>这将使开发人员的类型推断不那么令人惊讶，并消除了在闭包中添加多一个表达式或语句可能会导致编译失败的问题。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><h3 id="iOS-系列"><a href="#iOS-系列" class="headerlink" title="iOS 系列"></a>iOS 系列</h3><p><a href="https://mp.weixin.qq.com/s/ZprPxK8NbMqpP9flmWRagg" target="_blank" rel="noopener">百度一面总结（含答案）</a></p><p><a href="https://mp.weixin.qq.com/s/PYzQN5HYXLU1JuXBAZNyhQ" target="_blank" rel="noopener">使用 Swift 实现 Promise</a></p><p>我最近在找如何使用 Swift 实现 <code>Promise</code> 的资料，因为没找到好的文章，所以我想自己写一篇。通过本文，我们将实现自己的 <code>Promise</code> 类型，以便明了其背后的逻辑。</p><p><a href="https://mp.weixin.qq.com/s/8_utYi3y7I3ukh4VpnIM3A" target="_blank" rel="noopener">用 Swift 实现轻量的属性监听系统</a></p><p>本文的主要目的是解决客户端开发中对“模型的一处修改，UI 要多处更新”的问题。当然，我们要知晓解决方案的细节和思考过程，以及看到其能达到的效果。我们会用到函数式编程的思想，以及伟大的“泛型”。</p><h3 id="SwiftUI-系列"><a href="#SwiftUI-系列" class="headerlink" title="SwiftUI 系列"></a>SwiftUI 系列</h3><p><a href="https://mp.weixin.qq.com/s/hfe1m5bNiA0DzdFTEvi9sQ" target="_blank" rel="noopener">用 SwiftUI 实现 3D Scroll 效果</a></p><p>学完本教程后，你就可以在你的 App 中把这种 <code>3D</code> 效果加入任何自定义的 SwiftUI 视图。</p><p><a href="https://mp.weixin.qq.com/s/TD0I96HSUoTNmOmfySCtYQ" target="_blank" rel="noopener">如何让 SwiftUI 的列表变得更加灵活</a></p><p><code>List</code> 可能是 <code>SwiftUI</code> 附带的内置视图中最常用的一种，它使我们能够在任何 <code>Apple</code> 平台上呈现“类似于表格视图”的用户界面。今年，<code>List</code> 获得了许多非常重要的升级，使其更加灵活和易于定制。让我们看看都有哪些新功能。</p><p><a href="https://mp.weixin.qq.com/s/snJJi9KYViFErdJAP1HEPQ" target="_blank" rel="noopener">使用 SwiftUI 创建万花尺</a></p><p>为了完成一些真正意义上的绘图工作，我将带您通过创建一个简单的带 SwiftUI 的 <code>spirograph</code>。“Spirograph”是一种玩具的商标名称，你把一支铅笔放在一个圆圈里，然后绕着另一个圆圈的圆周旋转，创造出各种几何图案，称为轮盘赌——就像赌场游戏一样。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近 Swift.org 进行了一些非常好的改进，包括对 &lt;code&gt;dark mode&lt;/code&gt; 的支持。 对于在 iOS 上使用 &lt;code&gt;dark mode&lt;/code&gt; 的用户，该网站将自动切换模式以匹配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三期/</id>
    <published>2021-10-22T07:18:12.000Z</published>
    <updated>2021-10-22T07:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本期周报开始，将会引入<strong>推荐博文</strong>模块，主要为大家分享展示优秀的 iOS 技术博文，如果大家阅读到优秀的文章欢迎在文末留言告诉小编，大家资源共享共同进步。</p><p>iPhone 13 新品上架，你们都买了吗？苹果声称，iPhone 13 拥有全新的双摄像头系统，采用超快的 <code>A15</code> 芯片，提高电池的续航能力。</p><p>我们不仅要关注新的 iPhone 13，几天前，<code>Xcode 13</code> 与 <a href="https://forums.swift.org/t/swift-5-5-released/52247" title="Swift 5.5" target="_blank" rel="noopener">Swift 5.5</a> 也一起发布了。这是 Swift 5.5 更新的<a href="https://twitter.com/simjp/status/1440318174856036354" title="列表" target="_blank" rel="noopener">列表</a>，这个版本发布了很多新功能。Xcode 13 的发布说明可以在这里找到：<a href="https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes" title="iOS &amp; iPadOS 15 Release Notes" target="_blank" rel="noopener">iOS &amp; iPadOS 15 Release Notes</a>。</p><p>现在已经开始将<strong>并发</strong>功能向后部署到旧的 Swift 版本上。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Cory Benfield</strong> 告诉我们 <a href="https://forums.swift.org/t/swift-crypto-2-0-0/52308" title="Swift Crypto 2.0.0" target="_blank" rel="noopener">Swift Crypto 2.0.0 已经发布</a>。</p><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15218</strong>: [Compiler] <a href="https://bugs.swift.org/browse/SR-15218" title="Enhance interchangeable CGFloat/Double to allow interchange between optional" target="_blank" rel="noopener">增强 CGFloat/Double 之间的可互转，允许 optional 之间的互转</a></p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>salinas-miguel</strong> 的 PR 已合并：<a href="https://github.com/apple/swift/pull/39216" title="Remove Foundation dependency" target="_blank" rel="noopener">删除了 Swift 项目对 macOS 上的 Foundation 的依赖</a>。</p><p>Doug Gregor 创建了一个 <code>pull request</code> <a href="https://github.com/apple/swift/pull/39342" title="Back-deployment support for Swift concurrency" target="_blank" rel="noopener">对 Swift 向后部署支持并发</a>。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SE-0323</strong>：<a href="https://forums.swift.org/t/se-0323-asynchronous-main-semantics/52022" title="Asynchronous Main Semantics" target="_blank" rel="noopener">Asynchronous Main 语义</a> 正在审查中。</p><p>程序设置通常发生在 <code>main</code> 函数中，开发人员希望在程序的其他部分运行之前执行操作。<code>Objective-C</code>、<code>c++</code> 和 <code>C</code> 都有初始化，这些初始化在 <code>main</code> 入口点执行之前运行，并且可以与   Swift 的并发系统交互。在 Swift 并发模型中，开发人员编写的异步 <code>main</code> 函数被包装在一个任务中，并在 <code>main</code> 入口点运行时被放入到主队列中。如果初始化时在主队列中插入了一个任务，那么该任务可能会在 <code>main</code> 函数之前执行，所以设置是在初始化任务运行之后执行的。</p><p><strong>SE-0324</strong>：<a href="https://forums.swift.org/t/se-0324-relax-diagnostics-for-pointer-arguments-to-c-functions/52019" title="Relax diagnostics for pointer arguments to C functions" target="_blank" rel="noopener">对 C 函数的指针参数放宽诊断</a>正在审查中。</p><p><code>C</code> 有特殊的指针别名规则，例如允许 <code>char *</code> 为其他指针类型别名，并允许指向有符号和无符号类型的指针别名。 某些 <code>C</code> <code>API</code> 的可用性依赖于在这些规则的边界内轻松转换指针的能力。 Swift 通常不允许类型化指针转换。请参阅<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0107-unsaferawpointer.md" title="UnsafeRawPointer API" target="_blank" rel="noopener">SE-0107 UnsafeRawPointer API</a>。让 Swift 编译器在调用从 <code>C</code> 头文件导入的函数时允许在 <code>C</code> 规则内进行指针转换将显著提高互操作性，而不会对类型安全产生负面影响。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>Ashley Garland</strong> 介绍一些新实验出来的 <a href="https://forums.swift.org/t/swift-snippets/51947" title="Swift Snippets" target="_blank" rel="noopener">Swift Package Manager 代码段</a>。</p><p>我们都知道通过示例学习是很棒的，尤其是对于代码。 我想创建最小、最简单的方法来为 <code>Swift packages</code> 提供示例代码，我刚刚在 <a href="https://github.com/apple/swift-package-manager/commit/a0ffd92a2c80f2c4677d696e248f4cfbec9d6540" title="Swift Package Manager" target="_blank" rel="noopener">Swift Package Manager</a> 中完成了一些正在进行的工作。</p><p><strong>Filip Sakel</strong> 提出了一项<a href="https://forums.swift.org/t/pitch-refining-property-wrapper-related-initialization/52049" title="Refining Property wrapper  related Initialization" target="_blank" rel="noopener">改进 Property-wrapper-related 的初始化</a>的提案。</p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" title="SE 0258" target="_blank" rel="noopener">SE 0258</a> 引入了 <code>property wrappers</code>，<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0293-extend-property-wrappers-to-function-and-closure-parameters.md#detailed-design" title="SE 0293" target="_blank" rel="noopener">SE 0293</a> 使用类似函数的声明对其进行了扩展。 今天，<code>property wrappers</code> 初始化由于其日益增长的多功能性而表现出不一致。 具体来说，成员初始化使用复杂的、记录不足的规则，并且 <code>projection</code> 初始化仍然有限。该提案将简化具有包装属性的类型的合成成员初始化，并扩展 <code>projection</code> 值初始化以包括全局、类型和局部包装属性。</p><p><strong>Jordan Rose</strong> 开始讨论<a href="https://forums.swift.org/t/pre-pitch-remove-the-implicit-initialization-of-optional-variables/52300" title="remove the implicit initialization of Optional variables" target="_blank" rel="noopener">删除 Optional 变量的隐式初始化</a>。</p><p>在 Swift 6 中，可选变量与所有其他变量一样，默认情况下不会初始化。 局部变量和全局变量得到修复，添加 <code>= nil</code>。 属性仅在附加到有关未初始化变量的错误的注释中修复，这显然不是正确的做法，只有 Swift 5 中需要这么做。 不过，迁移者也可以自动应用该修复程序。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><h3 id="iOS-系列"><a href="#iOS-系列" class="headerlink" title="iOS 系列"></a>iOS 系列</h3><p><a href="https://mp.weixin.qq.com/s/vkbN_d3tR_Ym_gJYBVGCOw" target="_blank" rel="noopener">如何在 Swift 中实现状态机？</a></p><p>简言之：我们通常称作的状态机是有限状态机的简称，它是一种<strong>数学计算模型</strong>。</p><p><a href="https://mp.weixin.qq.com/s/DawFZMOuU5jbaw0Bi0gOhw" target="_blank" rel="noopener">避免 Swift 单元测试中的强制解析</a></p><p>强制解析（使用 <code>!</code>）是 Swift 语言中不可或缺的一个重要特点（特别是和 Objective-C 的接口混合使用时）。它回避了一些其他问题，使得 Swift 语言变得更加优秀。</p><p><a href="https://mp.weixin.qq.com/s/ZbZ4pFzzyfrQifmLewrxsw" target="_blank" rel="noopener">iOS 识别虚拟定位调研</a></p><p>最近业务开发中，有遇到我们的项目 app 定位被篡改的情况，在 android 端表现的尤为明显。为了防止这种黑产使用虚拟定位薅羊毛，iOS 也不得不进行虚拟定位的规避。</p><h3 id="实时文讯"><a href="#实时文讯" class="headerlink" title="实时文讯"></a>实时文讯</h3><p><a href="https://mp.weixin.qq.com/s/DwClglO_fOYDfLsINU_hdw" target="_blank" rel="noopener">Xcode 13 更新了哪些内容</a></p><p><a href="https://mp.weixin.qq.com/s/E5vTD9QDgKfVErWxCv4wjg" target="_blank" rel="noopener">开发者需要了解的 iOS 15</a></p><p><a href="https://mp.weixin.qq.com/s/4OGxPn-dgDc-jjtM-DtqGQ" target="_blank" rel="noopener">Xcode 13 正式版发布，来看看有什么新特性</a></p><h3 id="SwiftUI-系列"><a href="#SwiftUI-系列" class="headerlink" title="SwiftUI 系列"></a>SwiftUI 系列</h3><p><a href="https://mp.weixin.qq.com/s/K_i8bvcaHDfVMUsQTv3MOw" target="_blank" rel="noopener">为什么 SwiftUI 的修饰符顺序很重要</a></p><p>每当我们将修饰符应用于 <code>SwiftUI</code> 视图时，我们实际上都会创建一个，应用了更改的新视图 —— 我们不仅仅是修改现有的视图。</p><p><a href="https://mp.weixin.qq.com/s/gSeFOMrjze6KE_X6WwWAZQ" target="_blank" rel="noopener">为什么 SwiftUI 的视图使用结构体</a></p><p>如果您曾经为 <code>UIKit</code> 或 <code>AppKit</code>（Apple 的 iOS 和 macOS 原始用户界面框架）编程，您会知道它们使用类而非结构体来构造视图。<code>SwiftUI</code> 更喜欢将结构体用于整体视图。</p><p><a href="https://mp.weixin.qq.com/s/ZQSbu7dzwC-XbGcUcBkjAw" target="_blank" rel="noopener">如何结合 Core Data 和 SwiftUI</a></p><p><code>SwiftUI</code> 和 <code>Core Data</code> 之间相差将近十年。尽管时间相距遥远，Apple 还是投入了大量工作以确保这两种强大的技术能够完美地相互配合使用，这意味着 <code>Core Data</code> 就像始终以这种方式设计一样，已集成到 SwiftUI 中。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本期周报开始，将会引入&lt;strong&gt;推荐博文&lt;/strong&gt;模块，主要为大家分享展示优秀的 iOS 技术博文，如果大家阅读到优秀的文章欢迎在文末留言告诉小编，大家资源共享共同进步。&lt;/p&gt;
&lt;p&gt;iPhone 13 新品上架，你们都买了吗？苹果声称，iPhone 13 拥有全新的双摄像头系统，采用超快的 &lt;code&gt;A15&lt;/code&gt; 芯片，提高电池的续航能力。&lt;/p&gt;
&lt;p&gt;我们不仅要关注新的 iPhone 13，几天前，&lt;code&gt;Xcode 13&lt;/code&gt; 与 &lt;a href=&quot;https://forums.swift.org/t/swift-5-5-released/52247&quot; title=&quot;Swift 5.5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 5.5&lt;/a&gt; 也一起发布了。这是 Swift 5.5 更新的&lt;a href=&quot;https://twitter.com/simjp/status/1440318174856036354&quot; title=&quot;列表&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;列表&lt;/a&gt;，这个版本发布了很多新功能。Xcode 13 的发布说明可以在这里找到：&lt;a href=&quot;https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes&quot; title=&quot;iOS &amp;amp; iPadOS 15 Release Notes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS &amp;amp; iPadOS 15 Release Notes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在已经开始将&lt;strong&gt;并发&lt;/strong&gt;功能向后部署到旧的 Swift 版本上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二期/</id>
    <published>2021-10-22T07:16:35.000Z</published>
    <updated>2021-10-22T07:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.apple.com/apple-events/" title="California streaming" target="_blank" rel="noopener">California streaming</a>. 我们都知道这意味着什么：马上将迎来重要的一天 —— <code>Apple</code> 宣布了 <strong>9 月 14 日</strong>的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— <a href="https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/" title="一种隐藏的 AR 体验" target="_blank" rel="noopener">一种隐藏的 AR 体验</a>，看起来很酷。 这也让全球的粉丝们纷纷猜测 <code>Apple</code> 即将发布的产品。</p><p>过去两周 <code>Swift 社区</code>非常活跃。 许多提案正在 <code>Swift</code> 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 <code>Swift</code> 保持现代语言的地位，所以让我们继续努力吧！</p><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释  <a href="https://www.swiftbysundell.com/articles/conditional-compilation-within-swift-expressions/" title="Conditional compilation within Swift expressions" target="_blank" rel="noopener">Swift 表达式中的条件编译</a>。</p><p><a href="https://twitter.com/gabtheodor" title="Gabriel Theodoropoulos" target="_blank" rel="noopener">Gabriel Theodoropoulos</a> 写了一篇博文解释了如何<a href="https://serialcoder.dev/text-tutorials/swift-tutorials/using-variadic-parameters-in-swift/" title="Using Variadic Parameters in Swift" target="_blank" rel="noopener">在 Swift 中使用可变参数</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39051" title="Add an option to build the concurrency library for back deployment" target="_blank" rel="noopener">添加了一个选项来构建并发库以进行后端部署</a>。</p><p><a href="https://github.com/fwcd" title="FW" target="_blank" rel="noopener">FW</a> 合并了一个<a href="https://github.com/apple/sourcekit-lsp/pull/414" title="Implement semantic highlighting for Swift" target="_blank" rel="noopener">为 Swift 实现语义高亮</a> 的 <code>pull request</code>。</p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a> Package Registry Service - Publish Endpoint 已被<a href="https://forums.swift.org/t/accepted-se-0321-package-registry-service-publish-endpoint/51660" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">接受</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md" title="SE-0304" target="_blank" rel="noopener">SE-0304</a> Structured Concurrency <a href="https://forums.swift.org/t/se-0304-4th-review-structured-concurrency/50281" title="SE-0304 (4th review): Structured Concurrency" target="_blank" rel="noopener">第四次</a>审查被<a href="https://forums.swift.org/t/accepted-with-modifications-se-0304-structured-concurrency/51850" title="[Accepted with modifications] SE-0304: Structured Concurrency" target="_blank" rel="noopener">接受</a>。</p><h2 id="拒绝的提案"><a href="#拒绝的提案" class="headerlink" title="拒绝的提案"></a>拒绝的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a> 已返回进行<a href="https://forums.swift.org/t/returned-for-revision-se-0320-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51706" title="[Returned for revision] SE-0320: Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">修订</a>。</p><p>审查的反馈是积极的，社区成员建议作者和核心团队认为可以采用以下几项改进：</p><ol><li>在 <code>CodingKeyRepresentable</code> 中添加 <code>String</code> 和 <code>Int</code> 的一致性，这将允许在 <code>CodingKeyRepresentable</code> 用作通用约束时主动使用 <code>String</code> 和 <code>Int</code> 键。</li><li>使 <code>CodingKeyRepresentable</code> 协议的初始化通用。</li><li>为 <code>RawRepresentable</code> 的一致性提供默认实现（带有 <code>String</code> 和 <code>Int</code> 原始值）。</li><li>使内部 <code>_DictionaryCodingKey</code> 的初始值设定项 non-failable。</li></ol><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a>：允许将非 <code>String</code> / <code>Int</code> 键值 <code>Dictionary</code> 编码到 <code>KeyedContainer</code> 中 正在<a href="https://forums.swift.org/t/se-0320-2nd-review-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51710" title="SE-0320 (2nd review): Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">接受第二次审查</a>。</p><ul><li>第二次审查的重点是社区在第一次审查期间提出的改进建议，并通过 <a href="https://github.com/apple/swift-evolution/pull/1435" title="swift-evolution#1435" target="_blank" rel="noopener">swift-evolution#1435</a> 进行讨论。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0292-package-registry-service.md" title="SE-0292" target="_blank" rel="noopener">SE-0292</a>：Package Registry Service 修正<a href="https://github.com/apple/swift-evolution/pull/1410" title="修正 SE-0292 #1410" target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://forums.swift.org/t/amendment-se-0303-package-manager-extensible-build-tools/51763" title="SE-0303: Package Manager Extensible Build Tools" target="_blank" rel="noopener">SE-0303</a>：包管理器可扩展构建工具修正<a href="https://github.com/apple/swift-evolution/pull/1434" title="Amend SE-0303 to use @main for plugin entry point and adjust API accordingly #1434 " target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md" title="SE-0322" target="_blank" rel="noopener">SE-0322</a>：正在审查<a href="https://forums.swift.org/t/se-0322-temporary-uninitialized-buffers/51848" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>。</p><ul><li>该提案引入了新的标准库功能，用于操作临时缓冲区，这些缓冲区优先分配给堆栈，而不是堆。</li><li><code>Swift-evolution</code> 线程：[Pitch] <a href="https://forums.swift.org/t/pitch-temporary-uninitialized-buffers/48954" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a></li></ul><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://github.com/maustinstar" title="Michael Verges" target="_blank" rel="noopener">Michael Verges</a> 提出了<a href="https://forums.swift.org/t/pitching-optional-throws-in-swift/51650" title="Pitching Optional Throws in Swift" target="_blank" rel="noopener">在 Swift 中添加可选 <code>throws</code> 的提案</a>。</p><ul><li>在许多情况下，错误处理的权限不明确。开发者可能会质疑是处理还是传播错误。</li><li>选择抛出错误可以让调用者灵活地处理问题。</li><li>选择不抛出错误是为用户提供了简化语法（没有 <code>do-try-catch</code>）。</li></ul><p><a href="https://forums.swift.org/t/api-changes-for-0-2-0/51647" title="Karl" target="_blank" rel="noopener">Karl</a> 向社区通报了 <a href="https://karwa.github.io/swift-url/" title="WebURL" target="_blank" rel="noopener">WebURL</a> 0.2.0 版。</p><ul><li>我正准备发布 <code>WebURL 0.2.0</code> 版本 。 这将是一个非常重要的版本，包括用于与 <code>System.framework</code> 和 <code>swift-system</code> 包集成的 <code>WebURLSystemExtras</code> 模块，并使项目与 <code>URL</code> 标准的最新版本保持一致。</li></ul><p><a href="https://forums.swift.org/categories" title="Patrick Goley" target="_blank" rel="noopener">Patrick Goley</a> 提出了<a href="https://forums.swift.org/t/pitch-destructuring-assignment-of-structs-and-classes/51593" title="Destructuring Assignment of Structs and Classes" target="_blank" rel="noopener">添加结构和类的析构赋值</a>的建议。</p><ul><li>析构赋值是一项语言功能，允许你提取值的多个部分，并将其分配给单个赋值语句中的多个变量。</li></ul><p><a href="https://twitter.com/stephentyrone" title="Steve Canon" target="_blank" rel="noopener">Steve Canon</a> 宣布 <a href="https://forums.swift.org/t/1-0-0-release-notes/51641" title="Swift Numerics" target="_blank" rel="noopener">Swift Numerics</a> 的第一个稳定版本现已发布。</p><p>Austin 开始讨论 <a href="https://forums.swift.org/t/netlink-socket-support-in-swiftnio/51651" title="Netlink socket support in SwiftNIO" target="_blank" rel="noopener">SwiftNIO 中的 netlink 套接字支持</a>。</p><p><a href="https://forums.swift.org/categories" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 提出了一项实施 <a href="https://forums.swift.org/t/pitch-distributed-actors/51669" title="Distributed Actors" target="_blank" rel="noopener">Distributed Actors</a> 的提案。 </p><ul><li>随着最近 <code>Swift</code> 并发的引入，特别是该语言的参与者，<code>Swift</code> 在表达线程安全的并发程序方面获得了强大的基础构建。该提案旨在通过引入分布式参与者和与他们相关的位置透明度，扩大 <code>Swift</code>的参与者在分布式系统方面同样出色的工作能力。</li></ul><p><a href="https://twitter.com/maxdesiatov" title="Max Desiatov" target="_blank" rel="noopener">Max Desiatov</a> 告诉我们 <a href="https://forums.swift.org/t/swiftwasm-5-4-0-has-been-released/51753" title="SwiftWasm 5.4.0 has been released" target="_blank" rel="noopener">SwiftWasm 5.4.0</a> 已经发布。</p><ul><li>此版本与 <code>upstream</code> <code>Swift 5.4</code> 匹配，并允许您将 <code>Swift</code> 应用程序（只要它们不使用特定于其他平台的代码）编译到 <code>WebAssembly</code>，甚至可以在浏览器中运行。</li></ul><p><a href="https://forums.swift.org/categories" title="elsh" target="_blank" rel="noopener">elsh</a> 提出了添加<a href="https://forums.swift.org/t/pitch-module-aliasing/51737" title="Module Aliasing" target="_blank" rel="noopener">模块别名</a>支持的建议。</p><p>随着 <code>Swift</code> 库和软件包分布更加广泛，模块名称有时会发生冲突。由于 <code>Swift</code> 中还没有模块命名空间，在这种情况下，库经常被迫重命名或固定在旧的非冲突版本上。这使得以下用例具有挑战性：</p><ul><li><p>添加新的依赖项或升级，因为它可能会引入冲突：一个新的（或升级的）模块可以与依赖关系图中已经存在的另一个模块具有相同的名称。模块名称 <code>Logging</code> 是一个常见示例。</p></li><li><p>从上游库固定的旧版本升级到软件包的更新版本：考虑这样一个场景，其中 <code>MyApp</code> 依赖于模块 <code>Lib</code>，而 <code>Lib</code> 依赖于模块 <code>Logging</code>。 <code>MyApp</code> 还依赖于 <code>Logging</code>。 如果 <code>Lib</code> 固定到 <code>Logging 1.0.0</code>，则 <code>MyApp</code> 会停留在同一版本 <code>1.0.0</code>。</p></li></ul><p>2021年9月3日，服务器工作组的 <code>Swift</code> 宣布了一项<a href="https://forums.swift.org/t/september-3rd-2021-special-update/51766" title="September 3rd, 2021 Special Update" target="_blank" rel="noopener">特别更新</a>。</p><p><a href="https://forums.swift.org/t/pitch-introduce-expanded-parameters/51885" title="Introduce Expanded Parameters" target="_blank" rel="noopener">Isabel Lima</a> 向我们更新了有关<a href="https://forums.swift.org/t/add-shared-storage-to-property-wrappers/49898" title="Add shared storage to property wrappers " target="_blank" rel="noopener">添加 Property Wrappers 共享存储</a>的状态。</p><ul><li><code>Swift</code> 是一种允许我们编写富有表现力的 <code>API</code> 接口语言。通过<strong>约束泛型</strong>、<strong>方法重载</strong>、<strong>尾随闭包</strong>和<strong>默认参数</strong>等功能，您可以在实现相当灵活的 <code>API</code>的同时减少代码重复。本提案旨在使用 <code>@expanded</code>（函数参数的新属性）增加语言的这一部分。</li></ul><p><a href="https://github.com/johnno1962" title="John Holdsworth" target="_blank" rel="noopener">John Holdsworth</a> 提议引入 <a href="https://forums.swift.org/t/introducing-an-unwrap-or-throw-operator/51905" title="Introducing an “Unwrap or Throw” operator" target="_blank" rel="noopener"> Unwrap 或 Throw 运算符</a>。</p><ul><li><p>该提议是之前 <a href="https://forums.swift.org/t/pitch-introducing-the-unwrap-or-die-operator-to-the-standard-library/6207" title="[Pitch] Introducing the “Unwrap or Die” operator to the standard library" target="_blank" rel="noopener">[Pitch] Introducing the “Unwrap or Die” operator to the standard library</a> 以及最近 <a href="https://forums.swift.org/t/moving-toward-deprecating-force-unwrap-from-swift/43455" title="Moving toward deprecating force unwrap from Swift?" target="_blank" rel="noopener">Moving toward deprecating force unwrap from Swift?</a> 两个有争议提议的延伸。 后一个提议除了被锁定之外没有得出结论，这个提议在前一个提议上取而代之，建议使用 “<code>Unwrap or Throw</code>” 运算符可能是解决 <code>Swift</code> 中强制解包问题的更好解决方案，这让我很疑惑，我相信当用户的应用程序崩溃时，会影响到用户使用。</p></li><li><h1 id="总之，我想提出一个-运算符，强制打开和-nil-并之间的交叉，如果可选是-nil，则抛出。"><a href="#总之，我想提出一个-运算符，强制打开和-nil-并之间的交叉，如果可选是-nil，则抛出。" class="headerlink" title="总之，我想提出一个 !! 运算符，强制打开和 nil 并之间的交叉，如果可选是 nil，则抛出。"></a>总之，我想提出一个 <code>!!</code> 运算符，强制打开和 <code>nil</code> 并之间的交叉，如果可选是 <code>nil</code>，则抛出。</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2></li></ul><p><a href="https://www.apple.com/apple-events/" title="California streaming" target="_blank" rel="noopener">California streaming</a>. 我们都知道这意味着什么：马上将迎来重要的一天 —— <code>Apple</code> 宣布了 <strong>9 月 14 日</strong>的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— <a href="https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/" title="一种隐藏的 AR 体验" target="_blank" rel="noopener">一种隐藏的 AR 体验</a>，看起来很酷。 这也让全球的粉丝们纷纷猜测 <code>Apple</code> 即将发布的产品。</p><p>过去两周 <code>Swift 社区</code>非常活跃。 许多提案正在 <code>Swift</code> 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 <code>Swift</code> 保持现代语言的地位，所以让我们继续努力吧！</p><h2 id="新闻和社区-1"><a href="#新闻和社区-1" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释  <a href="https://www.swiftbysundell.com/articles/conditional-compilation-within-swift-expressions/" title="Conditional compilation within Swift expressions" target="_blank" rel="noopener">Swift 表达式中的条件编译</a>。</p><p><a href="https://twitter.com/gabtheodor" title="Gabriel Theodoropoulos" target="_blank" rel="noopener">Gabriel Theodoropoulos</a> 写了一篇博文解释了如何<a href="https://serialcoder.dev/text-tutorials/swift-tutorials/using-variadic-parameters-in-swift/" title="Using Variadic Parameters in Swift" target="_blank" rel="noopener">在 Swift 中使用可变参数</a>。</p><h2 id="Commits-和-pull-requests-1"><a href="#Commits-和-pull-requests-1" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39051" title="Add an option to build the concurrency library for back deployment" target="_blank" rel="noopener">添加了一个选项来构建并发库以进行后端部署</a>。</p><p><a href="https://github.com/fwcd" title="FW" target="_blank" rel="noopener">FW</a> 合并了一个<a href="https://github.com/apple/sourcekit-lsp/pull/414" title="Implement semantic highlighting for Swift" target="_blank" rel="noopener">为 Swift 实现语义高亮</a> 的 <code>pull request</code>。</p><h2 id="同意的提案-1"><a href="#同意的提案-1" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a> Package Registry Service - Publish Endpoint 已被<a href="https://forums.swift.org/t/accepted-se-0321-package-registry-service-publish-endpoint/51660" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">接受</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md" title="SE-0304" target="_blank" rel="noopener">SE-0304</a> Structured Concurrency <a href="https://forums.swift.org/t/se-0304-4th-review-structured-concurrency/50281" title="SE-0304 (4th review): Structured Concurrency" target="_blank" rel="noopener">第四次</a>审查被<a href="https://forums.swift.org/t/accepted-with-modifications-se-0304-structured-concurrency/51850" title="[Accepted with modifications] SE-0304: Structured Concurrency" target="_blank" rel="noopener">接受</a>。</p><h2 id="拒绝的提案-1"><a href="#拒绝的提案-1" class="headerlink" title="拒绝的提案"></a>拒绝的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a> 已返回进行<a href="https://forums.swift.org/t/returned-for-revision-se-0320-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51706" title="[Returned for revision] SE-0320: Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">修订</a>。</p><p>审查的反馈是积极的，社区成员建议作者和核心团队认为可以采用以下几项改进：</p><ol><li>在 <code>CodingKeyRepresentable</code> 中添加 <code>String</code> 和 <code>Int</code> 的一致性，这将允许在 <code>CodingKeyRepresentable</code> 用作通用约束时主动使用 <code>String</code> 和 <code>Int</code> 键。</li><li>使 <code>CodingKeyRepresentable</code> 协议的初始化通用。</li><li>为 <code>RawRepresentable</code> 的一致性提供默认实现（带有 <code>String</code> 和 <code>Int</code> 原始值）。</li><li>使内部 <code>_DictionaryCodingKey</code> 的初始值设定项 non-failable。</li></ol><h2 id="正在审查的提案-1"><a href="#正在审查的提案-1" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a>：允许将非 <code>String</code> / <code>Int</code> 键值 <code>Dictionary</code> 编码到 <code>KeyedContainer</code> 中 正在<a href="https://forums.swift.org/t/se-0320-2nd-review-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51710" title="SE-0320 (2nd review): Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">接受第二次审查</a>。</p><ul><li>第二次审查的重点是社区在第一次审查期间提出的改进建议，并通过 <a href="https://github.com/apple/swift-evolution/pull/1435" title="swift-evolution#1435" target="_blank" rel="noopener">swift-evolution#1435</a> 进行讨论。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0292-package-registry-service.md" title="SE-0292" target="_blank" rel="noopener">SE-0292</a>：Package Registry Service 修正<a href="https://github.com/apple/swift-evolution/pull/1410" title="修正 SE-0292 #1410" target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://forums.swift.org/t/amendment-se-0303-package-manager-extensible-build-tools/51763" title="SE-0303: Package Manager Extensible Build Tools" target="_blank" rel="noopener">SE-0303</a>：包管理器可扩展构建工具修正<a href="https://github.com/apple/swift-evolution/pull/1434" title="Amend SE-0303 to use @main for plugin entry point and adjust API accordingly #1434 " target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md" title="SE-0322" target="_blank" rel="noopener">SE-0322</a>：正在审查<a href="https://forums.swift.org/t/se-0322-temporary-uninitialized-buffers/51848" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>。</p><ul><li>该提案引入了新的标准库功能，用于操作临时缓冲区，这些缓冲区优先分配给堆栈，而不是堆。</li><li><code>Swift-evolution</code> 线程：[Pitch] <a href="https://forums.swift.org/t/pitch-temporary-uninitialized-buffers/48954" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a></li></ul><h2 id="Swift-论坛-1"><a href="#Swift-论坛-1" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://github.com/maustinstar" title="Michael Verges" target="_blank" rel="noopener">Michael Verges</a> 提出了<a href="https://forums.swift.org/t/pitching-optional-throws-in-swift/51650" title="Pitching Optional Throws in Swift" target="_blank" rel="noopener">在 Swift 中添加可选 <code>throws</code> 的提案</a>。</p><ul><li>在许多情况下，错误处理的权限不明确。开发者可能会质疑是处理还是传播错误。</li><li>选择抛出错误可以让调用者灵活地处理问题。</li><li>选择不抛出错误是为用户提供了简化语法（没有 <code>do-try-catch</code>）。</li></ul><p><a href="https://forums.swift.org/t/api-changes-for-0-2-0/51647" title="Karl" target="_blank" rel="noopener">Karl</a> 向社区通报了 <a href="https://karwa.github.io/swift-url/" title="WebURL" target="_blank" rel="noopener">WebURL</a> 0.2.0 版。</p><ul><li>我正准备发布 <code>WebURL 0.2.0</code> 版本 。 这将是一个非常重要的版本，包括用于与 <code>System.framework</code> 和 <code>swift-system</code> 包集成的 <code>WebURLSystemExtras</code> 模块，并使项目与 <code>URL</code> 标准的最新版本保持一致。</li></ul><p><a href="https://forums.swift.org/categories" title="Patrick Goley" target="_blank" rel="noopener">Patrick Goley</a> 提出了<a href="https://forums.swift.org/t/pitch-destructuring-assignment-of-structs-and-classes/51593" title="Destructuring Assignment of Structs and Classes" target="_blank" rel="noopener">添加结构和类的析构赋值</a>的建议。</p><ul><li>析构赋值是一项语言功能，允许你提取值的多个部分，并将其分配给单个赋值语句中的多个变量。</li></ul><p><a href="https://twitter.com/stephentyrone" title="Steve Canon" target="_blank" rel="noopener">Steve Canon</a> 宣布 <a href="https://forums.swift.org/t/1-0-0-release-notes/51641" title="Swift Numerics" target="_blank" rel="noopener">Swift Numerics</a> 的第一个稳定版本现已发布。</p><p>Austin 开始讨论 <a href="https://forums.swift.org/t/netlink-socket-support-in-swiftnio/51651" title="Netlink socket support in SwiftNIO" target="_blank" rel="noopener">SwiftNIO 中的 netlink 套接字支持</a>。</p><p><a href="https://forums.swift.org/categories" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 提出了一项实施 <a href="https://forums.swift.org/t/pitch-distributed-actors/51669" title="Distributed Actors" target="_blank" rel="noopener">Distributed Actors</a> 的提案。 </p><ul><li>随着最近 <code>Swift</code> 并发的引入，特别是该语言的参与者，<code>Swift</code> 在表达线程安全的并发程序方面获得了强大的基础构建。该提案旨在通过引入分布式参与者和与他们相关的位置透明度，扩大 <code>Swift</code>的参与者在分布式系统方面同样出色的工作能力。</li></ul><p><a href="https://twitter.com/maxdesiatov" title="Max Desiatov" target="_blank" rel="noopener">Max Desiatov</a> 告诉我们 <a href="https://forums.swift.org/t/swiftwasm-5-4-0-has-been-released/51753" title="SwiftWasm 5.4.0 has been released" target="_blank" rel="noopener">SwiftWasm 5.4.0</a> 已经发布。</p><ul><li>此版本与 <code>upstream</code> <code>Swift 5.4</code> 匹配，并允许您将 <code>Swift</code> 应用程序（只要它们不使用特定于其他平台的代码）编译到 <code>WebAssembly</code>，甚至可以在浏览器中运行。</li></ul><p><a href="https://forums.swift.org/categories" title="elsh" target="_blank" rel="noopener">elsh</a> 提出了添加<a href="https://forums.swift.org/t/pitch-module-aliasing/51737" title="Module Aliasing" target="_blank" rel="noopener">模块别名</a>支持的建议。</p><p>随着 <code>Swift</code> 库和软件包分布更加广泛，模块名称有时会发生冲突。由于 <code>Swift</code> 中还没有模块命名空间，在这种情况下，库经常被迫重命名或固定在旧的非冲突版本上。这使得以下用例具有挑战性：</p><ul><li><p>添加新的依赖项或升级，因为它可能会引入冲突：一个新的（或升级的）模块可以与依赖关系图中已经存在的另一个模块具有相同的名称。模块名称 <code>Logging</code> 是一个常见示例。</p></li><li><p>从上游库固定的旧版本升级到软件包的更新版本：考虑这样一个场景，其中 <code>MyApp</code> 依赖于模块 <code>Lib</code>，而 <code>Lib</code> 依赖于模块 <code>Logging</code>。 <code>MyApp</code> 还依赖于 <code>Logging</code>。 如果 <code>Lib</code> 固定到 <code>Logging 1.0.0</code>，则 <code>MyApp</code> 会停留在同一版本 <code>1.0.0</code>。</p></li></ul><p>2021年9月3日，服务器工作组的 <code>Swift</code> 宣布了一项<a href="https://forums.swift.org/t/september-3rd-2021-special-update/51766" title="September 3rd, 2021 Special Update" target="_blank" rel="noopener">特别更新</a>。</p><p><a href="https://forums.swift.org/t/pitch-introduce-expanded-parameters/51885" title="Introduce Expanded Parameters" target="_blank" rel="noopener">Isabel Lima</a> 向我们更新了有关<a href="https://forums.swift.org/t/add-shared-storage-to-property-wrappers/49898" title="Add shared storage to property wrappers " target="_blank" rel="noopener">添加 Property Wrappers 共享存储</a>的状态。</p><ul><li><code>Swift</code> 是一种允许我们编写富有表现力的 <code>API</code> 接口语言。通过<strong>约束泛型</strong>、<strong>方法重载</strong>、<strong>尾随闭包</strong>和<strong>默认参数</strong>等功能，您可以在实现相当灵活的 <code>API</code>的同时减少代码重复。本提案旨在使用 <code>@expanded</code>（函数参数的新属性）增加语言的这一部分。</li></ul><p><a href="https://github.com/johnno1962" title="John Holdsworth" target="_blank" rel="noopener">John Holdsworth</a> 提议引入 <a href="https://forums.swift.org/t/introducing-an-unwrap-or-throw-operator/51905" title="Introducing an “Unwrap or Throw” operator" target="_blank" rel="noopener"> Unwrap 或 Throw 运算符</a>。</p><ul><li><p>该提议是之前 <a href="https://forums.swift.org/t/pitch-introducing-the-unwrap-or-die-operator-to-the-standard-library/6207" title="[Pitch] Introducing the “Unwrap or Die” operator to the standard library" target="_blank" rel="noopener">[Pitch] Introducing the “Unwrap or Die” operator to the standard library</a> 以及最近 <a href="https://forums.swift.org/t/moving-toward-deprecating-force-unwrap-from-swift/43455" title="Moving toward deprecating force unwrap from Swift?" target="_blank" rel="noopener">Moving toward deprecating force unwrap from Swift?</a> 两个有争议提议的延伸。 后一个提议除了被锁定之外没有得出结论，这个提议在前一个提议上取而代之，建议使用 “<code>Unwrap or Throw</code>” 运算符可能是解决 <code>Swift</code> 中强制解包问题的更好解决方案，这让我很疑惑，我相信当用户的应用程序崩溃时，会影响到用户使用。</p></li><li><p>总之，我想提出一个 <code>!!</code> 运算符，强制打开和 <code>nil</code> 并之间的交叉，如果可选是 <code>nil</code>，则抛出。</p></li></ul><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.apple.com/apple-events/&quot; title=&quot;California streaming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;California streaming&lt;/a&gt;. 我们都知道这意味着什么：马上将迎来重要的一天 —— &lt;code&gt;Apple&lt;/code&gt; 宣布了 &lt;strong&gt;9 月 14 日&lt;/strong&gt;的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— &lt;a href=&quot;https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/&quot; title=&quot;一种隐藏的 AR 体验&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一种隐藏的 AR 体验&lt;/a&gt;，看起来很酷。 这也让全球的粉丝们纷纷猜测 &lt;code&gt;Apple&lt;/code&gt; 即将发布的产品。&lt;/p&gt;
&lt;p&gt;过去两周 &lt;code&gt;Swift 社区&lt;/code&gt;非常活跃。 许多提案正在 &lt;code&gt;Swift&lt;/code&gt; 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 &lt;code&gt;Swift&lt;/code&gt; 保持现代语言的地位，所以让我们继续努力吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第一期/</id>
    <published>2021-10-22T07:14:13.000Z</published>
    <updated>2021-10-22T07:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从本周开始，我们 Swift 社区公众号将开始与 SwiftWeekly 合作更新关于 Swift 社区最新的进展与动向。让我们乘着社区的风帆，一起荡起双桨，让 Swift 成为世界上最好的语言。</p><a id="more"></a><h2 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h2><p>在 Swift by Sundell 播客的<a href="https://www.swiftbysundell.com/podcast/103/" title="Swift by Sundell 第 103 期" target="_blank" rel="noopener">第 103 期</a>中，SwiftLee 的创建者 <a href="https://twitter.com/twannl" title="Antoine van der Lee" target="_blank" rel="noopener">Antoine van der Lee</a> 加入了 <a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a>。</p><p>他们从新的 concurrency 系统到 convenience 特性以及各种改进等方向讨论了 Swift 5.5 新引入的一部分功能。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p>Xcode 各版本的 <a href="https://developer.apple.com/cn/support/xcode/" title="最低要求和支持的 SDK" target="_blank" rel="noopener">最低要求和支持的 SDK</a></p><p><a href="https://twitter.com/twannl" title="Antoine van der Lee" target="_blank" rel="noopener">Antoine van der Lee</a> 写了一篇博文，<a href="https://www.avanderlee.com/swift/unwrap-or-throw/" title="Unwrap or throw: Exploring solutions in Swift" target="_blank" rel="noopener">探讨在 Swift 中解包或 throw 的解决方案</a>。</p><p><a href="https://twitter.com/Leo_Pugliese" title="Leonardo Maia Pugliese" target="_blank" rel="noopener">Leonardo Maia Pugliese</a> 写了一篇关于<a href="https://holyswift.app/how-to-do-apis-constraints-with-available-in-swift" title="How to do APIs constraints with @Available in Swift" target="_blank" rel="noopener">如何在 Swift 中使用 @available 进行 API 约束</a>的博客文章。</p><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释了如何<a href="https://www.swiftbysundell.com/articles/using-an-unknown-default-case-within-a-switch-statement/" title="Using ‘@unknown default’ within switch statements" target="_blank" rel="noopener">在 switch 语句中使用 @unknown default</a>。</p><p><a href="https://twitter.com/basthomas" title="Bas Broek" target="_blank" rel="noopener">Bas Broek</a> 写了一篇博文，探讨如何在 Swift 中<a href="https://www.basbroek.nl/deprecating-workarounds" title="Deprecating Workarounds" target="_blank" rel="noopener">弃用 Workarounds</a>。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a>: Package Registry Service - Publish Endpoint 正在<a href="https://forums.swift.org/t/se-0321-package-registry-service-publish-endpoint/51286" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">审查中</a></p><p>软件包注册表负责确定哪些软件包版本可提供给消费者使用。</p><p>目前，软件包版本的可用性由 <code>out-of-band</code> 流程决定。例如，注册表可以查询公共 Swift 软件包的索引，并为每个标签提供具有有效版本号的版本。</p><p>拥有发布新版本到软件包注册表的标准端点将增强维护者分发其软件的能力，并促进服务提供商之间的互操作性。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://forums.swift.org/categories" title="Dimitri Racordon" target="_blank" rel="noopener">Dimitri Racordon</a> 提出了一个<a href="https://forums.swift.org/t/pitch-protocols-with-private-fields/51209" title="Protocols with private fields" target="_blank" rel="noopener">用私有字段实现协议的想法</a>。</p><p>在协议中，所有字段（<code>properties</code> 和 <code>methods</code>）都将获得符合条件类型的访问可见性。例如，符合具有公共类型的协议将提示其所有要求都是公共的。</p><p><a href="https://forums.swift.org/categories" title="Evan Wilde" target="_blank" rel="noopener">Evan Wilde</a> 提出了一项<a href="https://forums.swift.org/t/pitch-revisit-the-semantics-of-async-main/51254" title="Revisit the semantics of async main" target="_blank" rel="noopener">重新审视 async main 语义</a>的提案。</p><ul><li>main 函数应该同步运行到第一个暂停点</li><li>main 函数应该在 <code>main actor</code> 上运行</li><li>MainActor 应该为默认的 <code>runloop</code> 行为提供用户指定的替代方案。</li><li>main 任务应该从 <code>getCurrentThreadPriority</code> 拉取优先级，而不是 <code>hard-coded</code> 默认优先级</li></ul><p><a href="https://forums.swift.org/u/abertelrud" title="Anders Bertelrud" target="_blank" rel="noopener">Anders Bertelrud</a> 提议修改 SE-0303：插件 API，使用 @main 作为插件入口点。</p><p>我想提议修改 <code>SE-0303</code>，<code>SwiftPM</code> 插件使用 <code>@main</code> 作为入口点，而不是 <code>top-level</code> 作为入口点。 虽然这样做有点冗长，但是可以为每种插件定制入口点，并且还可以更加清楚地说明每个插件的输入和预期输出是什么。</p><p><a href="https://forums.swift.org/u/saklad5" title="Jeremy Saklad" target="_blank" rel="noopener">Jeremy Saklad</a> 提出了一项提案，该提案将<a href="https://forums.swift.org/t/allow-use-of-concrete-associated-type-of-protocols/51277" title="Allow use of concrete associated type of protocols" target="_blank" rel="noopener">允许使用具体的相关协议类型</a>。</p><p><a href="https://twitter.com/lorentey" title="Karoy Lorentey" target="_blank" rel="noopener">Karoy Lorentey</a> 发布了 <a href="https://forums.swift.org/t/announcement-planning-for-swift-collections-v1-0/51321" title="Planning for Swift Collections v1.0" target="_blank" rel="noopener">Swift Collections 1.0 版</a>。</p><p><a href="https://forums.swift.org/u/ktoso" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 发布了 Swift Server Workgroup <a href="https://forums.swift.org/t/august-4th-2021/51315" title="August 4th 2021" target="_blank" rel="noopener">2021 年 8 月 4 日的会议记录</a>。</p><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 提出了 <a href="https://forums.swift.org/t/pitch-staging-in-sendable-checking/51341" title="Staging in Sendable checking" target="_blank" rel="noopener">在 Sendable 检查中实施 Staging</a> 的提案。</p><p><code>SE-0302</code> 引入了 Sendable 协议，该协议明确地指出哪些类型的值可以安全地跨过 <code>actors</code> 进行复制。通俗的讲，就是拷贝的值和原始值可以同时在上下文使用。</p><p>Sendable 检查在所有 Swift 代码中应用，消除了由 <code>shared mutable state</code> 引起的大量数据竞争。Swift 5.5 没有完全实现 Sendable 检查，因为这样做会导致太多的编译器 <code>errors</code> 和 <code>diagnostics</code>，从而导致该功能不可用。</p><p>我认为可以逐步采用 Sendable 检查来提高数据竞争的安全性。我们提出了两个想法分段完成 Sendable 检查:</p><ul><li>增量采用并发并且引入更多的 Sendable 检查。</li><li>不能让用户模块之外的 Sendable 问题阻挡进度，防止过度的注释</li></ul><p><a href="https://forums.swift.org/categories" title="Aura Lily Vulcano" target="_blank" rel="noopener">Aura Lily Vulcano</a> 推荐了一个 <a href="https://forums.swift.org/t/pitch-the-cstdlib-module/51373" title="The CStdlib module" target="_blank" rel="noopener">Swift 默认提供的新模块</a>。</p><p>该模块将重新导出包含当前平台的 <code>POSIX</code> 或类似 <code>POSIX</code> 的 C 标准库的正确模块（如果有的话）。</p><p>默认情况该模块不会被导入，但是允许 “reasonably cross-platform” 代码，以避免使用冗长的 <code>#if canImport(…)</code> 链来访问所有的标准库，因为它们在不同的操作系统上有不同的名称。</p><p>例如，模块可以命名为 CStdlib。</p><p>Robert Widmann（<a href="https://twitter.com/CodaFi_" title="CodaFi_" target="_blank" rel="noopener">@CodaFi_</a>）提出了一个关于<a href="https://forums.swift.org/t/pitching-the-start-of-variadic-generics/51467" title="The Start of Variadic Generics" target="_blank" rel="noopener">开始可变参数泛型</a>的想法。</p><p>作为改进泛型系统的人体工程学的一部分，以及为使用 tuples 抽象提供更好的支持，我想用 surface syntax 和 preliminary semantics 来实现这个想法。 由于这是一个很大的主题领域，对语言和后续提案的方向都有很大影响，因此你的反馈在此阶段对于塑造此功能集的方向至关重要。</p><p>我要感谢 <strong>Alejandro Alonso</strong>, <strong>Doug Gregor</strong> 和 <strong>Slava Pestov</strong>，感谢他们为我在这个问题上的思考奠定了基础。</p><p>可以在这里看到原文的链接 <a href="https://gist.github.com/CodaFi/a461aca155b16cd4d05a2635e7d7a361" title="TypeSequences.md · GitHub" target="_blank" rel="noopener">TypeSequences.md · GitHub</a></p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从本周开始，我们 Swift 社区公众号将开始与 SwiftWeekly 合作更新关于 Swift 社区最新的进展与动向。让我们乘着社区的风帆，一起荡起双桨，让 Swift 成为世界上最好的语言。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>如何将 Swift 代码添加为自定义 LLDB 命令</title>
    <link href="https://fanbaoying.github.io/%E5%A6%82%E4%BD%95%E5%B0%86-Swift-%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89-LLDB-%E5%91%BD%E4%BB%A4/"/>
    <id>https://fanbaoying.github.io/如何将-Swift-代码添加为自定义-LLDB-命令/</id>
    <published>2021-06-07T12:59:57.000Z</published>
    <updated>2021-06-07T13:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://swiftsenpai.com/testing/add-custom-lldb/" title="Adding Swift Code as Custom LLDB Command" target="_blank" rel="noopener">Adding Swift Code as Custom LLDB Command</a></p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 <code>po</code>。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？</p><p>在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：</p><ul><li>添加你的第一个 LLDB 命令</li><li>添加带参数的 LLDB 命令</li><li>将复杂的 Swift 代码转换为 LLDB 命令</li></ul><a id="more"></a><h2 id="2-添加您的第一个-LLDB-命令"><a href="#2-添加您的第一个-LLDB-命令" class="headerlink" title="2. 添加您的第一个 LLDB 命令"></a>2. 添加您的第一个 LLDB 命令</h2><h3 id="2-1-了解-LLDB-命令结构"><a href="#2-1-了解-LLDB-命令结构" class="headerlink" title="2.1 了解 LLDB 命令结构"></a>2.1 了解 LLDB 命令结构</h3><p>为了添加自定义 LLDB 命令，我们必须利用 <code>command alias</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias [command_name] expr -l Swift -O -- [swift_code]</span><br></pre></td></tr></table></figure><p><strong>对命令进行详细分解：</strong></p><ul><li><code>command alias</code>：使用名称为 Swift 代码添加别名的 LLDB 命令</li><li><code>[command_name]</code>: 自定义命令名称</li><li><code>expr -l Swift -O --</code>: 要求 LLDB 调试器将后面的所有内容解释为 Swift 代码</li><li><code>[swift_code]</code>：定义自定义命令逻辑的 Swift 代码</li></ul><p>举例说明，如果我们要添加一个别名为 <code>greet</code> 的自定义命令，在控制台上打印结果为 “Hello World！” ，LLDB 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias greet expr -l Swift -O -- print(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-2-添加自定义命令"><a href="#2-2-添加自定义命令" class="headerlink" title="2.2 添加自定义命令"></a>2.2 添加自定义命令</h3><p>现在已经构造了别名为 <code>greet</code> 的命令，然后添加到 LLDB 调试器中。</p><p>将 <code>greet</code> 命令添加到 LLDB 调试器的最直接方法是在 Xcode 控制台中执行别名命令。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a9a2981a3d603298.gif?imageMogr2/auto-orient/strip" alt=""></p><p>但是，这样做只会使 <code>greet</code> 命令在当前特定调试会话中可用。 也就是说，每当开始新的调试会话时，我们就需要重新键入相同的别名命令。</p><p>为了避免这种情况发生，我们可以利用位于主目录中的 <code>.lldbinit</code> 文件。 <strong>请注意</strong>，这是一个隐藏文件，如果看不到该文件，可以使用以下快捷方式在你的查找器中显示隐藏文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift + command + .</span><br></pre></td></tr></table></figure><p>如果在 finder 中启用了显示隐藏文件，仍然没有找到该文件，可以在根目录下使用下面的终端命令创建一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.lldbinit</span><br></pre></td></tr></table></figure><p>之后，打开 <code>.lldbinit</code> 文件将整个别名命令粘贴到文件中。这样，Xcode 将在每次启动新的调试会话时执行别名命令。</p><blockquote><p><strong>Pro Tip:</strong> 如果不想在每次更新 <code>.lldbinit</code> 文件时都重新启动调试会话，可以使用以下命令重新加载它：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command source ~/.lldbinit</span><br></pre></td></tr></table></figure><h2 id="3-添加带参数的-LLDB-命令"><a href="#3-添加带参数的-LLDB-命令" class="headerlink" title="3. 添加带参数的 LLDB 命令"></a>3. 添加带参数的 LLDB 命令</h2><p>接着，让我们尝试添加一个能够接受参数的命令。 在上面 greet 命令的基础上进行修改，使其能够接受一个字符串并且打印出问候消息。</p><p>这一次，我们将使用 <code>command regex</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex [command_name] &apos;s/[regex]/expr -l Swift -O -- [swift_code]/&apos;</span><br></pre></td></tr></table></figure><p>这里对 regex 命令的工作原理不做详细描述。 通常，是将 [regex] 替换为正则表达式语句 (.+)，然后在 Swift 代码中使用 %1 表示参数。</p><p>更新 <code>greet</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+)/expr -l Swift -O -- print(&quot;Hello \(%1)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name = &quot;Swift Senpai&quot;</code> 执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name</span><br><span class="line">Hello Swift Senpai!</span><br></pre></td></tr></table></figure><p>到这里，你可能会问：如果我需要传入多个参数怎么办？ 答案其实很简单。</p><p>首先，将多个 <code>(.+)</code> 添加到正则表达式语句并用空格分隔每个 <code>(.+)</code>。 之后，使用 <code>%2</code>, <code>%3</code>, <code>%4</code>… 来表示 Swift 代码中的每个参数。</p><p>将 <code>greet</code> 命令更新为支持两个参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+) (.+)/expr -l Swift -O -- print(&quot;Hello (%1) and (%2)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name1 = &quot;Swift Senpai&quot;</code> 和 <code>name2 = &quot;iOS developers&quot;</code>，使用该命令，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name1 name2</span><br><span class="line">Hello Swift Senpai and iOS developers!</span><br></pre></td></tr></table></figure><p>到这里，我们已经了解了如何添加带有多个参数的自定义 LLDB 命令。 下面，将向你展示如何将多行 Swift 函数转换为自定义 LLDB 命令。</p><h2 id="将复杂的-Swift-代码转换为-LLDB-命令"><a href="#将复杂的-Swift-代码转换为-LLDB-命令" class="headerlink" title="将复杂的 Swift 代码转换为 LLDB 命令"></a>将复杂的 Swift 代码转换为 LLDB 命令</h2><p>通过前面的介绍，我们知道添加自定义 Swift 代码作为 LLDB 命令，必须在一行中完成。因此，如果有一个多行的 Swift 函数，我们必须先将其转换为单行，然后才能将其添加到 <code>.lldbinit</code> 文件中。</p><p>比如要添加下面这个将 RGB 值转换为十六进制值的 Swift 函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hex</span><span class="params">(r: Int, g: Int, b: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(hex)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面的代码注释使用的是 <code>/* */</code> 而不是 <code>//</code>,这是为了确保将 Swift 代码转换为单行后不会中断。</p><p>下面我们需要将 Swift 代码转换为一行，操作流程如下：</p><ol><li>为每个函数参数定义一个变量。</li><li>将 <code>%1</code>、<code>%2</code>、<code>%3</code>… 分配给每个定义的变量。</li><li>在每个语句的末尾添加 <code>;</code>。</li></ol><p>更新后的 Swift 代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = %<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> g = %<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> b = %<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line"><span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(hex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们需要将 Swift 代码转换为一行，我比较喜欢使用这个<a href="https://www.textfixer.com/tools/paragraph-to-lines.php" title="代码单行转换工具" target="_blank" rel="noopener">免费在线工具</a>进行单行转换</p><p>将代码转换为单行后，就可以进行构造正则表达式命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex hex &apos;s/(.+) (.+) (.+)/expr -l Swift -O -- let r = %1; let g = %2; let b = %3; if (r &gt;= 0 &amp;&amp; r &lt;= 255) &amp;&amp; (g &gt;= 0 &amp;&amp; g &lt;= 255) &amp;&amp; (b &gt;= 0 &amp;&amp; b &lt;= 255) &#123; let rgb:Int = r&lt;&lt;16 | g&lt;&lt;8 | b&lt;&lt;0; let hex = String(format:&quot;#%06x&quot;, rgb); print(hex); &#125; else &#123; print(&quot;Invalid input value&quot;); &#125;/&apos;</span><br></pre></td></tr></table></figure><p>将命令粘贴到 <code>.lldbinit</code> 文件中，然后就可以使用了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-28714c53ef002c05.gif?imageMogr2/auto-orient/strip" alt=""></p><h2 id="实用的自定义-LLDB-命令"><a href="#实用的自定义-LLDB-命令" class="headerlink" title="实用的自定义 LLDB 命令"></a>实用的自定义 LLDB 命令</h2><p>在学会了如何向 LLDB 调试器中添加自定义命令，那么添加什么样的自定义 LLDB 命令最实用呢？</p><p>我个人认为下面的自定义命令非常实用。可以在 Xcode 控制台中将任何 JSON 可序列化类型（例如字典、数组、数据等）打印为 JSON 字符串。 可以参考<a href="https://soffes.blog/debugging-json-data-in-lldb" title="Debugging JSON Data in LLDB" target="_blank" rel="noopener">这篇文章</a>。</p><p>另外，我也很喜欢<a href="https://diamantidis.github.io/2018/10/14/modifying-ui-elements-with-xcode-and-lldb-v2" title="Modifying UI elements with Xcode and LLDB v2" target="_blank" rel="noopener">本文</a>讨论的一系列自定义命令，我们可以使用它们来动态修改 UI 元素的颜色，而无需重新构建项目。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是对 LLDB 调试器功能做了简单介绍。如果你是刚刚接触到 LLDB，希望这篇文章能帮助你开始探索这个神奇的调试工具。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://swiftsenpai.com/testing/add-custom-lldb/&quot; title=&quot;Adding Swift Code as Custom LLDB Command&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Adding Swift Code as Custom LLDB Command&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 &lt;code&gt;po&lt;/code&gt;。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？&lt;/p&gt;
&lt;p&gt;在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加你的第一个 LLDB 命令&lt;/li&gt;
&lt;li&gt;添加带参数的 LLDB 命令&lt;/li&gt;
&lt;li&gt;将复杂的 Swift 代码转换为 LLDB 命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>探索 SwiftUI 基本手势.md</title>
    <link href="https://fanbaoying.github.io/%E6%8E%A2%E7%B4%A2-SwiftUI-%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%8A%BF-md/"/>
    <id>https://fanbaoying.github.io/探索-SwiftUI-基本手势-md/</id>
    <published>2021-06-07T12:40:07.000Z</published>
    <updated>2021-06-07T12:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。</p><p>今天，我们将回顾<span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span>基本手势：</p><ul><li>TapGesture</li><li>长按手势</li><li>拖动手势</li><li>放大手势</li><li>旋转手势</li></ul><a id="more"></a><h2 id="TapGesture"><a href="#TapGesture" class="headerlink" title="TapGesture"></a>TapGesture</h2><p>轻击手势使我们能够识别 <span style="background-color:rgba(27,31,35,.05);color:orangered;">View</span> 上的一个或多个轻击。<br>我们有几种方法可以添加点击手势。</p><p>第一个是直接使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onTapGesture</span> 修饰符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">  .onTapGesture &#123;</span><br><span class="line">    <span class="comment">// Respond to Tap Gesture </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 文档中使用的其他选项是通过创建手势并将其配置为属性，然后将其与 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.gesture（_：include :)</span> 修饰符一起使用。</p><p><strong>注意：</strong> 为了执行某项操作或响应轻击，我们需要使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭，该操作在手势结束时触发。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SingleTapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">      <span class="type">TapGesture</span>()</span><br><span class="line">          .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">              <span class="comment">// Respond to Tap Gesture</span></span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">Circle</span>()</span><br><span class="line">          .gesture(singleTap)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我更喜欢第二种方法，因为这样我们可以创建不同的手势并通过我们的代码重复使用它们。</p><p>因此，如果我们将代码放在一起，就可以开始编写类似的东西。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-7c948aec7b7e9c3f.image?imageMogr2/auto-orient/strip" alt="giphy.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped1x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>()</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped1x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 1X: <span class="subst">\(tapped1x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"1X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(singleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，我们只需使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">TapGesture(count：Int)</span> 初始化程序就可以控制要响应的数量。</p><p>在这种情况下，您需要点击3次才能触发 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-49af6400b2230e18.image?imageMogr2/auto-orient/strip" alt="2.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGesture3xView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped3x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> multipleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>(<span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped3x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 3X: <span class="subst">\(tapped3x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"3X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(multipleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长按手势"><a href="#长按手势" class="headerlink" title="长按手势"></a>长按手势</h2><p>长按手势可让我们在用户长按定义的时间后以及在用户长按的时间内执行操作。</p><p>我们可以设置一个最小持续时间，以识别我们的长按手势。 可以在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">LongPressGesture</span> 初始化程序中进行设置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>然后，我们可以使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.updating</span> 方法在长按期间执行操作，并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 在识别到我们的手势时执行操作。</p><p>在此示例中，我将在长按操作期间更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 的大小和颜色，并且当识别出手势时，我将显示“文本已完成”。</p><p>另外，我在这里使用的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">GestureState</span> 属性包装器，该包装器在长按期间设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">true</span> ，在手势结束时设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">false</span> 。 我正在将此属性包装器用于示例动画。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-4a9fe52ce65b10a1.image?imageMogr2/auto-orient/strip" alt="3.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LongPressGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">GestureState</span> <span class="keyword">private</span> <span class="keyword">var</span> isLongPressDetected = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isDone = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> longPress: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br><span class="line">            .updating($isLongPressDetected) &#123; currentState, gestureState, transaction <span class="keyword">in</span></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    isDone = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                gestureState = currentState</span><br><span class="line">                transaction.animation = <span class="type">Animation</span>.easeIn(duration: <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; done <span class="keyword">in</span></span><br><span class="line">                isDone = done</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">10</span>, height: <span class="number">10</span>)</span><br><span class="line">                .foregroundColor(isLongPressDetected ? .orange : .primary)</span><br><span class="line">                .scaleEffect(<span class="type">CGSize</span>(</span><br><span class="line">                                width: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>,</span><br><span class="line">                                height: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="keyword">if</span> isLongPressDetected &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Updating..."</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isDone &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Long Press 2 sec"</span>)</span><br><span class="line">                .padding()</span><br><span class="line">                .background(isLongPressDetected ? <span class="type">Color</span>.green : <span class="type">Color</span>.orange)</span><br><span class="line">                .cornerRadius(<span class="number">16</span>)</span><br><span class="line">                .gesture(longPress)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拖动手势"><a href="#拖动手势" class="headerlink" title="拖动手势"></a>拖动手势</h2><p>拖动手势允许我们在拖动视图时执行操作。</p><p>我们可以利用并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 关闭方法来执行某些操作。 这两种方法都为我们提供了出色的属性 <span style="background-color:rgba(27,31,35,.05);color:orangered;">DragGesture.Value</span>，该属性存储以下拖动动作信息：</p><ul><li>location</li><li>predictedEndLocation</li><li>predictedEndTranslation</li><li>startLocation</li><li>time</li><li>translation</li></ul><p>我们可以使用该属性来创建可移动视图。 在当前示例中，我使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 方法更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-9d805e7489eb15e5.image?imageMogr2/auto-orient/strip" alt="4.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，添加了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 方法，以在拖动结束后重置 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-f1710b2656cab2f4.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                withAnimation(.easeOut) &#123;</span><br><span class="line">                    location = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放大手势"><a href="#放大手势" class="headerlink" title="放大手势"></a>放大手势</h2><p>当我们在View上应用放大动作时，放大手势允许做出一些动作。</p><p>在这里，还有 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，我们可以使用它们来在放大动作期间或结束时进行响应。 作为属性，接收到的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">CGFloat</span> 的 <span style="background-color:rgba(27,31,35,.05);color:orangered;">MagnificationGesture.Value</span> 。 我们可以以此为例来更改视图大小。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b3ac91417d23226f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MagnificationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> magnifiedValue: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> magnification: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">MagnificationGesture</span>()</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = value</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = <span class="number">1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span> * magnifiedValue, height: <span class="number">100</span> * magnifiedValue)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .gesture(magnification)</span><br><span class="line">            .animation(.easeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转手势"><a href="#旋转手势" class="headerlink" title="旋转手势"></a>旋转手势</h2><p>旋转手势允许旋转视图，并在旋转过程中和旋转结束时以某些动作做出响应。</p><p>它还为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，这些闭包为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">RotationGesture.Value</span>，它表示手势 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Angle</span> 值。 我们可以使用该值旋转视图。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-0939ef2e20c537bf.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RotationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> angle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> backgroundAngle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rotation: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">RotationGesture</span>()</span><br><span class="line">            .onChanged &#123; angle <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.angle = angle</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; angle <span class="keyword">in</span></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.spring()) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.backgroundAngle = angle</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span>()</span><br><span class="line">            .frame(width: <span class="number">150</span>, height: <span class="number">150</span>, alignment: .center)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .rotationEffect(<span class="keyword">self</span>.angle)</span><br><span class="line">            .gesture(rotation)</span><br><span class="line">            .background(</span><br><span class="line">                <span class="type">Rectangle</span>()</span><br><span class="line">                    .shadow(color: .primary, radius: <span class="number">10</span>, x: <span class="number">0.0</span>, y: <span class="number">0.01</span>)</span><br><span class="line">                    .foregroundColor(.secondary)</span><br><span class="line">                    .rotationEffect(backgroundAngle)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是对  <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 基本手势的总结。我们可以实现更多的交互使我们的 App 变得更生动。</p><p>对于高级的使用，可以将手势组合或者同时使用以做出响应，或者可以实现自己的自定义手势。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt; 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。&lt;/p&gt;
&lt;p&gt;今天，我们将回顾&lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt;基本手势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TapGesture&lt;/li&gt;
&lt;li&gt;长按手势&lt;/li&gt;
&lt;li&gt;拖动手势&lt;/li&gt;
&lt;li&gt;放大手势&lt;/li&gt;
&lt;li&gt;旋转手势&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>解决 iOS 14.5 UDP广播 sendto 返回 -1</title>
    <link href="https://fanbaoying.github.io/%E8%A7%A3%E5%86%B3-iOS-14-5-UDP%E5%B9%BF%E6%92%AD-sendto-%E8%BF%94%E5%9B%9E-1/"/>
    <id>https://fanbaoying.github.io/解决-iOS-14-5-UDP广播-sendto-返回-1/</id>
    <published>2021-06-07T12:37:18.000Z</published>
    <updated>2021-06-07T12:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h3><ol><li>手机系统升级到 iOS 14.5 之后，UDP 广播发送失败</li><li>项目中老版本使用到 socket </li><li>项目中新版本使用 CocoaAsyncSocket</li><li>两种 UDP 发包方式都会报错 No route to host</li></ol><p><strong>报错具体内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendto: -1</span><br><span class="line">client: sendto fail, but just ignore it</span><br><span class="line">: No route to host</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><h5 id="2-1-sendto-返回-1-问题排查"><a href="#2-1-sendto-返回-1-问题排查" class="headerlink" title="2.1  sendto 返回 -1 问题排查"></a>2.1  sendto 返回 -1 问题排查</h5><p>我们知道发送广播 sendto 返回 -1，正常情况sendto 返回值大于 0 。<br>首先判断 socket 连接是否建立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._sck_fd4 = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">if (DEBUG_ON) &#123;</span><br><span class="line">     NSLog(@&quot;client init() _sck_fd4=%d&quot;,self._sck_fd4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>self._sck_fd4 打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server init(): _sck_fd4=12</span><br></pre></td></tr></table></figure><p>socket 连接正常，接下来判断数据发包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto(self._sck_fd4, bytes, dataLen, 0, (struct sockaddr*)&amp;target_addr, addr_len) = -1</span><br></pre></td></tr></table></figure><p>数据发送失败</p><h5 id="2-2-增加-NSLocalNetworkUsageDescription-权限"><a href="#2-2-增加-NSLocalNetworkUsageDescription-权限" class="headerlink" title="2.2  增加 NSLocalNetworkUsageDescription 权限"></a>2.2  增加 NSLocalNetworkUsageDescription 权限</h5><ol><li><p>Info.plist 添加 <strong>NSLocalNetworkUsageDescription</strong></p></li><li><p>发送一次UDP广播，触发权限弹框，让用户点击好，允许访问本地网络。</p></li></ol><p>发现问题依旧存在</p><h5 id="2-3-发送单播排查"><a href="#2-3-发送单播排查" class="headerlink" title="2.3 发送单播排查"></a>2.3 发送单播排查</h5><p>由于项目中发送广播设置的 hostName 为 255.255.255.255，为了排查决定先发送单播看是否能成功。</p><p>将单播地址改为 192.168.0.101 之后发现是可以发送成功的，然后在新版本 CocoaAsyncSocket 库中发送单播也是可以成功的。</p><p>UDP 广播推荐使用 192.168.0.255 ，将广播地址改了之后，问题解决了，设备可以收到 UDP 广播数据。</p><h3 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3. 问题解决"></a>3. 问题解决</h3><p>由于 192.168.0.255 广播地址只是当前本地地址，App 中需要动态改变前三段 192.168.0 本地地址，解决方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *localInetAddr4 = [ESP_NetUtil getLocalIPv4];</span><br><span class="line"><span class="built_in">NSArray</span> *arr = [localInetAddr4 componentsSeparatedByString:<span class="string">@"."</span>];</span><br><span class="line"><span class="built_in">NSString</span> *deviceAddress4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.%@.%@.255"</span>,arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]];</span><br></pre></td></tr></table></figure><p>发包过滤，只需要过滤地址最后一段是否为 255</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isBroadcast = [targetHostName hasSuffix:@&quot;255&quot;];</span><br></pre></td></tr></table></figure><p>本文已在公众号「<strong>网罗开发</strong>」发布，如需转载请加微信：FBY-fan，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题背景&quot;&gt;&lt;a href=&quot;#1-问题背景&quot; class=&quot;headerlink&quot; title=&quot;1. 问题背景&quot;&gt;&lt;/a&gt;1. 问题背景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;手机系统升级到 iOS 14.5 之后，UDP 广播发送失败&lt;/li&gt;
&lt;li&gt;项目中老版本使用到 socket &lt;/li&gt;
&lt;li&gt;项目中新版本使用 CocoaAsyncSocket&lt;/li&gt;
&lt;li&gt;两种 UDP 发包方式都会报错 No route to host&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;报错具体内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sendto: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client: sendto fail, but just ignore it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;: No route to host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>提升工作效率 Mac 上的必备工具</title>
    <link href="https://fanbaoying.github.io/%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87-Mac-%E4%B8%8A%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    <id>https://fanbaoying.github.io/提升工作效率-Mac-上的必备工具/</id>
    <published>2021-05-02T14:19:35.000Z</published>
    <updated>2021-05-02T16:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。</p><p><strong>1. UI调试神器–Reveal</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-b5b7a9d2be34f95e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Reveal是一个界面调试工具。使用Reveal，我们可以在iOS开发时动态地查看和修改应用程序的界面。</p><p>它类似Chrome的“审查元素”功能，我们不但可以在运行时看到iOS程序的界面层级关系，还可以实时地修改程序界面，不用重新运行程序就可以看到修改之后的效果。</p><p><strong>2. 接口调试–Postman</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-a5a8702aaf98cb9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>在我们平时开发中，特别是需要与接口打交道时，无论是写接口还是用接口，拿到接口后肯定都得提前测试一下，这样的话就非常需要有一个比较给力的 Http 请求模拟工具。</p><p>Postman 就是一种网页调试与发送网页 http 请求的 chrome 插件。我们可以用来很方便的模拟 get 或者 post 或者其他方式的请求来调试接口。</p><p><strong>3. 网络拦截–Charles</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-63b1ffa7970c6be1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Charles是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p><p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。很多iOS的高仿应用都是用Charles来拦截获取网络数据的。</p><p><strong>4. 取色工具–Sip</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-5eb2a353d61b4fe4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Sip 是全栈开发人员的利器，用户只需轻点鼠标便可快速取得屏幕当前位置的颜色值，并将数据自动存到剪切板，方便随时粘贴出来。支持 CSS、UIColor 等多种格式。</p><p><strong>5. JSON 生成数据模型工具–JSONExport</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-e6767b6bbec4d27d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>JSONExport 是一个 Mac OS X 应用，用 Swift 编写。它可以将 JSON 自动生成指定语言的 Model 类代码，包括属性，属性的getters和setters方法等。</p><p>不管你 json 数据多复杂，里面嵌套多少层，该工具都可以将它转换出来，这对于我们开发生成数据模型节省了不少时间。JSONExport 支持 OC、Swift、Java 等语言。</p><p><strong>6. Git 代码界面管理工具–SourceTree</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-33833817fdc9e7f9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>SourceTree 是 Windows 和 Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。</p><p>同时它也是 Mercurial 和 Subversion 版本控制系统工具。支持创建、提交、clone、push、pull 和 merge 等操作。</p><p><strong>7. Svn 代码界面管理工具–Cornerstone</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-f5d236668488ba03?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>CornerStone 是 Mac OS X 系统下非常好用的一款 svn 软件管理工具，当然还有 Versions 也是可以用的，但是使用起来不如 CornerStone 好用、强大。</p><p><strong>注意：</strong>CornerStone 是收费，如果是公司需要使用到，建议让公司购买软件使用版权，支持正版。本人所用的是公司购买了使用权的版本。当然网上也是有破解版本的。</p><p><div align="center"></div></p><p><strong style="font-size: 20px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">软 件 链 接</span></strong></p><p><img width="150" height="150" src="https://upload-images.jianshu.io/upload_images/2829694-2fd9a02d886dd857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><section><span style="font-size: 15px;">进入上方<strong><span style="color: rgb(255, 0, 0);">▲</span></strong><span style="background-color: rgb(255, 255, 255);letter-spacing: 1px;">二维码内，回复：<strong style="font-size: 16px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">427</span></strong></span></span></section><br><br><br></p><p><strong><img src="https://upload-images.jianshu.io/upload_images/19359146-e6227bdef1fb12f8?imageMogr2/auto-orient/strip" alt=""></strong> </p><h5 id="分享-6-个百度出品的免费工具，你用过几个？"><a href="#分享-6-个百度出品的免费工具，你用过几个？" class="headerlink" title="分享 6 个百度出品的免费工具，你用过几个？"></a><a href="https://mp.weixin.qq.com/s/SCcQjGgdohHsEaD3m5aegw" target="_blank" rel="noopener">分享 6 个百度出品的免费工具，你用过几个？</a></h5><h5 id="「ApowerREC」一款功能强大的录屏软件"><a href="#「ApowerREC」一款功能强大的录屏软件" class="headerlink" title="「ApowerREC」一款功能强大的录屏软件"></a><a href="https://mp.weixin.qq.com/s/Iq4WccudqFg_0wKJ6UvrnQ" target="_blank" rel="noopener">「ApowerREC」一款功能强大的录屏软件</a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. UI调试神器–Reveal&lt;/strong&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;im
      
    
    </summary>
    
      <category term="软件工具库" scheme="https://fanbaoying.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
    
      <category term="工具" scheme="https://fanbaoying.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 支付宝支付开发（最新版）</title>
    <link href="https://fanbaoying.github.io/iOS-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/iOS-支付宝支付开发（最新版）/</id>
    <published>2021-04-28T14:00:30.000Z</published>
    <updated>2021-04-28T14:05:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。</p><p>今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。</p><p>在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。<br>其实如果接入的多的话，那些套路都可以绕着走。<br>网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。</p><a id="more"></a><h2 id="2-交互流程"><a href="#2-交互流程" class="headerlink" title="2. 交互流程"></a>2. 交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是交互流程这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8688fd141e5c4425b1e07ef6d5363447~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115b15944b364a15a6948eb180f086b1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>支付宝支付的功能流程相比较微信支付来说简单的很，如上面两张图展示的，我们的 App（也就是商户客户端）所做的大概只有三个步骤：</p><ul><li>生成订单</li><li>调用支付宝接口，发送订单</li><li>返回订单支付结果并处理</li></ul><h2 id="3-下载支付宝-SDK"><a href="#3-下载支付宝-SDK" class="headerlink" title="3. 下载支付宝 SDK"></a>3. 下载支付宝 SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了最新的 SDK 地址<br><strong>注意</strong>的是下载出来的 SDK 包里面并没有传说中的开发文档，需要其他地方找或者看网页上的。</p><p>公钥、私钥、PID、sellerID、key这些东西的用途和获取方式在文档上都有详细的说明，这里不再赘述，一定要把概念分清楚再去做，不然一会就乱了。如果遇到问题的话咱们可以再一起探讨。</p><h2 id="4-导入库集成SDK"><a href="#4-导入库集成SDK" class="headerlink" title="4.  导入库集成SDK"></a>4.  导入库集成SDK</h2><h3 id="4-1-导入文件和关键库"><a href="#4-1-导入文件和关键库" class="headerlink" title="4.1 导入文件和关键库"></a>4.1 导入文件和关键库</h3><p><strong>通过 CocoaPods 导入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod  &apos;AlipaySDK-iOS&apos;</span><br></pre></td></tr></table></figure><p><strong>手动导入</strong></p><p>官方 demo 截图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36fb998958da4664a3cb2fca96a24958~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>添加 framework 和其他文件<br>打开 iOS 工程，新版本 SDK 文件 Order 文件，你需要复制粘贴到自己工程里的有：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li><li>Until 文件夹</li><li>openssl 文件夹</li><li>libcrypto.a 和 libssl.a</li></ul><p>上面的一部分文件在打开的项目中是看不到的，需要打开项目文件夹找到。</p><p>在 Build Phases 选项卡的 Link Binary With Libraries 中，增加以下依赖：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e052992193d427e91285f9187bddff7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>其中，需要注意的是：</p><ul><li>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；</li><li>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib（如下图）。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b43efaeb56c4339af14127460fcd0c4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>此时，假如你启动工程，很大几率上你会发现报 error 的情况。</p><h3 id="4-2-引入头文件"><a href="#4-2-引入头文件" class="headerlink" title="4.2 引入头文件"></a>4.2 引入头文件</h3><p>在需要调用 AlipaySDK 的文件中，增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在支付宝的接入文档中，是将生成一个订单这步放在客户端来做了，但这个最好是放在服务器端来做。</p><p>后台生成订单然后拼接，签名，然后服务器端直接给客户端传一个加密签名过的参数就可以了，这样比较安全。</p><p>所有的订单信息，商户信息等都掌握在自己的手中，这样的话APP端就不怕被拦截数据，并且调用起来也就特别简单了，只需要调用支付的接口。</p><p>如果只需要发送订单和处理支付返回结果，只需要添加 AlipaySDK.bundle 和AlipaySDK.framework 这两个就行了，下载的SDK中很容易发现。<br>快捷支付方法是这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)payOrder:(NSString *)orderStr fromScheme:(NSString *)schemeStr callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure><p>在支付的按钮中，使用支付宝这个类，再调用这个方法就行啦！如下如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="4-4-配置支付宝客户端返回-url-处理方法"><a href="#4-4-配置支付宝客户端返回-url-处理方法" class="headerlink" title="4.4 配置支付宝客户端返回 url 处理方法"></a>4.4 配置支付宝客户端返回 url 处理方法</h3><p>如示例 AliSDKDemo\APAppDelegate.m 文件中，增加引用代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><p>在 <em>@</em>implementation  AppDelegate 中以下代码中的 NSLog 改为实际业务处理代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-项目配置"><a href="#4-5-项目配置" class="headerlink" title="4.5 项目配置"></a>4.5 项目配置</h3><p>最后，不要忘了还要写一个 URL Scheme，在 Targets -&gt; Info 下最后一个即可找到，<br>点击 “Info” 选项卡，在 “URL Types ”选项中，点击 “+”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/743ffb1092bb4cc4ab6f845a7cb7bd55~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="5-常见问题汇总"><a href="#5-常见问题汇总" class="headerlink" title="5. 常见问题汇总"></a>5. 常见问题汇总</h2><h3 id="5-1-支付后无法返回-App"><a href="#5-1-支付后无法返回-App" class="headerlink" title="5.1 支付后无法返回 App"></a>5.1 支付后无法返回 App</h3><p>一般是由于白名单没有设置正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上方代码中 appScheme 参数需要和文章 <strong>4.5 项目配置</strong>中设置的 URL Schemes 相同，这样才能对应返回 App。</p><h3 id="5-2-include-not-find"><a href="#5-2-include-not-find" class="headerlink" title="5.2 #include  not find"></a>5.2 #include <openssl opensslconf.h=""> not find</openssl></h3><p>这是一个神奇的大坑，我Google了好久，也不得其解，然后经网友提醒之后想起来#import “”和#import &lt;&gt;的区别。</p><p><strong>解决方法</strong>：Targets -&gt; Build Settings 下的 Header Search Paths。<br>添加如下目录 “$(SRCROOT)/项目名称/文件的绝对地址”<br>如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40f0b9ba81d48bc8ded85bf2fe6ae1e~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p><h3 id="5-3-‘openssl-asn1-h’-file-not-found"><a href="#5-3-‘openssl-asn1-h’-file-not-found" class="headerlink" title="5.3 ‘openssl/asn1.h’ file not found"></a>5.3 ‘openssl/asn1.h’ file not found</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae746bcaf0c4c32ae80ed76429b6b2b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>由于在项目中引入 openssl 库，出现这个问题是因为库文件项目无法找到，只需要在 Header Search Paths 中加入 $(PROJECT_DIR)/项目名称/openssl 即可，如下图操作：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5732304211a5473b9b1ed4edf5e61b32~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-4-Undefined-symbol-OBJCMETACLASS-WKWebView"><a href="#5-4-Undefined-symbol-OBJCMETACLASS-WKWebView" class="headerlink" title="5.4 Undefined symbol: _OBJCMETACLASS$_WKWebView"></a>5.4 Undefined symbol: _OBJC<em>METACLASS</em>$_WKWebView</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15de4c63d16e49ba831d344be0e19e3c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>出现上面的问题，需要在项目配置中添加系统类库：WebKit.framework</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8cff9e3b44418cbb2979ec0e9a2de5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-5-如果遇到运行后报错，类似于以下提示信息："><a href="#5-5-如果遇到运行后报错，类似于以下提示信息：" class="headerlink" title="5.5 如果遇到运行后报错，类似于以下提示信息："></a>5.5 如果遇到运行后报错，类似于以下提示信息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot find interface declaration for &apos;NSObject&apos;, superclass of &apos;Base64&apos;</span><br></pre></td></tr></table></figure><p>那么需要打开报错了的文件，增加头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br></pre></td></tr></table></figure><h3 id="5-6-Swift-中接入-SDK-遇到的问题"><a href="#5-6-Swift-中接入-SDK-遇到的问题" class="headerlink" title="5.6 Swift 中接入 SDK 遇到的问题"></a>5.6 Swift 中接入 SDK 遇到的问题</h3><p>如果项目使用 Swift 为开发语言，需要添加桥接文件，如 Bridging-Header.h</p><p>同时，在项目 Build Settings 中设置桥接文件的位置。</p><p>运行时如果发生以下报错，则在桥接文件中，写入#import <uikit uikit.h=""></uikit></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d474efcd7f487887e925a06627a0b7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-7-点击支付跳转至支付宝卡在启动页面"><a href="#5-7-点击支付跳转至支付宝卡在启动页面" class="headerlink" title="5.7 点击支付跳转至支付宝卡在启动页面"></a>5.7 点击支付跳转至支付宝卡在启动页面</h3><p>出现这个情况被卡在的页面会出现相应错误提示，一般有以下几种情况：</p><ul><li>商品信息拼接字符串错误</li><li>支付账号过期待续费状态</li><li>商户 ID 错误</li><li>订单信息验签失败</li></ul><p>获取源码方式：关注「<strong>网罗开发</strong>」回复 “<strong>支付宝支付</strong>” 即可获取</p><p>本文已在公众号「<strong>网罗开发</strong>」发布，如果转载长白请加微信：FBY-fan，备注<strong>转载长白</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-d0f9c79727486cae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。&lt;/p&gt;
&lt;p&gt;今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。&lt;/p&gt;
&lt;p&gt;在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。&lt;br&gt;其实如果接入的多的话，那些套路都可以绕着走。&lt;br&gt;网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native视频播放器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native视频播放器插件/</id>
    <published>2018-12-16T10:00:59.000Z</published>
    <updated>2018-12-16T10:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生视频播放器插件的开发与使用。</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生视频播放器插件是需要实现打开js端调用播放方法传入的视频链接URL，具体的实现思路如下：</p><ol><li><p>新建mediaPlay类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>创建一个视频播放控制器</p></li><li><p>创建一个视频播放图层</p></li><li><p>将视频播放图层添加到父控件图层</p></li><li><p>JavaScript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建mediaPlay类，实现RCTBridgeModule协议"><a href="#1-新建mediaPlay类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建mediaPlay类，实现RCTBridgeModule协议"></a>1. 新建mediaPlay类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的mediaPlay类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface mediaPlay : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，mediaPlay的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“MediaPlay”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">RCT_EXPORT_METHOD(mediaPlayer:(NSDictionary*)arguments</span><br><span class="line">                           :(RCTResponseSenderBlock)sucessCallback</span><br><span class="line">                           :(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起原声视频播放器的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-创建一个视频播放控制器"><a href="#5-创建一个视频播放控制器" class="headerlink" title="5. 创建一个视频播放控制器"></a>5. 创建一个视频播放控制器</h5><p>视频播放器是使用iOS原声<avfoundation avfoundation.h="">来实现视频的播放，创建一个视频播放控制器代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(AVPlayerViewController *)playerVC</span><br><span class="line">&#123;</span><br><span class="line">    if (_playerVC == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个视频播放控制器</span><br><span class="line">        _playerVC = [[AVPlayerViewController alloc] init];</span><br><span class="line">        //获取视频URL（远程、本地视频URL都可以）</span><br><span class="line">        NSURL * url = [NSURL URLWithString:self.vedioURL];</span><br><span class="line">        //根据URL创建播放曲目</span><br><span class="line">        AVPlayerItem * item = [AVPlayerItem playerItemWithURL:url];</span><br><span class="line">        //创建一个视频播放器</span><br><span class="line">        AVPlayer * player = [AVPlayer playerWithPlayerItem:item];</span><br><span class="line">    &#125;</span><br><span class="line">    return _playerVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></avfoundation></p><h5 id="6-创建一个视频播放图层"><a href="#6-创建一个视频播放图层" class="headerlink" title="6. 创建一个视频播放图层"></a>6. 创建一个视频播放图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个视频播放图层</span><br><span class="line"> AVPlayerLayer * playLayer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br></pre></td></tr></table></figure><h5 id="7-将视频播放图层添加到父控件图层"><a href="#7-将视频播放图层添加到父控件图层" class="headerlink" title="7. 将视频播放图层添加到父控件图层"></a>7. 将视频播放图层添加到父控件图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将视频播放图层添加到父控件图层</span><br><span class="line"> [_playerVC.view.layer addSublayer:playLayer];</span><br><span class="line"> //设置视频播放控制器的播放器为player</span><br><span class="line"> _playerVC.player = player;</span><br></pre></td></tr></table></figure><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const MediaPlayPlugin = NativeModules.MediaPlay;</span><br><span class="line">MediaPlayPlugin.mediaPlayer(&#123;filePath:&quot;http://static.tripbe.com/videofiles/20121214/9533522808.f4v.mp4&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
