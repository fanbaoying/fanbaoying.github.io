<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>加微信：『fzhanfei』进群</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2021-10-22T07:20:03.353Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 周报 第四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四期/</id>
    <published>2021-10-22T07:19:18.000Z</published>
    <updated>2021-10-22T07:20:03.353Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近 Swift.org 进行了一些非常好的改进，包括对 <code>dark mode</code> 的支持。 对于在 iOS 上使用 <code>dark mode</code> 的用户，该网站将自动切换模式以匹配。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15271</strong> [Compiler] <a href="https://bugs.swift.org/browse/SR-15271" title="Improve Codable Diagnostics When CodingKeys Do Not Match Properties" target="_blank" rel="noopener">当 CodingKeys 与属性不匹配时改进可编码诊断</a></p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Ted Kremenek</strong> 写了一篇关于 <a href="https://swift.org/blog/swift-5-5-released/" title="Swift 5.5 Released" target="_blank" rel="noopener">Swift 5.5 版本</a>的文章。</p><p><strong>Bruno Rocha</strong> 发表了一篇优秀的文章，解释了 <a href="https://swiftrocks.com/how-asyncsequence-works-internally-in-swift" title="How AsyncSequence works internally in Swift" target="_blank" rel="noopener">AsyncSequence 在 Swift 内部是如何工作</a>的。</p><p><strong>Lee Kah Seng</strong> 写了一篇文章，描述了 <a href="https://swiftsenpai.com/swift/actor-reentrancy-problem/" title="The Actor Reentrancy Problem in Swift" target="_blank" rel="noopener">Swift 中的 Actor Reentrancy 问题</a>。</p><p><strong>Amritpan Kaur</strong> 解释了她如何参与首届 <a href="https://forums.swift.org/t/swift-mentorship-compiler-language-design/52522" title="Swift Mentorship - Compiler &amp; Language Design" target="_blank" rel="noopener">Swift 导师，并致力于编译器开发和语言设计</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>Michael Ilseman</strong> 合并了一个为 <a href="https://github.com/apple/swift/pull/38922" title="[stdlib] Implement native normalization for String" target="_blank" rel="noopener">String 实现原生规范化</a>的 pull request。</p><p><strong>Doug Gregor</strong> 创建了一个 pull request，<a href="https://github.com/apple/swift/pull/39609" title="Back-deploy @objc actor types" target="_blank" rel="noopener">向后兼容  @objc actor 类型</a>。</p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><strong>SE-0322</strong> <a href="https://forums.swift.org/t/accepted-with-modifications-se-0322-temporary-uninitialized-buffers/52532" title="Temporary Uninitialized Buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>已接受修改。</p><p><strong>SE-0323</strong> <a href="https://forums.swift.org/t/accepted-se-0323-asynchronous-main-semantics/52531" title="Asynchronous Main Semantics" target="_blank" rel="noopener">Asynchronous Main 语义</a>已接受。</p><p><strong>SE-0324</strong> 接受了<a href="https://forums.swift.org/t/accepted-se-0324-relax-diagnostics-for-pointer-arguments-to-c-functions/52599" title="Relax diagnostics for pointer arguments to C functions" target="_blank" rel="noopener">对 C 函数的指针参数放宽诊断</a>提案。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SSWG-0017</strong>：<a href="https://forums.swift.org/t/sswg-0017-multipartkit/52586" title="MultipartKit" target="_blank" rel="noopener">MultipartKit</a> 正在审查中。</p><p><code>MultipartKit</code> 提供 <code>Multipart</code> 数据的低级解析和序列化，以及对 <code>Multipart</code> 表单数据的编码和解码的高级 <code>Codable</code> 支持。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>1. Karoy Lorentey</strong> 询问什么时候将 <code>ManagedAtomic/UnsafeAtomic</code> 标记为 <code>Sendable</code>？</p><p>刚刚提交了<a href="https://github.com/apple/swift-atomics/issues/45" title="The constructs provided by this package need to be marked Sendable" target="_blank" rel="noopener">问题 #45</a>，要求将 <code>UnsafeAtomic</code>、<code>ManagedAtomic</code> 和朋友标记为 <code>Sendable</code>，这反映了它们可以安全地跨并发域传输。</p><p><strong>2. Kavon Farvardin</strong> 提议定义 <a href="https://forums.swift.org/t/proposal-actor-initializers-and-deinitializers/52322" title="[proposal] Actor Initializers and Deinitializers" target="_blank" rel="noopener">actor 初始化器</a>在 <code>Swift</code> 中的工作方式。</p><p>目前，本提案中描述的一些问题的建议解决方案通过警告反映在 <code>Swift 5.5</code> 中，但是审查 <code>Swift 6</code> 的这些更改很重要。此外，该提案为 <code>MainActor</code> 隔离类的 <code>deinit</code> 增加了额外的功能，这样可以更容易、更安全地编写。如果有新的想法和评论可以在<a href="https://github.com/kavon/swift-evolution/blob/actor-init-proposal2/proposals/nnnn-actor-initializers.md" title="Actor Initializers and Deinitializers" target="_blank" rel="noopener">这里提出来</a>。</p><p><strong>3. Kelvin Ma</strong> 发现 <a href="https://forums.swift.org/t/swift-5-5-has-serious-stack-corruption-bugs/52344" title="Swift 5.5 has serious stack corruption bugs!" target="_blank" rel="noopener">Swift 5.5 存在严重的堆栈损坏错误</a>。</p><p>我发现了几个与 async/await 相关的堆栈损坏错误，这些错误可以在使用最近的夜间工具链编译的简单测试程序中重现。 我已经确认 5.5-RELEASE 工具链中存在这些错误中的两个三四个。</p><p>我发现了几个与 <code>async/await</code> 相关的堆栈损坏错误，可以在 <code>recent nightly toolchains</code> 的简单测试程序中重现问题。<strong>我已确认 <code>5.5-RELEASE toolchain</code> 中存在多个错误</strong>。</p><p><strong>4. Becca Royal-Gordon</strong> 提出了在<a href="https://forums.swift.org/t/pitch-2-staging-in-sendable-checking/52413" title="Staging in Sendable checking" target="_blank" rel="noopener">Sendable 检查中添加暂存</a>的建议。</p><p>几周前，<strong>@Douglas_Gregor</strong> <a href="https://forums.swift.org/t/pitch-staging-in-sendable-checking/51341" title="[Pitch] Staging in Sendable checking" target="_blank" rel="noopener">提出了一些更改</a>，试图解决在一些客户端或依赖项可能尚未更新时在模块中采用 Sendable 检查所涉及的一些问题。当模块最终更新时，这种方法可能会出现问题和隐藏的 BUG，以及 <code>Objective-C</code> 库如何能够控制其类型的可发送性。</p><p><strong>5. YR Chen</strong> 开始讨论<a href="https://forums.swift.org/t/upon-swift-6-solve-inconsistency-within-the-language/52437" title="Upon Swift 6: Solve inconsistency within the language" target="_blank" rel="noopener">解决 Swift 6 发布时的不一致问题</a>。</p><p>一些 API 破损的语言设计可以在 3 年后 <code>Swift 6</code> 的发布中修复。这是一个相当长的时间，通过 <code>Swift 3.2</code> 和 <code>Swift 4.2</code> 事实证明，过渡到 Swift 突破性发布要顺畅的多。</p><p>建议我们选择一些延迟的断点，目的是消除语言中的不一致。这些想法已经得到了社区的积极反馈，但是还是没有开始实施。</p><p><strong>6. Philippe Hausler</strong> 提出了<a href="https://forums.swift.org/t/pitch-clock-instant-date-and-duration/52451" title="[Pitch] Clock, Instant, Date, and Duration" target="_blank" rel="noopener">定义 Clock, Instant, Date 和 Duration </a>的提案。</p><p><strong>时间的概念可以分为三个不同的部分：</strong></p><ul><li>提供现在概念的项目加上一个在给定时间点后醒来的方法，* 时间点的概念</li><li>时间测量的概念</li></ul><p>这三项分别是时钟、瞬间和持续时间。时间的测量可用于许多类型的 API，从高级网络连接超时概念到休眠任务的时间量。目前，测量时间类型的 API 采用 <code>NSTimeInterval</code> 又名 <code>TimeInterval</code>、<code>DispatchTimeInterval</code>，甚至像 <code>timespec</code> 这样的类型。</p><p><strong>7. Michael Ilseman</strong> 提出了<a href="https://forums.swift.org/t/declarative-string-processing-overview/52459" title="Declarative String Processing Overview" target="_blank" rel="noopener">实现声明性字符串处理</a> API 的想法。</p><p>字符串处理很困难，Swift 标准库目前提供的功能不足。我们建议添加两个新的声明性字符串处理 API，一个是熟悉的 <code>Regex</code> 文本，一个是更强大的 <code>Pattern</code> 结果生成器，以便 Swift 字符串处理起来更快速简便。</p><p>这是一个大型功能，最终将分为多个 <code>Swift Evolution</code> 提案。主要目的在于推动高级方向的讨论，并介绍该功能的关键点及其相互关系。</p><p><strong>8. Kelvin Ma</strong> 开始讨论<a href="https://forums.swift.org/t/we-need-long-term-support-lts-releases/52462" title="long-term-support (“LTS”) releases." target="_blank" rel="noopener">长期支持 (“LTS”) 版本</a>。</p><p>对于那些没有关注开发主题的人，@mickeyl，@timdecode，我最近在 <code>Swift 5.5</code> 发布工具链中发现了数量惊人的高危险的堆栈损坏 BUG。</p><p>撇开 <code>Swift 5.5</code> 中堆栈损坏问题的技术方面不谈，在我们发布周期中采用某种形式的<a href="https://forums.swift.org/t/we-need-long-term-support-lts-releases/52462" title="“Long-Term Support” (LTS) release 8 " target="_blank" rel="noopener">“长期支持”（LTS）版本8</a>的概念是否值得，就像 Ubuntu 一直以来所做的那样。</p><p><strong>9. Anders Bertelrud</strong> 提出了扩展插件 <a href="https://forums.swift.org/t/pitch-additional-api-available-to-swiftpm-plugins/52494" title="pitch additional api available to swiftpm plugins" target="_blank" rel="noopener">SwiftPM 插件 API </a>以提供更多上下文的提案。</p><p><code>SE-0303</code> 引入了 SwiftPM 插件，特别关注构建工具插件（尤其是那些生成源代码的插件）。为了保持该提案的界限，插件可用的信息类型和数量针对生成构建命令的任务。</p><p>在开始考虑新类型的插件之前，扩展所有类型插件可用的信息似乎是明智的。未来的提案可能会为特定类型的插件添加特定的 API，但在此之前，一个好的起点似乎是让所有插件访问 SwiftPM 内部已经拥有的包图的提炼形式。这应该允许任何特定插件有很大的自由度。</p><p>我提出一份提案草案，用于扩展可用于 SwiftPM 插件的 API，并且很想听听大家的想法。在 SwiftPM 存储库中的 PR 中有一个实现。</p><p><strong>10. Guillaume Lessard</strong> 提出了一项<a href="https://forums.swift.org/t/pitch-expand-usability-of-withmemoryrebound/52500" title="expand usability of withMemoryRebound" target="_blank" rel="noopener">扩大 withMemoryRebound 可用性</a>的提案。</p><p>函数 <code>withMemoryRebound(to:capacity:_ body:)</code> 执行一个闭包，同时将一定范围的内存临时绑定到与被调用者绑定的类型不同的类型。</p><p>我们建议解除 <code>withMemoryRebound</code> 的一些显着限制，并启用重新绑定到更大的类型集，以及从原始内存指针和缓冲区重新绑定。</p><p><strong>11. Tim Condon</strong> 向我们介绍了 <a href="https://forums.swift.org/t/async-await-and-the-future-of-vapor/52590" title="async/await and the future of Vapor." target="_blank" rel="noopener">async/await 和 Vapor 的未来</a>。</p><p><strong>12. Drew McCormack</strong> 提出了一项提案，该提案将创建用于<a href="https://forums.swift.org/t/proposal-a-standard-library-type-for-working-with-shared-data-in-a-concurrent-system/52603" title="standard library data structures designed for working with shared data in a concurrent system." target="_blank" rel="noopener">在并发系统中处理共享数据的标准库数据结构</a>。</p><p>我想在这里提出这样一种类型：分支资源。</p><p><code>BranchingResource</code> 将是一种类型，其携带的有效负载（即资源）具有通用参数。 资源将从单个分支开始，称为“<code>main</code>”或“<code>trunk</code>”或“<code>truth</code>”。 该应用程序可以添加任意数量的辅助命名分支。</p><p><strong>13. Pavel Yaskevich</strong> 提出了<a href="https://forums.swift.org/t/pitch-enable-multi-statement-closure-parameter-result-type-inference/52619" title="enable multi-statement closure parameter/result type" target="_blank" rel="noopener">启用 multi-statement closure parameter/result type 推断</a>的想法。</p><p>我建议通过从闭包主体中启用参数和结果类型推断来改进多语句闭包的推理行为。</p><p>这将使开发人员的类型推断不那么令人惊讶，并消除了在闭包中添加多一个表达式或语句可能会导致编译失败的问题。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><h3 id="iOS-系列"><a href="#iOS-系列" class="headerlink" title="iOS 系列"></a>iOS 系列</h3><p><a href="https://mp.weixin.qq.com/s/ZprPxK8NbMqpP9flmWRagg" target="_blank" rel="noopener">百度一面总结（含答案）</a></p><p><a href="https://mp.weixin.qq.com/s/PYzQN5HYXLU1JuXBAZNyhQ" target="_blank" rel="noopener">使用 Swift 实现 Promise</a></p><p>我最近在找如何使用 Swift 实现 <code>Promise</code> 的资料，因为没找到好的文章，所以我想自己写一篇。通过本文，我们将实现自己的 <code>Promise</code> 类型，以便明了其背后的逻辑。</p><p><a href="https://mp.weixin.qq.com/s/8_utYi3y7I3ukh4VpnIM3A" target="_blank" rel="noopener">用 Swift 实现轻量的属性监听系统</a></p><p>本文的主要目的是解决客户端开发中对“模型的一处修改，UI 要多处更新”的问题。当然，我们要知晓解决方案的细节和思考过程，以及看到其能达到的效果。我们会用到函数式编程的思想，以及伟大的“泛型”。</p><h3 id="SwiftUI-系列"><a href="#SwiftUI-系列" class="headerlink" title="SwiftUI 系列"></a>SwiftUI 系列</h3><p><a href="https://mp.weixin.qq.com/s/hfe1m5bNiA0DzdFTEvi9sQ" target="_blank" rel="noopener">用 SwiftUI 实现 3D Scroll 效果</a></p><p>学完本教程后，你就可以在你的 App 中把这种 <code>3D</code> 效果加入任何自定义的 SwiftUI 视图。</p><p><a href="https://mp.weixin.qq.com/s/TD0I96HSUoTNmOmfySCtYQ" target="_blank" rel="noopener">如何让 SwiftUI 的列表变得更加灵活</a></p><p><code>List</code> 可能是 <code>SwiftUI</code> 附带的内置视图中最常用的一种，它使我们能够在任何 <code>Apple</code> 平台上呈现“类似于表格视图”的用户界面。今年，<code>List</code> 获得了许多非常重要的升级，使其更加灵活和易于定制。让我们看看都有哪些新功能。</p><p><a href="https://mp.weixin.qq.com/s/snJJi9KYViFErdJAP1HEPQ" target="_blank" rel="noopener">使用 SwiftUI 创建万花尺</a></p><p>为了完成一些真正意义上的绘图工作，我将带您通过创建一个简单的带 SwiftUI 的 <code>spirograph</code>。“Spirograph”是一种玩具的商标名称，你把一支铅笔放在一个圆圈里，然后绕着另一个圆圈的圆周旋转，创造出各种几何图案，称为轮盘赌——就像赌场游戏一样。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近 Swift.org 进行了一些非常好的改进，包括对 &lt;code&gt;dark mode&lt;/code&gt; 的支持。 对于在 iOS 上使用 &lt;code&gt;dark mode&lt;/code&gt; 的用户，该网站将自动切换模式以匹配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三期/</id>
    <published>2021-10-22T07:18:12.000Z</published>
    <updated>2021-10-22T07:18:59.097Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本期周报开始，将会引入<strong>推荐博文</strong>模块，主要为大家分享展示优秀的 iOS 技术博文，如果大家阅读到优秀的文章欢迎在文末留言告诉小编，大家资源共享共同进步。</p><p>iPhone 13 新品上架，你们都买了吗？苹果声称，iPhone 13 拥有全新的双摄像头系统，采用超快的 <code>A15</code> 芯片，提高电池的续航能力。</p><p>我们不仅要关注新的 iPhone 13，几天前，<code>Xcode 13</code> 与 <a href="https://forums.swift.org/t/swift-5-5-released/52247" title="Swift 5.5" target="_blank" rel="noopener">Swift 5.5</a> 也一起发布了。这是 Swift 5.5 更新的<a href="https://twitter.com/simjp/status/1440318174856036354" title="列表" target="_blank" rel="noopener">列表</a>，这个版本发布了很多新功能。Xcode 13 的发布说明可以在这里找到：<a href="https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes" title="iOS &amp; iPadOS 15 Release Notes" target="_blank" rel="noopener">iOS &amp; iPadOS 15 Release Notes</a>。</p><p>现在已经开始将<strong>并发</strong>功能向后部署到旧的 Swift 版本上。</p><blockquote><p>为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与<strong>周报编辑</strong>，同时邀请赞助商对我们平台赞助支持。</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><strong>Cory Benfield</strong> 告诉我们 <a href="https://forums.swift.org/t/swift-crypto-2-0-0/52308" title="Swift Crypto 2.0.0" target="_blank" rel="noopener">Swift Crypto 2.0.0 已经发布</a>。</p><h2 id="入门任务"><a href="#入门任务" class="headerlink" title="入门任务"></a>入门任务</h2><p><strong>SR-15218</strong>: [Compiler] <a href="https://bugs.swift.org/browse/SR-15218" title="Enhance interchangeable CGFloat/Double to allow interchange between optional" target="_blank" rel="noopener">增强 CGFloat/Double 之间的可互转，允许 optional 之间的互转</a></p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><strong>salinas-miguel</strong> 的 PR 已合并：<a href="https://github.com/apple/swift/pull/39216" title="Remove Foundation dependency" target="_blank" rel="noopener">删除了 Swift 项目对 macOS 上的 Foundation 的依赖</a>。</p><p>Doug Gregor 创建了一个 <code>pull request</code> <a href="https://github.com/apple/swift/pull/39342" title="Back-deployment support for Swift concurrency" target="_blank" rel="noopener">对 Swift 向后部署支持并发</a>。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><strong>SE-0323</strong>：<a href="https://forums.swift.org/t/se-0323-asynchronous-main-semantics/52022" title="Asynchronous Main Semantics" target="_blank" rel="noopener">Asynchronous Main 语义</a> 正在审查中。</p><p>程序设置通常发生在 <code>main</code> 函数中，开发人员希望在程序的其他部分运行之前执行操作。<code>Objective-C</code>、<code>c++</code> 和 <code>C</code> 都有初始化，这些初始化在 <code>main</code> 入口点执行之前运行，并且可以与   Swift 的并发系统交互。在 Swift 并发模型中，开发人员编写的异步 <code>main</code> 函数被包装在一个任务中，并在 <code>main</code> 入口点运行时被放入到主队列中。如果初始化时在主队列中插入了一个任务，那么该任务可能会在 <code>main</code> 函数之前执行，所以设置是在初始化任务运行之后执行的。</p><p><strong>SE-0324</strong>：<a href="https://forums.swift.org/t/se-0324-relax-diagnostics-for-pointer-arguments-to-c-functions/52019" title="Relax diagnostics for pointer arguments to C functions" target="_blank" rel="noopener">对 C 函数的指针参数放宽诊断</a>正在审查中。</p><p><code>C</code> 有特殊的指针别名规则，例如允许 <code>char *</code> 为其他指针类型别名，并允许指向有符号和无符号类型的指针别名。 某些 <code>C</code> <code>API</code> 的可用性依赖于在这些规则的边界内轻松转换指针的能力。 Swift 通常不允许类型化指针转换。请参阅<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0107-unsaferawpointer.md" title="UnsafeRawPointer API" target="_blank" rel="noopener">SE-0107 UnsafeRawPointer API</a>。让 Swift 编译器在调用从 <code>C</code> 头文件导入的函数时允许在 <code>C</code> 规则内进行指针转换将显著提高互操作性，而不会对类型安全产生负面影响。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><strong>Ashley Garland</strong> 介绍一些新实验出来的 <a href="https://forums.swift.org/t/swift-snippets/51947" title="Swift Snippets" target="_blank" rel="noopener">Swift Package Manager 代码段</a>。</p><p>我们都知道通过示例学习是很棒的，尤其是对于代码。 我想创建最小、最简单的方法来为 <code>Swift packages</code> 提供示例代码，我刚刚在 <a href="https://github.com/apple/swift-package-manager/commit/a0ffd92a2c80f2c4677d696e248f4cfbec9d6540" title="Swift Package Manager" target="_blank" rel="noopener">Swift Package Manager</a> 中完成了一些正在进行的工作。</p><p><strong>Filip Sakel</strong> 提出了一项<a href="https://forums.swift.org/t/pitch-refining-property-wrapper-related-initialization/52049" title="Refining Property wrapper  related Initialization" target="_blank" rel="noopener">改进 Property-wrapper-related 的初始化</a>的提案。</p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" title="SE 0258" target="_blank" rel="noopener">SE 0258</a> 引入了 <code>property wrappers</code>，<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0293-extend-property-wrappers-to-function-and-closure-parameters.md#detailed-design" title="SE 0293" target="_blank" rel="noopener">SE 0293</a> 使用类似函数的声明对其进行了扩展。 今天，<code>property wrappers</code> 初始化由于其日益增长的多功能性而表现出不一致。 具体来说，成员初始化使用复杂的、记录不足的规则，并且 <code>projection</code> 初始化仍然有限。该提案将简化具有包装属性的类型的合成成员初始化，并扩展 <code>projection</code> 值初始化以包括全局、类型和局部包装属性。</p><p><strong>Jordan Rose</strong> 开始讨论<a href="https://forums.swift.org/t/pre-pitch-remove-the-implicit-initialization-of-optional-variables/52300" title="remove the implicit initialization of Optional variables" target="_blank" rel="noopener">删除 Optional 变量的隐式初始化</a>。</p><p>在 Swift 6 中，可选变量与所有其他变量一样，默认情况下不会初始化。 局部变量和全局变量得到修复，添加 <code>= nil</code>。 属性仅在附加到有关未初始化变量的错误的注释中修复，这显然不是正确的做法，只有 Swift 5 中需要这么做。 不过，迁移者也可以自动应用该修复程序。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><h3 id="iOS-系列"><a href="#iOS-系列" class="headerlink" title="iOS 系列"></a>iOS 系列</h3><p><a href="https://mp.weixin.qq.com/s/vkbN_d3tR_Ym_gJYBVGCOw" target="_blank" rel="noopener">如何在 Swift 中实现状态机？</a></p><p>简言之：我们通常称作的状态机是有限状态机的简称，它是一种<strong>数学计算模型</strong>。</p><p><a href="https://mp.weixin.qq.com/s/DawFZMOuU5jbaw0Bi0gOhw" target="_blank" rel="noopener">避免 Swift 单元测试中的强制解析</a></p><p>强制解析（使用 <code>!</code>）是 Swift 语言中不可或缺的一个重要特点（特别是和 Objective-C 的接口混合使用时）。它回避了一些其他问题，使得 Swift 语言变得更加优秀。</p><p><a href="https://mp.weixin.qq.com/s/ZbZ4pFzzyfrQifmLewrxsw" target="_blank" rel="noopener">iOS 识别虚拟定位调研</a></p><p>最近业务开发中，有遇到我们的项目 app 定位被篡改的情况，在 android 端表现的尤为明显。为了防止这种黑产使用虚拟定位薅羊毛，iOS 也不得不进行虚拟定位的规避。</p><h3 id="实时文讯"><a href="#实时文讯" class="headerlink" title="实时文讯"></a>实时文讯</h3><p><a href="https://mp.weixin.qq.com/s/DwClglO_fOYDfLsINU_hdw" target="_blank" rel="noopener">Xcode 13 更新了哪些内容</a></p><p><a href="https://mp.weixin.qq.com/s/E5vTD9QDgKfVErWxCv4wjg" target="_blank" rel="noopener">开发者需要了解的 iOS 15</a></p><p><a href="https://mp.weixin.qq.com/s/4OGxPn-dgDc-jjtM-DtqGQ" target="_blank" rel="noopener">Xcode 13 正式版发布，来看看有什么新特性</a></p><h3 id="SwiftUI-系列"><a href="#SwiftUI-系列" class="headerlink" title="SwiftUI 系列"></a>SwiftUI 系列</h3><p><a href="https://mp.weixin.qq.com/s/K_i8bvcaHDfVMUsQTv3MOw" target="_blank" rel="noopener">为什么 SwiftUI 的修饰符顺序很重要</a></p><p>每当我们将修饰符应用于 <code>SwiftUI</code> 视图时，我们实际上都会创建一个，应用了更改的新视图 —— 我们不仅仅是修改现有的视图。</p><p><a href="https://mp.weixin.qq.com/s/gSeFOMrjze6KE_X6WwWAZQ" target="_blank" rel="noopener">为什么 SwiftUI 的视图使用结构体</a></p><p>如果您曾经为 <code>UIKit</code> 或 <code>AppKit</code>（Apple 的 iOS 和 macOS 原始用户界面框架）编程，您会知道它们使用类而非结构体来构造视图。<code>SwiftUI</code> 更喜欢将结构体用于整体视图。</p><p><a href="https://mp.weixin.qq.com/s/ZQSbu7dzwC-XbGcUcBkjAw" target="_blank" rel="noopener">如何结合 Core Data 和 SwiftUI</a></p><p><code>SwiftUI</code> 和 <code>Core Data</code> 之间相差将近十年。尽管时间相距遥远，Apple 还是投入了大量工作以确保这两种强大的技术能够完美地相互配合使用，这意味着 <code>Core Data</code> 就像始终以这种方式设计一样，已集成到 SwiftUI 中。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本期周报开始，将会引入&lt;strong&gt;推荐博文&lt;/strong&gt;模块，主要为大家分享展示优秀的 iOS 技术博文，如果大家阅读到优秀的文章欢迎在文末留言告诉小编，大家资源共享共同进步。&lt;/p&gt;
&lt;p&gt;iPhone 13 新品上架，你们都买了吗？苹果声称，iPhone 13 拥有全新的双摄像头系统，采用超快的 &lt;code&gt;A15&lt;/code&gt; 芯片，提高电池的续航能力。&lt;/p&gt;
&lt;p&gt;我们不仅要关注新的 iPhone 13，几天前，&lt;code&gt;Xcode 13&lt;/code&gt; 与 &lt;a href=&quot;https://forums.swift.org/t/swift-5-5-released/52247&quot; title=&quot;Swift 5.5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift 5.5&lt;/a&gt; 也一起发布了。这是 Swift 5.5 更新的&lt;a href=&quot;https://twitter.com/simjp/status/1440318174856036354&quot; title=&quot;列表&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;列表&lt;/a&gt;，这个版本发布了很多新功能。Xcode 13 的发布说明可以在这里找到：&lt;a href=&quot;https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15-release-notes&quot; title=&quot;iOS &amp;amp; iPadOS 15 Release Notes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS &amp;amp; iPadOS 15 Release Notes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在已经开始将&lt;strong&gt;并发&lt;/strong&gt;功能向后部署到旧的 Swift 版本上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了 Swift 社区周报持续稳定的发布更新，我们希望邀请 Swift 爱好者参与&lt;strong&gt;周报编辑&lt;/strong&gt;，同时邀请赞助商对我们平台赞助支持。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二期/</id>
    <published>2021-10-22T07:16:35.000Z</published>
    <updated>2021-10-22T07:17:56.669Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.apple.com/apple-events/" title="California streaming" target="_blank" rel="noopener">California streaming</a>. 我们都知道这意味着什么：马上将迎来重要的一天 —— <code>Apple</code> 宣布了 <strong>9 月 14 日</strong>的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— <a href="https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/" title="一种隐藏的 AR 体验" target="_blank" rel="noopener">一种隐藏的 AR 体验</a>，看起来很酷。 这也让全球的粉丝们纷纷猜测 <code>Apple</code> 即将发布的产品。</p><p>过去两周 <code>Swift 社区</code>非常活跃。 许多提案正在 <code>Swift</code> 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 <code>Swift</code> 保持现代语言的地位，所以让我们继续努力吧！</p><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释  <a href="https://www.swiftbysundell.com/articles/conditional-compilation-within-swift-expressions/" title="Conditional compilation within Swift expressions" target="_blank" rel="noopener">Swift 表达式中的条件编译</a>。</p><p><a href="https://twitter.com/gabtheodor" title="Gabriel Theodoropoulos" target="_blank" rel="noopener">Gabriel Theodoropoulos</a> 写了一篇博文解释了如何<a href="https://serialcoder.dev/text-tutorials/swift-tutorials/using-variadic-parameters-in-swift/" title="Using Variadic Parameters in Swift" target="_blank" rel="noopener">在 Swift 中使用可变参数</a>。</p><h2 id="Commits-和-pull-requests"><a href="#Commits-和-pull-requests" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39051" title="Add an option to build the concurrency library for back deployment" target="_blank" rel="noopener">添加了一个选项来构建并发库以进行后端部署</a>。</p><p><a href="https://github.com/fwcd" title="FW" target="_blank" rel="noopener">FW</a> 合并了一个<a href="https://github.com/apple/sourcekit-lsp/pull/414" title="Implement semantic highlighting for Swift" target="_blank" rel="noopener">为 Swift 实现语义高亮</a> 的 <code>pull request</code>。</p><h2 id="同意的提案"><a href="#同意的提案" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a> Package Registry Service - Publish Endpoint 已被<a href="https://forums.swift.org/t/accepted-se-0321-package-registry-service-publish-endpoint/51660" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">接受</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md" title="SE-0304" target="_blank" rel="noopener">SE-0304</a> Structured Concurrency <a href="https://forums.swift.org/t/se-0304-4th-review-structured-concurrency/50281" title="SE-0304 (4th review): Structured Concurrency" target="_blank" rel="noopener">第四次</a>审查被<a href="https://forums.swift.org/t/accepted-with-modifications-se-0304-structured-concurrency/51850" title="[Accepted with modifications] SE-0304: Structured Concurrency" target="_blank" rel="noopener">接受</a>。</p><h2 id="拒绝的提案"><a href="#拒绝的提案" class="headerlink" title="拒绝的提案"></a>拒绝的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a> 已返回进行<a href="https://forums.swift.org/t/returned-for-revision-se-0320-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51706" title="[Returned for revision] SE-0320: Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">修订</a>。</p><p>审查的反馈是积极的，社区成员建议作者和核心团队认为可以采用以下几项改进：</p><ol><li>在 <code>CodingKeyRepresentable</code> 中添加 <code>String</code> 和 <code>Int</code> 的一致性，这将允许在 <code>CodingKeyRepresentable</code> 用作通用约束时主动使用 <code>String</code> 和 <code>Int</code> 键。</li><li>使 <code>CodingKeyRepresentable</code> 协议的初始化通用。</li><li>为 <code>RawRepresentable</code> 的一致性提供默认实现（带有 <code>String</code> 和 <code>Int</code> 原始值）。</li><li>使内部 <code>_DictionaryCodingKey</code> 的初始值设定项 non-failable。</li></ol><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a>：允许将非 <code>String</code> / <code>Int</code> 键值 <code>Dictionary</code> 编码到 <code>KeyedContainer</code> 中 正在<a href="https://forums.swift.org/t/se-0320-2nd-review-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51710" title="SE-0320 (2nd review): Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">接受第二次审查</a>。</p><ul><li>第二次审查的重点是社区在第一次审查期间提出的改进建议，并通过 <a href="https://github.com/apple/swift-evolution/pull/1435" title="swift-evolution#1435" target="_blank" rel="noopener">swift-evolution#1435</a> 进行讨论。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0292-package-registry-service.md" title="SE-0292" target="_blank" rel="noopener">SE-0292</a>：Package Registry Service 修正<a href="https://github.com/apple/swift-evolution/pull/1410" title="修正 SE-0292 #1410" target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://forums.swift.org/t/amendment-se-0303-package-manager-extensible-build-tools/51763" title="SE-0303: Package Manager Extensible Build Tools" target="_blank" rel="noopener">SE-0303</a>：包管理器可扩展构建工具修正<a href="https://github.com/apple/swift-evolution/pull/1434" title="Amend SE-0303 to use @main for plugin entry point and adjust API accordingly #1434 " target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md" title="SE-0322" target="_blank" rel="noopener">SE-0322</a>：正在审查<a href="https://forums.swift.org/t/se-0322-temporary-uninitialized-buffers/51848" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>。</p><ul><li>该提案引入了新的标准库功能，用于操作临时缓冲区，这些缓冲区优先分配给堆栈，而不是堆。</li><li><code>Swift-evolution</code> 线程：[Pitch] <a href="https://forums.swift.org/t/pitch-temporary-uninitialized-buffers/48954" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a></li></ul><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://github.com/maustinstar" title="Michael Verges" target="_blank" rel="noopener">Michael Verges</a> 提出了<a href="https://forums.swift.org/t/pitching-optional-throws-in-swift/51650" title="Pitching Optional Throws in Swift" target="_blank" rel="noopener">在 Swift 中添加可选 <code>throws</code> 的提案</a>。</p><ul><li>在许多情况下，错误处理的权限不明确。开发者可能会质疑是处理还是传播错误。</li><li>选择抛出错误可以让调用者灵活地处理问题。</li><li>选择不抛出错误是为用户提供了简化语法（没有 <code>do-try-catch</code>）。</li></ul><p><a href="https://forums.swift.org/t/api-changes-for-0-2-0/51647" title="Karl" target="_blank" rel="noopener">Karl</a> 向社区通报了 <a href="https://karwa.github.io/swift-url/" title="WebURL" target="_blank" rel="noopener">WebURL</a> 0.2.0 版。</p><ul><li>我正准备发布 <code>WebURL 0.2.0</code> 版本 。 这将是一个非常重要的版本，包括用于与 <code>System.framework</code> 和 <code>swift-system</code> 包集成的 <code>WebURLSystemExtras</code> 模块，并使项目与 <code>URL</code> 标准的最新版本保持一致。</li></ul><p><a href="https://forums.swift.org/categories" title="Patrick Goley" target="_blank" rel="noopener">Patrick Goley</a> 提出了<a href="https://forums.swift.org/t/pitch-destructuring-assignment-of-structs-and-classes/51593" title="Destructuring Assignment of Structs and Classes" target="_blank" rel="noopener">添加结构和类的析构赋值</a>的建议。</p><ul><li>析构赋值是一项语言功能，允许你提取值的多个部分，并将其分配给单个赋值语句中的多个变量。</li></ul><p><a href="https://twitter.com/stephentyrone" title="Steve Canon" target="_blank" rel="noopener">Steve Canon</a> 宣布 <a href="https://forums.swift.org/t/1-0-0-release-notes/51641" title="Swift Numerics" target="_blank" rel="noopener">Swift Numerics</a> 的第一个稳定版本现已发布。</p><p>Austin 开始讨论 <a href="https://forums.swift.org/t/netlink-socket-support-in-swiftnio/51651" title="Netlink socket support in SwiftNIO" target="_blank" rel="noopener">SwiftNIO 中的 netlink 套接字支持</a>。</p><p><a href="https://forums.swift.org/categories" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 提出了一项实施 <a href="https://forums.swift.org/t/pitch-distributed-actors/51669" title="Distributed Actors" target="_blank" rel="noopener">Distributed Actors</a> 的提案。 </p><ul><li>随着最近 <code>Swift</code> 并发的引入，特别是该语言的参与者，<code>Swift</code> 在表达线程安全的并发程序方面获得了强大的基础构建。该提案旨在通过引入分布式参与者和与他们相关的位置透明度，扩大 <code>Swift</code>的参与者在分布式系统方面同样出色的工作能力。</li></ul><p><a href="https://twitter.com/maxdesiatov" title="Max Desiatov" target="_blank" rel="noopener">Max Desiatov</a> 告诉我们 <a href="https://forums.swift.org/t/swiftwasm-5-4-0-has-been-released/51753" title="SwiftWasm 5.4.0 has been released" target="_blank" rel="noopener">SwiftWasm 5.4.0</a> 已经发布。</p><ul><li>此版本与 <code>upstream</code> <code>Swift 5.4</code> 匹配，并允许您将 <code>Swift</code> 应用程序（只要它们不使用特定于其他平台的代码）编译到 <code>WebAssembly</code>，甚至可以在浏览器中运行。</li></ul><p><a href="https://forums.swift.org/categories" title="elsh" target="_blank" rel="noopener">elsh</a> 提出了添加<a href="https://forums.swift.org/t/pitch-module-aliasing/51737" title="Module Aliasing" target="_blank" rel="noopener">模块别名</a>支持的建议。</p><p>随着 <code>Swift</code> 库和软件包分布更加广泛，模块名称有时会发生冲突。由于 <code>Swift</code> 中还没有模块命名空间，在这种情况下，库经常被迫重命名或固定在旧的非冲突版本上。这使得以下用例具有挑战性：</p><ul><li><p>添加新的依赖项或升级，因为它可能会引入冲突：一个新的（或升级的）模块可以与依赖关系图中已经存在的另一个模块具有相同的名称。模块名称 <code>Logging</code> 是一个常见示例。</p></li><li><p>从上游库固定的旧版本升级到软件包的更新版本：考虑这样一个场景，其中 <code>MyApp</code> 依赖于模块 <code>Lib</code>，而 <code>Lib</code> 依赖于模块 <code>Logging</code>。 <code>MyApp</code> 还依赖于 <code>Logging</code>。 如果 <code>Lib</code> 固定到 <code>Logging 1.0.0</code>，则 <code>MyApp</code> 会停留在同一版本 <code>1.0.0</code>。</p></li></ul><p>2021年9月3日，服务器工作组的 <code>Swift</code> 宣布了一项<a href="https://forums.swift.org/t/september-3rd-2021-special-update/51766" title="September 3rd, 2021 Special Update" target="_blank" rel="noopener">特别更新</a>。</p><p><a href="https://forums.swift.org/t/pitch-introduce-expanded-parameters/51885" title="Introduce Expanded Parameters" target="_blank" rel="noopener">Isabel Lima</a> 向我们更新了有关<a href="https://forums.swift.org/t/add-shared-storage-to-property-wrappers/49898" title="Add shared storage to property wrappers " target="_blank" rel="noopener">添加 Property Wrappers 共享存储</a>的状态。</p><ul><li><code>Swift</code> 是一种允许我们编写富有表现力的 <code>API</code> 接口语言。通过<strong>约束泛型</strong>、<strong>方法重载</strong>、<strong>尾随闭包</strong>和<strong>默认参数</strong>等功能，您可以在实现相当灵活的 <code>API</code>的同时减少代码重复。本提案旨在使用 <code>@expanded</code>（函数参数的新属性）增加语言的这一部分。</li></ul><p><a href="https://github.com/johnno1962" title="John Holdsworth" target="_blank" rel="noopener">John Holdsworth</a> 提议引入 <a href="https://forums.swift.org/t/introducing-an-unwrap-or-throw-operator/51905" title="Introducing an “Unwrap or Throw” operator" target="_blank" rel="noopener"> Unwrap 或 Throw 运算符</a>。</p><ul><li><p>该提议是之前 <a href="https://forums.swift.org/t/pitch-introducing-the-unwrap-or-die-operator-to-the-standard-library/6207" title="[Pitch] Introducing the “Unwrap or Die” operator to the standard library" target="_blank" rel="noopener">[Pitch] Introducing the “Unwrap or Die” operator to the standard library</a> 以及最近 <a href="https://forums.swift.org/t/moving-toward-deprecating-force-unwrap-from-swift/43455" title="Moving toward deprecating force unwrap from Swift?" target="_blank" rel="noopener">Moving toward deprecating force unwrap from Swift?</a> 两个有争议提议的延伸。 后一个提议除了被锁定之外没有得出结论，这个提议在前一个提议上取而代之，建议使用 “<code>Unwrap or Throw</code>” 运算符可能是解决 <code>Swift</code> 中强制解包问题的更好解决方案，这让我很疑惑，我相信当用户的应用程序崩溃时，会影响到用户使用。</p></li><li><h1 id="总之，我想提出一个-运算符，强制打开和-nil-并之间的交叉，如果可选是-nil，则抛出。"><a href="#总之，我想提出一个-运算符，强制打开和-nil-并之间的交叉，如果可选是-nil，则抛出。" class="headerlink" title="总之，我想提出一个 !! 运算符，强制打开和 nil 并之间的交叉，如果可选是 nil，则抛出。"></a>总之，我想提出一个 <code>!!</code> 运算符，强制打开和 <code>nil</code> 并之间的交叉，如果可选是 <code>nil</code>，则抛出。</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2></li></ul><p><a href="https://www.apple.com/apple-events/" title="California streaming" target="_blank" rel="noopener">California streaming</a>. 我们都知道这意味着什么：马上将迎来重要的一天 —— <code>Apple</code> 宣布了 <strong>9 月 14 日</strong>的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— <a href="https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/" title="一种隐藏的 AR 体验" target="_blank" rel="noopener">一种隐藏的 AR 体验</a>，看起来很酷。 这也让全球的粉丝们纷纷猜测 <code>Apple</code> 即将发布的产品。</p><p>过去两周 <code>Swift 社区</code>非常活跃。 许多提案正在 <code>Swift</code> 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 <code>Swift</code> 保持现代语言的地位，所以让我们继续努力吧！</p><h2 id="新闻和社区-1"><a href="#新闻和社区-1" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释  <a href="https://www.swiftbysundell.com/articles/conditional-compilation-within-swift-expressions/" title="Conditional compilation within Swift expressions" target="_blank" rel="noopener">Swift 表达式中的条件编译</a>。</p><p><a href="https://twitter.com/gabtheodor" title="Gabriel Theodoropoulos" target="_blank" rel="noopener">Gabriel Theodoropoulos</a> 写了一篇博文解释了如何<a href="https://serialcoder.dev/text-tutorials/swift-tutorials/using-variadic-parameters-in-swift/" title="Using Variadic Parameters in Swift" target="_blank" rel="noopener">在 Swift 中使用可变参数</a>。</p><h2 id="Commits-和-pull-requests-1"><a href="#Commits-和-pull-requests-1" class="headerlink" title="Commits 和 pull requests"></a>Commits 和 pull requests</h2><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 合并了一个 <code>pull request</code>，该请求<a href="https://github.com/apple/swift/pull/39051" title="Add an option to build the concurrency library for back deployment" target="_blank" rel="noopener">添加了一个选项来构建并发库以进行后端部署</a>。</p><p><a href="https://github.com/fwcd" title="FW" target="_blank" rel="noopener">FW</a> 合并了一个<a href="https://github.com/apple/sourcekit-lsp/pull/414" title="Implement semantic highlighting for Swift" target="_blank" rel="noopener">为 Swift 实现语义高亮</a> 的 <code>pull request</code>。</p><h2 id="同意的提案-1"><a href="#同意的提案-1" class="headerlink" title="同意的提案"></a>同意的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a> Package Registry Service - Publish Endpoint 已被<a href="https://forums.swift.org/t/accepted-se-0321-package-registry-service-publish-endpoint/51660" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">接受</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md" title="SE-0304" target="_blank" rel="noopener">SE-0304</a> Structured Concurrency <a href="https://forums.swift.org/t/se-0304-4th-review-structured-concurrency/50281" title="SE-0304 (4th review): Structured Concurrency" target="_blank" rel="noopener">第四次</a>审查被<a href="https://forums.swift.org/t/accepted-with-modifications-se-0304-structured-concurrency/51850" title="[Accepted with modifications] SE-0304: Structured Concurrency" target="_blank" rel="noopener">接受</a>。</p><h2 id="拒绝的提案-1"><a href="#拒绝的提案-1" class="headerlink" title="拒绝的提案"></a>拒绝的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a> 已返回进行<a href="https://forums.swift.org/t/returned-for-revision-se-0320-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51706" title="[Returned for revision] SE-0320: Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">修订</a>。</p><p>审查的反馈是积极的，社区成员建议作者和核心团队认为可以采用以下几项改进：</p><ol><li>在 <code>CodingKeyRepresentable</code> 中添加 <code>String</code> 和 <code>Int</code> 的一致性，这将允许在 <code>CodingKeyRepresentable</code> 用作通用约束时主动使用 <code>String</code> 和 <code>Int</code> 键。</li><li>使 <code>CodingKeyRepresentable</code> 协议的初始化通用。</li><li>为 <code>RawRepresentable</code> 的一致性提供默认实现（带有 <code>String</code> 和 <code>Int</code> 原始值）。</li><li>使内部 <code>_DictionaryCodingKey</code> 的初始值设定项 non-failable。</li></ol><h2 id="正在审查的提案-1"><a href="#正在审查的提案-1" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md" title="SE-0320" target="_blank" rel="noopener">SE-0320</a>：允许将非 <code>String</code> / <code>Int</code> 键值 <code>Dictionary</code> 编码到 <code>KeyedContainer</code> 中 正在<a href="https://forums.swift.org/t/se-0320-2nd-review-coding-of-non-string-int-keyed-dictionary-into-a-keyedcontainer/51710" title="SE-0320 (2nd review): Coding of non String / Int keyed Dictionary into a KeyedContainer" target="_blank" rel="noopener">接受第二次审查</a>。</p><ul><li>第二次审查的重点是社区在第一次审查期间提出的改进建议，并通过 <a href="https://github.com/apple/swift-evolution/pull/1435" title="swift-evolution#1435" target="_blank" rel="noopener">swift-evolution#1435</a> 进行讨论。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0292-package-registry-service.md" title="SE-0292" target="_blank" rel="noopener">SE-0292</a>：Package Registry Service 修正<a href="https://github.com/apple/swift-evolution/pull/1410" title="修正 SE-0292 #1410" target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://forums.swift.org/t/amendment-se-0303-package-manager-extensible-build-tools/51763" title="SE-0303: Package Manager Extensible Build Tools" target="_blank" rel="noopener">SE-0303</a>：包管理器可扩展构建工具修正<a href="https://github.com/apple/swift-evolution/pull/1434" title="Amend SE-0303 to use @main for plugin entry point and adjust API accordingly #1434 " target="_blank" rel="noopener">正在审查中</a>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md" title="SE-0322" target="_blank" rel="noopener">SE-0322</a>：正在审查<a href="https://forums.swift.org/t/se-0322-temporary-uninitialized-buffers/51848" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a>。</p><ul><li>该提案引入了新的标准库功能，用于操作临时缓冲区，这些缓冲区优先分配给堆栈，而不是堆。</li><li><code>Swift-evolution</code> 线程：[Pitch] <a href="https://forums.swift.org/t/pitch-temporary-uninitialized-buffers/48954" title="Temporary uninitialized buffers" target="_blank" rel="noopener">临时未初始化缓冲区</a></li></ul><h2 id="Swift-论坛-1"><a href="#Swift-论坛-1" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://github.com/maustinstar" title="Michael Verges" target="_blank" rel="noopener">Michael Verges</a> 提出了<a href="https://forums.swift.org/t/pitching-optional-throws-in-swift/51650" title="Pitching Optional Throws in Swift" target="_blank" rel="noopener">在 Swift 中添加可选 <code>throws</code> 的提案</a>。</p><ul><li>在许多情况下，错误处理的权限不明确。开发者可能会质疑是处理还是传播错误。</li><li>选择抛出错误可以让调用者灵活地处理问题。</li><li>选择不抛出错误是为用户提供了简化语法（没有 <code>do-try-catch</code>）。</li></ul><p><a href="https://forums.swift.org/t/api-changes-for-0-2-0/51647" title="Karl" target="_blank" rel="noopener">Karl</a> 向社区通报了 <a href="https://karwa.github.io/swift-url/" title="WebURL" target="_blank" rel="noopener">WebURL</a> 0.2.0 版。</p><ul><li>我正准备发布 <code>WebURL 0.2.0</code> 版本 。 这将是一个非常重要的版本，包括用于与 <code>System.framework</code> 和 <code>swift-system</code> 包集成的 <code>WebURLSystemExtras</code> 模块，并使项目与 <code>URL</code> 标准的最新版本保持一致。</li></ul><p><a href="https://forums.swift.org/categories" title="Patrick Goley" target="_blank" rel="noopener">Patrick Goley</a> 提出了<a href="https://forums.swift.org/t/pitch-destructuring-assignment-of-structs-and-classes/51593" title="Destructuring Assignment of Structs and Classes" target="_blank" rel="noopener">添加结构和类的析构赋值</a>的建议。</p><ul><li>析构赋值是一项语言功能，允许你提取值的多个部分，并将其分配给单个赋值语句中的多个变量。</li></ul><p><a href="https://twitter.com/stephentyrone" title="Steve Canon" target="_blank" rel="noopener">Steve Canon</a> 宣布 <a href="https://forums.swift.org/t/1-0-0-release-notes/51641" title="Swift Numerics" target="_blank" rel="noopener">Swift Numerics</a> 的第一个稳定版本现已发布。</p><p>Austin 开始讨论 <a href="https://forums.swift.org/t/netlink-socket-support-in-swiftnio/51651" title="Netlink socket support in SwiftNIO" target="_blank" rel="noopener">SwiftNIO 中的 netlink 套接字支持</a>。</p><p><a href="https://forums.swift.org/categories" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 提出了一项实施 <a href="https://forums.swift.org/t/pitch-distributed-actors/51669" title="Distributed Actors" target="_blank" rel="noopener">Distributed Actors</a> 的提案。 </p><ul><li>随着最近 <code>Swift</code> 并发的引入，特别是该语言的参与者，<code>Swift</code> 在表达线程安全的并发程序方面获得了强大的基础构建。该提案旨在通过引入分布式参与者和与他们相关的位置透明度，扩大 <code>Swift</code>的参与者在分布式系统方面同样出色的工作能力。</li></ul><p><a href="https://twitter.com/maxdesiatov" title="Max Desiatov" target="_blank" rel="noopener">Max Desiatov</a> 告诉我们 <a href="https://forums.swift.org/t/swiftwasm-5-4-0-has-been-released/51753" title="SwiftWasm 5.4.0 has been released" target="_blank" rel="noopener">SwiftWasm 5.4.0</a> 已经发布。</p><ul><li>此版本与 <code>upstream</code> <code>Swift 5.4</code> 匹配，并允许您将 <code>Swift</code> 应用程序（只要它们不使用特定于其他平台的代码）编译到 <code>WebAssembly</code>，甚至可以在浏览器中运行。</li></ul><p><a href="https://forums.swift.org/categories" title="elsh" target="_blank" rel="noopener">elsh</a> 提出了添加<a href="https://forums.swift.org/t/pitch-module-aliasing/51737" title="Module Aliasing" target="_blank" rel="noopener">模块别名</a>支持的建议。</p><p>随着 <code>Swift</code> 库和软件包分布更加广泛，模块名称有时会发生冲突。由于 <code>Swift</code> 中还没有模块命名空间，在这种情况下，库经常被迫重命名或固定在旧的非冲突版本上。这使得以下用例具有挑战性：</p><ul><li><p>添加新的依赖项或升级，因为它可能会引入冲突：一个新的（或升级的）模块可以与依赖关系图中已经存在的另一个模块具有相同的名称。模块名称 <code>Logging</code> 是一个常见示例。</p></li><li><p>从上游库固定的旧版本升级到软件包的更新版本：考虑这样一个场景，其中 <code>MyApp</code> 依赖于模块 <code>Lib</code>，而 <code>Lib</code> 依赖于模块 <code>Logging</code>。 <code>MyApp</code> 还依赖于 <code>Logging</code>。 如果 <code>Lib</code> 固定到 <code>Logging 1.0.0</code>，则 <code>MyApp</code> 会停留在同一版本 <code>1.0.0</code>。</p></li></ul><p>2021年9月3日，服务器工作组的 <code>Swift</code> 宣布了一项<a href="https://forums.swift.org/t/september-3rd-2021-special-update/51766" title="September 3rd, 2021 Special Update" target="_blank" rel="noopener">特别更新</a>。</p><p><a href="https://forums.swift.org/t/pitch-introduce-expanded-parameters/51885" title="Introduce Expanded Parameters" target="_blank" rel="noopener">Isabel Lima</a> 向我们更新了有关<a href="https://forums.swift.org/t/add-shared-storage-to-property-wrappers/49898" title="Add shared storage to property wrappers " target="_blank" rel="noopener">添加 Property Wrappers 共享存储</a>的状态。</p><ul><li><code>Swift</code> 是一种允许我们编写富有表现力的 <code>API</code> 接口语言。通过<strong>约束泛型</strong>、<strong>方法重载</strong>、<strong>尾随闭包</strong>和<strong>默认参数</strong>等功能，您可以在实现相当灵活的 <code>API</code>的同时减少代码重复。本提案旨在使用 <code>@expanded</code>（函数参数的新属性）增加语言的这一部分。</li></ul><p><a href="https://github.com/johnno1962" title="John Holdsworth" target="_blank" rel="noopener">John Holdsworth</a> 提议引入 <a href="https://forums.swift.org/t/introducing-an-unwrap-or-throw-operator/51905" title="Introducing an “Unwrap or Throw” operator" target="_blank" rel="noopener"> Unwrap 或 Throw 运算符</a>。</p><ul><li><p>该提议是之前 <a href="https://forums.swift.org/t/pitch-introducing-the-unwrap-or-die-operator-to-the-standard-library/6207" title="[Pitch] Introducing the “Unwrap or Die” operator to the standard library" target="_blank" rel="noopener">[Pitch] Introducing the “Unwrap or Die” operator to the standard library</a> 以及最近 <a href="https://forums.swift.org/t/moving-toward-deprecating-force-unwrap-from-swift/43455" title="Moving toward deprecating force unwrap from Swift?" target="_blank" rel="noopener">Moving toward deprecating force unwrap from Swift?</a> 两个有争议提议的延伸。 后一个提议除了被锁定之外没有得出结论，这个提议在前一个提议上取而代之，建议使用 “<code>Unwrap or Throw</code>” 运算符可能是解决 <code>Swift</code> 中强制解包问题的更好解决方案，这让我很疑惑，我相信当用户的应用程序崩溃时，会影响到用户使用。</p></li><li><p>总之，我想提出一个 <code>!!</code> 运算符，强制打开和 <code>nil</code> 并之间的交叉，如果可选是 <code>nil</code>，则抛出。</p></li></ul><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.apple.com/apple-events/&quot; title=&quot;California streaming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;California streaming&lt;/a&gt;. 我们都知道这意味着什么：马上将迎来重要的一天 —— &lt;code&gt;Apple&lt;/code&gt; 宣布了 &lt;strong&gt;9 月 14 日&lt;/strong&gt;的活动！ 他们在活动邀请中隐藏了一个彩蛋 —— &lt;a href=&quot;https://9to5mac.com/2021/09/07/apple-hypes-next-weeks-iphone-13-event-with-ar-portal-experience/&quot; title=&quot;一种隐藏的 AR 体验&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一种隐藏的 AR 体验&lt;/a&gt;，看起来很酷。 这也让全球的粉丝们纷纷猜测 &lt;code&gt;Apple&lt;/code&gt; 即将发布的产品。&lt;/p&gt;
&lt;p&gt;过去两周 &lt;code&gt;Swift 社区&lt;/code&gt;非常活跃。 许多提案正在 &lt;code&gt;Swift&lt;/code&gt; 迭代中产生，有些已经同意或拒绝，有些仍在审查中。 这些提议有助于促进 &lt;code&gt;Swift&lt;/code&gt; 保持现代语言的地位，所以让我们继续努力吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第一期/</id>
    <published>2021-10-22T07:14:13.000Z</published>
    <updated>2021-10-22T07:17:18.773Z</updated>
    
    <content type="html"><![CDATA[<p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从本周开始，我们 Swift 社区公众号将开始与 SwiftWeekly 合作更新关于 Swift 社区最新的进展与动向。让我们乘着社区的风帆，一起荡起双桨，让 Swift 成为世界上最好的语言。</p><a id="more"></a><h2 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h2><p>在 Swift by Sundell 播客的<a href="https://www.swiftbysundell.com/podcast/103/" title="Swift by Sundell 第 103 期" target="_blank" rel="noopener">第 103 期</a>中，SwiftLee 的创建者 <a href="https://twitter.com/twannl" title="Antoine van der Lee" target="_blank" rel="noopener">Antoine van der Lee</a> 加入了 <a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a>。</p><p>他们从新的 concurrency 系统到 convenience 特性以及各种改进等方向讨论了 Swift 5.5 新引入的一部分功能。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><p>Xcode 各版本的 <a href="https://developer.apple.com/cn/support/xcode/" title="最低要求和支持的 SDK" target="_blank" rel="noopener">最低要求和支持的 SDK</a></p><p><a href="https://twitter.com/twannl" title="Antoine van der Lee" target="_blank" rel="noopener">Antoine van der Lee</a> 写了一篇博文，<a href="https://www.avanderlee.com/swift/unwrap-or-throw/" title="Unwrap or throw: Exploring solutions in Swift" target="_blank" rel="noopener">探讨在 Swift 中解包或 throw 的解决方案</a>。</p><p><a href="https://twitter.com/Leo_Pugliese" title="Leonardo Maia Pugliese" target="_blank" rel="noopener">Leonardo Maia Pugliese</a> 写了一篇关于<a href="https://holyswift.app/how-to-do-apis-constraints-with-available-in-swift" title="How to do APIs constraints with @Available in Swift" target="_blank" rel="noopener">如何在 Swift 中使用 @available 进行 API 约束</a>的博客文章。</p><p><a href="https://twitter.com/johnsundell" title="John Sundell" target="_blank" rel="noopener">John Sundell</a> 写了一篇文章解释了如何<a href="https://www.swiftbysundell.com/articles/using-an-unknown-default-case-within-a-switch-statement/" title="Using ‘@unknown default’ within switch statements" target="_blank" rel="noopener">在 switch 语句中使用 @unknown default</a>。</p><p><a href="https://twitter.com/basthomas" title="Bas Broek" target="_blank" rel="noopener">Bas Broek</a> 写了一篇博文，探讨如何在 Swift 中<a href="https://www.basbroek.nl/deprecating-workarounds" title="Deprecating Workarounds" target="_blank" rel="noopener">弃用 Workarounds</a>。</p><h2 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0321-package-registry-publish.md" title="SE-0321" target="_blank" rel="noopener">SE-0321</a>: Package Registry Service - Publish Endpoint 正在<a href="https://forums.swift.org/t/se-0321-package-registry-service-publish-endpoint/51286" title="Package Registry Service - Publish Endpoint" target="_blank" rel="noopener">审查中</a></p><p>软件包注册表负责确定哪些软件包版本可提供给消费者使用。</p><p>目前，软件包版本的可用性由 <code>out-of-band</code> 流程决定。例如，注册表可以查询公共 Swift 软件包的索引，并为每个标签提供具有有效版本号的版本。</p><p>拥有发布新版本到软件包注册表的标准端点将增强维护者分发其软件的能力，并促进服务提供商之间的互操作性。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p><a href="https://forums.swift.org/categories" title="Dimitri Racordon" target="_blank" rel="noopener">Dimitri Racordon</a> 提出了一个<a href="https://forums.swift.org/t/pitch-protocols-with-private-fields/51209" title="Protocols with private fields" target="_blank" rel="noopener">用私有字段实现协议的想法</a>。</p><p>在协议中，所有字段（<code>properties</code> 和 <code>methods</code>）都将获得符合条件类型的访问可见性。例如，符合具有公共类型的协议将提示其所有要求都是公共的。</p><p><a href="https://forums.swift.org/categories" title="Evan Wilde" target="_blank" rel="noopener">Evan Wilde</a> 提出了一项<a href="https://forums.swift.org/t/pitch-revisit-the-semantics-of-async-main/51254" title="Revisit the semantics of async main" target="_blank" rel="noopener">重新审视 async main 语义</a>的提案。</p><ul><li>main 函数应该同步运行到第一个暂停点</li><li>main 函数应该在 <code>main actor</code> 上运行</li><li>MainActor 应该为默认的 <code>runloop</code> 行为提供用户指定的替代方案。</li><li>main 任务应该从 <code>getCurrentThreadPriority</code> 拉取优先级，而不是 <code>hard-coded</code> 默认优先级</li></ul><p><a href="https://forums.swift.org/u/abertelrud" title="Anders Bertelrud" target="_blank" rel="noopener">Anders Bertelrud</a> 提议修改 SE-0303：插件 API，使用 @main 作为插件入口点。</p><p>我想提议修改 <code>SE-0303</code>，<code>SwiftPM</code> 插件使用 <code>@main</code> 作为入口点，而不是 <code>top-level</code> 作为入口点。 虽然这样做有点冗长，但是可以为每种插件定制入口点，并且还可以更加清楚地说明每个插件的输入和预期输出是什么。</p><p><a href="https://forums.swift.org/u/saklad5" title="Jeremy Saklad" target="_blank" rel="noopener">Jeremy Saklad</a> 提出了一项提案，该提案将<a href="https://forums.swift.org/t/allow-use-of-concrete-associated-type-of-protocols/51277" title="Allow use of concrete associated type of protocols" target="_blank" rel="noopener">允许使用具体的相关协议类型</a>。</p><p><a href="https://twitter.com/lorentey" title="Karoy Lorentey" target="_blank" rel="noopener">Karoy Lorentey</a> 发布了 <a href="https://forums.swift.org/t/announcement-planning-for-swift-collections-v1-0/51321" title="Planning for Swift Collections v1.0" target="_blank" rel="noopener">Swift Collections 1.0 版</a>。</p><p><a href="https://forums.swift.org/u/ktoso" title="Konrad ktoso Malawski" target="_blank" rel="noopener">Konrad ktoso Malawski</a> 发布了 Swift Server Workgroup <a href="https://forums.swift.org/t/august-4th-2021/51315" title="August 4th 2021" target="_blank" rel="noopener">2021 年 8 月 4 日的会议记录</a>。</p><p><a href="https://twitter.com/dgregor79" title="Doug Gregor" target="_blank" rel="noopener">Doug Gregor</a> 提出了 <a href="https://forums.swift.org/t/pitch-staging-in-sendable-checking/51341" title="Staging in Sendable checking" target="_blank" rel="noopener">在 Sendable 检查中实施 Staging</a> 的提案。</p><p><code>SE-0302</code> 引入了 Sendable 协议，该协议明确地指出哪些类型的值可以安全地跨过 <code>actors</code> 进行复制。通俗的讲，就是拷贝的值和原始值可以同时在上下文使用。</p><p>Sendable 检查在所有 Swift 代码中应用，消除了由 <code>shared mutable state</code> 引起的大量数据竞争。Swift 5.5 没有完全实现 Sendable 检查，因为这样做会导致太多的编译器 <code>errors</code> 和 <code>diagnostics</code>，从而导致该功能不可用。</p><p>我认为可以逐步采用 Sendable 检查来提高数据竞争的安全性。我们提出了两个想法分段完成 Sendable 检查:</p><ul><li>增量采用并发并且引入更多的 Sendable 检查。</li><li>不能让用户模块之外的 Sendable 问题阻挡进度，防止过度的注释</li></ul><p><a href="https://forums.swift.org/categories" title="Aura Lily Vulcano" target="_blank" rel="noopener">Aura Lily Vulcano</a> 推荐了一个 <a href="https://forums.swift.org/t/pitch-the-cstdlib-module/51373" title="The CStdlib module" target="_blank" rel="noopener">Swift 默认提供的新模块</a>。</p><p>该模块将重新导出包含当前平台的 <code>POSIX</code> 或类似 <code>POSIX</code> 的 C 标准库的正确模块（如果有的话）。</p><p>默认情况该模块不会被导入，但是允许 “reasonably cross-platform” 代码，以避免使用冗长的 <code>#if canImport(…)</code> 链来访问所有的标准库，因为它们在不同的操作系统上有不同的名称。</p><p>例如，模块可以命名为 CStdlib。</p><p>Robert Widmann（<a href="https://twitter.com/CodaFi_" title="CodaFi_" target="_blank" rel="noopener">@CodaFi_</a>）提出了一个关于<a href="https://forums.swift.org/t/pitching-the-start-of-variadic-generics/51467" title="The Start of Variadic Generics" target="_blank" rel="noopener">开始可变参数泛型</a>的想法。</p><p>作为改进泛型系统的人体工程学的一部分，以及为使用 tuples 抽象提供更好的支持，我想用 surface syntax 和 preliminary semantics 来实现这个想法。 由于这是一个很大的主题领域，对语言和后续提案的方向都有很大影响，因此你的反馈在此阶段对于塑造此功能集的方向至关重要。</p><p>我要感谢 <strong>Alejandro Alonso</strong>, <strong>Doug Gregor</strong> 和 <strong>Slava Pestov</strong>，感谢他们为我在这个问题上的思考奠定了基础。</p><p>可以在这里看到原文的链接 <a href="https://gist.github.com/CodaFi/a461aca155b16cd4d05a2635e7d7a361" title="TypeSequences.md · GitHub" target="_blank" rel="noopener">TypeSequences.md · GitHub</a></p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>感谢 SwiftWeekly 与我们的合作，开启 Swift 周报中文版发布之旅。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们，扫码添加微信</p><p><img width="300" alt="fzhanfei" src="https://files.mdnice.com/user/17787/9a7911bf-75f2-40f5-866b-3171868bb92c.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从本周开始，我们 Swift 社区公众号将开始与 SwiftWeekly 合作更新关于 Swift 社区最新的进展与动向。让我们乘着社区的风帆，一起荡起双桨，让 Swift 成为世界上最好的语言。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>如何将 Swift 代码添加为自定义 LLDB 命令</title>
    <link href="https://fanbaoying.github.io/%E5%A6%82%E4%BD%95%E5%B0%86-Swift-%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89-LLDB-%E5%91%BD%E4%BB%A4/"/>
    <id>https://fanbaoying.github.io/如何将-Swift-代码添加为自定义-LLDB-命令/</id>
    <published>2021-06-07T12:59:57.000Z</published>
    <updated>2021-06-07T13:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://swiftsenpai.com/testing/add-custom-lldb/" title="Adding Swift Code as Custom LLDB Command" target="_blank" rel="noopener">Adding Swift Code as Custom LLDB Command</a></p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 <code>po</code>。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？</p><p>在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：</p><ul><li>添加你的第一个 LLDB 命令</li><li>添加带参数的 LLDB 命令</li><li>将复杂的 Swift 代码转换为 LLDB 命令</li></ul><a id="more"></a><h2 id="2-添加您的第一个-LLDB-命令"><a href="#2-添加您的第一个-LLDB-命令" class="headerlink" title="2. 添加您的第一个 LLDB 命令"></a>2. 添加您的第一个 LLDB 命令</h2><h3 id="2-1-了解-LLDB-命令结构"><a href="#2-1-了解-LLDB-命令结构" class="headerlink" title="2.1 了解 LLDB 命令结构"></a>2.1 了解 LLDB 命令结构</h3><p>为了添加自定义 LLDB 命令，我们必须利用 <code>command alias</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias [command_name] expr -l Swift -O -- [swift_code]</span><br></pre></td></tr></table></figure><p><strong>对命令进行详细分解：</strong></p><ul><li><code>command alias</code>：使用名称为 Swift 代码添加别名的 LLDB 命令</li><li><code>[command_name]</code>: 自定义命令名称</li><li><code>expr -l Swift -O --</code>: 要求 LLDB 调试器将后面的所有内容解释为 Swift 代码</li><li><code>[swift_code]</code>：定义自定义命令逻辑的 Swift 代码</li></ul><p>举例说明，如果我们要添加一个别名为 <code>greet</code> 的自定义命令，在控制台上打印结果为 “Hello World！” ，LLDB 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command alias greet expr -l Swift -O -- print(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-2-添加自定义命令"><a href="#2-2-添加自定义命令" class="headerlink" title="2.2 添加自定义命令"></a>2.2 添加自定义命令</h3><p>现在已经构造了别名为 <code>greet</code> 的命令，然后添加到 LLDB 调试器中。</p><p>将 <code>greet</code> 命令添加到 LLDB 调试器的最直接方法是在 Xcode 控制台中执行别名命令。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a9a2981a3d603298.gif?imageMogr2/auto-orient/strip" alt=""></p><p>但是，这样做只会使 <code>greet</code> 命令在当前特定调试会话中可用。 也就是说，每当开始新的调试会话时，我们就需要重新键入相同的别名命令。</p><p>为了避免这种情况发生，我们可以利用位于主目录中的 <code>.lldbinit</code> 文件。 <strong>请注意</strong>，这是一个隐藏文件，如果看不到该文件，可以使用以下快捷方式在你的查找器中显示隐藏文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift + command + .</span><br></pre></td></tr></table></figure><p>如果在 finder 中启用了显示隐藏文件，仍然没有找到该文件，可以在根目录下使用下面的终端命令创建一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.lldbinit</span><br></pre></td></tr></table></figure><p>之后，打开 <code>.lldbinit</code> 文件将整个别名命令粘贴到文件中。这样，Xcode 将在每次启动新的调试会话时执行别名命令。</p><blockquote><p><strong>Pro Tip:</strong> 如果不想在每次更新 <code>.lldbinit</code> 文件时都重新启动调试会话，可以使用以下命令重新加载它：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command source ~/.lldbinit</span><br></pre></td></tr></table></figure><h2 id="3-添加带参数的-LLDB-命令"><a href="#3-添加带参数的-LLDB-命令" class="headerlink" title="3. 添加带参数的 LLDB 命令"></a>3. 添加带参数的 LLDB 命令</h2><p>接着，让我们尝试添加一个能够接受参数的命令。 在上面 greet 命令的基础上进行修改，使其能够接受一个字符串并且打印出问候消息。</p><p>这一次，我们将使用 <code>command regex</code> LLDB 命令。它结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex [command_name] &apos;s/[regex]/expr -l Swift -O -- [swift_code]/&apos;</span><br></pre></td></tr></table></figure><p>这里对 regex 命令的工作原理不做详细描述。 通常，是将 [regex] 替换为正则表达式语句 (.+)，然后在 Swift 代码中使用 %1 表示参数。</p><p>更新 <code>greet</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+)/expr -l Swift -O -- print(&quot;Hello \(%1)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name = &quot;Swift Senpai&quot;</code> 执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name</span><br><span class="line">Hello Swift Senpai!</span><br></pre></td></tr></table></figure><p>到这里，你可能会问：如果我需要传入多个参数怎么办？ 答案其实很简单。</p><p>首先，将多个 <code>(.+)</code> 添加到正则表达式语句并用空格分隔每个 <code>(.+)</code>。 之后，使用 <code>%2</code>, <code>%3</code>, <code>%4</code>… 来表示 Swift 代码中的每个参数。</p><p>将 <code>greet</code> 命令更新为支持两个参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex greet &apos;s/(.+) (.+)/expr -l Swift -O -- print(&quot;Hello (%1) and (%2)!&quot;)/&apos;</span><br></pre></td></tr></table></figure><p>假设 <code>name1 = &quot;Swift Senpai&quot;</code> 和 <code>name2 = &quot;iOS developers&quot;</code>，使用该命令，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) greet name1 name2</span><br><span class="line">Hello Swift Senpai and iOS developers!</span><br></pre></td></tr></table></figure><p>到这里，我们已经了解了如何添加带有多个参数的自定义 LLDB 命令。 下面，将向你展示如何将多行 Swift 函数转换为自定义 LLDB 命令。</p><h2 id="将复杂的-Swift-代码转换为-LLDB-命令"><a href="#将复杂的-Swift-代码转换为-LLDB-命令" class="headerlink" title="将复杂的 Swift 代码转换为 LLDB 命令"></a>将复杂的 Swift 代码转换为 LLDB 命令</h2><p>通过前面的介绍，我们知道添加自定义 Swift 代码作为 LLDB 命令，必须在一行中完成。因此，如果有一个多行的 Swift 函数，我们必须先将其转换为单行，然后才能将其添加到 <code>.lldbinit</code> 文件中。</p><p>比如要添加下面这个将 RGB 值转换为十六进制值的 Swift 函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hex</span><span class="params">(r: Int, g: Int, b: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(hex)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上面的代码注释使用的是 <code>/* */</code> 而不是 <code>//</code>,这是为了确保将 Swift 代码转换为单行后不会中断。</p><p>下面我们需要将 Swift 代码转换为一行，操作流程如下：</p><ol><li>为每个函数参数定义一个变量。</li><li>将 <code>%1</code>、<code>%2</code>、<code>%3</code>… 分配给每个定义的变量。</li><li>在每个语句的末尾添加 <code>;</code>。</li></ol><p>更新后的 Swift 代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = %<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> g = %<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> b = %<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure RGB value within range */</span></span><br><span class="line"><span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= <span class="number">255</span>) &amp;&amp; (g &gt;= <span class="number">0</span> &amp;&amp; g &lt;= <span class="number">255</span>) &amp;&amp; (b &gt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">255</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rgb:<span class="type">Int</span> = r&lt;&lt;<span class="number">16</span> | g&lt;&lt;<span class="number">8</span> | b&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> hex = <span class="type">String</span>(format:<span class="string">"#%06x"</span>, rgb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(hex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid input value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们需要将 Swift 代码转换为一行，我比较喜欢使用这个<a href="https://www.textfixer.com/tools/paragraph-to-lines.php" title="代码单行转换工具" target="_blank" rel="noopener">免费在线工具</a>进行单行转换</p><p>将代码转换为单行后，就可以进行构造正则表达式命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command regex hex &apos;s/(.+) (.+) (.+)/expr -l Swift -O -- let r = %1; let g = %2; let b = %3; if (r &gt;= 0 &amp;&amp; r &lt;= 255) &amp;&amp; (g &gt;= 0 &amp;&amp; g &lt;= 255) &amp;&amp; (b &gt;= 0 &amp;&amp; b &lt;= 255) &#123; let rgb:Int = r&lt;&lt;16 | g&lt;&lt;8 | b&lt;&lt;0; let hex = String(format:&quot;#%06x&quot;, rgb); print(hex); &#125; else &#123; print(&quot;Invalid input value&quot;); &#125;/&apos;</span><br></pre></td></tr></table></figure><p>将命令粘贴到 <code>.lldbinit</code> 文件中，然后就可以使用了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-28714c53ef002c05.gif?imageMogr2/auto-orient/strip" alt=""></p><h2 id="实用的自定义-LLDB-命令"><a href="#实用的自定义-LLDB-命令" class="headerlink" title="实用的自定义 LLDB 命令"></a>实用的自定义 LLDB 命令</h2><p>在学会了如何向 LLDB 调试器中添加自定义命令，那么添加什么样的自定义 LLDB 命令最实用呢？</p><p>我个人认为下面的自定义命令非常实用。可以在 Xcode 控制台中将任何 JSON 可序列化类型（例如字典、数组、数据等）打印为 JSON 字符串。 可以参考<a href="https://soffes.blog/debugging-json-data-in-lldb" title="Debugging JSON Data in LLDB" target="_blank" rel="noopener">这篇文章</a>。</p><p>另外，我也很喜欢<a href="https://diamantidis.github.io/2018/10/14/modifying-ui-elements-with-xcode-and-lldb-v2" title="Modifying UI elements with Xcode and LLDB v2" target="_blank" rel="noopener">本文</a>讨论的一系列自定义命令，我们可以使用它们来动态修改 UI 元素的颜色，而无需重新构建项目。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是对 LLDB 调试器功能做了简单介绍。如果你是刚刚接触到 LLDB，希望这篇文章能帮助你开始探索这个神奇的调试工具。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://swiftsenpai.com/testing/add-custom-lldb/&quot; title=&quot;Adding Swift Code as Custom LLDB Command&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Adding Swift Code as Custom LLDB Command&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;如果问你最常使用哪个 LLDB 命令？ 我相信大多数 iOS 开发者都会回答 &lt;code&gt;po&lt;/code&gt;。 你是否知道实际上可以使用纯 Swift 代码自定义自己的 LLDB 命令吗？&lt;/p&gt;
&lt;p&gt;在本文中将会向你展示如何创建你自己的 LLDB 命令。以下是将要分享的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加你的第一个 LLDB 命令&lt;/li&gt;
&lt;li&gt;添加带参数的 LLDB 命令&lt;/li&gt;
&lt;li&gt;将复杂的 Swift 代码转换为 LLDB 命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>探索 SwiftUI 基本手势.md</title>
    <link href="https://fanbaoying.github.io/%E6%8E%A2%E7%B4%A2-SwiftUI-%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%8A%BF-md/"/>
    <id>https://fanbaoying.github.io/探索-SwiftUI-基本手势-md/</id>
    <published>2021-06-07T12:40:07.000Z</published>
    <updated>2021-06-07T12:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。</p><p>今天，我们将回顾<span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span>基本手势：</p><ul><li>TapGesture</li><li>长按手势</li><li>拖动手势</li><li>放大手势</li><li>旋转手势</li></ul><a id="more"></a><h2 id="TapGesture"><a href="#TapGesture" class="headerlink" title="TapGesture"></a>TapGesture</h2><p>轻击手势使我们能够识别 <span style="background-color:rgba(27,31,35,.05);color:orangered;">View</span> 上的一个或多个轻击。<br>我们有几种方法可以添加点击手势。</p><p>第一个是直接使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onTapGesture</span> 修饰符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">  .onTapGesture &#123;</span><br><span class="line">    <span class="comment">// Respond to Tap Gesture </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 文档中使用的其他选项是通过创建手势并将其配置为属性，然后将其与 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.gesture（_：include :)</span> 修饰符一起使用。</p><p><strong>注意：</strong> 为了执行某项操作或响应轻击，我们需要使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭，该操作在手势结束时触发。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SingleTapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">      <span class="type">TapGesture</span>()</span><br><span class="line">          .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">              <span class="comment">// Respond to Tap Gesture</span></span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">Circle</span>()</span><br><span class="line">          .gesture(singleTap)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我更喜欢第二种方法，因为这样我们可以创建不同的手势并通过我们的代码重复使用它们。</p><p>因此，如果我们将代码放在一起，就可以开始编写类似的东西。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-7c948aec7b7e9c3f.image?imageMogr2/auto-orient/strip" alt="giphy.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped1x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> singleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>()</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped1x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 1X: <span class="subst">\(tapped1x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"1X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(singleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似地，我们只需使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">TapGesture(count：Int)</span> 初始化程序就可以控制要响应的数量。</p><p>在这种情况下，您需要点击3次才能触发 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 操作关闭。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-49af6400b2230e18.image?imageMogr2/auto-orient/strip" alt="2.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TapGesture3xView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isAnimating = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> tapped3x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> multipleTap: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">TapGesture</span>(<span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line">            .onEnded &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                tapped3x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.easeOut(duration: <span class="number">0.5</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">0.5</span>) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.isAnimating = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Tapped 3X: <span class="subst">\(tapped3x)</span> times"</span>)</span><br><span class="line">                .font(.caption)</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">                .foregroundColor(.orange)</span><br><span class="line">                .overlay(</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"3X"</span>)</span><br><span class="line">                        .fontWeight(.medium)</span><br><span class="line">                )</span><br><span class="line">                .background(</span><br><span class="line">                    <span class="type">Circle</span>()</span><br><span class="line">                        .strokeBorder(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">                        .scaleEffect(isAnimating ? <span class="number">1.5</span> : <span class="number">1</span>)</span><br><span class="line">                        .opacity(isAnimating ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .gesture(multipleTap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长按手势"><a href="#长按手势" class="headerlink" title="长按手势"></a>长按手势</h2><p>长按手势可让我们在用户长按定义的时间后以及在用户长按的时间内执行操作。</p><p>我们可以设置一个最小持续时间，以识别我们的长按手势。 可以在 <span style="background-color:rgba(27,31,35,.05);color:orangered;">LongPressGesture</span> 初始化程序中进行设置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>然后，我们可以使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.updating</span> 方法在长按期间执行操作，并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 在识别到我们的手势时执行操作。</p><p>在此示例中，我将在长按操作期间更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 的大小和颜色，并且当识别出手势时，我将显示“文本已完成”。</p><p>另外，我在这里使用的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">GestureState</span> 属性包装器，该包装器在长按期间设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">true</span> ，在手势结束时设置为 <span style="background-color:rgba(27,31,35,.05);color:orangered;">false</span> 。 我正在将此属性包装器用于示例动画。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-4a9fe52ce65b10a1.image?imageMogr2/auto-orient/strip" alt="3.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LongPressGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">GestureState</span> <span class="keyword">private</span> <span class="keyword">var</span> isLongPressDetected = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isDone = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> longPress: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">LongPressGesture</span>(minimumDuration: <span class="number">2</span>)</span><br><span class="line">            .updating($isLongPressDetected) &#123; currentState, gestureState, transaction <span class="keyword">in</span></span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    isDone = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                gestureState = currentState</span><br><span class="line">                transaction.animation = <span class="type">Animation</span>.easeIn(duration: <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; done <span class="keyword">in</span></span><br><span class="line">                isDone = done</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Circle</span>()</span><br><span class="line">                .frame(width: <span class="number">10</span>, height: <span class="number">10</span>)</span><br><span class="line">                .foregroundColor(isLongPressDetected ? .orange : .primary)</span><br><span class="line">                .scaleEffect(<span class="type">CGSize</span>(</span><br><span class="line">                                width: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>,</span><br><span class="line">                                height: isLongPressDetected ? <span class="number">10</span> : <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="keyword">if</span> isLongPressDetected &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Updating..."</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isDone &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Long Press 2 sec"</span>)</span><br><span class="line">                .padding()</span><br><span class="line">                .background(isLongPressDetected ? <span class="type">Color</span>.green : <span class="type">Color</span>.orange)</span><br><span class="line">                .cornerRadius(<span class="number">16</span>)</span><br><span class="line">                .gesture(longPress)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拖动手势"><a href="#拖动手势" class="headerlink" title="拖动手势"></a>拖动手势</h2><p>拖动手势允许我们在拖动视图时执行操作。</p><p>我们可以利用并使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 关闭方法来执行某些操作。 这两种方法都为我们提供了出色的属性 <span style="background-color:rgba(27,31,35,.05);color:orangered;">DragGesture.Value</span>，该属性存储以下拖动动作信息：</p><ul><li>location</li><li>predictedEndLocation</li><li>predictedEndTranslation</li><li>startLocation</li><li>time</li><li>translation</li></ul><p>我们可以使用该属性来创建可移动视图。 在当前示例中，我使用 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 方法更新 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-9d805e7489eb15e5.image?imageMogr2/auto-orient/strip" alt="4.gif"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，添加了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 方法，以在拖动结束后重置 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Circle()</span> 位置坐标。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-f1710b2656cab2f4.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> location: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drag: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">DragGesture</span>(minimumDistance: <span class="number">1</span>, coordinateSpace: .local)</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                location = value.location</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                withAnimation(.easeOut) &#123;</span><br><span class="line">                    location = <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .position(location)</span><br><span class="line">            .gesture(drag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放大手势"><a href="#放大手势" class="headerlink" title="放大手势"></a>放大手势</h2><p>当我们在View上应用放大动作时，放大手势允许做出一些动作。</p><p>在这里，还有 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，我们可以使用它们来在放大动作期间或结束时进行响应。 作为属性，接收到的是 <span style="background-color:rgba(27,31,35,.05);color:orangered;">CGFloat</span> 的 <span style="background-color:rgba(27,31,35,.05);color:orangered;">MagnificationGesture.Value</span> 。 我们可以以此为例来更改视图大小。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b3ac91417d23226f.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MagnificationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> magnifiedValue: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> magnification: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">MagnificationGesture</span>()</span><br><span class="line">            .onChanged &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = value</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; value <span class="keyword">in</span></span><br><span class="line">                magnifiedValue = <span class="number">1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Circle</span>()</span><br><span class="line">            .frame(width: <span class="number">100</span> * magnifiedValue, height: <span class="number">100</span> * magnifiedValue)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .gesture(magnification)</span><br><span class="line">            .animation(.easeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转手势"><a href="#旋转手势" class="headerlink" title="旋转手势"></a>旋转手势</h2><p>旋转手势允许旋转视图，并在旋转过程中和旋转结束时以某些动作做出响应。</p><p>它还为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onChanged</span> 和 <span style="background-color:rgba(27,31,35,.05);color:orangered;">.onEnded</span> 闭包，这些闭包为我们提供了 <span style="background-color:rgba(27,31,35,.05);color:orangered;">RotationGesture.Value</span>，它表示手势 <span style="background-color:rgba(27,31,35,.05);color:orangered;">Angle</span> 值。 我们可以使用该值旋转视图。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-0939ef2e20c537bf.gif?imageMogr2/auto-orient/strip" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RotationGestureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> angle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> backgroundAngle = <span class="type">Angle</span>(degrees: <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rotation: some <span class="type">Gesture</span> &#123;</span><br><span class="line">        <span class="type">RotationGesture</span>()</span><br><span class="line">            .onChanged &#123; angle <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.angle = angle</span><br><span class="line">            &#125;</span><br><span class="line">            .onEnded &#123; angle <span class="keyword">in</span></span><br><span class="line">                withAnimation(<span class="type">Animation</span>.spring()) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.backgroundAngle = angle</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span>()</span><br><span class="line">            .frame(width: <span class="number">150</span>, height: <span class="number">150</span>, alignment: .center)</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            .rotationEffect(<span class="keyword">self</span>.angle)</span><br><span class="line">            .gesture(rotation)</span><br><span class="line">            .background(</span><br><span class="line">                <span class="type">Rectangle</span>()</span><br><span class="line">                    .shadow(color: .primary, radius: <span class="number">10</span>, x: <span class="number">0.0</span>, y: <span class="number">0.01</span>)</span><br><span class="line">                    .foregroundColor(.secondary)</span><br><span class="line">                    .rotationEffect(backgroundAngle)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是对  <span style="background-color:rgba(27,31,35,.05);color:orangered;">SwiftUI</span> 基本手势的总结。我们可以实现更多的交互使我们的 App 变得更生动。</p><p>对于高级的使用，可以将手势组合或者同时使用以做出响应，或者可以实现自己的自定义手势。</p><p>本文已在公众号「<strong>Swift 社区</strong>」发布，如需转载请加微信：fzhanfei，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt; 中，我们可以通过添加不同的交互来使我们的应用程序更具交互性，这些交互可以响应我们的点击，点击和滑动。&lt;/p&gt;
&lt;p&gt;今天，我们将回顾&lt;span style=&quot;background-color:rgba(27,31,35,.05);color:orangered;&quot;&gt;SwiftUI&lt;/span&gt;基本手势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TapGesture&lt;/li&gt;
&lt;li&gt;长按手势&lt;/li&gt;
&lt;li&gt;拖动手势&lt;/li&gt;
&lt;li&gt;放大手势&lt;/li&gt;
&lt;li&gt;旋转手势&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>解决 iOS 14.5 UDP广播 sendto 返回 -1</title>
    <link href="https://fanbaoying.github.io/%E8%A7%A3%E5%86%B3-iOS-14-5-UDP%E5%B9%BF%E6%92%AD-sendto-%E8%BF%94%E5%9B%9E-1/"/>
    <id>https://fanbaoying.github.io/解决-iOS-14-5-UDP广播-sendto-返回-1/</id>
    <published>2021-06-07T12:37:18.000Z</published>
    <updated>2021-06-07T12:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h3><ol><li>手机系统升级到 iOS 14.5 之后，UDP 广播发送失败</li><li>项目中老版本使用到 socket </li><li>项目中新版本使用 CocoaAsyncSocket</li><li>两种 UDP 发包方式都会报错 No route to host</li></ol><p><strong>报错具体内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendto: -1</span><br><span class="line">client: sendto fail, but just ignore it</span><br><span class="line">: No route to host</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><h5 id="2-1-sendto-返回-1-问题排查"><a href="#2-1-sendto-返回-1-问题排查" class="headerlink" title="2.1  sendto 返回 -1 问题排查"></a>2.1  sendto 返回 -1 问题排查</h5><p>我们知道发送广播 sendto 返回 -1，正常情况sendto 返回值大于 0 。<br>首先判断 socket 连接是否建立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._sck_fd4 = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">if (DEBUG_ON) &#123;</span><br><span class="line">     NSLog(@&quot;client init() _sck_fd4=%d&quot;,self._sck_fd4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>self._sck_fd4 打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server init(): _sck_fd4=12</span><br></pre></td></tr></table></figure><p>socket 连接正常，接下来判断数据发包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendto(self._sck_fd4, bytes, dataLen, 0, (struct sockaddr*)&amp;target_addr, addr_len) = -1</span><br></pre></td></tr></table></figure><p>数据发送失败</p><h5 id="2-2-增加-NSLocalNetworkUsageDescription-权限"><a href="#2-2-增加-NSLocalNetworkUsageDescription-权限" class="headerlink" title="2.2  增加 NSLocalNetworkUsageDescription 权限"></a>2.2  增加 NSLocalNetworkUsageDescription 权限</h5><ol><li><p>Info.plist 添加 <strong>NSLocalNetworkUsageDescription</strong></p></li><li><p>发送一次UDP广播，触发权限弹框，让用户点击好，允许访问本地网络。</p></li></ol><p>发现问题依旧存在</p><h5 id="2-3-发送单播排查"><a href="#2-3-发送单播排查" class="headerlink" title="2.3 发送单播排查"></a>2.3 发送单播排查</h5><p>由于项目中发送广播设置的 hostName 为 255.255.255.255，为了排查决定先发送单播看是否能成功。</p><p>将单播地址改为 192.168.0.101 之后发现是可以发送成功的，然后在新版本 CocoaAsyncSocket 库中发送单播也是可以成功的。</p><p>UDP 广播推荐使用 192.168.0.255 ，将广播地址改了之后，问题解决了，设备可以收到 UDP 广播数据。</p><h3 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3. 问题解决"></a>3. 问题解决</h3><p>由于 192.168.0.255 广播地址只是当前本地地址，App 中需要动态改变前三段 192.168.0 本地地址，解决方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *localInetAddr4 = [ESP_NetUtil getLocalIPv4];</span><br><span class="line"><span class="built_in">NSArray</span> *arr = [localInetAddr4 componentsSeparatedByString:<span class="string">@"."</span>];</span><br><span class="line"><span class="built_in">NSString</span> *deviceAddress4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.%@.%@.255"</span>,arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]];</span><br></pre></td></tr></table></figure><p>发包过滤，只需要过滤地址最后一段是否为 255</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isBroadcast = [targetHostName hasSuffix:@&quot;255&quot;];</span><br></pre></td></tr></table></figure><p>本文已在公众号「<strong>网罗开发</strong>」发布，如需转载请加微信：FBY-fan，备注转载开白</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题背景&quot;&gt;&lt;a href=&quot;#1-问题背景&quot; class=&quot;headerlink&quot; title=&quot;1. 问题背景&quot;&gt;&lt;/a&gt;1. 问题背景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;手机系统升级到 iOS 14.5 之后，UDP 广播发送失败&lt;/li&gt;
&lt;li&gt;项目中老版本使用到 socket &lt;/li&gt;
&lt;li&gt;项目中新版本使用 CocoaAsyncSocket&lt;/li&gt;
&lt;li&gt;两种 UDP 发包方式都会报错 No route to host&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;报错具体内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sendto: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client: sendto fail, but just ignore it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;: No route to host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>提升工作效率 Mac 上的必备工具</title>
    <link href="https://fanbaoying.github.io/%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87-Mac-%E4%B8%8A%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    <id>https://fanbaoying.github.io/提升工作效率-Mac-上的必备工具/</id>
    <published>2021-05-02T14:19:35.000Z</published>
    <updated>2021-05-02T16:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。</p><p><strong>1. UI调试神器–Reveal</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-b5b7a9d2be34f95e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Reveal是一个界面调试工具。使用Reveal，我们可以在iOS开发时动态地查看和修改应用程序的界面。</p><p>它类似Chrome的“审查元素”功能，我们不但可以在运行时看到iOS程序的界面层级关系，还可以实时地修改程序界面，不用重新运行程序就可以看到修改之后的效果。</p><p><strong>2. 接口调试–Postman</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-a5a8702aaf98cb9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>在我们平时开发中，特别是需要与接口打交道时，无论是写接口还是用接口，拿到接口后肯定都得提前测试一下，这样的话就非常需要有一个比较给力的 Http 请求模拟工具。</p><p>Postman 就是一种网页调试与发送网页 http 请求的 chrome 插件。我们可以用来很方便的模拟 get 或者 post 或者其他方式的请求来调试接口。</p><p><strong>3. 网络拦截–Charles</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-63b1ffa7970c6be1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Charles是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p><p>除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。很多iOS的高仿应用都是用Charles来拦截获取网络数据的。</p><p><strong>4. 取色工具–Sip</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-5eb2a353d61b4fe4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>Sip 是全栈开发人员的利器，用户只需轻点鼠标便可快速取得屏幕当前位置的颜色值，并将数据自动存到剪切板，方便随时粘贴出来。支持 CSS、UIColor 等多种格式。</p><p><strong>5. JSON 生成数据模型工具–JSONExport</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-e6767b6bbec4d27d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>JSONExport 是一个 Mac OS X 应用，用 Swift 编写。它可以将 JSON 自动生成指定语言的 Model 类代码，包括属性，属性的getters和setters方法等。</p><p>不管你 json 数据多复杂，里面嵌套多少层，该工具都可以将它转换出来，这对于我们开发生成数据模型节省了不少时间。JSONExport 支持 OC、Swift、Java 等语言。</p><p><strong>6. Git 代码界面管理工具–SourceTree</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-33833817fdc9e7f9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>SourceTree 是 Windows 和 Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。</p><p>同时它也是 Mercurial 和 Subversion 版本控制系统工具。支持创建、提交、clone、push、pull 和 merge 等操作。</p><p><strong>7. Svn 代码界面管理工具–Cornerstone</strong></p><div align="center"><br><img src="https://upload-images.jianshu.io/upload_images/19359146-f5d236668488ba03?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div><p>CornerStone 是 Mac OS X 系统下非常好用的一款 svn 软件管理工具，当然还有 Versions 也是可以用的，但是使用起来不如 CornerStone 好用、强大。</p><p><strong>注意：</strong>CornerStone 是收费，如果是公司需要使用到，建议让公司购买软件使用版权，支持正版。本人所用的是公司购买了使用权的版本。当然网上也是有破解版本的。</p><p><div align="center"></div></p><p><strong style="font-size: 20px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">软 件 链 接</span></strong></p><p><img width="150" height="150" src="https://upload-images.jianshu.io/upload_images/2829694-2fd9a02d886dd857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><section><span style="font-size: 15px;">进入上方<strong><span style="color: rgb(255, 0, 0);">▲</span></strong><span style="background-color: rgb(255, 255, 255);letter-spacing: 1px;">二维码内，回复：<strong style="font-size: 16px;"><span style="font-size: 15px;color: rgb(255, 0, 0);">427</span></strong></span></span></section><br><br><br></p><p><strong><img src="https://upload-images.jianshu.io/upload_images/19359146-e6227bdef1fb12f8?imageMogr2/auto-orient/strip" alt=""></strong> </p><h5 id="分享-6-个百度出品的免费工具，你用过几个？"><a href="#分享-6-个百度出品的免费工具，你用过几个？" class="headerlink" title="分享 6 个百度出品的免费工具，你用过几个？"></a><a href="https://mp.weixin.qq.com/s/SCcQjGgdohHsEaD3m5aegw" target="_blank" rel="noopener">分享 6 个百度出品的免费工具，你用过几个？</a></h5><h5 id="「ApowerREC」一款功能强大的录屏软件"><a href="#「ApowerREC」一款功能强大的录屏软件" class="headerlink" title="「ApowerREC」一款功能强大的录屏软件"></a><a href="https://mp.weixin.qq.com/s/Iq4WccudqFg_0wKJ6UvrnQ" target="_blank" rel="noopener">「ApowerREC」一款功能强大的录屏软件</a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac上有很多好用的软件，有的能提升我们的开发效率，有的能提升我们的工作效率。今天我就来介绍一些Mac上对我们开发有帮助的软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. UI调试神器–Reveal&lt;/strong&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;im
      
    
    </summary>
    
      <category term="软件工具库" scheme="https://fanbaoying.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
    
      <category term="工具" scheme="https://fanbaoying.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 支付宝支付开发（最新版）</title>
    <link href="https://fanbaoying.github.io/iOS-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/iOS-支付宝支付开发（最新版）/</id>
    <published>2021-04-28T14:00:30.000Z</published>
    <updated>2021-04-28T14:05:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。</p><p>今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。</p><p>在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。<br>其实如果接入的多的话，那些套路都可以绕着走。<br>网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。</p><a id="more"></a><h2 id="2-交互流程"><a href="#2-交互流程" class="headerlink" title="2. 交互流程"></a>2. 交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是交互流程这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8688fd141e5c4425b1e07ef6d5363447~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115b15944b364a15a6948eb180f086b1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>支付宝支付的功能流程相比较微信支付来说简单的很，如上面两张图展示的，我们的 App（也就是商户客户端）所做的大概只有三个步骤：</p><ul><li>生成订单</li><li>调用支付宝接口，发送订单</li><li>返回订单支付结果并处理</li></ul><h2 id="3-下载支付宝-SDK"><a href="#3-下载支付宝-SDK" class="headerlink" title="3. 下载支付宝 SDK"></a>3. 下载支付宝 SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了最新的 SDK 地址<br><strong>注意</strong>的是下载出来的 SDK 包里面并没有传说中的开发文档，需要其他地方找或者看网页上的。</p><p>公钥、私钥、PID、sellerID、key这些东西的用途和获取方式在文档上都有详细的说明，这里不再赘述，一定要把概念分清楚再去做，不然一会就乱了。如果遇到问题的话咱们可以再一起探讨。</p><h2 id="4-导入库集成SDK"><a href="#4-导入库集成SDK" class="headerlink" title="4.  导入库集成SDK"></a>4.  导入库集成SDK</h2><h3 id="4-1-导入文件和关键库"><a href="#4-1-导入文件和关键库" class="headerlink" title="4.1 导入文件和关键库"></a>4.1 导入文件和关键库</h3><p><strong>通过 CocoaPods 导入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod  &apos;AlipaySDK-iOS&apos;</span><br></pre></td></tr></table></figure><p><strong>手动导入</strong></p><p>官方 demo 截图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36fb998958da4664a3cb2fca96a24958~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>添加 framework 和其他文件<br>打开 iOS 工程，新版本 SDK 文件 Order 文件，你需要复制粘贴到自己工程里的有：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li><li>Until 文件夹</li><li>openssl 文件夹</li><li>libcrypto.a 和 libssl.a</li></ul><p>上面的一部分文件在打开的项目中是看不到的，需要打开项目文件夹找到。</p><p>在 Build Phases 选项卡的 Link Binary With Libraries 中，增加以下依赖：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e052992193d427e91285f9187bddff7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>其中，需要注意的是：</p><ul><li>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；</li><li>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib（如下图）。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b43efaeb56c4339af14127460fcd0c4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>此时，假如你启动工程，很大几率上你会发现报 error 的情况。</p><h3 id="4-2-引入头文件"><a href="#4-2-引入头文件" class="headerlink" title="4.2 引入头文件"></a>4.2 引入头文件</h3><p>在需要调用 AlipaySDK 的文件中，增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在支付宝的接入文档中，是将生成一个订单这步放在客户端来做了，但这个最好是放在服务器端来做。</p><p>后台生成订单然后拼接，签名，然后服务器端直接给客户端传一个加密签名过的参数就可以了，这样比较安全。</p><p>所有的订单信息，商户信息等都掌握在自己的手中，这样的话APP端就不怕被拦截数据，并且调用起来也就特别简单了，只需要调用支付的接口。</p><p>如果只需要发送订单和处理支付返回结果，只需要添加 AlipaySDK.bundle 和AlipaySDK.framework 这两个就行了，下载的SDK中很容易发现。<br>快捷支付方法是这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)payOrder:(NSString *)orderStr fromScheme:(NSString *)schemeStr callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure><p>在支付的按钮中，使用支付宝这个类，再调用这个方法就行啦！如下如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="4-4-配置支付宝客户端返回-url-处理方法"><a href="#4-4-配置支付宝客户端返回-url-处理方法" class="headerlink" title="4.4 配置支付宝客户端返回 url 处理方法"></a>4.4 配置支付宝客户端返回 url 处理方法</h3><p>如示例 AliSDKDemo\APAppDelegate.m 文件中，增加引用代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><p>在 <em>@</em>implementation  AppDelegate 中以下代码中的 NSLog 改为实际业务处理代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-项目配置"><a href="#4-5-项目配置" class="headerlink" title="4.5 项目配置"></a>4.5 项目配置</h3><p>最后，不要忘了还要写一个 URL Scheme，在 Targets -&gt; Info 下最后一个即可找到，<br>点击 “Info” 选项卡，在 “URL Types ”选项中，点击 “+”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/743ffb1092bb4cc4ab6f845a7cb7bd55~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="5-常见问题汇总"><a href="#5-常见问题汇总" class="headerlink" title="5. 常见问题汇总"></a>5. 常见问题汇总</h2><h3 id="5-1-支付后无法返回-App"><a href="#5-1-支付后无法返回-App" class="headerlink" title="5.1 支付后无法返回 App"></a>5.1 支付后无法返回 App</h3><p>一般是由于白名单没有设置正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NOTE: 调用支付结果开始支付</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;FBYAlipayDemo&quot; callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    NSLog(@&quot;reslut = %@&quot;,resultDic);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>上方代码中 appScheme 参数需要和文章 <strong>4.5 项目配置</strong>中设置的 URL Schemes 相同，这样才能对应返回 App。</p><h3 id="5-2-include-not-find"><a href="#5-2-include-not-find" class="headerlink" title="5.2 #include  not find"></a>5.2 #include <openssl opensslconf.h=""> not find</openssl></h3><p>这是一个神奇的大坑，我Google了好久，也不得其解，然后经网友提醒之后想起来#import “”和#import &lt;&gt;的区别。</p><p><strong>解决方法</strong>：Targets -&gt; Build Settings 下的 Header Search Paths。<br>添加如下目录 “$(SRCROOT)/项目名称/文件的绝对地址”<br>如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40f0b9ba81d48bc8ded85bf2fe6ae1e~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p><h3 id="5-3-‘openssl-asn1-h’-file-not-found"><a href="#5-3-‘openssl-asn1-h’-file-not-found" class="headerlink" title="5.3 ‘openssl/asn1.h’ file not found"></a>5.3 ‘openssl/asn1.h’ file not found</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae746bcaf0c4c32ae80ed76429b6b2b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>由于在项目中引入 openssl 库，出现这个问题是因为库文件项目无法找到，只需要在 Header Search Paths 中加入 $(PROJECT_DIR)/项目名称/openssl 即可，如下图操作：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5732304211a5473b9b1ed4edf5e61b32~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-4-Undefined-symbol-OBJCMETACLASS-WKWebView"><a href="#5-4-Undefined-symbol-OBJCMETACLASS-WKWebView" class="headerlink" title="5.4 Undefined symbol: _OBJCMETACLASS$_WKWebView"></a>5.4 Undefined symbol: _OBJC<em>METACLASS</em>$_WKWebView</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15de4c63d16e49ba831d344be0e19e3c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>出现上面的问题，需要在项目配置中添加系统类库：WebKit.framework</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8cff9e3b44418cbb2979ec0e9a2de5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-5-如果遇到运行后报错，类似于以下提示信息："><a href="#5-5-如果遇到运行后报错，类似于以下提示信息：" class="headerlink" title="5.5 如果遇到运行后报错，类似于以下提示信息："></a>5.5 如果遇到运行后报错，类似于以下提示信息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot find interface declaration for &apos;NSObject&apos;, superclass of &apos;Base64&apos;</span><br></pre></td></tr></table></figure><p>那么需要打开报错了的文件，增加头文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br></pre></td></tr></table></figure><h3 id="5-6-Swift-中接入-SDK-遇到的问题"><a href="#5-6-Swift-中接入-SDK-遇到的问题" class="headerlink" title="5.6 Swift 中接入 SDK 遇到的问题"></a>5.6 Swift 中接入 SDK 遇到的问题</h3><p>如果项目使用 Swift 为开发语言，需要添加桥接文件，如 Bridging-Header.h</p><p>同时，在项目 Build Settings 中设置桥接文件的位置。</p><p>运行时如果发生以下报错，则在桥接文件中，写入#import <uikit uikit.h=""></uikit></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4d474efcd7f487887e925a06627a0b7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="5-7-点击支付跳转至支付宝卡在启动页面"><a href="#5-7-点击支付跳转至支付宝卡在启动页面" class="headerlink" title="5.7 点击支付跳转至支付宝卡在启动页面"></a>5.7 点击支付跳转至支付宝卡在启动页面</h3><p>出现这个情况被卡在的页面会出现相应错误提示，一般有以下几种情况：</p><ul><li>商品信息拼接字符串错误</li><li>支付账号过期待续费状态</li><li>商户 ID 错误</li><li>订单信息验签失败</li></ul><p>获取源码方式：关注「<strong>网罗开发</strong>」回复 “<strong>支付宝支付</strong>” 即可获取</p><p>本文已在公众号「<strong>网罗开发</strong>」发布，如果转载长白请加微信：FBY-fan，备注<strong>转载长白</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-d0f9c79727486cae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h2&gt;&lt;p&gt;本文为以前做的项目总结，由于相关支付 SDK 迭代，原文已经不满足需求，故作如下更新，供大家参考，另外增加常见问题总结。&lt;/p&gt;
&lt;p&gt;今天我们就主要介绍一下支付宝支付，其他支付介绍后面会尽快更新出来。&lt;/p&gt;
&lt;p&gt;在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。&lt;br&gt;其实如果接入的多的话，那些套路都可以绕着走。&lt;br&gt;网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native视频播放器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native视频播放器插件/</id>
    <published>2018-12-16T10:00:59.000Z</published>
    <updated>2018-12-16T10:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生视频播放器插件的开发与使用。</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生视频播放器插件是需要实现打开js端调用播放方法传入的视频链接URL，具体的实现思路如下：</p><ol><li><p>新建mediaPlay类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>创建一个视频播放控制器</p></li><li><p>创建一个视频播放图层</p></li><li><p>将视频播放图层添加到父控件图层</p></li><li><p>JavaScript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建mediaPlay类，实现RCTBridgeModule协议"><a href="#1-新建mediaPlay类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建mediaPlay类，实现RCTBridgeModule协议"></a>1. 新建mediaPlay类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的mediaPlay类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface mediaPlay : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，mediaPlay的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“MediaPlay”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// mediaPlay.m</span><br><span class="line">#import &quot;mediaPlay.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation mediaPlay</span><br><span class="line">RCT_EXPORT_MODULE(MediaPlay);</span><br><span class="line">RCT_EXPORT_METHOD(mediaPlayer:(NSDictionary*)arguments</span><br><span class="line">                           :(RCTResponseSenderBlock)sucessCallback</span><br><span class="line">                           :(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起原声视频播放器的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-创建一个视频播放控制器"><a href="#5-创建一个视频播放控制器" class="headerlink" title="5. 创建一个视频播放控制器"></a>5. 创建一个视频播放控制器</h5><p>视频播放器是使用iOS原声<avfoundation avfoundation.h="">来实现视频的播放，创建一个视频播放控制器代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(AVPlayerViewController *)playerVC</span><br><span class="line">&#123;</span><br><span class="line">    if (_playerVC == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        //创建一个视频播放控制器</span><br><span class="line">        _playerVC = [[AVPlayerViewController alloc] init];</span><br><span class="line">        //获取视频URL（远程、本地视频URL都可以）</span><br><span class="line">        NSURL * url = [NSURL URLWithString:self.vedioURL];</span><br><span class="line">        //根据URL创建播放曲目</span><br><span class="line">        AVPlayerItem * item = [AVPlayerItem playerItemWithURL:url];</span><br><span class="line">        //创建一个视频播放器</span><br><span class="line">        AVPlayer * player = [AVPlayer playerWithPlayerItem:item];</span><br><span class="line">    &#125;</span><br><span class="line">    return _playerVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></avfoundation></p><h5 id="6-创建一个视频播放图层"><a href="#6-创建一个视频播放图层" class="headerlink" title="6. 创建一个视频播放图层"></a>6. 创建一个视频播放图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建一个视频播放图层</span><br><span class="line"> AVPlayerLayer * playLayer = [AVPlayerLayer playerLayerWithPlayer:player];</span><br></pre></td></tr></table></figure><h5 id="7-将视频播放图层添加到父控件图层"><a href="#7-将视频播放图层添加到父控件图层" class="headerlink" title="7. 将视频播放图层添加到父控件图层"></a>7. 将视频播放图层添加到父控件图层</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将视频播放图层添加到父控件图层</span><br><span class="line"> [_playerVC.view.layer addSublayer:playLayer];</span><br><span class="line"> //设置视频播放控制器的播放器为player</span><br><span class="line"> _playerVC.player = player;</span><br></pre></td></tr></table></figure><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const MediaPlayPlugin = NativeModules.MediaPlay;</span><br><span class="line">MediaPlayPlugin.mediaPlayer(&#123;filePath:&quot;http://static.tripbe.com/videofiles/20121214/9533522808.f4v.mp4&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native FMDB数据库插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native-FMDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native-FMDB数据库插件/</id>
    <published>2018-12-16T09:59:40.000Z</published>
    <updated>2018-12-16T10:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍FMDB数据库插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>FMDB数据库插件是需要实现数据的新增、查询、修改、删除等功能，通过querySQLite方法来实现数据的查询，并将接口提供给Javascript开发使用</p><p>打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建DataBasePlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>判断数据库语句，适合使用那个数据库方法</p></li><li><p>创建数据库DataBase.db</p></li><li><p>打开数据库</p></li><li><p>执行sql语句</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建DataBasePlugin类，实现RCTBridgeModule协议"><a href="#1-新建DataBasePlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建DataBasePlugin类，实现RCTBridgeModule协议"></a>1. 新建DataBasePlugin类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的DataBasePlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface DataBasePlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，DataBasePlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“DataBasePlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// DataBasePlugin.m</span><br><span class="line">#import &quot;DataBasePlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation DataBasePlugin</span><br><span class="line">RCT_EXPORT_MODULE(DataBasePlugin);</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(execSQLite:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;数据库常用语句执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(querySQLite:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;数据库查询语句执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-判断数据库语句，适合使用那个数据库方法"><a href="#5-判断数据库语句，适合使用那个数据库方法" class="headerlink" title="5. 判断数据库语句，适合使用那个数据库方法"></a>5. 判断数据库语句，适合使用那个数据库方法</h5><p>由于数据库查询语句中的查询参数，需要通过接口传入，并不是和sql语句一起传入，所以需要进行拼接，这就需要用到数据库查询方法querySQLite，因为查询语句中包含select字符串，因此作出如下判断：<br>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if([arguments[@&quot;sql&quot;] rangeOfString:@&quot;select&quot;].location !=NSNotFound)</span><br><span class="line">    &#123;</span><br><span class="line">        failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;请使用查询方法querySQLite进行查询&quot;&#125;]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="6-创建数据库DataBase-db"><a href="#6-创建数据库DataBase-db" class="headerlink" title="6. 创建数据库DataBase.db"></a>6. 创建数据库DataBase.db</h5><p>在导入第三方FMDB库之后，需要在DataBasePlugin.m引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FMDatabase.h&quot;</span><br></pre></td></tr></table></figure></p><p>实现数据库的第一步，创建数据表，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (FMDatabase *)db</span><br><span class="line">&#123;</span><br><span class="line">    if (!_db) &#123;</span><br><span class="line">        NSString *path = [[self getDocumentPath] stringByAppendingPathComponent:@&quot;DataBase.db&quot;];</span><br><span class="line">        _db = [FMDatabase databaseWithPath:path];</span><br><span class="line">    &#125;</span><br><span class="line">    return _db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-打开数据库"><a href="#7-打开数据库" class="headerlink" title="7. 打开数据库"></a>7. 打开数据库</h5><p>判断数据库表是否已创建，如果创建成功，或者已经存在数据表，即可打开数据库，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (self.db) &#123;</span><br><span class="line">            if ([self.db open]) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;打开数据库失败&quot;&#125;]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;数据库创建失败&quot;&#125;]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-执行sql语句"><a href="#8-执行sql语句" class="headerlink" title="8. 执行sql语句"></a>8. 执行sql语句</h5><p>在创建数据表和打开数据库成功之后，对Javascript传入的sql数据库语句进行处理执行，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL result = [self.db executeUpdate:sqlString];</span><br><span class="line">if (result) &#123;</span><br><span class="line">    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;执行SQL成功&quot;&#125;]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    failure(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;执行SQL失败&quot;&#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-Javascript调用浏览器方法"><a href="#9-Javascript调用浏览器方法" class="headerlink" title="9. Javascript调用浏览器方法"></a>9. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const DataBasePlugin = NativeModules.DataBasePlugin;</span><br><span class="line">DataBasePlugin.execSQLite(&#123;sql:&quot;CREATE TABLE IF NOT EXISTS NotificatonTable (id integer PRIMARY KEY AUTOINCREMENT, status text NOT NULL, title text NOT NULL, content text NOT NULL, url text NOT NULL, time text NOT NULL, remark text NOT NULL)&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native手势密码插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E6%89%8B%E5%8A%BF%E5%AF%86%E7%A0%81%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native手势密码插件/</id>
    <published>2018-12-16T09:56:29.000Z</published>
    <updated>2018-12-16T10:02:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍手势密码插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>手势密码插件是需要实现可视页面控制器、设置手势密码、验证手势密码、密码sm3加密、密码本地保存等功能，这些功能加通过在PwdLockPlugin类中封装的SetPwdLock方法和DecryptLock方法来提供给Javascript开发使用。</p><p>具体的实现思路如下：</p><ol><li><p>新建PwdLockPlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>新建设置密码控制器</p></li><li><p>新建验证密码控制器</p></li><li><p>设置手势密码</p></li><li><p>验证手势密码</p></li><li><p>密码sm3加密</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>实现源码分析是根据上面列出的具体实现思路来为大家解刨内部的实现流程及核心代码分析。</p><h4 id="1-新建PwdLockPlugin类，实现RCTBridgeModule协议"><a href="#1-新建PwdLockPlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建PwdLockPlugin类，实现RCTBridgeModule协议"></a>1. 新建PwdLockPlugin类，实现RCTBridgeModule协议</h4><p>新建继承NSObject的PwdLockPlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface PwdLockPlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h4><p>为了实现RCTBridgeModule协议，PwdLockPlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“PwdLockPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &quot;PwdLockPlugin.h&quot;</span><br><span class="line">@implementation PwdLockPlugin</span><br><span class="line">RCT_EXPORT_MODULE(PwdLockPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h4><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h4 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h4><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。下面通过举例来展示声明的方法，通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// PwdLockPlugin.m</span><br><span class="line">#import &quot;PwdLockPlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation PwdLockPlugin</span><br><span class="line">RCT_EXPORT_MODULE(PwdLockPlugin);</span><br><span class="line">//设置手势密码</span><br><span class="line">RCT_EXPORT_METHOD(SetPwdLock:(RCTResponseSenderBlock)sucessCallback failCallback:(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">        NSLog(@&quot;调起设置密码方法&quot;);</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">[CLLockVC showSettingLockVCInVC:RCTPresentedViewController() successBlock:^(CLLockVC *lockVC, NSString *pwd) &#123;</span><br><span class="line">[lockVC dismiss:0.0f];</span><br><span class="line">sucessCallback(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;密码设置成功&quot;&#125;]);</span><br><span class="line">                CIBNSLog(@&quot;%@&quot;,[self jsonStringWithDict:@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;密码设置成功&quot;&#125;]);</span><br><span class="line">//存储密码</span><br><span class="line">                pwd = [CLLockVC sm3:pwd];</span><br><span class="line">[CoreArchive setStr:pwd key:CoreLockPWDKey];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//验证手势密码</span><br><span class="line">RCT_EXPORT_METHOD(DecryptLock:(RCTResponseSenderBlock)sucessCallback failCallback:(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">        NSLog(@&quot;调起验证密码方法&quot;);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">[CLLockVC showVerifyLockVCInVC:RCTPresentedViewController() forgetPwdBlock:^&#123;</span><br><span class="line">failCallback(@[@&#123;@&quot;resultCode&quot;:@&quot;-1&quot;,@&quot;resultMessage&quot;:@&quot;手势密码三次验证失败&quot;&#125;]);</span><br><span class="line">&#125; successBlock:^(CLLockVC *lockVC, NSString *pwd) &#123;</span><br><span class="line">[lockVC dismiss:0.0f];</span><br><span class="line">sucessCallback(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;手势密码验证成功&quot;&#125;]);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="5-新建设置密码控制器"><a href="#5-新建设置密码控制器" class="headerlink" title="5. 新建设置密码控制器"></a>5. 新建设置密码控制器</h4><p>设置密码控制器是由3乘3的9个可触摸按钮实现，用户可以通过滑动屏幕来触动屏幕按钮，每个按钮有自己特有的编号（编号为0-9），通过触动按钮的先后顺序来记录手势密码，并将密码存储在本地。</p><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)showSettingLockVCInVC:(UIViewController *)vc successBlock:(void(^)(CLLockVC *lockVC,NSString *pwd))successBlock&#123;</span><br><span class="line">    CLLockVC *lockVC = [self lockVC:vc];</span><br><span class="line">    lockVC.title = @&quot;设置密码&quot;;</span><br><span class="line">    lockVC.type = CoreLockTypeSetPwd;</span><br><span class="line">    lockVC.successBlock = successBlock;</span><br><span class="line">    return lockVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-cad7f3f2a337dff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="1.png"></p><h4 id="6-新建验证密码控制器"><a href="#6-新建验证密码控制器" class="headerlink" title="6. 新建验证密码控制器"></a>6. 新建验证密码控制器</h4><p>验证密码控制器是由3乘3的9个可触摸按钮实现，用户可以通过滑动屏幕来触动屏幕按钮，每个按钮有自己特有的编号（编号为0-9），通过触动按钮的先后顺序来记录手势密码，通过和本地存储的密码进行对比验证是否一致，判断是否通过验证。</p><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)showVerifyLockVCInVC:(UIViewController *)vc forgetPwdBlock:(void(^)())forgetPwdBlock successBlock:(void(^)(CLLockVC *lockVC, NSString *pwd))successBlock&#123;</span><br><span class="line">    CLLockVC *lockVC = [self lockVC:vc];</span><br><span class="line">    lockVC.title = @&quot;手势解锁&quot;;</span><br><span class="line">    lockVC.type = CoreLockTypeVeryfiPwd;</span><br><span class="line">    lockVC.successBlock = successBlock;</span><br><span class="line">    lockVC.forgetPwdBlock = forgetPwdBlock;</span><br><span class="line">    return lockVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-8eac35c9db483377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="2.png"></p><h4 id="7-设置手势密码"><a href="#7-设置手势密码" class="headerlink" title="7. 设置手势密码"></a>7. 设置手势密码</h4><p>设置手势密码的滑动实现流程如下：</p><ul><li><ol><li>第一次滑动设置</li></ol></li><li><ol><li>再次确认滑动设置</li></ol></li><li><ol><li>检测密码长度是否符合要求（至少为四个点）</li></ol></li><li><ol><li>判断两次设置的密码是否一致</li></ol></li><li><ol><li>如果密码一致提示设置成功</li></ol></li><li><ol><li>如果不一致提示再次输入</li></ol></li><li><ol><li>将密码存储在本地</li></ol></li></ul><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//第一次滑动设置</span><br><span class="line">self.lockView.setPWBeginBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleFirst];</span><br><span class="line">&#125;;</span><br><span class="line">//再次确认滑动设置</span><br><span class="line">self.lockView.setPWConfirmlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleConfirm];</span><br><span class="line">&#125;;</span><br><span class="line">//检测密码长度是否符合要求（至少为四个点）</span><br><span class="line">self.lockView.setPWSErrorLengthTooShortBlock = ^(NSUInteger currentCount)&#123;</span><br><span class="line">    [self.label showWarnMsg:[NSString stringWithFormat:@&quot;请连接至少%@个点&quot;,@(CoreLockMinItemCount)]];</span><br><span class="line">&#125;;</span><br><span class="line">//判断两次设置的密码是否一致</span><br><span class="line">self.lockView.setPWSErrorTwiceDiffBlock = ^(NSString *pwd1,NSString *pwdNow)&#123;</span><br><span class="line">    [self.label showWarnMsg:CoreLockPWDDiffTitle];</span><br><span class="line">    self.navigationItem.rightBarButtonItem = self.resetItem;</span><br><span class="line">&#125;;</span><br><span class="line">//如果密码一致提示设置成功</span><br><span class="line">self.lockView.setPWFirstRightBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWDTitleConfirm];</span><br><span class="line">&#125;;</span><br><span class="line">//如果不一致提示再次输入</span><br><span class="line">self.lockView.setPWTwiceSameBlock = ^(NSString *pwd)&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockPWSuccessTitle];</span><br><span class="line">    //将密码存储在本地</span><br><span class="line">    [CoreArchive setStr:pwd key:CoreLockPWDKey];</span><br><span class="line">    self.view.userInteractionEnabled = NO;</span><br><span class="line">    if(_successBlock != nil) _successBlock(self,pwd);</span><br><span class="line">    if(CoreLockTypeModifyPwd == _type)&#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-验证手势密码"><a href="#8-验证手势密码" class="headerlink" title="8. 验证手势密码"></a>8. 验证手势密码</h4><p>验证手势密码的滑动实现流程如下：</p><ul><li><ol><li>滑动输入密码</li></ol></li><li><ol><li>检测密码长度是否符合要求（至少为四个点）</li></ol></li><li><ol><li>取出本地存储的密码</li></ol></li><li><ol><li>判断输入的密码和本地密码是否一致</li></ol></li><li><ol><li>如果一致返回验证成功</li></ol></li><li><ol><li>如果不一致提示重新验证</li></ol></li></ul><p>核心源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//滑动输入密码</span><br><span class="line">self.lockView.verifyPWBeginBlock = ^()&#123;</span><br><span class="line">    [self.label showNormalMsg:CoreLockVerifyNormalTitle];</span><br><span class="line">&#125;;</span><br><span class="line">//检测密码长度是否符合要求（至少为四个点）</span><br><span class="line">self.lockView.verifyPwdBlock = ^(NSString *pwd)&#123;</span><br><span class="line">    //取出本地存储的密码</span><br><span class="line">    NSString *pwdLocal = [CoreArchive strForKey:CoreLockPWDKey];</span><br><span class="line">    BOOL res = [pwdLocal isEqualToString:pwd];</span><br><span class="line">    //判断输入的密码和本地密码是否一致</span><br><span class="line">    if(res)&#123;</span><br><span class="line">        [self.label showNormalMsg:CoreLockVerifySuccesslTitle];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [self.label showWarnMsg:CoreLockVerifyErrorPwdTitle];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9-密码sm3加密"><a href="#9-密码sm3加密" class="headerlink" title="9. 密码sm3加密"></a>9. 密码sm3加密</h4><p>对密码进行sm3加密，可以保证密码在传输过程中安全传输，实现源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *) sm3:(NSString *) input</span><br><span class="line">&#123;</span><br><span class="line">    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSData *outputData = [PwdLockSM3Coded sm3_hashWithPainData:inputData];</span><br><span class="line">    NSString *outputString = [CLLockVC convertDataToHexStr:outputData];</span><br><span class="line">    NSString *upper = [outputString uppercaseString];</span><br><span class="line">    return upper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-Javascript调用浏览器方法"><a href="#10-Javascript调用浏览器方法" class="headerlink" title="10. Javascript调用浏览器方法"></a>10. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const PwdLockPlugin = NativeModules.PwdLockPlugin;</span><br><span class="line">//设置手势密码</span><br><span class="line">PwdlockPlugin.SetPwdLock((msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br><span class="line">//验证手势密码</span><br><span class="line">PwdlockPlugin.DecryptLock((msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native浏览器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native浏览器插件/</id>
    <published>2018-12-16T09:34:19.000Z</published>
    <updated>2018-12-16T10:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生浏览器插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生浏览器插件是需要实现打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建WebviewManager类，实现自定义浏览器</p></li><li><p>新建Webview类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>URL规范检测</p></li><li><p>根据传参打开浏览器</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建WebviewManager类，实现自定义浏览器"><a href="#1-新建WebviewManager类，实现自定义浏览器" class="headerlink" title="1. 新建WebviewManager类，实现自定义浏览器"></a>1. 新建WebviewManager类，实现自定义浏览器</h5><p>新建继承UIViewController的WebviewManager类，并在.h声明webURL变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface WebviewManager : UIViewController</span><br><span class="line">@property(nonatomic,strong)NSString *webURL;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>通过webURL调用NSURLRequest 封装的requestWithURL方法打开浏览器，并在视图中显示，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.m</span><br><span class="line">#import &quot;WebviewManager.h&quot;</span><br><span class="line">#import&lt;WebKit/WebKit.h&gt;</span><br><span class="line">@interface WebviewManager ()</span><br><span class="line">@property(nonatomic,strong)WKWebView *webView;</span><br><span class="line">@end</span><br><span class="line">@implementation WebviewManager</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    btn.frame = CGRectMake(20, 30, 40, 24);</span><br><span class="line">    [btn setTitle:@&quot;返回&quot; forState:UIControlStateNormal];</span><br><span class="line">    [btn addTarget:self action:@selector(backAction)</span><br><span class="line">              forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    btn.titleLabel.font = [UIFont systemFontOfSize:15];</span><br><span class="line">    [btn setTitleColor:[UIColor blackColor]  forState:UIControlStateNormal];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line">    self.webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 64, [[UIScreen mainScreen]bounds].size.width, [[UIScreen mainScreen]bounds].size.height-64)];</span><br><span class="line">    [self.view addSubview:self.webView];</span><br><span class="line">    [self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:self.webURL]]];   </span><br><span class="line">&#125;</span><br><span class="line">- (void)backAction&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-新建Webview类，实现RCTBridgeModule协议"><a href="#2-新建Webview类，实现RCTBridgeModule协议" class="headerlink" title="2. 新建Webview类，实现RCTBridgeModule协议"></a>2. 新建Webview类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的Webview类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface Webview : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加RCT-EXPORT-MODULE-宏"><a href="#3-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="3. 添加RCT_EXPORT_MODULE()宏"></a>3. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，Webview的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“WebviewPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="4-添加React-Native跟控制器"><a href="#4-添加React-Native跟控制器" class="headerlink" title="4. 添加React Native跟控制器"></a>4. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="5-声明被JavaScript-调用的方法"><a href="#5-声明被JavaScript-调用的方法" class="headerlink" title="5. 声明被JavaScript 调用的方法"></a>5. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起打开浏览器方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="6-URL规范检测"><a href="#6-URL规范检测" class="headerlink" title="6. URL规范检测"></a>6. URL规范检测</h5><p>arguments字典是JavaScript调用方法传参用的，arguments字典里面的具体字段可以和JavaScript约定好，打开浏览器的url就是通过arguments字典传过来的，传过来的url字段还不能直接使用，需要检测是否符合url规范，否则是不能正常打开网页的。<br>URL规范检测代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)smartURLForString:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    NSString *     result;</span><br><span class="line">    NSString *  trimmedStr;</span><br><span class="line">    NSRange     schemeMarkerRange;</span><br><span class="line">    NSString *  scheme;</span><br><span class="line">    assert(str != nil);</span><br><span class="line">    result = nil;</span><br><span class="line">    trimmedStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br><span class="line">    if ( (trimmedStr != nil) &amp;&amp; (trimmedStr.length != 0) ) &#123;</span><br><span class="line">        schemeMarkerRange = [trimmedStr rangeOfString:@&quot;://&quot;];</span><br><span class="line">        if (schemeMarkerRange.location == NSNotFound) &#123;</span><br><span class="line">            result = [NSString stringWithFormat:@&quot;http://%@&quot;, trimmedStr];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scheme = [trimmedStr substringWithRange:NSMakeRange(0, schemeMarkerRange.location)];</span><br><span class="line">            assert(scheme != nil);</span><br><span class="line">            if ( ([scheme compare:@&quot;http&quot;  options:NSCaseInsensitiveSearch] == NSOrderedSame)</span><br><span class="line">                || ([scheme compare:@&quot;https&quot; options:NSCaseInsensitiveSearch] == NSOrderedSame) ) &#123;</span><br><span class="line">                result = trimmedStr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // It looks like this is some unsupported URL scheme.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-根据传参打开浏览器"><a href="#7-根据传参打开浏览器" class="headerlink" title="7. 根据传参打开浏览器"></a>7. 根据传参打开浏览器</h5><p>此浏览器插件支持打开自定义浏览器和打开默认浏览器，具体使用哪种方法打开浏览器，需要JavaScript通过arguments字典以字段的形式传过来，这里就使用openType字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    if ([arguments.allKeys containsObject:@&quot;url&quot;]) &#123;</span><br><span class="line">        NSString *url = [NSString stringWithFormat:@&quot;%@&quot;,arguments[@&quot;url&quot;]];</span><br><span class="line">        NSString *openURL = [self smartURLForString:url];</span><br><span class="line">        NSString *openType = arguments[@&quot;openType&quot;];</span><br><span class="line">        if (!ValidStr(url)&amp;&amp;!ValidStr(openType)) &#123;</span><br><span class="line">            CIBNSLog(@&quot;参数错误&quot;);</span><br><span class="line">            failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if ([openType isEqualToString:[NSString stringWithFormat:@&quot;0&quot;]]) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    WebviewManager *manager = [[WebviewManager alloc]init];</span><br><span class="line">                    manager.webURL = openURL;</span><br><span class="line">                    UIViewController *vc = RCTPresentedViewController();</span><br><span class="line">                    [vc presentViewController:manager animated:YES completion:nil];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSURL *urlStr = [NSURL URLWithString:openURL];</span><br><span class="line">                    [[UIApplication sharedApplication] openURL:urlStr];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const WebviewPlugin = NativeModules.WebviewPlugin;</span><br><span class="line">WebviewPlugin.open(&#123;url:&quot;http://www.baidu.com&quot;,openType:&quot;1&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native网络请求插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native网络请求插件/</id>
    <published>2018-12-16T09:11:01.000Z</published>
    <updated>2018-12-16T10:02:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍网络请求插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>网络请求插件是需要实现前端与服务端的数据交互，其中包括GET请求、POST请求、文件上传、单/多张图片上传、文件下载等功能。这些功能将通过封装后的方法暴漏出来，通过RN接口提供给Javascript开发使用。</p><p>具体的实现思路如下：</p><ol><li><p>新建NetWorkPlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>导入AFNetworking请求库</p></li><li><p>新建NetworkHelper类，封装实现网络请求功能</p></li><li><p>实现GET请求</p></li><li><p>实现POST请求</p></li><li><p>实现文件上传</p></li><li><p>实现单/多张图片上传</p></li><li><p>实现文件下载</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建NetWorkPlugin类，实现RCTBridgeModule协议"><a href="#1-新建NetWorkPlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建NetWorkPlugin类，实现RCTBridgeModule协议"></a>1. 新建NetWorkPlugin类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的NetWorkPlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface NetWorkPlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，NetWorkPlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“NetWorkPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。下面通过举例来展示声明的方法，通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(post:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;POST网络请求执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-导入AFNetworking请求库"><a href="#5-导入AFNetworking请求库" class="headerlink" title="5. 导入AFNetworking请求库"></a>5. 导入AFNetworking请求库</h5><p>网络请求使用的第三方库是AFNetworking，这个库很常见，也比较常用，就不做过多的描述，可手动导入也可使用cocoapods自动导入，导入之后在.m文件中引入头文件。</p><h5 id="6-新建NetworkHelper类，封装实现网络请求功能"><a href="#6-新建NetworkHelper类，封装实现网络请求功能" class="headerlink" title="6. 新建NetworkHelper类，封装实现网络请求功能"></a>6. 新建NetworkHelper类，封装实现网络请求功能</h5><p>新建继承NSObject的NetworkHelper类，定义枚举类型来判断网络状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NetworkStatusType) &#123;</span><br><span class="line">    /** 未知网络*/</span><br><span class="line">    NetworkStatusUnknown,</span><br><span class="line">    /** 无网络*/</span><br><span class="line">    NetworkStatusNotReachable,</span><br><span class="line">    /** 手机网络*/</span><br><span class="line">    NetworkStatusReachableViaWWAN,</span><br><span class="line">    /** WIFI网络*/</span><br><span class="line">    NetworkStatusReachableViaWiFi</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定义网络状态的Block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^NetworkStatus)(NetworkStatusType status);</span><br></pre></td></tr></table></figure></p><p>实时获取网络状态,通过Block回调实时获取(此方法可多次调用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkStatusWithBlock:(NetworkStatus)networkStatus;</span><br></pre></td></tr></table></figure></p><h5 id="7-实现GET请求"><a href="#7-实现GET请求" class="headerlink" title="7. 实现GET请求"></a>7. 实现GET请求</h5><p>声明GET请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)GET:(NSString *)URL</span><br><span class="line">                        parameters:(id)parameters</span><br><span class="line">                           success:(HttpRequestSuccess)success</span><br><span class="line">                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><h5 id="8-实现POST请求"><a href="#8-实现POST请求" class="headerlink" title="8. 实现POST请求"></a>8. 实现POST请求</h5><p>声明POST请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                         parameters:(id)parameters</span><br><span class="line">                            success:(HttpRequestSuccess)success</span><br><span class="line">                            failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>POST请求具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                parameters:(id)parameters</span><br><span class="line">                   success:(HttpRequestSuccess)success</span><br><span class="line">                   failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    [self setAFHTTPSessionManagerProperty:^(AFHTTPSessionManager *sessionManager) &#123;</span><br><span class="line">        [sessionManager.requestSerializer setQueryStringSerializationWithBlock:^NSString * _Nonnull(NSURLRequest * _Nonnull request, id  _Nonnull parameters, NSError * _Nullable __autoreleasing * _Nullable error) &#123;</span><br><span class="line">            return parameters;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-实现文件上传"><a href="#9-实现文件上传" class="headerlink" title="9. 实现文件上传"></a>9. 实现文件上传</h5><p>声明文件上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param names       文件对应服务器上的字段</span><br><span class="line"> *  @param filePaths   文件本地的沙盒路径</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                            names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                                        filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                                        progress:(HttpProgress)progress</span><br><span class="line">                                         success:(HttpRequestSuccess)success</span><br><span class="line">                                         failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>文件上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                             parameters:(id)parameters</span><br><span class="line">                                  names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                              filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                               progress:(HttpProgress)progress</span><br><span class="line">                                success:(HttpRequestSuccess)success</span><br><span class="line">                                failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; filePaths.count; i++) &#123;</span><br><span class="line">            NSString *name = names[i];</span><br><span class="line">            NSString *filePath = filePaths[i];</span><br><span class="line">            [formData appendPartWithFileURL:[NSURL fileURLWithPath:filePath] name:name error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        (failure &amp;&amp; error) ? failure(error) : nil;</span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        //上传进度</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="10-实现单-多张图片上传"><a href="#10-实现单-多张图片上传" class="headerlink" title="10. 实现单/多张图片上传"></a>10. 实现单/多张图片上传</h5><p>声明单/多张图片上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param name       图片对应服务器上的字段</span><br><span class="line"> *  @param images     图片数组</span><br><span class="line"> *  @param fileNames  图片文件名数组, 可以为nil, 数组内的文件名默认为当前日期时间&quot;yyyyMMddHHmmss&quot;</span><br><span class="line"> *  @param imageScale 图片文件压缩比 范围 (0.f ~ 1.f)</span><br><span class="line"> *  @param imageType  图片文件的类型,例:png、jpg(默认类型)....</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                                        parameters:(id)parameters</span><br><span class="line">                                              name:(NSString *)name</span><br><span class="line">                                            images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                         fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                                        imageScale:(CGFloat)imageScale</span><br><span class="line">                                         imageType:(NSString *)imageType</span><br><span class="line">                                          progress:(HttpProgress)progress</span><br><span class="line">                                           success:(HttpRequestSuccess)success</span><br><span class="line">                                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>图片经过等比压缩后得到的二进制文件，默认图片的文件名, 若fileNames为nil就使用，单/多张图片上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                               parameters:(id)parameters</span><br><span class="line">                                     name:(NSString *)name</span><br><span class="line">                                   images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                               imageScale:(CGFloat)imageScale</span><br><span class="line">                                imageType:(NSString *)imageType</span><br><span class="line">                                 progress:(HttpProgress)progress</span><br><span class="line">                                  success:(HttpRequestSuccess)success</span><br><span class="line">                                  failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line"></span><br><span class="line">        for (NSUInteger i = 0; i &lt; images.count; i++) &#123;</span><br><span class="line">            NSData *imageData = UIImageJPEGRepresentation(images[i], imageScale ?: 1.f);</span><br><span class="line"></span><br><span class="line">            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">            formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;</span><br><span class="line">            NSString *str = [formatter stringFromDate:[NSDate date]];</span><br><span class="line">            NSString *imageFileName = NSStringFormat(@&quot;%@%ld.%@&quot;,str,i,imageType?:@&quot;jpg&quot;);</span><br><span class="line"></span><br><span class="line">            [formData appendPartWithFileData:imageData</span><br><span class="line">                                        name:name</span><br><span class="line">                                    fileName:fileNames ? NSStringFormat(@&quot;%@.%@&quot;,fileNames[i],imageType?:@&quot;jpg&quot;) : imageFileName</span><br><span class="line">                                    mimeType:NSStringFormat(@&quot;image/%@&quot;,imageType ?: @&quot;jpg&quot;)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="11-实现文件下载"><a href="#11-实现文件下载" class="headerlink" title="11. 实现文件下载"></a>11. 实现文件下载</h5><p>声明文件下载方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL      请求地址</span><br><span class="line"> *  @param fileDir  文件存储目录(默认存储目录为Download)</span><br><span class="line"> *  @param progress 文件下载的进度信息</span><br><span class="line"> *  @param success  下载成功的回调(回调参数filePath:文件的路径)</span><br><span class="line"> *  @param failure  下载失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回NSURLSessionDownloadTask实例，可用于暂停继续，暂停调用suspend方法，开始下载调用resume方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                                       fileDir:(NSString *)fileDir</span><br><span class="line">                                      progress:(HttpProgress)progress</span><br><span class="line">                                       success:(void(^)(NSString *filePath))success</span><br><span class="line">                                       failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>在下载过程中可以获取到下载进度，下载流程为：缓存目录拼接完成，打开文件管理器，创建Download目录，拼接文件路径，返回文件位置的URL路径。文件下载具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                              fileDir:(NSString *)fileDir</span><br><span class="line">                             progress:(HttpProgress)progress</span><br><span class="line">                              success:(void(^)(NSString *))success</span><br><span class="line">                              failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:AllReplaceURL]];</span><br><span class="line">    __block NSURLSessionDownloadTask *downloadTask = [_sessionManager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(downloadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">        NSString *downloadDir = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileDir ? fileDir : @&quot;Download&quot;];</span><br><span class="line"></span><br><span class="line">        NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">        [fileManager createDirectoryAtPath:downloadDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line"></span><br><span class="line">        NSString *filePath = [downloadDir stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line"></span><br><span class="line">        return [NSURL fileURLWithPath:filePath];</span><br><span class="line"></span><br><span class="line">    &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        [[self allSessionTask] removeObject:downloadTask];</span><br><span class="line">        if(failure &amp;&amp; error) &#123;failure(error) ; return ;&#125;;</span><br><span class="line">        success ? success(filePath.absoluteString /** NSURL-&gt;NSString*/) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    [downloadTask resume];</span><br><span class="line">    downloadTask ? [[self allSessionTask] addObject:downloadTask] : nil ;</span><br><span class="line"></span><br><span class="line">    return downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="12-Javascript调用浏览器方法"><a href="#12-Javascript调用浏览器方法" class="headerlink" title="12. Javascript调用浏览器方法"></a>12. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const NetWorkPlugin = NativeModules.NetWorkPlugin;</span><br><span class="line">NetworkPlugin.post(&#123;url:&quot;http://192.168.1.1:8080/ApiSystem/login&quot;,params:&#123;name:&quot;15842137500&quot;,login_type:&quot;0&quot;,password:&quot;000000&quot;&#125;,headers:&#123;&#125;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-React Native 原生密码键盘插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native-%E5%8E%9F%E7%94%9F%E5%AF%86%E7%A0%81%E9%94%AE%E7%9B%98%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native-原生密码键盘插件/</id>
    <published>2018-12-08T12:48:03.000Z</published>
    <updated>2018-12-16T10:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><a id="more"></a><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生密码键盘插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生密码键盘插件是需要实现自定以键盘包含数字、大写字母、小写字母、特殊字符四种切换方式，并且需要实现随机键盘和非随机键盘模式。<br>实现根据密码包含数字、大写字母、小写字母、特殊字符种类判断密码强度和长度。<br>为了密码的安全考虑，实现对输出密码进行SM3加密。<br>实现键盘类型，其中包括以下6种类型：</p><blockquote><p> FBYCustomKeyBordType_NumWord,//数字及字母键盘<br>    FBYCustomKeyBordType_WordNum,//字母及数字键盘<br>    FBYCustomKeyBordType_NumWordSymbol,//数字及字母,标点键盘<br>    FBYCustomKeyBordType_WordNumSymbol,//字母及数字,标点键盘<br>    FBYCustomKeyBordType_Num,//仅数字键盘<br>    FBYCustomKeyBordType_Word//仅字母键盘</p></blockquote><p>基本键盘截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-439e92cad094e974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="66.png"></p><p>实现键盘视图显示类型，其中包括以下5种类型：</p><blockquote><p> FBYCustomKeyBordShowType_Common,//普通<br>    FBYCustomKeyBordShowType_Text,//文本框<br>    FBYCustomKeyBordShowType_Pass,//密码<br>    FBYCustomKeyBordShowType_PayPass,//支付密码格<br>    FBYCustomKeyBordShowType_NoTitle//无标题</p></blockquote><p>带有文本框的键盘：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-a49793a2fd35fc83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="88.png"></p><p>有支付密码格的键盘：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-a23509f64f8eda1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="99.png"></p><p>打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建CustomKeyboard类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>新建数字键盘FBYNumKeyBord类，实现相应视图及功能</p></li><li><p>新建字母键盘FBYWordKeyBord类，实现相应视图及功能</p></li><li><p>新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能</p></li><li><p>新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能</p></li><li><p>新建符号键盘FBYCustomKeyBord类，实现键盘类型切换功能</p></li><li><p>实现根据密码判断密码强度和长度功能</p></li><li><p>实现输出密码SM3加密功能</p></li><li><p>根据传参分析调用自定义键盘</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建CustomKeyboard类，实现RCTBridgeModule协议"><a href="#1-新建CustomKeyboard类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建CustomKeyboard类，实现RCTBridgeModule协议"></a>1. 新建CustomKeyboard类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的CustomKeyboard类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface CustomKeyboard : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，CustomKeyboard的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“KeybordPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(onKeyboard:(NSDictionary *)arguments</span><br><span class="line">                  :(RCTResponseSenderBlock)sucessCallback</span><br><span class="line">                  :(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起原生密码键盘方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-新建数字键盘FBYNumKeyBord类，实现相应视图及功能"><a href="#5-新建数字键盘FBYNumKeyBord类，实现相应视图及功能" class="headerlink" title="5. 新建数字键盘FBYNumKeyBord类，实现相应视图及功能"></a>5. 新建数字键盘FBYNumKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYNumKeyBord类中，视图包含0-9数字按钮、ABC字母切换按钮、@%#特殊字符切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-2417576b5300316d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="number.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//FBYNumKeyBord.m</span><br><span class="line">- (void)setRandom:(BOOL)random&#123;</span><br><span class="line">    _random = random;</span><br><span class="line">    if (random) &#123;</span><br><span class="line">        NSMutableArray *newArray = [NSMutableArray arrayWithArray:self.numArray];</span><br><span class="line">        for(int i = 0; i&lt; self.numArray.count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int m = (arc4random() % (self.numArray.count - i)) + i;</span><br><span class="line">            [newArray exchangeObjectAtIndex:i withObjectAtIndex: m];</span><br><span class="line">        &#125;</span><br><span class="line">        self.numArray = newArray;</span><br><span class="line">        for (UIButton *btn in self.subviews) &#123;</span><br><span class="line">            [btn removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">        [self addControl];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="6-新建字母键盘FBYWordKeyBord类，实现相应视图及功能"><a href="#6-新建字母键盘FBYWordKeyBord类，实现相应视图及功能" class="headerlink" title="6. 新建字母键盘FBYWordKeyBord类，实现相应视图及功能"></a>6. 新建字母键盘FBYWordKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYWordKeyBord类中，视图包含26个字母按钮、大小写切换按钮、123数字键盘切换按钮、@%#特殊字符切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-5c0e7fc781441217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="1234.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//FBYWordKeyBord.m</span><br><span class="line">for (int i = 0; i&lt; 26; i++) &#123;</span><br><span class="line">        FBYCustomKeyBordButton *btn = [FBYCustomKeyBordButton buttonWithTitle:self.wordArray[i] tag:i delegate:self];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchDown:) forControlEvents:(UIControlEventTouchDown)];</span><br><span class="line">         [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpOutside)];</span><br><span class="line">         [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchCancel)];</span><br><span class="line">        [btnArray addObject:btn];</span><br><span class="line">        [self addSubview:btn];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能"><a href="#7-新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能" class="headerlink" title="7. 新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能"></a>7. 新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYNumOnlyKeyBord类中，视图包含0-9数字按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-fe5cee6594182af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="0987.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//FBYNumOnlyKeyBord.m</span><br><span class="line">for (int i=0;i&lt;self.btnArray.count;i++) &#123;</span><br><span class="line">        UIButton *btn =self.btnArray[i];</span><br><span class="line">        if(i&lt;9)&#123;</span><br><span class="line">            btn.frame = CGRectMake(btn.tag % 3 * (btnW ), btn.tag / 3 * (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==9)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 1 * (btnW ),  3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==10)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 0* (btnW ),  3* (btnH ) , btnW, btnH);</span><br><span class="line"></span><br><span class="line">        &#125;else if (i==11)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 2* (btnW ), 3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==12)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 0* (btnW ), 3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能"><a href="#8-新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能" class="headerlink" title="8. 新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能"></a>8. 新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYSymbolKeyBord类中，视图包含30种特殊字符按钮、123数字键盘切换按钮、ABC字母切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-629be3c087db45af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="4321.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//FBYSymbolKeyBord.m</span><br><span class="line">- (NSArray *)symbolArray&#123;</span><br><span class="line">    if (!_symbolArray) &#123;</span><br><span class="line">        _symbolArray = @[@&quot;*&quot;,@&quot;/&quot;,@&quot;:&quot;,@&quot;;&quot;,@&quot;(&quot;,@&quot;)&quot;,@&quot;[&quot;,@&quot;]&quot;,@&quot;$&quot;,@&quot;=&quot;,@&quot;!&quot;,@&quot;^&quot;,@&quot;&amp;&quot;,@&quot;%&quot;,@&quot;+&quot;,@&quot;-&quot;,@&quot;￥&quot;,@&quot;?&quot;,@&quot;&#123;&quot;,@&quot;&#125;&quot;,@&quot;#&quot;,@&quot;_&quot;,@&quot;\\&quot;,@&quot;|&quot;,@&quot;~&quot;,@&quot;`&quot;,@&quot;∑&quot;,@&quot;€&quot;,@&quot;£&quot;,@&quot;。&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return _symbolArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addControl&#123;</span><br><span class="line">    NSMutableArray *btnArray = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">        FBYCustomKeyBordButton *btn = [FBYCustomKeyBordButton buttonWithTitle:self.symbolArray[i] tag:i delegate:self];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchDown:) forControlEvents:(UIControlEventTouchDown)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpOutside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchCancel)];</span><br><span class="line">        [self addSubview:btn];</span><br><span class="line">        [btnArray addObject:btn];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-新建FBYCustomKeyBord类，实现键盘类型切换功能"><a href="#9-新建FBYCustomKeyBord类，实现键盘类型切换功能" class="headerlink" title="9. 新建FBYCustomKeyBord类，实现键盘类型切换功能"></a>9. 新建FBYCustomKeyBord类，实现键盘类型切换功能</h5><p>FBYCustomKeyBord类中根据JS调用键盘时传入的参数，来实现何种键盘模式，实现键盘类型，共有6种类型：数字及字母、字母及数字、数字及字母特殊字符、字母及数字特殊字符、仅数字、仅字母。<br>键盘视图显示类型，共包括5种类型：普通、文本框、密码、支付密码格、无标题。<br>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-(void)setKeybordType:(FBYCustomKeyBordType)keybordType&#123;</span><br><span class="line">    _keybordType=keybordType;</span><br><span class="line">    [self.numPad removeFromSuperview];</span><br><span class="line">    if(_keybordType==FBYCustomKeyBordType_NumWord)&#123;</span><br><span class="line">        self.numPad.random=self.random;</span><br><span class="line">        self.numPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_WordNum)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_Num)&#123;</span><br><span class="line">        self.numOnlyPad.random=self.random;</span><br><span class="line">        self.numOnlyPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numOnlyPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_NumWordSymbol)&#123;</span><br><span class="line">        self.numPad.random=self.random;</span><br><span class="line">        self.numPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_Word)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;else if (keybordType==FBYCustomKeyBordType_WordNumSymbol)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="10-实现根据密码判断密码强度和长度功能"><a href="#10-实现根据密码判断密码强度和长度功能" class="headerlink" title="10. 实现根据密码判断密码强度和长度功能"></a>10. 实现根据密码判断密码强度和长度功能</h5><p>根据密码字符串获取其长度,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//FBYCustomKeyBord.m</span><br><span class="line">#pragma mark 长度计算</span><br><span class="line">-(NSUInteger)messageLength:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line"></span><br><span class="line">    NSUInteger length= msg.length;</span><br><span class="line">    NSLog(@&quot;%lu&quot;,(unsigned long)length);</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据密码字符串message，通过正则校验，判断字符串中包含几种字符，进而判断其密码强度。<br>总共是数字、大写字母、小写字母、特殊字符四种状态，包含两种强度为弱，包含三种强度为中，包含四种强度为强,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//FBYCustomKeyBord.m</span><br><span class="line">#pragma mark 强度计算</span><br><span class="line">-(NSUInteger)messageStrength:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line">    NSUInteger length= msg.length;</span><br><span class="line">    BOOL capitalBool = NO;</span><br><span class="line">    BOOL lowercaseBool = NO;</span><br><span class="line">    BOOL numberBool = NO;</span><br><span class="line">    BOOL stringBool = NO;</span><br><span class="line">    NSString* result1;</span><br><span class="line">    NSString* result2;</span><br><span class="line">    NSString* result3;</span><br><span class="line">    NSString* result4;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        char commitChar = [msg characterAtIndex:i];</span><br><span class="line">        if((commitChar&gt;64)&amp;&amp;(commitChar&lt;91))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有大写英文字母&quot;);</span><br><span class="line">            capitalBool = YES;</span><br><span class="line">        &#125;else if((commitChar&gt;96)&amp;&amp;(commitChar&lt;123))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有小写英文字母&quot;);</span><br><span class="line">            lowercaseBool = YES;</span><br><span class="line">        &#125;else if((commitChar&gt;47)&amp;&amp;(commitChar&lt;58))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有数字&quot;);</span><br><span class="line">            numberBool = YES;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有空格&quot;);</span><br><span class="line">            stringBool = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result1 = [NSString stringWithFormat:@&quot;%d&quot;,capitalBool];</span><br><span class="line">    result2 = [NSString stringWithFormat:@&quot;%d&quot;,lowercaseBool];</span><br><span class="line">    result3 = [NSString stringWithFormat:@&quot;%d&quot;,numberBool];</span><br><span class="line">    result4 = [NSString stringWithFormat:@&quot;%d&quot;,stringBool];</span><br><span class="line"></span><br><span class="line">    NSMutableArray* resultArray = [[NSMutableArray alloc] init];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result1]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result2]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result3]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result4]];</span><br><span class="line">    int intResult=0;</span><br><span class="line">    for (int j=0; j&lt;[resultArray count]; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([[resultArray objectAtIndex:j] isEqualToString:@&quot;1&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            intResult++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSUInteger result;</span><br><span class="line">    if (intResult == 4)&#123;</span><br><span class="line">        result = 3;</span><br><span class="line">    &#125;else if (intResult == 3)&#123;</span><br><span class="line">        result = 2;</span><br><span class="line">    &#125;else if (intResult == 2)&#123;</span><br><span class="line">        result = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="11-实现输出密码SM3加密功能"><a href="#11-实现输出密码SM3加密功能" class="headerlink" title="11. 实现输出密码SM3加密功能"></a>11. 实现输出密码SM3加密功能</h5><p> 这里的密码加密采用的是国密SM3加密方式，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 加密设置</span><br><span class="line">-(NSString *)encryptMessage:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line">    return [self sm3:msg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 对字符串做sm3处理</span><br><span class="line">- (NSString *) sm3:(NSString *) input</span><br><span class="line">&#123;</span><br><span class="line">    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSData *outputData = [CustomKBSM3Coded sm3_hashWithPainData:inputData];</span><br><span class="line">    //NSString *outputString = [GTMBase64 stringByEncodingData:outputData];</span><br><span class="line">    NSString *outputString = [self convertDataToHexStr:outputData];</span><br><span class="line">    NSString *upper = [outputString uppercaseString];</span><br><span class="line">    return upper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="12-根据传参打开浏览器"><a href="#12-根据传参打开浏览器" class="headerlink" title="12. 根据传参打开浏览器"></a>12. 根据传参打开浏览器</h5><p>此浏览器插件支持打开自定义浏览器和打开默认浏览器，具体使用哪种方法打开浏览器，需要JavaScript通过arguments字典以字段的形式传过来，这里就使用openType字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@interface CustomKeyboard ()&lt;FBYCustomKeyBordDelegate&gt;</span><br><span class="line">@property(strong,nonatomic)RCTResponseSenderBlock sucessCallback;</span><br><span class="line">@property(strong,nonatomic)RCTResponseSenderBlock failCallback;</span><br><span class="line">@property (nonatomic, strong) FBYCustomKeyBord *keyBoard;</span><br><span class="line">@property(assign,nonatomic)FBYCustomKeyBordType keybordType;</span><br><span class="line">@property(assign,nonatomic)FBYCustomKeyBordShowType keybordShowType;</span><br><span class="line">@property(strong,nonatomic)NSString *tag;</span><br><span class="line">@property(strong,nonatomic)NSString *isUp;</span><br><span class="line">@end</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.keyBoard = [FBYCustomKeyBord instance];</span><br><span class="line">        self.keyBoard.delegate = self;</span><br><span class="line">        self.sucessCallback = sucessCallback;</span><br><span class="line">        self.failCallback =  failCallback;</span><br><span class="line">        NSString *isUp=@&quot;1&quot;;</span><br><span class="line">        NSString *isRandom=@&quot;0&quot;;</span><br><span class="line">        NSString *type=@&quot;4&quot;;</span><br><span class="line">        NSString *showType=@&quot;0&quot;;</span><br><span class="line">        NSString *isEncrypt=@&quot;0&quot;;</span><br><span class="line">        //是否是随机键盘</span><br><span class="line">        self.keyBoard.random = YES;</span><br><span class="line">        self.keybordType = FBYCustomKeyBordType_Num;   </span><br><span class="line">        self.keybordShowType = FBYCustomKeyBordShowType_Common;     </span><br><span class="line">        self.keyBoard.keybordType = self.keybordType;</span><br><span class="line">        //弹起键盘或收起键盘</span><br><span class="line">        self.keyBoard.keybordShowType = self.keybordShowType;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if ((isUp==nil) || isUp.intValue == 1) &#123;</span><br><span class="line">                [self.keyBoard popKeyBordInParent:RCTPresentedViewController()];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [self.keyBoard disappearSwitchBtnClickWithBlock:^&#123;</span><br><span class="line">                    self.sucessCallback(@[@&#123;SucessReslutCode:@&quot;1&quot;,SucessData:@&quot;ok&quot;&#125;]);</span><br><span class="line">                    CIBNSLog(@&quot;成功调起密码键盘方法&quot;);</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//键盘数据回调</span><br><span class="line">-(void)customKeybord:(FBYCustomKeyBord *)keybord didReturnMessage:(NSString *)message withLength:(NSUInteger)length withStrength:(NSUInteger)strength&#123;</span><br><span class="line">    if(self.tag == nil)&#123;</span><br><span class="line">        self.tag = [CustomKeyboard getSecondTimeStringSince1970];</span><br><span class="line">    &#125;</span><br><span class="line">    if (![self.isUp isEqualToString:@&quot;0&quot;]) &#123;</span><br><span class="line">        self.sucessCallback(@[@&#123;SucessReslutCode:@&quot;1&quot;,SucessData:@&#123;@&quot;pwdLength&quot;:[NSString stringWithFormat:@&quot;%lu&quot;,(unsigned long)length],@&quot;pwdStrong&quot;:[NSString stringWithFormat:@&quot;%lu&quot;,strength],@&quot;pwdValue&quot;:message&#125;&#125;]);</span><br><span class="line">        NSLog(@&quot;成功调起密码键盘方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="13-Javascript调用浏览器方法"><a href="#13-Javascript调用浏览器方法" class="headerlink" title="13. Javascript调用浏览器方法"></a>13. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const CustomkeyBoardPlugin = NativeModules.KeybordPlugin;</span><br><span class="line">CustomkeyBoardPlugin.onKeyboard(&#123;isRandom:&quot;1&quot;,isUp:&quot;1&quot;,type:&quot;4&quot;,showType:&quot;3&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>第三方微信登录 | 静默授权与网页授权的实现</title>
    <link href="https://fanbaoying.github.io/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95-%E9%9D%99%E9%BB%98%E6%8E%88%E6%9D%83%E4%B8%8E%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fanbaoying.github.io/第三方微信登录-静默授权与网页授权的实现/</id>
    <published>2018-04-17T01:24:45.000Z</published>
    <updated>2018-04-17T01:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>第三方登录有QQ、微信、微博、支付宝等等，如果现在自己的项目中实现这些登录，即可以使用友盟的sdk，也可以一个一个接入，各有各的有点，这里不做赘述。</p><p>今天和大家分享的是，在项目中实现微信登录，虽然微信官网给出了接入文档，但是我在接入的过程中，遇到一些问题，在此做出总结以便大家参考。主要讲微信snsapi_base静默授权与snsapi_userinfo网页授权的实现。</p><a id="more"></a><h2 id="二：准备工作"><a href="#二：准备工作" class="headerlink" title="二：准备工作"></a>二：准备工作</h2><p>移动应用微信登录是基于OAuth2.0标准协议构建的微信OAuth2.0授权登录系统。</p><p>在进行微信OAuth2.0授权登录接入之前，需要完成一下工作才可以开始介接入：</p><ol><li>在微信开放平台注册开发者帐号；</li><li>拥有一个已审核通过的移动应用；</li><li>并获得相应的AppID和AppSecret；</li><li>申请微信登录且通过审核。</li></ol><h2 id="三：授权流程"><a href="#三：授权流程" class="headerlink" title="三：授权流程"></a>三：授权流程</h2><p>微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为：</p><ol><li>第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；</li><li>通过code参数加上AppID和AppSecret等，通过API换取access_token；</li><li>通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。</li></ol><p>获取access_token时序图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-006de32d62d4a298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="h.png"></p><h2 id="四：静默授权与网页授权的实现"><a href="#四：静默授权与网页授权的实现" class="headerlink" title="四：静默授权与网页授权的实现"></a>四：静默授权与网页授权的实现</h2><h4 id="1-静默授权与网页授权的区别"><a href="#1-静默授权与网页授权的区别" class="headerlink" title="1. 静默授权与网页授权的区别"></a>1. 静默授权与网页授权的区别</h4><p>网页授权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.scope = @&quot;snsapi_userinfo&quot;;</span><br></pre></td></tr></table></figure></p><p>静默授权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.scope = @&quot;snsapi_base&quot;;</span><br></pre></td></tr></table></figure></p><p>snsapi_base与snsapi_userinfo属于微信网页授权获取用户信息的两种作用域：</p><p>snsapi_base只能获取access_token和openID</p><p>snsapi_userinfo可以获取更详细的用户资料，比如头像、昵称、性别等</p><h4 id="2-获取CODE"><a href="#2-获取CODE" class="headerlink" title="2. 获取CODE"></a>2. 获取CODE</h4><p>再登录按钮的点击事件中写入一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//构造SendAuthReq结构体</span><br><span class="line">SendAuthReq* req =[[[SendAuthReq alloc]init]autorelease];</span><br><span class="line">req.scope = @&quot;snsapi_userinfo&quot;;</span><br><span class="line">req.state = @&quot;123&quot;;</span><br><span class="line">//第三方向微信终端发送一个SendAuthReq消息结构</span><br><span class="line">[WXApi sendReq:req];</span><br></pre></td></tr></table></figure><p>在AppDelegate的didFinishLaunchingWithOptions方法中注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WXApi registerApp:@&quot;wx1234567890&quot;];</span><br></pre></td></tr></table></figure><p>“wx1234567890”为appid，请更换为自己项目的appid</p><p>拉起微信打开授权登录页如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-fa107c90fd2394c5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>点击确认登陆，授权后回调 WXApiDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(void)onResp:(BaseReq *)resp</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     ErrCode ERR_OK = 0(用户同意)</span><br><span class="line">     ERR_AUTH_DENIED = -4（用户拒绝授权）</span><br><span class="line">     ERR_USER_CANCEL = -2（用户取消）</span><br><span class="line">     code    用户换取access_token的code，仅在ErrCode为0时有效</span><br><span class="line">     state   第三方程序发送时用来标识其请求的唯一性的标志，由第三方程序调用sendReq时传入，由微信终端回传，state字符串长度不能超过1K</span><br><span class="line">     lang    微信客户端当前语言</span><br><span class="line">     country 微信用户当前国家信息</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if ([resp isKindOfClass:[SendAuthResp class]]) //判断是否为授权请求，否则与微信支付等功能发生冲突</span><br><span class="line">    &#123;</span><br><span class="line">        SendAuthResp *aresp = (SendAuthResp *)resp;</span><br><span class="line">        if (aresp.errCode== 0)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;code %@&quot;,aresp.code);</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;wechatDidLoginNotification&quot; object:self userInfo:@&#123;@&quot;code&quot;:aresp.code&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用通知，将aresp.code传递到登录页面</p><h4 id="3-通过code获取access-token"><a href="#3-通过code获取access-token" class="headerlink" title="3. 通过code获取access_token"></a>3. 通过code获取access_token</h4><p>在登录页面通过通知，获取到code之后，请求以下链接获取access_token：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>appid：应用唯一标识，在微信开放平台提交应用审核通过后获得</li><li>secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</li><li>code：填写第一步获取的code参数</li><li>grant_type：填authorization_code</li></ul><p>网络请求返回的参数格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">&quot;expires_in&quot;:7200,</span><br><span class="line">&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;scope&quot;:&quot;SCOPE&quot;,</span><br><span class="line">&quot;unionid&quot;:&quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：接口调用凭证</li><li>expires_in：access_token接口调用凭证超时时间，单位（秒）</li><li>refresh_token：用户刷新access_token</li><li>openid：授权用户唯一标识</li><li>scope：用户授权的作用域，使用逗号（,）分隔</li><li>unionid：当且仅当该移动应用已获得该用户的userinfo授权时，才会出现该字段</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><p>1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）；<br>2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为；<br>3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。</p><p>还有就是要注意网络授权<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">网页授权access_token</a> 与 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">普通access_token</a>的区别：<br>1、网页授权的access_token在每次获取openID时一起更新，在接口调用频次限制中为“无上限”；<br>2、普通access_token一般限制为2000次/日，需要自己保存起来并定时更新。</p></blockquote><p>到这里同时获得access_token和openid，静默授权与网页授权操作都是一样的。根据官网文档，网页授权还可以进一步操作，获取用户更多详细信息。</p><h4 id="4-获取用户个人信息（UnionID机制）"><a href="#4-获取用户个人信息（UnionID机制）" class="headerlink" title="4. 获取用户个人信息（UnionID机制）"></a>4. 获取用户个人信息（UnionID机制）</h4><p>此接口用于获取用户个人信息，开发者可通过OpenID来获取用户基本信息，接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：调用凭证</li><li>openid：普通用户的标识，对当前开发者帐号唯一</li></ul><p>正确的Json返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;nickname&quot;:&quot;NICKNAME&quot;,</span><br><span class="line">&quot;sex&quot;:1,</span><br><span class="line">&quot;province&quot;:&quot;PROVINCE&quot;,</span><br><span class="line">&quot;city&quot;:&quot;CITY&quot;,</span><br><span class="line">&quot;country&quot;:&quot;COUNTRY&quot;,</span><br><span class="line">&quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span><br><span class="line">&quot;privilege&quot;:[</span><br><span class="line">&quot;PRIVILEGE1&quot;,</span><br><span class="line">&quot;PRIVILEGE2&quot;</span><br><span class="line">],</span><br><span class="line">&quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-静默授权获取到用户详细资料"><a href="#5-静默授权获取到用户详细资料" class="headerlink" title="5. 静默授权获取到用户详细资料"></a>5. 静默授权获取到用户详细资料</h4><p>在第3步通过snsapi_base，同时获得access_token和openid，</p><p>把这里的access_token和openid用于下面接口中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：调用凭证</li><li>openid：普通用户的标识，对当前开发者帐号唯一</li><li>lang：国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语，默认为zh-CN</li></ul><p>Json返回结果和snsapi_userinfo下获取的用户详情一样。</p><p>但是这个方法的前提是同一个公众号内，用户关注了，如果是其他公众号，还是需要用户点击授权的。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;第三方登录有QQ、微信、微博、支付宝等等，如果现在自己的项目中实现这些登录，即可以使用友盟的sdk，也可以一个一个接入，各有各的有点，这里不做赘述。&lt;/p&gt;
&lt;p&gt;今天和大家分享的是，在项目中实现微信登录，虽然微信官网给出了接入文档，但是我在接入的过程中，遇到一些问题，在此做出总结以便大家参考。主要讲微信snsapi_base静默授权与snsapi_userinfo网页授权的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>AVFoundation | 封装一个好用的视频播放器</title>
    <link href="https://fanbaoying.github.io/AVFoundation-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://fanbaoying.github.io/AVFoundation-封装一个好用的视频播放器/</id>
    <published>2018-04-06T07:25:43.000Z</published>
    <updated>2018-04-08T01:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="video.png"></p><p>上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。</p><a id="more"></a><ul><li><p>CoreAudio : 处理所有音频事件.是由多个框架整合在一起的总称,为音频和MIDI内容的录制,播放和处理提供相应接口.设置可以针对音频信号进行完全控制,并通过Audio Units来构建一些复杂的音频处理.有兴趣的可以单独了解一下这个框架。</p></li><li><p>CoreMedia: 是AVFoundation所用到低层级媒体管道的一部分.提供音频样本和视频帧处理所需的低层级数据类型和接口。</p></li><li><p>CoreAnimation: 动画相关框架, 封装了支持OpenGL和OpenGL ES功能的ObjC各种类. AVFoundation可以利用CoreAnimation让开发者能够在视频的编辑和播放过程中添加动画和图片效果。</p></li></ul><p>下面我就和大家详细的分享一下，如何使用AVFoundation来实现一个好用的视频播放器。如果好用或者对你有所帮助，不要忘了关注点个赞呦！！！</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>视频控制界面实现</p></li><li><p>用于视频显示的View创建</p></li><li><p>视频数据下载器FBYVideoDownload创建</p></li><li><p>播放、暂停、横竖屏操作方法实现</p></li><li><p>监听播放进度</p></li><li><p>控制存储缓冲范围</p></li><li><p>拖动滑块，控制快进快退</p></li><li><p>定义临时文件路径</p></li><li><p>定义缓存文件夹路径</p></li><li><p>发起视频路径网路请求方法</p></li><li><p>播放结束设置</p></li><li><p>前后视频播放控制</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-视频控制界面实现"><a href="#1-视频控制界面实现" class="headerlink" title="1. 视频控制界面实现"></a>1. 视频控制界面实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (FBYVideoPlayerView *)videoPlayControl&#123;</span><br><span class="line">    if (!_videoPlayControl) &#123;</span><br><span class="line">        _videoPlayControl = [[FBYVideoPlayerView alloc] initWithFrame:self.backgroundView.bounds];</span><br><span class="line">        [self.backgroundView addSubview:_videoPlayControl];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return _videoPlayControl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-用于视频显示的View创建"><a href="#2-用于视频显示的View创建" class="headerlink" title="2. 用于视频显示的View创建"></a>2. 用于视频显示的View创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)videoShowView&#123;</span><br><span class="line">    if (!_videoShowView) &#123;</span><br><span class="line">        _videoShowView = [[UIView alloc] init];</span><br><span class="line">        _videoShowView.layer.masksToBounds = YES;</span><br><span class="line">        [self.backgroundView addSubview:_videoShowView];</span><br><span class="line">    &#125;</span><br><span class="line">    return _videoShowView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-视频数据下载器FBYVideoDownload创建"><a href="#3-视频数据下载器FBYVideoDownload创建" class="headerlink" title="3. 视频数据下载器FBYVideoDownload创建"></a>3. 视频数据下载器FBYVideoDownload创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, weak) id &lt;FBYVideoDownloadDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">//定义初始化方法 传入videoUrl参数（NSString）</span><br><span class="line">- (instancetype)initWithURL:(NSString *)videoUrl withDelegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">//开始下载</span><br><span class="line">- (void)start;</span><br><span class="line">//暂停</span><br><span class="line">- (void)suspend;</span><br><span class="line">//关闭</span><br><span class="line">- (void)cancel;</span><br></pre></td></tr></table></figure><h4 id="4-播放、暂停、横竖屏操作方法实现"><a href="#4-播放、暂停、横竖屏操作方法实现" class="headerlink" title="4. 播放、暂停、横竖屏操作方法实现"></a>4. 播放、暂停、横竖屏操作方法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//全屏</span><br><span class="line">[_videoPlayControl setFullScreenButtonClick_block:^&#123;</span><br><span class="line">    if (weakSelf.delegate &amp;&amp; [weakSelf.delegate respondsToSelector:@selector(videoPlayerDidFullScreenButtonClick)]) &#123;</span><br><span class="line">        [weakSelf.delegate videoPlayerDidFullScreenButtonClick];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">//播放/暂停</span><br><span class="line">[_videoPlayControl setPlayButtonClick_block:^(BOOL play) &#123;</span><br><span class="line">    if (play) &#123;</span><br><span class="line">        [weakSelf.player play];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [weakSelf.player pause];</span><br><span class="line">    &#125;</span><br><span class="line">    weakSelf.playButtonState = !weakSelf.playButtonState;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="5-监听播放进度"><a href="#5-监听播放进度" class="headerlink" title="5. 监听播放进度"></a>5. 监听播放进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.timeObserve = [self.player addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) &#123;</span><br><span class="line">        CGFloat current = CMTimeGetSeconds(time);</span><br><span class="line">        CGFloat total = CMTimeGetSeconds(weakSelf.currentPlayerItem.duration);</span><br><span class="line">        CGFloat progress = current / total;</span><br><span class="line"></span><br><span class="line">        weakSelf.videoPlayControl.currentTime = current;</span><br><span class="line">        weakSelf.videoPlayControl.playValue = progress;</span><br><span class="line"></span><br><span class="line">        if (weakSelf.isCanToGetLocalTime) &#123;</span><br><span class="line">            weakSelf.localTime = [weakSelf getLocalTime];</span><br><span class="line">        &#125;</span><br><span class="line">        NSInteger timeNow = [weakSelf getLocalTime];</span><br><span class="line">        if (timeNow - weakSelf.localTime &gt; 1.5) &#123;</span><br><span class="line">            [weakSelf.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">            weakSelf.isCanToGetLocalTime = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h4 id="6-监听播放器的状态"><a href="#6-监听播放器的状态" class="headerlink" title="6. 监听播放器的状态"></a>6. 监听播放器的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="7-监听当前的缓冲进度"><a href="#7-监听当前的缓冲进度" class="headerlink" title="7. 监听当前的缓冲进度"></a>7. 监听当前的缓冲进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;loadedTimeRanges&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="8-监听到当前没有缓冲数据"><a href="#8-监听到当前没有缓冲数据" class="headerlink" title="8. 监听到当前没有缓冲数据"></a>8. 监听到当前没有缓冲数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;playbackBufferEmpty&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="9-控制存储缓冲范围"><a href="#9-控制存储缓冲范围" class="headerlink" title="9. 控制存储缓冲范围"></a>9. 控制存储缓冲范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)playForActivity&#123;</span><br><span class="line">    if (self.playButtonState) &#123;</span><br><span class="line">        [self.player play];</span><br><span class="line">    &#125;</span><br><span class="line">    self.isBufferEmpty = NO;</span><br><span class="line">    self.isPlaying = YES;</span><br><span class="line">    [self.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-拖动滑块，控制快进快退"><a href="#10-拖动滑块，控制快进快退" class="headerlink" title="10. 拖动滑块，控制快进快退"></a>10. 拖动滑块，控制快进快退</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//拖动滑块</span><br><span class="line">[_videoPlayControl setSliderTouchEnd_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">//快进快退</span><br><span class="line">[_videoPlayControl setFastFastForwardAndRewind_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure><h4 id="11-定义临时文件路径"><a href="#11-定义临时文件路径" class="headerlink" title="11. 定义临时文件路径"></a>11. 定义临时文件路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoTempPath = [NSString tempFilePathWithFileName:videoName];</span><br></pre></td></tr></table></figure><h4 id="12-定义缓存文件夹路径"><a href="#12-定义缓存文件夹路径" class="headerlink" title="12. 定义缓存文件夹路径"></a>12. 定义缓存文件夹路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoCachePath = [NSString cacheFilePathWithName:videoName];</span><br></pre></td></tr></table></figure><h4 id="13-发起视频路径网路请求方法"><a href="#13-发起视频路径网路请求方法" class="headerlink" title="13. 发起视频路径网路请求方法"></a>13. 发起视频路径网路请求方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendHttpRequst</span><br><span class="line">&#123;</span><br><span class="line">    [_fileHandle seekToEndOfFile];</span><br><span class="line">    NSURL *url = [NSURL URLWithString:_videoUrl];</span><br><span class="line">    NSMutableURLRequest *requeset = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    //指定头信息  当前已下载的进度</span><br><span class="line">    [requeset setValue:[NSString stringWithFormat:@&quot;bytes=%ld-&quot;, _curruentLength] forHTTPHeaderField:@&quot;Range&quot;];</span><br><span class="line"></span><br><span class="line">    //创建请求</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self.session dataTaskWithRequest:requeset];</span><br><span class="line">    self.dataTask = dataTask;</span><br><span class="line"></span><br><span class="line">    //发起请求</span><br><span class="line">    [self.dataTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-播放结束设置"><a href="#14-播放结束设置" class="headerlink" title="14. 播放结束设置"></a>14. 播放结束设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)playerItemDidPlayToEnd:(NSNotification *)notification&#123;</span><br><span class="line">    //重新开始播放</span><br><span class="line">    __weak typeof(self) weak_self = self;</span><br><span class="line">    [self.player seekToTime:CMTimeMake(0, 1) completionHandler:^(BOOL finished) &#123;</span><br><span class="line">        __strong typeof(weak_self) strong_self = weak_self;</span><br><span class="line">        if (!strong_self) return;</span><br><span class="line">        [strong_self.player play];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-前后视频播放控制"><a href="#15-前后视频播放控制" class="headerlink" title="15. 前后视频播放控制"></a>15. 前后视频播放控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//进入后台</span><br><span class="line">- (void)appDidEnterBackground&#123;</span><br><span class="line">    if (self.stopWhenAppDidEnterBackground) &#123;</span><br><span class="line">        [self pauseVideo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//进入前台</span><br><span class="line">- (void)appDidEnterForeground&#123;</span><br><span class="line">    [self playVideo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYVideoData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"><a href="#2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理" class="headerlink" title="2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"></a>2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYVideoPlayer.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;FBYVideoPlayerDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic ,strong) FBYVideoPlayer *videoPlayer;</span><br><span class="line">@property (nonatomic ,strong) UIView *videoPlayBGView;</span><br><span class="line">@property (nonatomic ,copy)   NSString*videoUrl;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-初始化创建基层view"><a href="#3-初始化创建基层view" class="headerlink" title="3. 初始化创建基层view"></a>3. 初始化创建基层view</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayBGView = [[UIView alloc] initWithFrame:CGRectMake(0, 90, SCREEN_WIDTH, SCREEN_WIDTH * 0.6)];</span><br><span class="line">self.videoPlayBGView.backgroundColor = [UIColor blackColor];</span><br><span class="line">    [self.view addSubview:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="4-初始化调用视频播放方法"><a href="#4-初始化调用视频播放方法" class="headerlink" title="4. 初始化调用视频播放方法"></a>4. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="5-初始化调用视频播放方法"><a href="#5-初始化调用视频播放方法" class="headerlink" title="5. 初始化调用视频播放方法"></a>5. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYVideoPlayer-iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;video.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>人脸识别 -- 活体检测(张嘴摇头识别)</title>
    <link href="https://fanbaoying.github.io/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%B4%BB%E4%BD%93%E6%A3%80%E6%B5%8B-%E5%BC%A0%E5%98%B4%E6%91%87%E5%A4%B4%E8%AF%86%E5%88%AB/"/>
    <id>https://fanbaoying.github.io/人脸识别-活体检测-张嘴摇头识别/</id>
    <published>2018-03-19T01:14:22.000Z</published>
    <updated>2018-03-19T01:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。</p><p>大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。</p><p>在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>点击识别按钮，调用相机</p></li><li><p>CameraRules类，检测相机权限</p></li><li><p>初始化页面，创建摄像页面，创建张嘴数据和摇头数据</p></li><li><p>开启识别，脸部框识别</p></li><li><p>脸部部位识别，脸部识别判断是否检测到人脸</p></li><li><p>检测到人脸之后，判断位置</p></li><li><p>位置判断合适，判断是否张嘴</p></li><li><p>张嘴判断完毕，验证是否摇头</p></li><li><p>摇头判断完毕，3秒倒计时拍照</p></li><li><p>拍照完毕，选择重拍或者上传图片</p></li><li><p>选择重拍重复5-9步骤，选择上传将图片数据回调</p></li><li><p>数据clean</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-点击识别按钮，调用相机"><a href="#1-点击识别按钮，调用相机" class="headerlink" title="1. 点击识别按钮，调用相机"></a>1. 点击识别按钮，调用相机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if([CameraRules isCapturePermissionGranted])&#123;</span><br><span class="line">        [self setDeviceAuthorized:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSString* info=@&quot;没有相机权限&quot;;</span><br><span class="line">            [self showAlert:info];</span><br><span class="line">            [self setDeviceAuthorized:NO];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-CameraRules类，检测相机权限"><a href="#2-CameraRules类，检测相机权限" class="headerlink" title="2. CameraRules类，检测相机权限"></a>2. CameraRules类，检测相机权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//检测相机权限</span><br><span class="line">+(BOOL)isCapturePermissionGranted&#123;</span><br><span class="line">    if([AVCaptureDevice respondsToSelector:@selector(authorizationStatusForMediaType:)])&#123;</span><br><span class="line">        AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];</span><br><span class="line">        if(authStatus ==AVAuthorizationStatusRestricted || authStatus ==AVAuthorizationStatusDenied)&#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(authStatus==AVAuthorizationStatusNotDetermined)&#123;</span><br><span class="line">            dispatch_semaphore_t sema = dispatch_semaphore_create(0);</span><br><span class="line">            __block BOOL isGranted=YES;</span><br><span class="line">            [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) &#123;</span><br><span class="line">                isGranted=granted;</span><br><span class="line">                dispatch_semaphore_signal(sema);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">            return isGranted;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据"><a href="#3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据" class="headerlink" title="3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据"></a>3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建摄像页面，创建张嘴数据和摇头数据</span><br><span class="line">[self faceUI];</span><br><span class="line">[self faceCamera];</span><br><span class="line">[self faceNumber];</span><br></pre></td></tr></table></figure><h4 id="4-开启识别，脸部框识别"><a href="#4-开启识别，脸部框识别" class="headerlink" title="4. 开启识别，脸部框识别"></a>4. 开启识别，脸部框识别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float cx = (left+right)/2;</span><br><span class="line">float cy = (top + bottom)/2;</span><br><span class="line">float w = right - left;</span><br><span class="line">float h = bottom - top;</span><br><span class="line">float ncx = cy ;</span><br><span class="line">float ncy = cx ;</span><br><span class="line"></span><br><span class="line">CGRect rectFace = CGRectMake(ncx-w/2 ,ncy-w/2 , w, h);</span><br><span class="line"></span><br><span class="line">if(!isFrontCamera)&#123;</span><br><span class="line">    rectFace=rSwap(rectFace);</span><br><span class="line">    rectFace=rRotate90(rectFace, faceImg.height, faceImg.width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL isNotLocation = [self identifyYourFaceLeft:left right:right top:top bottom:bottom];</span><br><span class="line"></span><br><span class="line">if (isNotLocation==YES) &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-脸部部位识别，脸部识别判断是否检测到人脸"><a href="#5-脸部部位识别，脸部识别判断是否检测到人脸" class="headerlink" title="5. 脸部部位识别，脸部识别判断是否检测到人脸"></a>5. 脸部部位识别，脸部识别判断是否检测到人脸</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for(id key in keys)&#123;</span><br><span class="line">    id attr=[landmarkDic objectForKey:key];</span><br><span class="line">    if(attr &amp;&amp; [attr isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line"></span><br><span class="line">        if(!isFrontCamera)&#123;</span><br><span class="line">            p=pSwap(p);</span><br><span class="line">            p=pRotate90(p, faceImg.height, faceImg.width);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isCrossBorder == YES) &#123;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        p=pScale(p, widthScaleBy, heightScaleBy);</span><br><span class="line"></span><br><span class="line">        [arrStrPoints addObject:NSStringFromCGPoint(p)];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-检测到人脸之后，判断位置动作提醒"><a href="#6-检测到人脸之后，判断位置动作提醒" class="headerlink" title="6. 检测到人脸之后，判断位置动作提醒"></a>6. 检测到人脸之后，判断位置动作提醒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if (right - left &lt; 230 || bottom - top &lt; 250) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太远了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else if (right - left &gt; 320 || bottom - top &gt; 320) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太近了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    if (isJudgeMouth != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复张嘴动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line"></span><br><span class="line">        if (left &lt; 100 || top &lt; 100 || right &gt; 460 || bottom &gt; 400) &#123;</span><br><span class="line">            isCrossBorder = YES;</span><br><span class="line">            isJudgeMouth = NO;</span><br><span class="line">            self.textLabel.text = @&quot;调整下位置先&quot;;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (isJudgeMouth == YES &amp;&amp; isShakeHead != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复摇头动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;shakeHead&quot; count:4];</span><br><span class="line">        number = 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        takePhotoNumber += 1;</span><br><span class="line">        if (takePhotoNumber == 2) &#123;</span><br><span class="line">            [self timeBegin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isCrossBorder = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-位置判断合适，判断是否张嘴"><a href="#7-位置判断合适，判断是否张嘴" class="headerlink" title="7. 位置判断合适，判断是否张嘴"></a>7. 位置判断合适，判断是否张嘴</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (rightX &amp;&amp; leftX &amp;&amp; upperY &amp;&amp; lowerY &amp;&amp; isJudgeMouth != YES) &#123;</span><br><span class="line"></span><br><span class="line">    number ++;</span><br><span class="line">    if (number == 1 || number == 300 || number == 600 || number ==900) &#123;</span><br><span class="line">        mouthWidthF = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">        mouthHeightF = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">        NSLog(@&quot;%d,%d&quot;,mouthWidthF,mouthHeightF);</span><br><span class="line">    &#125;else if (number &gt; 1200) &#123;</span><br><span class="line">        [self delateNumber];</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mouthWidth = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">    mouthHeight = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">    NSLog(@&quot;%d,%d&quot;,mouthWidth,mouthHeight);</span><br><span class="line">    NSLog(@&quot;张嘴前：width=%d，height=%d&quot;,mouthWidthF - mouthWidth,mouthHeight - mouthHeightF);</span><br><span class="line">    if (mouthWidth &amp;&amp; mouthWidthF) &#123;</span><br><span class="line"></span><br><span class="line">        if (mouthHeight - mouthHeightF &gt;= 20 &amp;&amp; mouthWidthF - mouthWidth &gt;= 15) &#123;</span><br><span class="line">            isJudgeMouth = YES;</span><br><span class="line">            imgView.animationImages = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-张嘴判断完毕，验证是否摇头"><a href="#8-张嘴判断完毕，验证是否摇头" class="headerlink" title="8. 张嘴判断完毕，验证是否摇头"></a>8. 张嘴判断完毕，验证是否摇头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if ([key isEqualToString:@&quot;mouth_middle&quot;] &amp;&amp; isJudgeMouth == YES) &#123;</span><br><span class="line"></span><br><span class="line">        if (bigNumber == 0 ) &#123;</span><br><span class="line">            firstNumber = p.x;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &gt; bigNumber) &#123;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &lt; smallNumber) &#123;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bigNumber - smallNumber &gt; 60) &#123;</span><br><span class="line">            isShakeHead = YES;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="9-摇头判断完毕，3秒倒计时拍照"><a href="#9-摇头判断完毕，3秒倒计时拍照" class="headerlink" title="9. 摇头判断完毕，3秒倒计时拍照"></a>9. 摇头判断完毕，3秒倒计时拍照</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(timeCount &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        self.textLabel.text = [NSString  stringWithFormat:@&quot;%ld s后拍照&quot;,(long)timeCount];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        [theTimer invalidate];</span><br><span class="line">        theTimer=nil;</span><br><span class="line"></span><br><span class="line">        [self didClickTakePhoto];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="10-拍照完毕，选择重拍或者上传图片"><a href="#10-拍照完毕，选择重拍或者上传图片" class="headerlink" title="10. 拍照完毕，选择重拍或者上传图片"></a>10. 拍照完毕，选择重拍或者上传图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickPhotoAgain</span><br><span class="line">&#123;</span><br><span class="line">    [self delateNumber];</span><br><span class="line"></span><br><span class="line">    [self.previewLayer.session startRunning];</span><br><span class="line">    self.textLabel.text = @&quot;请调整位置&quot;;</span><br><span class="line"></span><br><span class="line">    [backView removeFromSuperview];</span><br><span class="line"></span><br><span class="line">    isJudgeMouth = NO;</span><br><span class="line">    isShakeHead = NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-选择重拍重复5-9步骤，选择上传将图片数据回调"><a href="#11-选择重拍重复5-9步骤，选择上传将图片数据回调" class="headerlink" title="11. 选择重拍重复5-9步骤，选择上传将图片数据回调"></a>11. 选择重拍重复5-9步骤，选择上传将图片数据回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickUpPhoto</span><br><span class="line">&#123;</span><br><span class="line">    //上传照片成功</span><br><span class="line">    [self.faceDelegate sendFaceImage:imageView.image];</span><br><span class="line">    [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-数据clean"><a href="#12-数据clean" class="headerlink" title="12. 数据clean"></a>12. 数据clean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)delateNumber</span><br><span class="line">&#123;</span><br><span class="line">    number = 0;</span><br><span class="line">    takePhotoNumber = 0;</span><br><span class="line"></span><br><span class="line">    mouthWidthF = 0;</span><br><span class="line">    mouthHeightF = 0;</span><br><span class="line">    mouthWidth = 0;</span><br><span class="line">    mouthHeight = 0;</span><br><span class="line"></span><br><span class="line">    smallNumber = 0;</span><br><span class="line">    bigNumber = 0;</span><br><span class="line">    firstNumber = 0;</span><br><span class="line"></span><br><span class="line">    imgView.animationImages = nil;</span><br><span class="line">    imgView.image = [UIImage imageNamed:@&quot;shakeHead0&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：讯飞SDK下载及配置"><a href="#四：讯飞SDK下载及配置" class="headerlink" title="四：讯飞SDK下载及配置"></a>四：讯飞SDK下载及配置</h2><h4 id="1-SDK下载"><a href="#1-SDK下载" class="headerlink" title="1. SDK下载"></a>1. SDK下载</h4><p>因为项目中使用到讯飞人脸识别SDK，需要去<a href="http://console.xfyun.cn/app/edit?appId=NWFhNjI3OTM%3D&amp;appName=RkJZRmFjZVJlY29nbml0aW9uX2lPUw%3D%3D" target="_blank" rel="noopener">讯飞开放平台</a>创建应用，下载SDK。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b10687203a879c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><h4 id="2-添加系统库"><a href="#2-添加系统库" class="headerlink" title="2. 添加系统库"></a>2. 添加系统库</h4><p>将开发工具包中lib目录下的iflyMSC.framework添加到工程中。同时请将Demo中依赖的其他库也添加到工程中。 按下图示例添加 SDK 所需要的 iOS系统库：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-93809e5d166a1633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="88.png"></p><h4 id="3-设置Bitcode"><a href="#3-设置Bitcode" class="headerlink" title="3. 设置Bitcode"></a>3. 设置Bitcode</h4><p>在Targets - Build Settings 中搜索Bitcode 即可，找到相应选项，设置为NO，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-3414999985ccd080.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="333.jpg"></p><h4 id="4-用户隐私权限配置"><a href="#4-用户隐私权限配置" class="headerlink" title="4. 用户隐私权限配置"></a>4. 用户隐私权限配置</h4><p>在Info.plist 中增加下图设置：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-19d0d89539d05cbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="444.png"></p><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYFaceData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYFaceRecognitionViewController"><a href="#2-在项目中引入FBYFaceRecognitionViewController" class="headerlink" title="2. 在项目中引入FBYFaceRecognitionViewController"></a>2. 在项目中引入FBYFaceRecognitionViewController</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYFaceRecognitionViewController.h&quot;</span><br></pre></td></tr></table></figure><h4 id="3-在项目识别按钮的点击事件中添加代码"><a href="#3-在项目识别按钮的点击事件中添加代码" class="headerlink" title="3. 在项目识别按钮的点击事件中添加代码"></a>3. 在项目识别按钮的点击事件中添加代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)pushToFaceStreamDetectorVC</span><br><span class="line">&#123;</span><br><span class="line">    FBYFaceRecognitionViewController *faceVC = [[FBYFaceRecognitionViewController alloc]init];</span><br><span class="line">    faceVC.faceDelegate = self;</span><br><span class="line">    [self.navigationController pushViewController:faceVC animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-图片回调函数"><a href="#4-图片回调函数" class="headerlink" title="4. 图片回调函数"></a>4. 图片回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)sendFaceImage:(UIImage *)faceImage</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;图片上传成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendFaceImageError &#123;</span><br><span class="line">    NSLog(@&quot;图片上传失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYFaceRecognitionDemo_iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。&lt;/p&gt;
&lt;p&gt;大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。&lt;/p&gt;
&lt;p&gt;在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 识别集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%AF%86%E5%88%AB%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 实现点击图片放大</title>
    <link href="https://fanbaoying.github.io/iOS-%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7/"/>
    <id>https://fanbaoying.github.io/iOS-实现点击图片放大/</id>
    <published>2018-03-06T02:02:13.000Z</published>
    <updated>2018-03-06T02:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>给UIImageView添加手势</p></li><li><p>封装一个继承NSObject的FBYImageZoom类</p></li><li><p>写一个函数用来接收出入的UIImageView</p></li><li><p>根据传入的UIImageView重新绘制在Window中</p></li><li><p>添加放大后背景视图的颜色和透明度</p></li><li><p>使用动画放大展示ImageView</p></li><li><p>添加恢复ImageView原始尺寸的tap点击事件</p></li><li><p>完成之后将背景视图删掉</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-给UIImageView添加手势"><a href="#1-给UIImageView添加手势" class="headerlink" title="1. 给UIImageView添加手势"></a>1. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.myImageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 150, SCREEN_WIDTH-100, SCREEN_WIDTH-100)];</span><br><span class="line">self.myImageView.image = [UIImage imageNamed:@&quot;bankcard&quot;];</span><br><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br><span class="line">[_myImageView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line">[_myImageView setUserInteractionEnabled:YES];</span><br><span class="line">[self.view addSubview:_myImageView];</span><br></pre></td></tr></table></figure><h4 id="2-封装一个继承NSObject的FBYImageZoom类"><a href="#2-封装一个继承NSObject的FBYImageZoom类" class="headerlink" title="2. 封装一个继承NSObject的FBYImageZoom类"></a>2. 封装一个继承NSObject的FBYImageZoom类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYImageZoom : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-写一个函数用来接收出入的UIImageView"><a href="#3-写一个函数用来接收出入的UIImageView" class="headerlink" title="3. 写一个函数用来接收出入的UIImageView"></a>3. 写一个函数用来接收出入的UIImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @param contentImageview 图片所在的imageView</span><br><span class="line"> */</span><br><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview;</span><br></pre></td></tr></table></figure><h4 id="4-根据传入的UIImageView重新绘制在Window中"><a href="#4-根据传入的UIImageView重新绘制在Window中" class="headerlink" title="4. 根据传入的UIImageView重新绘制在Window中"></a>4. 根据传入的UIImageView重新绘制在Window中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview&#123;</span><br><span class="line"></span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    [self scanBigImageWithImage:contentImageview.image frame:[contentImageview convertRect:contentImageview.bounds toView:window]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-添加放大后背景视图的颜色和透明度"><a href="#5-添加放大后背景视图的颜色和透明度" class="headerlink" title="5. 添加放大后背景视图的颜色和透明度"></a>5. 添加放大后背景视图的颜色和透明度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当前视图</span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    //背景</span><br><span class="line">    UIView *backgroundView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">    [backgroundView setBackgroundColor:[UIColor colorWithRed:107/255.0 green:107/255.0 blue:99/255.0 alpha:0.6]];</span><br></pre></td></tr></table></figure><h4 id="6-使用动画放大展示ImageView"><a href="#6-使用动画放大展示ImageView" class="headerlink" title="6. 使用动画放大展示ImageView"></a>6. 使用动画放大展示ImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//动画放大所展示的ImageView</span><br><span class="line">[UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">    CGFloat y,width,height;</span><br><span class="line">    y = ([UIScreen mainScreen].bounds.size.height - image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width) * 0.5;</span><br><span class="line">    //宽度为屏幕宽度</span><br><span class="line">    width = [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">    //高度 根据图片宽高比设置</span><br><span class="line">    height = image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width;</span><br><span class="line">    [imageView setFrame:CGRectMake(0, y, width, height)];</span><br><span class="line">    //重要！ 将视图显示出来</span><br><span class="line">    [backgroundView setAlpha:1];</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="7-添加恢复ImageView原始尺寸的tap点击事件"><a href="#7-添加恢复ImageView原始尺寸的tap点击事件" class="headerlink" title="7. 添加恢复ImageView原始尺寸的tap点击事件"></a>7. 添加恢复ImageView原始尺寸的tap点击事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件同样是类方法 -&gt; 作用是再次点击回到初始大小</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hideImageView:)];</span><br><span class="line">[backgroundView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  恢复imageView原始尺寸</span><br><span class="line"> */</span><br><span class="line">+(void)hideImageView:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    UIView *backgroundView = tap.view;</span><br><span class="line">    //原始imageview</span><br><span class="line">    UIImageView *imageView = [tap.view viewWithTag:1024];</span><br><span class="line">    //恢复</span><br><span class="line">    [UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">        [imageView setFrame:oldframe];</span><br><span class="line">        [backgroundView setAlpha:0];</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        [backgroundView removeFromSuperview];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-完成之后将背景视图删掉"><a href="#8-完成之后将背景视图删掉" class="headerlink" title="8. 完成之后将背景视图删掉"></a>8. 完成之后将背景视图删掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//完成后操作-&gt;将背景视图删掉</span><br><span class="line">[backgroundView removeFromSuperview];</span><br></pre></td></tr></table></figure><h2 id="四：项目实际使用"><a href="#四：项目实际使用" class="headerlink" title="四：项目实际使用"></a>四：项目实际使用</h2><h4 id="1-引入封装类FBYImageZoom"><a href="#1-引入封装类FBYImageZoom" class="headerlink" title="1. 引入封装类FBYImageZoom"></a>1. 引入封装类FBYImageZoom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYImageZoom.h&quot;</span><br></pre></td></tr></table></figure><h4 id="2-给UIImageView添加手势"><a href="#2-给UIImageView添加手势" class="headerlink" title="2. 给UIImageView添加手势"></a>2. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br></pre></td></tr></table></figure><h4 id="3-调用封装类函数"><a href="#3-调用封装类函数" class="headerlink" title="3. 调用封装类函数"></a>3. 调用封装类函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//浏览大图点击事件</span><br><span class="line">-(void)scanBigImageClick:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    NSLog(@&quot;点击图片&quot;);</span><br><span class="line">    UIImageView *clickedImageView = (UIImageView *)tap.view;</span><br><span class="line">    [FBYImageZoom ImageZoomWithImageView:clickedImageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里点击图片放大到全屏就完成了</p><h2 id="五：项目展示"><a href="#五：项目展示" class="headerlink" title="五：项目展示"></a>五：项目展示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161f900f7b9f73d6?w=300&amp;h=500&amp;f=gif&amp;s=1992499" alt=""></p><h4 id="六-本篇文章demo源码："><a href="#六-本篇文章demo源码：" class="headerlink" title="六. 本篇文章demo源码："></a>六. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYImageZoom-iOS" target="_blank" rel="noopener">github demo</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIDatePicker | 时间选择器</title>
    <link href="https://fanbaoying.github.io/iOS-UIDatePicker%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85/"/>
    <id>https://fanbaoying.github.io/iOS-UIDatePicker的使用详情/</id>
    <published>2018-02-09T07:25:17.000Z</published>
    <updated>2021-06-07T12:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：UIDatePicker的介绍"><a href="#一：UIDatePicker的介绍" class="headerlink" title="一：UIDatePicker的介绍"></a>一：UIDatePicker的介绍</h2><p>UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。<br>日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。<br>你也可以对其进行定制，令其使用任何范围的日期。</p><p>UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。<br>iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。<br>使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。<br>UIDatePicker给出了倒计时模式，但是并没有实现相关事件。<br>如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。</p><a id="more"></a><h2 id="二：UIDatePicker的使用"><a href="#二：UIDatePicker的使用" class="headerlink" title="二：UIDatePicker的使用"></a>二：UIDatePicker的使用</h2><h2 id="2-1-创建并添加一个UIDatePicker对象"><a href="#2-1-创建并添加一个UIDatePicker对象" class="headerlink" title="2.1 创建并添加一个UIDatePicker对象"></a>2.1 创建并添加一个UIDatePicker对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  DatePicker</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">//创建对象</span><br><span class="line">@property (nonatomic, strong) UIDatePicker *datePicker;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="2-2-配置UIDatePicker对象"><a href="#2-2-配置UIDatePicker对象" class="headerlink" title="2.2 配置UIDatePicker对象"></a>2.2 配置UIDatePicker对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupDateKeyPan &#123;</span><br><span class="line"></span><br><span class="line">    UIDatePicker *datePicker = [[UIDatePicker alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置地区: zh-中国</span><br><span class="line">    datePicker.locale = [NSLocale localeWithLocaleIdentifier:@&quot;zh&quot;];</span><br><span class="line"></span><br><span class="line">    //设置日期模式(Displays month, day, and year depending on the locale setting)</span><br><span class="line">    datePicker.datePickerMode = UIDatePickerModeCountDownTimer;</span><br><span class="line">    // 设置当前显示时间</span><br><span class="line">    [datePicker setDate:[NSDate date] animated:YES];</span><br><span class="line">    // 设置显示最大时间（此处为当前时间）</span><br><span class="line">    [datePicker setMaximumDate:[NSDate date]];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line"></span><br><span class="line">    //监听DataPicker的滚动</span><br><span class="line">    [datePicker addTarget:self action:@selector(dateChange:) forControlEvents:UIControlEventValueChanged];</span><br><span class="line"></span><br><span class="line">    self.datePicker = datePicker;</span><br><span class="line"></span><br><span class="line">    //设置时间输入框的键盘框样式为时间选择器</span><br><span class="line">    self.timeTextField.inputView = datePicker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-禁止用户输入文字"><a href="#2-3-禁止用户输入文字" class="headerlink" title="2.3 禁止用户输入文字"></a>2.3 禁止用户输入文字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//禁止用户输入文字</span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">  return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-显示文本"><a href="#2-4-显示文本" class="headerlink" title="2.4 显示文本"></a>2.4 显示文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)dateChange:(UIDatePicker *)datePicker &#123;</span><br><span class="line"></span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line">    formatter.dateFormat = @&quot;yyyy年 MM月 dd日&quot;;</span><br><span class="line">    NSString *dateStr = [formatter  stringFromDate:datePicker.date];</span><br><span class="line"></span><br><span class="line">    self.timeTextField.text = dateStr;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="三：选择模式"><a href="#三：选择模式" class="headerlink" title="三：选择模式"></a>三：选择模式</h2><p>日期/时间选取器持4种不同模式的选择方式。<br>通过设置 datePickerMode 属性，可以定义选择模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.datePickerMode = UIDatePickerModeTime;</span><br></pre></td></tr></table></figure></p><p>支持的模式：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a1d8372b?w=600&amp;h=214&amp;f=png&amp;s=93770" alt="支持模式"></p><p>四种时间模式样式截图如下：</p><h4 id="3-1-UIDatePickerModeTime"><a href="#3-1-UIDatePickerModeTime" class="headerlink" title="3.1 UIDatePickerModeTime"></a>3.1 UIDatePickerModeTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a01a3438?w=600&amp;h=1065&amp;f=jpeg&amp;s=20585" alt="UIDatePickerModeTime"><br>在这种模式下，显示时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-2-UIDatePickerModeDate"><a href="#3-2-UIDatePickerModeDate" class="headerlink" title="3.2 UIDatePickerModeDate"></a>3.2 UIDatePickerModeDate</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a20f7db1?w=600&amp;h=1065&amp;f=jpeg&amp;s=28097" alt="UIDatePickerModeDate"></p><p>在这种模式下，显示年、月、日。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-3-UIDatePickerModeDateAndTime"><a href="#3-3-UIDatePickerModeDateAndTime" class="headerlink" title="3.3 UIDatePickerModeDateAndTime"></a>3.3 UIDatePickerModeDateAndTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa39d537561?w=600&amp;h=1065&amp;f=jpeg&amp;s=28835" alt="UIDatePickerModeDateAndTime"></p><p>在这种模式下，显示日期的月、日、星期，时间的时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-4-UIDatePickerModeCountDownTimer"><a href="#3-4-UIDatePickerModeCountDownTimer" class="headerlink" title="3.4 UIDatePickerModeCountDownTimer"></a>3.4 UIDatePickerModeCountDownTimer</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a24ca874?w=600&amp;h=1065&amp;f=jpeg&amp;s=21341" alt="UIDatePickerModeCountDownTimer"></p><p>在这种模式下，显示时、分。应用程序必须实现一个计数器（NSTimer对象），让倒计时中的时间不断减少。</p><h2 id="四：日期范围"><a href="#四：日期范围" class="headerlink" title="四：日期范围"></a>四：日期范围</h2><p>你可以通过设置mininumDate 和 maxinumDate 属性，来指定使用的日期范围。如果用户试图滚动到超出这一范围的日期，表盘会回滚到最近的有效日期。两个方法都需要NSDate 对象作参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDate* minDate = [[NSDate alloc]initWithString:@&quot;1900-01-01 00:00:00 -0500&quot;];    </span><br><span class="line">NSDate* maxDate = [[NSDate alloc]initWithString:@&quot;2099-01-01 00:00:00 -0500&quot;];    </span><br><span class="line"></span><br><span class="line">datePicker.minimumDate = minDate;    </span><br><span class="line">datePicker.maximumDate = maxDate;</span><br></pre></td></tr></table></figure></p><p>如果两个日期范围属性中任何一个未被设置，则默认行为将会允许用户选择过去或未来的任意日期。这在某些情况下很有用处，比如，当选择生日时，可以是过去的任意日期，但终止与当前日期。如果你希望设置默认显示的日期，可以使用date属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.date = minDate;</span><br></pre></td></tr></table></figure><p>此外，你还可以用 setDate 方法。如果选择了使用动画，则表盘会滚动到你指定的日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[datePicker setDate:maxDate animated:YES];</span><br></pre></td></tr></table></figure><h4 id="4-本篇文章demo源码："><a href="#4-本篇文章demo源码：" class="headerlink" title="4. 本篇文章demo源码："></a>4. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">UIDatePicker–DEMO</a></p><hr><p>欢迎关注我的公众号：网罗开发</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/29/1613fe638def80c9?w=300&amp;h=300&amp;f=jpeg&amp;s=21616" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;a href=&quot;#一：UIDatePicker的介绍&quot; class=&quot;headerlink&quot; title=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;/a&gt;一：UIDatePicker的介绍&lt;/h2&gt;&lt;p&gt;UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。&lt;br&gt;日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。&lt;br&gt;你也可以对其进行定制，令其使用任何范围的日期。&lt;/p&gt;
&lt;p&gt;UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。&lt;br&gt;iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。&lt;br&gt;使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。&lt;br&gt;UIDatePicker给出了倒计时模式，但是并没有实现相关事件。&lt;br&gt;如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
