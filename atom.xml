<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2022-04-06T02:33:15.419Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SwiftUI 动画进阶 — Part 5：Canvas</title>
    <link href="https://fanbaoying.github.io/SwiftUI-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6-%E2%80%94-Part-5%EF%BC%9ACanvas/"/>
    <id>https://fanbaoying.github.io/SwiftUI-动画进阶-—-Part-5：Canvas/</id>
    <published>2022-04-06T02:31:33.000Z</published>
    <updated>2022-04-06T02:33:15.419Z</updated>
    
    <content type="html"><![CDATA[<p>这个高级SwiftUI动画系列的第五部分将探索Canvas视图。从技术上讲，它不是一个动画视图，但当它与第四部分的 <code>TimelineView</code> 结合时，它带来了很多有趣的可能性，正如这个数字雨的例子所示。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/120523a00d0eae25fce6b66bf2cbd5af.gif" alt=""></p><p>我不得不把这篇文章推迟几周，因为 Canvas 视图有点不稳定。我们仍然处于测试阶段，所以这是可以预期的。然而，该视图产生的崩溃使这里的一些例子无法分享。虽然不是所有的问题都得到了解决，但现在每个例子都能顺利运行。在文章的最后，我将指出我找到的一些解决方法。</p><a id="more"></a><h1 id="一个简单的-Canvas"><a href="#一个简单的-Canvas" class="headerlink" title="一个简单的 Canvas"></a>一个简单的 Canvas</h1><p>简而言之，画布<code>Canvas</code> 是一个 SwiftUI 视图，它从一个渲染闭包中获得绘制指令。与 SwiftUI API 中的大多数闭包不同，它不是一个视图生成器。这意味着我们可以使用 Swift 语言且没有任何限制。</p><p>该闭包接收两个参数：上下文<code>context</code> 和 尺寸<code>size</code>。上下文使用一个新的 SwiftUI 类型 <code>GraphicsContext</code>，它包含了很多方法和属性，可以让我们绘制任何东西。下面是一个关于如何使用 <code>Canvas</code> 的基本例子。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/5f98cc102dc7e6b6fba0ad5fca2c02ac.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> rect = <span class="type">CGRect</span>(origin: .zero, size: size).insetBy(dx: <span class="number">25</span>, dy: <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Path</span></span><br><span class="line">            <span class="keyword">let</span> path = <span class="type">Path</span>(roundedRect: rect, cornerRadius: <span class="number">35.0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Gradient</span></span><br><span class="line">            <span class="keyword">let</span> gradient = <span class="type">Gradient</span>(colors: [.green, .blue])</span><br><span class="line">            <span class="keyword">let</span> from = rect.origin</span><br><span class="line">            <span class="keyword">let</span> to = <span class="type">CGPoint</span>(x: rect.width + from.x, y: rect.height + from.y)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Stroke path</span></span><br><span class="line">            context.stroke(path, with: .color(.blue), lineWidth: <span class="number">25</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Fill path</span></span><br><span class="line">            context.fill(path, with: .linearGradient(gradient,</span><br><span class="line">                                                     startPoint: from,</span><br><span class="line">                                                     endPoint: to))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Canvas</code>初始值设定项还有其他参数（不透明度<code>opaque</code>、颜色模式<code>colorMode</code>和渲染同步<code>rendersAsynchronously</code>）。请参阅<a href="https://developer.apple.com/documentation/swiftui/canvas/init(opaque:colormode:rendersasynchronously:renderer:symbols:" target="_blank" rel="noopener">苹果的文档</a>)以了解更多信息。</p><h1 id="图形上下文-GraphicsContext"><a href="#图形上下文-GraphicsContext" class="headerlink" title="图形上下文 - GraphicsContext"></a>图形上下文 - GraphicsContext</h1><p><code>GraphicsContext</code>有很多方法和属性，但我并不打算把这篇文章作为一个参考，把它们z一一列出。这是一个很长的列表，可能会让人有点不知所措。然而，当我在更新<a href="https://swiftui-lab.com/companion/" target="_blank" rel="noopener">Companion for SwiftUI app</a> 时，我确实不得不去浏览所有这些方法。这让我有了一个整体的想法。我将尝试对现有的东西进行分类，这样你就能得到同样的东西。</p><ul><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#paths" target="_blank" rel="noopener">Drawing Paths</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#images" target="_blank" rel="noopener">Drawing Images and Text</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#symbols" target="_blank" rel="noopener">Drawing Symbols (aka SwiftUI views)</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#mutating" target="_blank" rel="noopener">Mutating the Graphics Context</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#coregraphics" target="_blank" rel="noopener">Reusing CoreGraphics Code</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#animating" target="_blank" rel="noopener">Animating the Canvas</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#crashes" target="_blank" rel="noopener">Canvas Crashes</a></li></ul><h1 id="路径-Paths"><a href="#路径-Paths" class="headerlink" title="路径 - Paths"></a>路径 - Paths</h1><p>绘制路径的第一件事是创建它。从 SwiftUI 的第一个版本开始，路径可以通过多种方式创建和修改。一些可用的初始化器是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">Path</span>(roundedRect: rect, cornerSize: <span class="type">CGSize</span>(width: <span class="number">10</span>, height: <span class="number">50</span>), style: .continuous)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cgPath = <span class="type">CGPath</span>(ellipseIn: rect, transform: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> path = <span class="type">Path</span>(cgPath)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">Path</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> points: [<span class="type">CGPoint</span>] = [</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">10</span>, y: <span class="number">10</span>),</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">50</span>),</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">100</span>, y: <span class="number">100</span>),</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">100</span>, y: <span class="number">0</span>),</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    $<span class="number">0</span>.move(to: .zero)</span><br><span class="line">    $<span class="number">0</span>.addLines(points)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径也可以从一个 SwiftUI 形状中创建。<code>Shape</code> 协议有一个路径方法，你可以用它来创建一个 <code>path</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">Circle</span>().path(<span class="keyword">in</span>: rect)</span><br></pre></td></tr></table></figure><p> 当然，这也适用于自定义形状：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">MyCustomShape</span>().path(<span class="keyword">in</span>: rect)</span><br></pre></td></tr></table></figure><h2 id="填充路径"><a href="#填充路径" class="headerlink" title="填充路径"></a>填充路径</h2><p>要填充一个路径，请使用 <code>context.fill()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(<span class="number">_</span> path: <span class="type">Path</span>, with shading: <span class="type">GraphicsContext</span>.<span class="type">Shading</span>, style: <span class="type">FillStyle</span> = <span class="type">FillStyle</span>())</span><br></pre></td></tr></table></figure><p>着色<code>shading</code>表示如何填充形状（用颜色、渐变、平铺图像等）。如果你需要指示要使用的样式，请使用<code>FillStyle</code>类型（即偶数奇数/反义属性）。</p><h2 id="路径描边-Stroke"><a href="#路径描边-Stroke" class="headerlink" title="路径描边 - Stroke"></a>路径描边 - Stroke</h2><p>要描画一个路径，请使用这些<code>GraphicsContext</code>方法中的一个:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stroke(<span class="number">_</span> path: <span class="type">Path</span>, with shading: <span class="type">GraphicsContext</span>.<span class="type">Shading</span>, style: <span class="type">StrokeStyle</span>)</span><br><span class="line">stroke(<span class="number">_</span> path: <span class="type">Path</span>, with shading: <span class="type">GraphicsContext</span>.<span class="type">Shading</span>, lineWidth: <span class="type">CGFloat</span> = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>你可以指定一个<code>shading</code>（颜色、渐变等）来表示如何描画路径。如果你需要指定破折号、线帽、连接等，请使用样式<code>style</code>。另外，你也可以只指定线宽。</p><p>关于如何描边和填充一个形状的完整例子，请看上面的例子（<strong>一个简单的 Canvas</strong>）。</p><h2 id="图片和文本-Image-amp-Text"><a href="#图片和文本-Image-amp-Text" class="headerlink" title="图片和文本 - Image &amp; Text"></a>图片和文本 - Image &amp; Text</h2><p>图像和文本是使用上下文<code>draw()</code>方法绘制的，有两个版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">draw(image_or_text, at point: <span class="type">CGPoint</span>, anchor: <span class="type">UnitPoint</span> = .center)</span><br><span class="line">draw(image_or_text, <span class="keyword">in</span> rect: <span class="type">CGRect</span>)</span><br></pre></td></tr></table></figure><p>在图像的情况下，第二个<code>draw()</code>版本有一个额外的可选参数，<code>style</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw(image, <span class="keyword">in</span> rect: <span class="type">CGRect</span>, style: <span class="type">FillStyle</span> = <span class="type">FillStyle</span>())</span><br></pre></td></tr></table></figure><p>在这些元素之一可以被绘制之前，它们必须被解析。通过解析，SwiftUI将考虑到环境（例如，颜色方案、显示分辨率等）。此外，解析这些元素会暴露出一些有趣的属性，这些属性可能会被进一步用于我们的绘制逻辑。例如，解析后的文本会告诉我们指定字体的最终尺寸。或者我们也可以在绘制之前改变已解析元素的阴影。要了解更多关于可用的属性和方法，请查看 <a href="https://developer.apple.com/documentation/swiftui/graphicscontext/resolvedimage" target="_blank" rel="noopener">ResolvedImage</a> 和 <a href="https://developer.apple.com/documentation/swiftui/graphicscontext/resolvedtext" target="_blank" rel="noopener">ResolvedText</a> 。</p><p>使用上下文的<code>resolve()</code>方法从<code>Image</code>中获得<code>ResolvedImage</code>，从<code>Text</code>中获得<code>ResolvedText</code>。</p><p>解析是可选的，<code>draw()</code>方法也接受<code>Image</code>和<code>Text</code>（而不是<code>ResolvedImage</code>和<code>ResolvedText</code>）。在这种情况下，<code>draw()</code>会自动解析它们。如果你对已解析的属性和方法没有任何用途，这很方便。</p><p>在这个例子中，文本被解决了。我们用它的大小来计算渐变，并用着色<code>shading</code>来应用这种渐变：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/555ea370f0cd7dbabeb00b8130629f0c.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> midPoint = <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> font = <span class="type">Font</span>.custom(<span class="string">"Arial Rounded MT Bold"</span>, size: <span class="number">36</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> resolved = context.resolve(<span class="type">Text</span>(<span class="string">"Hello World!"</span>).font(font))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> start = <span class="type">CGPoint</span>(x: (size.width - resolved.measure(<span class="keyword">in</span>: size).width) / <span class="number">2.0</span>, y: <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> end = <span class="type">CGPoint</span>(x: size.width - start.x, y: <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            resolved.shading = .linearGradient(<span class="type">Gradient</span>(colors: [.green, .blue]),</span><br><span class="line">                                               startPoint: start,</span><br><span class="line">                                               endPoint: end)</span><br><span class="line">            </span><br><span class="line">            context.draw(resolved, at: midPoint, anchor: .center)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="符号-Symbols"><a href="#符号-Symbols" class="headerlink" title="符号 - Symbols"></a>符号 - Symbols</h2><p>在谈<code>Canvas</code>时，符号<code>Symbols</code>指的只是任何的 SwiftUI。不要与SF符号相混淆，后者是完全不同的东西。<code>Canvas</code> 视图有一种引用 SwiftUI 视图的方式，将其解析为一个符号，然后绘制它。</p><p>要解决的视图是在<code>ViewBuilder</code>闭包中传递的，如下面的例子所示。为了引用一个视图，它需要被标记为一个唯一的可散列的标识符。请注意，一个被解析的符号可以在<code>Canvas</code>上绘制不止一次。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/25c25b8a2fce3d78473c7971e7ee556e.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> r0 = context.resolveSymbol(id: <span class="number">0</span>)!</span><br><span class="line">            <span class="keyword">let</span> r1 = context.resolveSymbol(id: <span class="number">1</span>)!</span><br><span class="line">            <span class="keyword">let</span> r2 = context.resolveSymbol(id: <span class="number">2</span>)!</span><br><span class="line">            </span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">10</span>, y: <span class="number">10</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r1, at: .<span class="keyword">init</span>(x: <span class="number">30</span>, y: <span class="number">20</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r2, at: .<span class="keyword">init</span>(x: <span class="number">50</span>, y: <span class="number">30</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">70</span>, y: <span class="number">40</span>), anchor: .topLeading)</span><br><span class="line"></span><br><span class="line">        &#125; symbols: &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(.cyan)</span><br><span class="line">                .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                .tag(<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(.blue)</span><br><span class="line">                .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                .tag(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(.indigo)</span><br><span class="line">                .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                .tag(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewBuilder</code>也可以使用一个<code>ForEach</code>。同样的例子可以改写成这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> colors: [<span class="type">Color</span>] = [.cyan, .blue, .indigo]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> r0 = context.resolveSymbol(id: <span class="number">0</span>)!</span><br><span class="line">            <span class="keyword">let</span> r1 = context.resolveSymbol(id: <span class="number">1</span>)!</span><br><span class="line">            <span class="keyword">let</span> r2 = context.resolveSymbol(id: <span class="number">2</span>)!</span><br><span class="line">            </span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">10</span>, y: <span class="number">10</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r1, at: .<span class="keyword">init</span>(x: <span class="number">30</span>, y: <span class="number">20</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r2, at: .<span class="keyword">init</span>(x: <span class="number">50</span>, y: <span class="number">30</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">70</span>, y: <span class="number">40</span>), anchor: .topLeading)</span><br><span class="line"></span><br><span class="line">        &#125; symbols: &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="type">Array</span>(colors.enumerated()), id: \.<span class="number">0</span>) &#123; n, <span class="built_in">c</span> <span class="keyword">in</span></span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(<span class="built_in">c</span>)</span><br><span class="line">                    .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                    .tag(n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="符号的动画-Animated-Symbols"><a href="#符号的动画-Animated-Symbols" class="headerlink" title="符号的动画 - Animated Symbols"></a>符号的动画 - Animated Symbols</h2><p>当我测试如果视图作为一个符号被解析为动画，会发生什么时，我感到非常惊喜。你猜怎么着，画布会不断地重绘它以保持动画效果。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/1279412a14866c8db5c9860d2a0522a8.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> symbol = context.resolveSymbol(id: <span class="number">1</span>)!</span><br><span class="line">            </span><br><span class="line">            context.draw(symbol, at: <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">        &#125; symbols: &#123;</span><br><span class="line">            <span class="type">SpinningView</span>()</span><br><span class="line">                .tag(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpinningView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">""</span>)</span><br><span class="line">            .font(.custom(<span class="string">"Arial"</span>, size: <span class="number">72</span>))</span><br><span class="line">            .rotationEffect(.degrees(flag ? <span class="number">0</span> : <span class="number">360</span>))</span><br><span class="line">            .onAppear&#123;</span><br><span class="line">                withAnimation(.linear(duration: <span class="number">1.0</span>).repeatForever(autoreverses: <span class="literal">false</span>)) &#123;</span><br><span class="line">                    flag.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="改变图形上下文"><a href="#改变图形上下文" class="headerlink" title="改变图形上下文"></a>改变图形上下文</h1><p>图形上下文可以被改变，使用以下方法之一：</p><ul><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/addfilter(_:options:" target="_blank" rel="noopener">addFilter</a>?changes=l_7_8_3)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/clip(to:style:options:" target="_blank" rel="noopener">clip</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/cliptolayer(opacity:options:content:" target="_blank" rel="noopener">clipToLayer</a>/)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/concatenate(_:" target="_blank" rel="noopener">concatenate</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/rotate(by:" target="_blank" rel="noopener">rotate</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/scaleby(x:y:" target="_blank" rel="noopener">scaleBy</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/translateby(x:y:" target="_blank" rel="noopener">translateBy</a>)</li></ul><p>如果你熟悉 AppKit 的 <code>NSGraphicContext</code> 或 CoreGraphic 的 <code>CGContext</code>，你可能习惯于从堆栈中推送（保存）和弹出（恢复）图形上下文状态。Canvas GraphicsContext 的工作方式有些不同，如果你想对上下文做一个临时的改变，你有好几个选择。</p><p>为了说明这一点，让我们看看下面的例子。我们需要用三种颜色画三座房子。只有中间的房子，需要被模糊化：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/234d739c8d952cad3d383d0f2db9a55a.png" alt=""></p><p>下面的所有例子将使用以下<code>CGPoint</code>扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +<span class="params">(lhs: CGPoint, rhs: CGPoint)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGPoint</span>(x: lhs.x + rhs.x, y: lhs.y + rhs.y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -<span class="params">(lhs: CGPoint, rhs: CGPoint)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGPoint</span>(x: lhs.x - rhs.x, y: lhs.y - rhs.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有三种实现相同结果的方法：</p><h4 id="1、通过对相应操作排序"><a href="#1、通过对相应操作排序" class="headerlink" title="1、通过对相应操作排序"></a>1、通过对相应操作排序</h4><p>在可能的情况下，你可以选择以一种适合你的方式对绘制操作进行排序。在这种情况下，最后绘制模糊的房子，就能解决问题。否则，只要你添加了模糊过滤器，所有的绘制操作都会继续模糊。</p><p>有时这可能是行不通的，即使可以，也可能变成难以阅读的代码。如果是这种情况，请检查其他选项。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// All drawing is done at x4 the size</span></span><br><span class="line">            context.scaleBy(x: <span class="number">4</span>, y: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> midpoint = <span class="type">CGPoint</span>(x: size.width / (<span class="number">2</span> * <span class="number">4</span>), y: size.height / (<span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> house = context.resolve(<span class="type">Image</span>(systemName: <span class="string">"house.fill"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Left house</span></span><br><span class="line">            house.shading = .color(.red)</span><br><span class="line">            context.draw(house, at: midpoint - <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Right house</span></span><br><span class="line">            house.shading = .color(.blue)</span><br><span class="line">            context.draw(house, at: midpoint + <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Center house</span></span><br><span class="line">            context.addFilter(.blur(radius: <span class="number">1.0</span>, options: .dithersResult), options: .linearColor)</span><br><span class="line">            house.shading = .color(.green)</span><br><span class="line">            context.draw(house, at: midpoint, anchor: .center)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、通过拷贝上下文"><a href="#2、通过拷贝上下文" class="headerlink" title="2、通过拷贝上下文"></a>2、通过拷贝上下文</h3><p>由于图形上下文是一个值类型，你可以简单地创建一个副本。在副本上所做的所有改变，都不会影响到原始的上下文。一旦你完成了，你就可以继续在原始（未改变的）上下文上绘图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// All drawing is done at x4 the size</span></span><br><span class="line">            context.scaleBy(x: <span class="number">4</span>, y: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> midpoint = <span class="type">CGPoint</span>(x: size.width / (<span class="number">2</span> * <span class="number">4</span>), y: size.height / (<span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> house = context.resolve(<span class="type">Image</span>(systemName: <span class="string">"house.fill"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Left house</span></span><br><span class="line">            house.shading = .color(.red)</span><br><span class="line">            context.draw(house, at: midpoint - <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Center house</span></span><br><span class="line">            <span class="keyword">var</span> blurContext = context</span><br><span class="line">            </span><br><span class="line">            blurContext.addFilter(.blur(radius: <span class="number">1.0</span>, options: .dithersResult), options: .linearColor)</span><br><span class="line">            house.shading = .color(.green)</span><br><span class="line">            blurContext.draw(house, at: midpoint, anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Right house</span></span><br><span class="line">            house.shading = .color(.blue)</span><br><span class="line">            context.draw(house, at: midpoint + <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、通过使用图层上下文"><a href="#3、通过使用图层上下文" class="headerlink" title="3、通过使用图层上下文"></a>3、通过使用图层上下文</h3><p>最后，你可以使用 <code>context</code> 的方法： <code>drawLayer</code>。该方法有一个闭包，接收一个你可以使用的上下文的副本。所有对图层上下文的改变都不会影响原始的上下文：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// All drawing is done at x4 the size</span></span><br><span class="line">            context.scaleBy(x: <span class="number">4</span>, y: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> midpoint = <span class="type">CGPoint</span>(x: size.width / (<span class="number">2</span> * <span class="number">4</span>), y: size.height / (<span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> house = context.resolve(<span class="type">Image</span>(systemName: <span class="string">"house.fill"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Left house</span></span><br><span class="line">            house.shading = .color(.red)</span><br><span class="line">            context.draw(house, at: midpoint - <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Center house</span></span><br><span class="line">            context.drawLayer &#123; layerContext <span class="keyword">in</span></span><br><span class="line">                layerContext.addFilter(.blur(radius: <span class="number">1.0</span>, options: .dithersResult), options: .linearColor)</span><br><span class="line">                house.shading = .color(.green)</span><br><span class="line">                layerContext.draw(house, at: midpoint, anchor: .center)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Right house</span></span><br><span class="line">            house.shading = .color(.blue)</span><br><span class="line">            context.draw(house, at: midpoint + <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重用-CoreGraphics-代码"><a href="#重用-CoreGraphics-代码" class="headerlink" title="重用 CoreGraphics 代码"></a>重用 CoreGraphics 代码</h1><p>如果你已经有使用 <code>CoreGraphics</code> 的绘制代码，你可以使用它。<code>Canvas</code>上下文有一个<code>withCGContext</code>方法，可以在如下这种情况下拯救你：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            context.withCGContext &#123; cgContext <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CoreGraphics code here</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="对画布进行动画处理"><a href="#对画布进行动画处理" class="headerlink" title="对画布进行动画处理"></a>对画布进行动画处理</h2><p>通过将<code>Canvas</code>包裹在<code>TimelineView</code>内，我们可以实现一些相当有趣的动画。基本上，每一次时间线的更新，你都有机会绘制一个新的动画帧。</p><p>文章的其余部分假定你已经熟悉<code>TimelineView</code>，但如果你不熟悉，你可以查看本系列的<a href="https://swiftui-lab.com/swiftui-animations-part4/" target="_blank" rel="noopener">第四部分</a>来了解更多。</p><p>在下面的例子中，我们的 <code>Canvas</code> 绘制了一个给定日期的模拟时钟。通过将<code>Canvas</code>放在<code>TimelineView</code>内，并使用时间线更新日期，我们得到了动画时钟。以下屏幕截图的一部分是加速的，以显示分针和时针是如何移动的，否则就不容易观察到效果：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/ef94d171903c01b0297711d9e3d51929.gif" alt=""></p><p>当我们用 <code>Canvas</code> 创建动画时，通常会使用时间线时间表的 <code>.animation</code>。这可以尽可能快地更新，每秒重绘我们的 <code>Canvas</code> 几次。然而，在可能的情况下，我们应该使用 <code>minimumInterval</code> 参数来限制每秒的更新次数。这样对CPU的要求会低一些。例如，在这种情况下，使用<code>.animation</code>和<code>.animation(minimumInterval: 0.06)</code>在视觉上没有明显的区别。然而，在我的测试硬件上，CPU使用率从30%下降到14%。使用更高的最小间隔时间可能开始变得视觉上明显，所以你可能需要做一些错误的试验，以找到最佳值。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/f6a032bc77438cca45f5e308e7f89e8f.gif" alt=""></p><p>为了进一步提高性能，你应该考虑<code>Canvas</code>中是否有一些部分不需要不断重绘。在我们的例子中，只有时钟指针在移动，其他部分保持静止。因此，明智的做法是把它分成两个重叠的画布。一个画除了钟针以外的所有东西（在时间线视图之外），另一个只画钟针，在时间线视图之内。通过实施这一改变，CPU从16%下降到6%。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Clock</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">ClockFaceCanvas</span>()</span><br><span class="line">            </span><br><span class="line">            <span class="type">TimelineView</span>(.animation(minimumInterval: <span class="number">0.06</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">                <span class="type">ClockHandsCanvas</span>(date: timeline.date)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过仔细分析我们的画布，并做了些许改动，我们成功地将CPU的使用率提高到了5倍（从30%降到6%）。顺便说一下，如果你能接受每秒更新的秒针，你将进一步减少CPU的使用，使其低于1%。你应该通过测试来找到最适合你的效果。</p><p>该时钟的完整代码可以在<a href="https://gist.github.com/swiftui-lab/168d8bb3abbe894c9dbbac22fdfdec86" target="_blank" rel="noopener">这里</a>找到。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>一旦我们了解了<code>Canvas</code>，我们可能会想用它来画一切。然而，有时最好的选择是选择做什么和在哪里做。下面这个Matrix Digital Rain动画就是一个很好的例子。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/991bc2c8ebb00060bd77b6345cf290a6.gif" alt=""></p><p>数字雨的完整代码可以在<a href="https://gist.github.com/swiftui-lab/7f13f04e2d103e43685193eec0c33dd5" target="_blank" rel="noopener">这里</a>找到。</p><p>我们来分析一下其中的内容。我们有一列字符出现，字符数量增长，慢慢滑落，最后减少其字符，直到消失。每一列都是用渐变绘制的。还有一种深度感，通过使靠近观察者的柱子滑动得更快和稍大。为了增加效果，柱子越靠后，它就越显得失焦（模糊）。</p><p>在 <code>Canvas</code> 中实现所有这些要求是完全可能的。然而，如果我们把这些任务分割开来（分而治之），任务就会变得容易得多。正如我们在本文的符号的动画部分已经看到的，一个带动画的SwiftUI视图可以通过一个<code>draw()</code>调用被绘制到<code>Canvas</code>中。因此，并不是所有的东西都要在<code>Canvas</code>里面处理。</p><p>每一列都被实现为一个单独的SwiftUI视图。叠加字符和用渐变绘图是由视图处理的。当我们在画布上使用渐变时，起始/结束点或任何其他几何参数都是相对于整个画布的。对于柱状渐变，在视图中实现它比较容易，因为它将相对于视图的原点。</p><p>每一列都有许多参数：位置（x、y、z）、字符、从顶部删除多少个字符，等等。这些值在每次<code>TimelineView</code>更新后都会被变更。</p><p>最后，<code>Canvas</code>负责解析每个视图，在它们的（x，y）位置上绘制，并根据其z值添加模糊和缩放效果。我在代码中添加了一些注释，以帮助你浏览它，如果你有兴趣的话。</p><h1 id="Canvas-崩溃"><a href="#Canvas-崩溃" class="headerlink" title="Canvas 崩溃"></a>Canvas 崩溃</h1><p>不幸的是，在写这篇文章的时候，我遇到了 Canvas 的一些崩溃问题。幸运的是，它们在每个测试版中都有很大的改进。我希望在iOS15正式发布时，它们都能得到解决。这条信息通常是这样的。</p><blockquote><p>-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:]:5252: failed assertion `Draw Errors Validation<br>Fragment Function(primitive_gradient_fragment): argument small[0] from buffer(3) with offset(65460) and length(65536) has space for 76 bytes, but argument has a length(96).</p></blockquote><p>我设法解决了这些崩溃的问题，至少使用了其中一个方法：</p><ul><li>减少绘图量。在数字雨的例子中，你可以减少列的数量。</li><li>使用更简单的渐变。最初，数字雨柱有三个颜色的渐变。当我把它减少到两个时，崩溃就消失了。</li><li>减少更新Canvas的频率。使用较慢的时间轴视图，可以防止崩溃。</li></ul><p>我并不是说你不能使用超过两种颜色的渐变，但这只是你可以考虑的一个地方，如果你发现自己处于Canvas崩溃的情况。如果这还不能解决你的问题，我建议你开始删除绘图操作，直到应用程序不再崩溃。这可以引导你找到导致崩溃的原因。一旦你知道是什么原因，你可以尝试用不同的方法来做。</p><p>如果你遇到这个问题，我鼓励你向苹果公司反馈。如果你愿意，你可以参考我的反馈：FB9363322。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我希望这篇文章能帮助你为你的SwiftUI动画工具箱添加一个新的工具。第五部分的动画系列到此结束。至少在今年……谁知道WWDC’22会带来什么呢!</p><blockquote><p>译自 <a href="https://swiftui-lab.com/" target="_blank" rel="noopener">The SwiftUI Lab</a> 的 <a href="https://swiftui-lab.com/swiftui-animations-part5/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 5: Canvas</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个高级SwiftUI动画系列的第五部分将探索Canvas视图。从技术上讲，它不是一个动画视图，但当它与第四部分的 &lt;code&gt;TimelineView&lt;/code&gt; 结合时，它带来了很多有趣的可能性，正如这个数字雨的例子所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/120523a00d0eae25fce6b66bf2cbd5af.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我不得不把这篇文章推迟几周，因为 Canvas 视图有点不稳定。我们仍然处于测试阶段，所以这是可以预期的。然而，该视图产生的崩溃使这里的一些例子无法分享。虽然不是所有的问题都得到了解决，但现在每个例子都能顺利运行。在文章的最后，我将指出我找到的一些解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画进阶 —— Part4：TimelineView</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6-%E2%80%94%E2%80%94-Part4%EF%BC%9ATimelineView/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画进阶-——-Part4：TimelineView/</id>
    <published>2022-04-06T02:31:24.000Z</published>
    <updated>2022-04-06T02:33:46.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前三篇<a href="https://xiaozhuanlan.com/topic/6089153247" target="_blank" rel="noopener">高级 SwiftUI 动画系列</a>是作者在 WWDC 2021 之前实战总结的内容。对 2021 年 WWDC 介绍的 <code>TimelineView</code> 和 <code>Canvas</code> 感到激动。这开启了一个全新的可能性，笔者将试图在这一部分和下一部分的系列中阐释这些可能性。</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/hello-there-25.gif" alt="" title="Hello There"></p><p>在这篇文章中，我们将详细地探索 <code>TimelineView</code> 。我们将从最常见的用途缓慢开始。然而笔者认为，最大的可能性来自于 <code>TimelineView</code> 和我们已知现有的动画相结合。在其他事物中，通过一点创意，这样的组合将让我们最终实现“关键帧类似”的动画。</p><p>在第 5 部分，我们将探索 <code>Canvas</code> 视图，以及它和我们的新朋友 <code>TimelineView</code> 相结合是如此的优秀。</p><p>上文中展示的动画，是使用本文中介绍的技术创建的。该动画的完整代码可在此 <a href="https://gist.github.com/swiftui-lab/c1d089207d6f7b365729b1af2e695cc4" target="_blank" rel="noopener">gist</a> 中找到。</p><a id="more"></a><h2 id="TimelineView-的组件"><a href="#TimelineView-的组件" class="headerlink" title="TimelineView 的组件"></a>TimelineView 的组件</h2><p><code>TimelineView</code> 是一个容器视图，它以相关调度程序确定的频率重新评估其内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">0.5</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ViewToEvaluatePeriodically</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TimelineView</code> 接收调度程序作为参数。 稍后我们将详细认识它们，现在，上述示例使用每半秒触发一次的调度程序。</p><p>另一个参数是一个内容闭包，它接收一个看起来像这样的 <code>TimelineView.Context</code> 参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cadence: <span class="type">Cadence</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Cadence</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> live</span><br><span class="line">        <span class="keyword">case</span> seconds</span><br><span class="line">        <span class="keyword">case</span> minutes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cadence</code> 是一个枚举类型，我们可以使用它来决定在我们的视图中显示什么。 可能的值是：live、seconds 和 minutes。 以此为提示，避免显示与 <code>Cadence</code> 无关的信息。 典型的例子，是避免在具有秒或分钟节奏的调度程序的时钟上显示毫秒。</p><p>请注意，<code>Cadence</code> 不是你可以更改的东西，而是反映设备状态的东西。文档仅提供了一个例子。 在 watchOS 上，降低手腕时 <code>Cadence</code> 会减慢。 如果你发现了 <code>Cadence</code> 发生变化的其他情况，笔者非常想知道。 请在下方发表评论。</p><p>好吧，这一切看起来都很棒，但是我们应该注意许多微妙之处。 让我们开始构建我们的第一个 <code>TimelineView</code> 动画，看看它们是什么。</p><h2 id="理解-TimelineView-如何工作"><a href="#理解-TimelineView-如何工作" class="headerlink" title="理解 TimelineView 如何工作"></a>理解 TimelineView 如何工作</h2><p>观察下面的代码。 我们有两个随机变化的表情符号。 两者之间的唯一区别是，一个写在内容闭包中，而另一个被放在单独的视图中以提高可读性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ManyFaces</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> emoji = [<span class="string">"😀"</span>, <span class="string">"😬"</span>, <span class="string">"😄"</span>, <span class="string">"🙂"</span>, <span class="string">"😗"</span>, <span class="string">"🤓"</span>, <span class="string">"😏"</span>, <span class="string">"😕"</span>, <span class="string">"😟"</span>, <span class="string">"😎"</span>, <span class="string">"😜"</span>, <span class="string">"😍"</span>, <span class="string">"🤪"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">0.2</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="type">HStack</span>(spacing: <span class="number">120</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> randomEmoji = <span class="type">ManyFaces</span>.emoji.randomElement() ?? <span class="string">""</span></span><br><span class="line">            </span><br><span class="line">                <span class="type">Text</span>(randomEmoji)</span><br><span class="line">                    .font(.largeTitle)</span><br><span class="line">                    .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="type">SubView</span>()</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SubView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> randomEmoji = <span class="type">ManyFaces</span>.emoji.randomElement() ?? <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(randomEmoji)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们看下运行代码会发生什么：</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/emojis-changing-one.gif" alt="" title="Emoji"></p><p>惊了？ 为什么左边的 emoji 会变，而另一个总是悲伤？ 事实证明， <code>SubView</code> 没有接收到任何变化的参数，这意味着它没有依赖关系。 <code>SwiftUI</code> 没有理由重新计算视图的主体。 2021 年 WWDC 的一个精彩演讲是 <code>Demystify SwiftUI</code>。 它解释了视图标识、生命周期和依赖关系。 所有这些主题对于理解时间线为何如此运行都非常重要。</p><p>为了解决这个问题，我们更改了 <code>SubView</code> 视图以添加一个参数，该参数将随着时间轴的每次更新而改变。 请注意，我们不需要使用参数，它只需要在那里。 尽管如此，我们将看到这个未使用的值稍后会非常有用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span> <span class="comment">// just by declaring it, the view will now be recomputed apropriately.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> randomEmoji = <span class="type">ManyFaces</span>.emoji.randomElement() ?? <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Text</span>(randomEmoji)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>SubView</code> 是这样创建的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SubView</span>(date: timeline.date)</span><br></pre></td></tr></table></figure><p>最后，我们的两个表情都可以体验到情绪的狂飙：</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/emojis-changing-two.gif" alt="" title="Emoji"></p><h2 id="按照时间线执行"><a href="#按照时间线执行" class="headerlink" title="按照时间线执行"></a>按照时间线执行</h2><p>大多数关于 <code>TimelineView</code> 的示例（截至编写本文）通常是关于绘制时钟的。 这就说得通了。 时间线提供的数据毕竟是一个日期类型实例。</p><p>有史以来最简单的 <code>TimelineView</code> 时钟：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">1.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"<span class="subst">\(timeline.date)</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时钟可能会变得更加精致。 例如，使用带有形状的模拟时钟，或使用新的 <code>Canvas</code> 视图绘制时钟。</p><p>但是，<code>TimelineView</code> 不仅仅用于时钟。 在许多情况下，我们希望每次时间线更新我们的视图时，视图处理一些事情。 放置此代码的最佳位置是 <code>onChange(of:perform)</code> 闭包。</p><p>在以下示例中，我们使用此技术每 3 秒更新一次模型。</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/anim-part4-example-3.gif" alt="" title="Animation"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">3.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">QuipView</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QuipView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        @<span class="type">StateObject</span> <span class="keyword">var</span> quips = <span class="type">QuipDatabase</span>()</span><br><span class="line">        <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"_<span class="subst">\(quips.sentence)</span>_"</span>)</span><br><span class="line">                .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                    quips.<span class="built_in">advance</span>()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuipDatabase</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sentences = [</span><br><span class="line">        <span class="string">"There are two types of people, those who can extrapolate from incomplete data"</span>,</span><br><span class="line">        <span class="string">"After all is said and done, more is said than done."</span>,</span><br><span class="line">        <span class="string">"Haikus are easy. But sometimes they don't make sense. Refrigerator."</span>,</span><br><span class="line">        <span class="string">"Confidence is the feeling you have before you really understand the problem."</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> sentence: <span class="type">String</span> = <span class="type">QuipDatabase</span>.sentences[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">advance</span><span class="params">()</span></span> &#123;</span><br><span class="line">        idx = (idx + <span class="number">1</span>) % <span class="type">QuipDatabase</span>.sentences.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        sentence = <span class="type">QuipDatabase</span>.sentences[idx]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，每次时间线更新，我们的 <code>QuipView</code> 都会刷新两次。 也就是说，在时间线更新时一次，然后在之后立即再次，因为通过调用 <code>quips.advance()</code> 导致 <code>quips.sentence</code> 的 <code>@Published</code> 值发生变化并触发视图更新。 这很好，但需要注意，因为稍后它会变得更加重要。</p><blockquote><p>我们从中得出的一个重要概念是，尽管时间线可能会产生一定数量的更新，但视图的内容很可能会更新更多次。</p></blockquote><h2 id="TimelineView-与传统动画相结合"><a href="#TimelineView-与传统动画相结合" class="headerlink" title="TimelineView 与传统动画相结合"></a>TimelineView 与传统动画相结合</h2><p>新的 <code>TimelineView</code> 带来了很多新的机会。 正如我们将在以后的文章中看到的那样，将它与 <code>Canvas</code> 结合起来是一个很好的补充。 但为动画的每一帧编写所有代码给了我们带来了很多负担。 笔者将在本节中介绍的技术，使用我们已熟知的动画并且热衷于视图动画从一个时间线更新到下一个时间线。 这最终将让我们在纯 <code>SwiftUI</code> 中创建我们自己的类似关键帧的动画。</p><p>但是让我们慢慢开始，从我们的小项目开始：如下所示的节拍器。 调高音量播放视频，欣赏节拍声如何与钟摆同步。 此外，就像节拍器一样，每隔几拍就会响起一次铃声：</p><p><a href="https://swiftui-lab.com/wp-content/uploads/2021/06/metronome.mp4" target="_blank" rel="noopener">https://swiftui-lab.com/wp-content/uploads/2021/06/metronome.mp4</a></p><p>首先，让我们看看我们的时间线是什么样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Metronome</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> bpm: <span class="type">Double</span> = <span class="number">60</span> <span class="comment">// beats per minute</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">60</span> / bpm)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">MetronomeBack</span>()</span><br><span class="line">                .overlay(<span class="type">MetronomePendulum</span>(bpm: bpm, date: timeline.date))</span><br><span class="line">                .overlay(<span class="type">MetronomeFront</span>(), alignment: .bottom)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节拍器速度通常以 bpm（每分钟节拍数）指定。 该示例使用周期性调度程序，每 60/bpm 秒重复一次。 对于我们的例子，<code>bpm = 60</code>，所以调度程序每 1 秒触发一次。 即每分钟 60 次。</p><p><code>Metronome</code> 视图由三层组成：<code>MetronomeBack</code>、<code>MetronomePendulum</code> 和 <code>MetronomeFront</code>。 它们按此顺序叠加。 每次时间线更新都必须刷新的唯一视图是 <code>MetronomePendulum</code>，它可以左右摆动。 其他视图不会刷新，因为它们没有依赖关系。</p><p>MetronomeBack 和 Metronome Front 的代码非常简单，它们使用了一种称为圆形梯形的自定义形状。 为避免使此页面过长，自定义形状的代码在此 <a href="https://gist.github.com/swiftui-lab/62c3a7512644271e7881985f0b4f7357" target="_blank" rel="noopener">gist</a> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetronomeBack</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c1 = <span class="type">Color</span>(red: <span class="number">0</span>, green: <span class="number">0.3</span>, blue: <span class="number">0.5</span>, opacity: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> c2 = <span class="type">Color</span>(red: <span class="number">0</span>, green: <span class="number">0.46</span>, blue: <span class="number">0.73</span>, opacity: <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> gradient = <span class="type">LinearGradient</span>(colors: [c1, c2],</span><br><span class="line">                                      startPoint: .topLeading,</span><br><span class="line">                                      endPoint: .bottomTrailing)</span><br><span class="line">        </span><br><span class="line">        <span class="type">RoundedTrapezoid</span>(pct: <span class="number">0.5</span>, cornerSizes: [<span class="type">CGSize</span>(width: <span class="number">15</span>, height: <span class="number">15</span>)])</span><br><span class="line">            .foregroundStyle(gradient)</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">350</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetronomeFront</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">RoundedTrapezoid</span>(pct: <span class="number">0.85</span>, cornerSizes: [.zero, <span class="type">CGSize</span>(width: <span class="number">10</span>, height: <span class="number">10</span>)])</span><br><span class="line">            .foregroundStyle(<span class="type">Color</span>(red: <span class="number">0</span>, green: <span class="number">0.46</span>, blue: <span class="number">0.73</span>, opacity: <span class="number">1</span>))</span><br><span class="line">            .frame(width: <span class="number">180</span>, height: <span class="number">100</span>).padding(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，<code>MetronomePendulum</code> 视图是事情开始变得有趣的地方：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetronomePendulum</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> pendulumOnLeft: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> bellCounter = <span class="number">0</span> <span class="comment">// sound bell every 4 beats</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bpm: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Pendulum</span>(angle: pendulumOnLeft ? -<span class="number">30</span> : <span class="number">30</span>)</span><br><span class="line">            .animation(.easeInOut(duration: <span class="number">60</span> / bpm), value: pendulumOnLeft)</span><br><span class="line">            .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span> beat() &#125;</span><br><span class="line">            .onAppear &#123; beat() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">beat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pendulumOnLeft.toggle() <span class="comment">// triggers the animation</span></span><br><span class="line">        bellCounter = (bellCounter + <span class="number">1</span>) % <span class="number">4</span> <span class="comment">// keeps count of beats, to sound bell every 4th</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sound bell or beat?</span></span><br><span class="line">        <span class="keyword">if</span> bellCounter == <span class="number">0</span> &#123;</span><br><span class="line">            bellSound?.play()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            beatSound?.play()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pendulum</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> angle: <span class="type">Double</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Capsule</span>()</span><br><span class="line">                .fill(.red)</span><br><span class="line">                .frame(width: <span class="number">10</span>, height: <span class="number">320</span>)</span><br><span class="line">                .overlay(weight)</span><br><span class="line">                .rotationEffect(<span class="type">Angle</span>.degrees(angle), anchor: .bottom)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> weight: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>)</span><br><span class="line">                .fill(.orange)</span><br><span class="line">                .frame(width: <span class="number">35</span>, height: <span class="number">35</span>)</span><br><span class="line">                .padding(.bottom, <span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的视图需要跟踪我们在动画中的位置。 我称之为动画阶段。 由于我们需要跟踪这些阶段，我们将使用 <code>@State</code> 变量：</p><ol><li><code>pendulumOnLeft</code>: 跟踪钟摆 <code>Pendulum</code> 摆动的方向。</li><li><code>bellCounter</code>: 记录节拍的数量，以确定是否应该听到节拍或铃声。</li></ol><p>该示例使用 <code>.animation(_:value:)</code> 修饰语。 此版本的修改器，在指定值更改时应用动画。 请注意，也可以使用显式动画。 无需调用 <code>.animation()</code>，只需在 <code>withAnimation</code> 闭包内切换 <code>pendulumOnLeft</code> 变量。</p><p>为了使我们的视图在动画阶段前进，我们使用 <code>onChange(of:perform)</code> 修饰符监视日期的变化，就像我们在前面的 quip 示例中所做的那样。</p><p>除了在每次日期值更改时推进动画阶段，我们还在 <code>onAppear</code> 闭包中执行此操作。 否则，一开始就会有停顿。</p><p>最后一段与 <code>SwiftUI</code> 无关的代码是创建 <code>NSSound</code> 实例。 为了避免使示例过于复杂，笔者创建了几个全局变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bellSound: <span class="type">NSSound</span>? = &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"bell"</span>, withExtension: <span class="string">"mp3"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSSound</span>(contentsOf: url, byReference: <span class="literal">true</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beatSound: <span class="type">NSSound</span>? = &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"beat"</span>, withExtension: <span class="string">"mp3"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSSound</span>(contentsOf: url, byReference: <span class="literal">true</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>如果你需要声音文件，可以到 freesound 下载：<a href="https://freesound.org/" target="_blank" rel="noopener">https://freesound.org/</a></p><p>示例代码中的声音为：</p><ul><li><p>钟声: <a href="https://freesound.org/people/m1rk0/sounds/50071/" target="_blank" rel="noopener">metronome_pling</a> 根据许可证 CC BY 3.0 (m1rk0)</p></li><li><p>节拍声: <a href="https://freesound.org/people/Druminfected/sounds/250552/" target="_blank" rel="noopener">metronome.wav</a> 根据 CC0 1.0 </p></li></ul><h2 id="TimelineScheduler"><a href="#TimelineScheduler" class="headerlink" title="TimelineScheduler"></a>TimelineScheduler</h2><p>正如我们已经看到的，<code>TimelineView</code> 需要一个 <code>TimelineScheduler</code> 来确定何时更新其内容。 <code>SwiftUI</code> 提供了一些预定义的调度器，比如我们使用的那些。 但是，我们也可以创建自己的自定义调度程序。 笔者将在下一节中详细说明。 但让我们从已有的调度器开始。</p><p>时间线调度器基本上是一个采用 <code>TimelineScheduler</code> 协议的结构。 现有的类型有：</p><ul><li><code>AnimationTimelineSchedule</code>： 尽可能快地更新，给你绘制动画每一帧的机会。 它具有让你限制更新频率和暂停更新的参数。 在 <code>TimelineView</code> 与新的 <code>Canvas</code> 视图结合使用时，这将非常有用。</li><li><code>EveryMinuteTimelineSchedule</code>： 顾名思义，它每分钟更新一次，在每分钟开始时更新。</li><li><code>ExplicitTimelineSchedule</code>： 可以提供一个数组，其中包含你希望时间线更新的所有时间。</li><li><code>PeriodicTimelineSchedule</code>： 可以提供开始时间和发生更新的频率。</li></ul><p>尽管你可以以这种方式创建 <code>Timeline</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timeline</span>(<span class="type">EveryMinuteTimelineSchedule</span>()) &#123; timeline <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自 Swift 5.5 和 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0299-extend-generic-static-member-lookup.md" target="_blank" rel="noopener">SE-0299</a> 的引入以来，我们现在已经支持类枚举语法。 这使代码更具可读性并改进了自动完成功能。 建议我们改用这种语法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.everyMinute) &#123; timeline <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：你可能听说过，但今年也引入了样式。 更好的是，对于样式，只要你使用的是 Swift 5.5，你就可以使用以前的版本进行反向部署。</em></p><p>对于每个现有的调度程序，可能有多个类似枚举的选项。 例如，这两行代码创建了 <code>AnimationTimelineSchedule</code> 类型的调度程序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.animation) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TimelineView</span>(.animation(minimumInterval: <span class="number">0.3</span>, paused: <span class="literal">false</span>)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>你甚至可以创建属于自己的调度程序（不要忘记 <code>static</code> 关键字）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimelineSchedule</span> <span class="title">where</span> <span class="title">Self</span> == <span class="title">PeriodicTimelineSchedule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> everyFiveSeconds: <span class="type">PeriodicTimelineSchedule</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; .<span class="keyword">init</span>(from: .now, by: <span class="number">5.0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.everyFiveSeconds) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-TimelineScheduler"><a href="#自定义-TimelineScheduler" class="headerlink" title="自定义 TimelineScheduler"></a>自定义 TimelineScheduler</h2><p>如果现有调度程序都不符合你的需求，可以创建自己的调度程序。 思考以下动画： </p><p><img src="https://images.xiaozhuanlan.com/photo/2022/d4c8ee7e28437fd6880043228b366cf7.gif" alt=""></p><p>在这个动画中，我们有一个心形表情符号，它会以不规则的间隔和不规则的幅度改变其比例。<br>它以 1.0 的比例开始，0.2 秒后增长到 1.6，0.2 秒后增长到 2.0，然后缩小到 1.0 并保持 0.4 秒，然后重新开始。 换一种说法：</p><p>尺度变化：1.0 → 1.6 → 2.0 → 重新开始</p><p>变化之间的时间：0.2 → 0.2 → 0.4 → 重新开始</p><p>我们可以创建一个 <code>HeartTimelineSchedule</code>，它完全按照心脏的需要进行更新。 但是以可重用性的名义，让我们做一些更通用的东西，将来可以重用。</p><p>我们新调度程序将被称为：<code>CyclicTimelineSchedule</code>，并将接收一组时间偏移量。 每个偏移值都将相对于数组中的前一个值。 当调度程序用尽偏移量时，它将循环回到数组的开头并重新开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CyclicTimelineSchedule</span>: <span class="title">TimelineSchedule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeOffsets: [<span class="type">TimeInterval</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">entries</span><span class="params">(from startDate: Date, mode: TimelineScheduleMode)</span></span> -&gt; <span class="type">Entries</span> &#123;</span><br><span class="line">        <span class="type">Entries</span>(last: startDate, offsets: timeOffsets)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Entries</span>: <span class="title">Sequence</span>, <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> last: <span class="type">Date</span></span><br><span class="line">        <span class="keyword">let</span> offsets: [<span class="type">TimeInterval</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> idx: <span class="type">Int</span> = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Date</span>? &#123;</span><br><span class="line">            idx = (idx + <span class="number">1</span>) % offsets.<span class="built_in">count</span></span><br><span class="line">            </span><br><span class="line">            last = last.addingTimeInterval(offsets[idx])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> last</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>TimelineSchedule</code> 有几个要求：</p><ul><li>提供 <code>entry(from:mode:)</code> 函数。</li><li>我们 <code>Entries</code> 的类型必须符合 <code>Sequence where Entries.Element == Date</code></li></ul><p>有几种方法可以符合 <code>Sequence</code>。 此示例实现 <code>IteratorProtocol</code> 并声明符合 <code>Sequence</code> 和 <code>IteratorProtocol</code>。 你可以在<a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener">此处</a>阅读有关序列一致性的更多信息。</p><p>对于实现 <code>IteratorProtocol</code> 的 <code>Entries</code>，我们必须编写 <code>next()</code> 函数，该函数在时间线中生成日期。 我们的调度程序会记住最后日期并添加适当的偏移量。 当没有更多的偏移量时，它会循环回到数组中的第一个。</p><p>最后，锦上添花的是，为我们的调度器创建一个类似枚举的初始化器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimelineSchedule</span> <span class="title">where</span> <span class="title">Self</span> == <span class="title">CyclicTimelineSchedule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cyclic</span><span class="params">(timeOffsets: [TimeInterval])</span></span> -&gt; <span class="type">CyclicTimelineSchedule</span> &#123;</span><br><span class="line">            .<span class="keyword">init</span>(timeOffsets: timeOffsets)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经准备好 <code>TimelineSchedue</code> 类型了，让我们为我们的心脏注入一些活力：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BeatingHeart</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.cyclic(timeOffsets: [<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>])) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">Heart</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heart</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> phase = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> scales: [<span class="type">CGFloat</span>] = [<span class="number">1.0</span>, <span class="number">1.6</span>, <span class="number">2.0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"❤️"</span>)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .scaleEffect(scales[phase])</span><br><span class="line">                .animation(.spring(response: <span class="number">0.10</span>,</span><br><span class="line">                                   dampingFraction: <span class="number">0.24</span>,</span><br><span class="line">                                   blendDuration: <span class="number">0.2</span>),</span><br><span class="line">                           value: phase)</span><br><span class="line">                .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                    advanceAnimationPhase()</span><br><span class="line">                &#125;</span><br><span class="line">                .onAppear &#123;</span><br><span class="line">                    advanceAnimationPhase()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">advanceAnimationPhase</span><span class="params">()</span></span> &#123;</span><br><span class="line">        phase = (phase + <span class="number">1</span>) % scales.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你现在应该熟悉这种模式，它与我们使用节拍器的模式相同。 使用 <code>onChange</code> 和 <code>onAppear</code> 推进动画，使用 <code>@State</code> 变量来跟踪动画，并设置一个动画，将我们的视图从一个时间线更新过渡到下一个。 在这种情况下，我们使用 <code>.spring</code> 动画，给它一个很好的摇晃效果。</p><h2 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><p>心脏和节拍器示例在某种程度上是关键帧动画。 我们在整个动画中定义了几个关键点，在这里我们改变了我们视图的参数，并让 <code>SwiftUI</code> 动画这些点之间的过渡。 以下示例将尝试概括该想法，并使其更加明显。 认识我们的新项目朋友，跳跃的家伙：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/603741f728ab66e0171c89ebe7ff95d0.gif" alt=""></p><p>如果你仔细观察动画，你会注意到这个表情符号角色的许多参数在不同的时间点发生了变化。 这些参数是：<code>y-offset</code>、<code>rotation</code> 和 <code>y-scale</code>。 同样重要的是，动画的不同片段有不同的动画类型（线性、缓入和缓出）。 由于这些是我们更改的参数，因此最好将它们放在一个数组中。 让我们开始： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset: <span class="type">TimeInterval</span>    </span><br><span class="line">    <span class="keyword">let</span> rotation: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> yScale: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> animation: <span class="type">Animation</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyframes = [</span><br><span class="line">    <span class="comment">// Initial state, will be used once. Its offset is useless and will be ignored</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.0</span>, rotation: <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: <span class="number">0</span>, animation: <span class="literal">nil</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Animation keyframes</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animation: .linear(duration: <span class="number">0.2</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .linear(duration: <span class="number">0.4</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animation: .easeOut(duration: <span class="number">0.5</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .easeIn(duration: <span class="number">0.4</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation: <span class="number">360</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animation: .easeOut(duration: <span class="number">0.2</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .linear(duration: <span class="number">0.4</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animation: .easeOut(duration: <span class="number">0.5</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .easeIn(duration: <span class="number">0.4</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>重要的是要知道，当 <code>TimelineView</code> 出现时，它会绘制我们的视图，即使没有计划的更新，或者它们是否在将来。 当 <code>TimelineView</code> 出现时，它需要显示一些东西，以便绘制我们的视图。 我们将使用第一个关键帧作为我们的视图状态，但是当我们循环时，该帧将被忽略。 这是一个实施决策，你可能需要或想要以不同的方式进行。</p><p>现在，让我们看看我们的时间线：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JumpingEmoji</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use all offset, minus the first</span></span><br><span class="line">    <span class="keyword">let</span> offsets = <span class="type">Array</span>(keyframes.<span class="built_in">map</span> &#123; $<span class="number">0</span>.offset &#125;.<span class="built_in">dropFirst</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.cyclic(timeOffsets: offsets)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">HappyEmoji</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经从我们在前一个示例中所做的工作中受益，并重用了 <code>CyclicTimelineScheduler</code>。 如前所述，我们不需要第一个关键帧的偏移量，因此我们将其丢弃。</p><p>现在，有趣的部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HappyEmoji</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// current keyframe number</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> idx: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// timeline update</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"😃"</span>)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">            .modifier(<span class="type">Effects</span>(keyframe: keyframes[idx]))</span><br><span class="line">            .animation(keyframes[idx].animation, value: idx)</span><br><span class="line">            .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span> advanceKeyFrame() &#125;</span><br><span class="line">            .onAppear &#123; advanceKeyFrame()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">advanceKeyFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// advance to next keyframe</span></span><br><span class="line">        idx = (idx + <span class="number">1</span>) % keyframes.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// skip first frame for animation, which we</span></span><br><span class="line">        <span class="comment">// only used as the initial state.</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span> &#123; idx = <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Effects</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> keyframe: <span class="type">KeyFrame</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">            content</span><br><span class="line">                .scaleEffect(<span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: keyframe.yScale))</span><br><span class="line">                .rotationEffect(<span class="type">Angle</span>(degrees: keyframe.rotation))</span><br><span class="line">                .offset(y: keyframe.y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的可读性，我将所有变化的参数放在一个名为 <code>Effects</code> 的修改器中。 如你所见，它还是相同的模式：使用 <code>onChange</code> 和 <code>onAppear</code> 来推进我们的动画，并为每个关键帧片段添加一个动画。 那里没有什么新鲜事。</p><h2 id="不要！-这是一个陷阱！"><a href="#不要！-这是一个陷阱！" class="headerlink" title="不要！ 这是一个陷阱！"></a>不要！ 这是一个陷阱！</h2><p>在你的 <code>TimelineView</code> 发现路径中，你可能会遇到此错误：</p><blockquote><p>Action Tried to Update Multiple Times Per Frame</p></blockquote><p>让我们看一个生成此消息的示例： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">2.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">                .foregroundStyle(flag ? .red : .blue)</span><br><span class="line">                .onChange(of: timeline.date) &#123; (date: <span class="type">Date</span>) <span class="keyword">in</span></span><br><span class="line">                    flag.toggle()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来没有问题，它应该每两秒改变一次文本颜色，在红色和蓝色之间交替。那么可能会发生什么？稍等片刻，看看你是否能找出背后的原因。</p><p>我们不是在处理一个 bug。事实上，这个问题是可以预见的。<br><code>重要的是要记住，时间线的第一次更新是在它第一次出现时，然后它遵循调度程序规则来触发以下更新。因此，即使我们的调度程序没有产生更新，</code>TimelineView` 内容也至少会生成一次。</p><p>在这个具体的例子中，我们监控 <code>timeline.date</code> 值的变化，当它发生变化时，我们切换 <code>flag</code> 变量，它会产生颜色变化。</p><p><code>TimelineView</code> 将首先出现。两秒后，时间线将更新（例如，由于第一次调度程序更新），触发 <code>onChange</code> 关闭。这将反过来改变标志变量。现在，由于我们的 <code>TimelineView</code> 依赖于它，它需要立即刷新，触发标志变量的另一个切换，强制另一个 <code>TimelineView</code> 刷新，依此类推……你明白了：每帧多次更新。</p><p>那么我们该如何解决呢？解决方案可能会有所不同。在这种情况下，我们只需封装内容并将标志变量移动到封装的视图内。现在 <code>TimelineView</code> 不再依赖它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">1.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">SubView</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">            .foregroundStyle(flag ? .red : .blue)</span><br><span class="line">            .onChange(of: date) &#123; (date: <span class="type">Date</span>) <span class="keyword">in</span></span><br><span class="line">                flag.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="探索新点子"><a href="#探索新点子" class="headerlink" title="探索新点子"></a>探索新点子</h2><p><strong>每次时间线更新刷新一次</strong>：如前所述，这种模式使我们的视图每次更新计算它们的主体两次：第一次是在时间线更新时，然后在我们推进动画状态值时再次计算。在这种类型的动画中，我们在时间上间隔了关键点，这非常好。</p><p>在这些时间点太靠近的动画中，你可能需要/想要避免这种情况。如果你需要更改存储的值，但要避免视图刷新……你可以使用一个技巧。使用 <code>@StateObject</code> 代替<code>@State</code>。确保你不要在 <code>@Published</code> 中设置这样的值。如果在某个时候，你想要/需要告诉你的视图刷新，你可以随时调用<code>objectWillChange.send()</code></p><p><strong>匹配动画持续时间和偏移量</strong>：在关键帧示例中，我们为每个动画片段使用不同的动画。为此，我们将动画值存储在数组中。如果你仔细观察，你会发现在我们的具体示例中，偏移量和动画持续时间匹配！这是合理的，对吧？因此，你可以定义一个具有动画类型的枚举，而不是在数组中包含 <code>Animation</code> 值。稍后在你的视图中，你将根据动画类型创建动画值，但使用偏移值的持续时间对其进行实例化。类似这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KeyFrameAnimation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> linear</span><br><span class="line">    <span class="keyword">case</span> easeOut</span><br><span class="line">    <span class="keyword">case</span> easeIn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset: <span class="type">TimeInterval</span>    </span><br><span class="line">    <span class="keyword">let</span> rotation: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> yScale: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> animationKind: <span class="type">KeyFrameAnimation</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animation: <span class="type">Animation</span>? &#123;</span><br><span class="line">        <span class="keyword">switch</span> animationKind &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> .linear: <span class="keyword">return</span> .linear(duration: offset)</span><br><span class="line">        <span class="keyword">case</span> .easeIn: <span class="keyword">return</span> .easeIn(duration: offset)</span><br><span class="line">        <span class="keyword">case</span> .easeOut: <span class="keyword">return</span> .easeOut(duration: offset)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyframes = [</span><br><span class="line">    <span class="comment">// Initial state, will be used once. Its offset is useless and will be ignored</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.0</span>, rotation: <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: <span class="number">0</span>, animationKind: .<span class="keyword">none</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Animation keyframes</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animationKind: .linear),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .linear),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animationKind: .easeOut),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .easeIn),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation: <span class="number">360</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animationKind: .easeOut),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .linear),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animationKind: .easeOut),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .easeIn),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果你想知道为什么我一开始不这样做，我只是想向你展示两种方式都是可能的。 第一种情况更灵活，但更冗长。 也就是说，我们被迫为每个动画指定持续时间，但是，它更灵活，因为我们可以自由使用与偏移量不匹配的持续时间。</p><p>然而，当使用这种新方法时，你可以轻松地添加一个可自定义的因素，这可以让你减慢或加快动画速度，而无需触摸关键帧。</p><p><strong>嵌套 TimelineViews</strong>：没有什么能阻止你将一个 <code>TimelineView</code> 嵌套在另一个 <code>TimelineView</code> 中。 现在我们有了 <code>JumpingEmoji</code>，我们可以在 <code>TimelineView</code> 中放置三个 <code>JumpingEmoji</code> 视图，使它们一次出现一个，并有延迟：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/305e84985d4d239e6ae75c508a025062.gif" alt=""></p><p>对于 Emoji 波浪的全部源码，检出这个 <a href="https://gist.github.com/swiftui-lab/f4e77af35ba15853cc1426c735cc6cdc" target="_blank" rel="noopener">gits</a>。</p><h2 id="GifImage-示例"><a href="#GifImage-示例" class="headerlink" title="GifImage 示例"></a>GifImage 示例</h2><p>笔者原本还有一个示例，但是它在笔者发布文章的时候废弃了。 它没有入选的原因是并发 API 还不稳定。 幸运的是，现在可以安全地发布它。 该代码使用 <code>TimelineView</code> 来实现动画 gif 的视图。 视图从 URL（可以是本地的或远程的）异步加载 gif。 此 <a href="https://gist.github.com/swiftui-lab/aa5d73b81c8696dee4a5996954b22e5c" target="_blank" rel="noopener">gist</a> 中提供了所有代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>恭喜阅读到这么长的一篇文章的结尾。这是一次骑行！我们从最简单的 <code>TimelineView</code> 示例转到视图的一些创造性使用。 在第 5 部分中，笔者将探索新的 <code>Canvas</code> 视图，以及它与 <code>TimelineView</code> 的结合程度。 通过将它们放在一起，我们将扩展 <code>SwiftUI</code> 动画世界中的更多可能性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前三篇&lt;a href=&quot;https://xiaozhuanlan.com/topic/6089153247&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高级 SwiftUI 动画系列&lt;/a&gt;是作者在 WWDC 2021 之前实战总结的内容。对 2021 年 WWDC 介绍的 &lt;code&gt;TimelineView&lt;/code&gt; 和 &lt;code&gt;Canvas&lt;/code&gt; 感到激动。这开启了一个全新的可能性，笔者将试图在这一部分和下一部分的系列中阐释这些可能性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://swiftui-lab.com/wp-content/uploads/2021/06/hello-there-25.gif&quot; alt=&quot;&quot; title=&quot;Hello There&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将详细地探索 &lt;code&gt;TimelineView&lt;/code&gt; 。我们将从最常见的用途缓慢开始。然而笔者认为，最大的可能性来自于 &lt;code&gt;TimelineView&lt;/code&gt; 和我们已知现有的动画相结合。在其他事物中，通过一点创意，这样的组合将让我们最终实现“关键帧类似”的动画。&lt;/p&gt;
&lt;p&gt;在第 5 部分，我们将探索 &lt;code&gt;Canvas&lt;/code&gt; 视图，以及它和我们的新朋友 &lt;code&gt;TimelineView&lt;/code&gt; 相结合是如此的优秀。&lt;/p&gt;
&lt;p&gt;上文中展示的动画，是使用本文中介绍的技术创建的。该动画的完整代码可在此 &lt;a href=&quot;https://gist.github.com/swiftui-lab/c1d089207d6f7b365729b1af2e695cc4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gist&lt;/a&gt; 中找到。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画 — Part 3：AnimatableModifier</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB-%E2%80%94-Part-3%EF%BC%9AAnimatableModifier/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画-—-Part-3：AnimatableModifier/</id>
    <published>2022-04-06T02:31:12.000Z</published>
    <updated>2022-04-06T02:37:25.566Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2022/44ccd720a2cc827b4921c612d1dbf6f9.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的两篇文章<a href="https://xiaozhuanlan.com/topic/9583407126" target="_blank" rel="noopener">animating paths</a> 和 <a href="https://xiaozhuanlan.com/topic/9685470312" target="_blank" rel="noopener">transform matrices</a> 对 Animatable 协议使用做了介绍，今天这篇文章将为大家介绍 AnimatableModifier，使用它可以完成更多的动画工作。</p><p>AnimatableModifier 是一个 ViewModifier，符合 Animatable 协议，如果对这个协议不了解可以阅读之前发布的两篇文章。</p><a id="more"></a><h1 id="AnimatableModifier-无法实现动画"><a href="#AnimatableModifier-无法实现动画" class="headerlink" title="AnimatableModifier 无法实现动画"></a>AnimatableModifier 无法实现动画</h1><p>如果是第一次使用 AnimatableModifier，可能会遇到问题。写一个简单的动画，但是没有动画效果。 我又试了几次，也没有成功。因此我认为该功能不存并且放弃使用。幸运的是，后来我坚持了下来。事实证明，我的第一个 <code>modifier</code> 非常好，但是 <code>animatable modifiers</code> 在容器中不起作用。 我在第二次尝试时，动画视图不在容器内。</p><p>例如，以下 modifier 可以成功实现动画：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyView</span>().modifier(<span class="type">MyAnimatableModifier</span>(value: flag ? <span class="number">1</span> : <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>但是相同的代码，在 VStack 中就没有动画了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">MyView</span>().modifier(<span class="type">MyAnimatableModifier</span>(value: flag ? <span class="number">1</span> : <span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题在官方解决之前，经过尝试，可以在 VStack 中改成下面的代码，就可以实现动画：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Color</span>.clear.overlay(<span class="type">MyView</span>().modifier(<span class="type">MyAnimatableModifier</span>(value: flag ? <span class="number">1</span> : <span class="number">0</span>))).frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写是使用一个透明视图占据实际视图空间，动画被放在透明视图上，使用 <code>.overlay()</code>。有点不方便的是，我们需要知道实际视图有多大，所以我们可以在它后面设置透明视图的框架。在下面的示例中可以开到实现代码。</p><h1 id="动画文本"><a href="#动画文本" class="headerlink" title="动画文本"></a>动画文本</h1><p>首先需要制作一些文字动画。对于这个例子，我们将创建一个进度加载指示器。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/5758d75eef91ca96c7591467047153f4.gif" alt=""></p><p>可能很多人都认为应该使用动画路径实现。但是，内部标签就无法设置动画，使用 <code>AnimatableModifier</code> 可以实现。</p><p>完整的代码作为 <strong>示例10</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PercentageIndicator</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .overlay(<span class="type">ArcShape</span>(pct: pct).foregroundColor(.red))</span><br><span class="line">            .overlay(<span class="type">LabelView</span>(pct: pct))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> pct: <span class="type">CGFloat</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="type">Path</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> p = <span class="type">Path</span>()</span><br><span class="line"></span><br><span class="line">            p.addArc(center: <span class="type">CGPoint</span>(x: rect.width / <span class="number">2.0</span>, y:rect.height / <span class="number">2.0</span>),</span><br><span class="line">                     radius: rect.height / <span class="number">2.0</span> + <span class="number">5.0</span>,</span><br><span class="line">                     startAngle: .degrees(<span class="number">0</span>),</span><br><span class="line">                     endAngle: .degrees(<span class="number">360.0</span> * <span class="type">Double</span>(pct)), clockwise: <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> p.strokedPath(.<span class="keyword">init</span>(lineWidth: <span class="number">10</span>, dash: [<span class="number">6</span>, <span class="number">3</span>], dashPhase: <span class="number">10</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LabelView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> pct: <span class="type">CGFloat</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"<span class="subst">\(Int(pct * <span class="number">100</span>)</span>) %"</span>)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .fontWeight(.bold)</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在示例代码中可以看到，没有使 <code>ArcShape animatable</code>。 因为 <code>modifier</code> 已经多次创建形状，具有不同的 pct 值。</p><h1 id="动画渐变"><a href="#动画渐变" class="headerlink" title="动画渐变"></a>动画渐变</h1><p>在实现渐变动画时，可能会遇到一些限制。比如，可以为起点和终点设置动画，但是不能为渐变颜色设置动画。使用 <code>AnimatableModifier</code> 可以避免出现这种情况。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/eaedb1f634b7e68c3e7967cbe1ecb15c.gif" alt=""></p><p>很容易就可以实现这个功能，在这个基础上可以实现更多复杂的动画。如果需要插入中间颜色，我们只需要计算 RGB 值的平均值。另外需要注意，<code>modifier</code> 假设输入颜色数组都包含相同数量的颜色。</p><p>完整的代码作为 <strong>示例11</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnimatableGradient</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> from: [<span class="type">UIColor</span>]</span><br><span class="line">    <span class="keyword">let</span> to: [<span class="type">UIColor</span>]</span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> gColors = [<span class="type">Color</span>]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;from.<span class="built_in">count</span> &#123;</span><br><span class="line">            gColors.append(colorMixer(c1: from[i], c2: to[i], pct: pct))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">15</span>)</span><br><span class="line">            .fill(<span class="type">LinearGradient</span>(gradient: <span class="type">Gradient</span>(colors: gColors),</span><br><span class="line">                                 startPoint: <span class="type">UnitPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>),</span><br><span class="line">                                 endPoint: <span class="type">UnitPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)))</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This is a very basic implementation of a color interpolation</span></span><br><span class="line">    <span class="comment">// between two values.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">colorMixer</span><span class="params">(c1: UIColor, c2: UIColor, pct: CGFloat)</span></span> -&gt; <span class="type">Color</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cc1 = c1.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cc2 = c2.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> r = (cc1[<span class="number">0</span>] + (cc2[<span class="number">0</span>] - cc1[<span class="number">0</span>]) * pct)</span><br><span class="line">        <span class="keyword">let</span> g = (cc1[<span class="number">1</span>] + (cc2[<span class="number">1</span>] - cc1[<span class="number">1</span>]) * pct)</span><br><span class="line">        <span class="keyword">let</span> b = (cc1[<span class="number">2</span>] + (cc2[<span class="number">2</span>] - cc1[<span class="number">2</span>]) * pct)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Color</span>(red: <span class="type">Double</span>(r), green: <span class="type">Double</span>(g), blue: <span class="type">Double</span>(b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多文本动画"><a href="#更多文本动画" class="headerlink" title="更多文本动画"></a>更多文本动画</h1><p>这个示例中，将再次实现一个文本动画。但是是逐步进行，一次放大一个字符</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/2dc189297ef8f91cd26ebd11eef0c86c.gif" alt=""></p><p>完整的代码作为 <strong>示例12</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WaveTextModifier</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> waveWidth: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HStack</span>(spacing: <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="type">Array</span>(text.enumerated()), id: \.<span class="number">0</span>) &#123; (n, ch) <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(<span class="type">String</span>(ch))</span><br><span class="line">                    .font(<span class="type">Font</span>.custom(<span class="string">"Menlo"</span>, size: <span class="keyword">self</span>.size).bold())</span><br><span class="line">                    .scaleEffect(<span class="keyword">self</span>.effect(<span class="keyword">self</span>.pct, n, <span class="keyword">self</span>.text.<span class="built_in">count</span>, <span class="type">Double</span>(<span class="keyword">self</span>.waveWidth)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effect</span><span class="params">(<span class="number">_</span> pct: Double, <span class="number">_</span> n: Int, <span class="number">_</span> total: Int, <span class="number">_</span> waveWidth: Double)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="type">Double</span>(n)</span><br><span class="line">        <span class="keyword">let</span> total = <span class="type">Double</span>(total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="number">1</span> + valueInCurve(pct: pct, total: total, x: n/total, waveWidth: waveWidth))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">valueInCurve</span><span class="params">(pct: Double, total: Double, x: Double, waveWidth: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> chunk = waveWidth / total</span><br><span class="line">        <span class="keyword">let</span> m = <span class="number">1</span> / chunk</span><br><span class="line">        <span class="keyword">let</span> offset = (chunk - (<span class="number">1</span> / total)) * pct</span><br><span class="line">        <span class="keyword">let</span> lowerLimit = (pct - chunk) + offset</span><br><span class="line">        <span class="keyword">let</span> upperLimit = (pct) + offset</span><br><span class="line">        <span class="keyword">guard</span> x &gt;= lowerLimit &amp;&amp; x &lt; upperLimit <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> angle = ((x - pct - offset) * m)*<span class="number">360</span>-<span class="number">90</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (sin(angle.rad) + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rad: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * .pi / <span class="number">180</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> deg: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">180</span> / .pi &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数器动画"><a href="#计数器动画" class="headerlink" title="计数器动画"></a>计数器动画</h1><p>如果你没有用过或者对 AnimatableModifier 不了解，下面这个示例基本上是无法实现的。下面我们来介绍一下如何创建一个计数器动画：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/cc47950bb3f88ec3dd90d006f27491aa.gif" alt=""></p><p>这个练习的诀窍是为每个数字使用 5 个文本视图，并使用 .spring() 动画上下移动它们。 我们还需要使用 .clipShape() 修饰符来隐藏在边框之外绘制的部分。 为了更好地理解它是如何工作的，您可以评论 .clipShape() 并大大减慢动画的速度。 完整代码在本页顶部链接的 gist 文件中以 Example13 的形式提供。</p><p>这个动画实现的主要内容是每个数字使用 5 个文本视图，并使用 .spring() 动画上下移动它们。然后使用  <code>.clipShape()</code> 修饰符来隐藏边框之外区域。如果想跟清晰的理解他们是如何实现的，可以通过    <code>.clipShape()</code>  让动画速度变慢。</p><p>完整的代码作为 <strong>示例13</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovingCounterModifier</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">        @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> height: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> number: <span class="type">Double</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; number &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; number = newValue &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> n = <span class="keyword">self</span>.number + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> tOffset: <span class="type">CGFloat</span> = getOffsetForTensDigit(n)</span><br><span class="line">            <span class="keyword">let</span> uOffset: <span class="type">CGFloat</span> = getOffsetForUnitDigit(n)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> u = [n - <span class="number">2</span>, n - <span class="number">1</span>, n + <span class="number">0</span>, n + <span class="number">1</span>, n + <span class="number">2</span>].<span class="built_in">map</span> &#123; getUnitDigit($<span class="number">0</span>) &#125;</span><br><span class="line">            <span class="keyword">let</span> x = getTensDigit(n)</span><br><span class="line">            <span class="keyword">var</span> t = [<span class="built_in">abs</span>(x - <span class="number">2</span>), <span class="built_in">abs</span>(x - <span class="number">1</span>), <span class="built_in">abs</span>(x + <span class="number">0</span>), <span class="built_in">abs</span>(x + <span class="number">1</span>), <span class="built_in">abs</span>(x + <span class="number">2</span>)]</span><br><span class="line">            t = t.<span class="built_in">map</span> &#123; getUnitDigit(<span class="type">Double</span>($<span class="number">0</span>)) &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> font = <span class="type">Font</span>.custom(<span class="string">"Menlo"</span>, size: <span class="number">34</span>).bold()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">HStack</span>(alignment: .top, spacing: <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">VStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">0</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">1</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">2</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">3</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">4</span>])</span>"</span>).font(font)</span><br><span class="line">                &#125;.foregroundColor(.green).modifier(<span class="type">ShiftEffect</span>(pct: tOffset))</span><br><span class="line">                </span><br><span class="line">                <span class="type">VStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">0</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">1</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">2</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">3</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">4</span>])</span>"</span>).font(font)</span><br><span class="line">                &#125;.foregroundColor(.green).modifier(<span class="type">ShiftEffect</span>(pct: uOffset))</span><br><span class="line">            &#125;</span><br><span class="line">            .clipShape(<span class="type">ClipShape</span>())</span><br><span class="line">            .overlay(<span class="type">CounterBorder</span>(height: $height))</span><br><span class="line">            .background(<span class="type">CounterBackground</span>(height: $height))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getUnitDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="type">Int</span>(number) - ((<span class="type">Int</span>(number) / <span class="number">10</span>) * <span class="number">10</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getTensDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="type">Int</span>(number) / <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getOffsetForUnitDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - <span class="type">CGFloat</span>(number - <span class="type">Double</span>(<span class="type">Int</span>(number)))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getOffsetForTensDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> getUnitDigit(number) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> - <span class="type">CGFloat</span>(number - <span class="type">Double</span>(<span class="type">Int</span>(number)))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="动画文本颜色"><a href="#动画文本颜色" class="headerlink" title="动画文本颜色"></a>动画文本颜色</h1><p>通常情况下是通过 <code>.foregroundColor()</code> 为动画添加颜色，但是在文本类动画中使用没有效果，不知道是缺少什么配置还是什么原因。我通过下面的方法实现给文本动画添加颜色。</p><p>完整的代码作为 <strong>示例14</strong> 在文末链接中。关键代码如下：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/7d75cef39eac0ff99a6549da9912d440.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnimatableColorText</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> from: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">let</span> to: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">let</span> pct: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> text: () -&gt; <span class="type">Text</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> textView = text()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> textView.foregroundColor(<span class="type">Color</span>.clear)</span><br><span class="line">            .overlay(<span class="type">Color</span>.clear.modifier(<span class="type">AnimatableColorTextModifier</span>(from: from, to: to, pct: pct, text: textView)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AnimatableColorTextModifier</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> from: <span class="type">UIColor</span></span><br><span class="line">        <span class="keyword">let</span> to: <span class="type">UIColor</span></span><br><span class="line">        <span class="keyword">var</span> pct: <span class="type">CGFloat</span></span><br><span class="line">        <span class="keyword">let</span> text: <span class="type">Text</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> text.foregroundColor(colorMixer(c1: from, c2: to, pct: pct))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// This is a very basic implementation of a color interpolation</span></span><br><span class="line">        <span class="comment">// between two values.</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">colorMixer</span><span class="params">(c1: UIColor, c2: UIColor, pct: CGFloat)</span></span> -&gt; <span class="type">Color</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> cc1 = c1.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> cc2 = c2.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> r = (cc1[<span class="number">0</span>] + (cc2[<span class="number">0</span>] - cc1[<span class="number">0</span>]) * pct)</span><br><span class="line">            <span class="keyword">let</span> g = (cc1[<span class="number">1</span>] + (cc2[<span class="number">1</span>] - cc1[<span class="number">1</span>]) * pct)</span><br><span class="line">            <span class="keyword">let</span> b = (cc1[<span class="number">2</span>] + (cc2[<span class="number">2</span>] - cc1[<span class="number">2</span>]) * pct)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Color</span>(red: <span class="type">Double</span>(r), green: <span class="type">Double</span>(g), blue: <span class="type">Double</span>(b))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="版本相关问题"><a href="#版本相关问题" class="headerlink" title="版本相关问题"></a>版本相关问题</h1><p>通过上面介绍可以看出 <code>AnimatableModifier</code> 非常强大，但是还存在一些问题。另外在 Xcode 和 iOS/macOS 某些版本中，App 在启动时会崩溃。而且是在部署时，正常开发编译中是不会发生这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Symbol not found: _$s7SwiftUI18AnimatableModifierPAAE13_makeViewList8modifier6inputs4bodyAA01_fG7OutputsVAA11_GraphValueVyxG_AA01_fG6InputsVAiA01_L0V_ANtctFZ</span><br><span class="line">  Referenced from: /Applications/MyApp.app/Contents/MacOS/MyApp</span><br><span class="line">  Expected in: /System/Library/Frameworks/SwiftUI.framework/Versions/A/SwiftUI</span><br></pre></td></tr></table></figure><p>例如，如果 App 在 Xcode 11.3 上部署并在 macOS 10.15.0 上执行，就会出现 “Symbol not found” 错误。然而，在 macOS  10.15.1 上运行相同的可执行文件可以正常工作。</p><blockquote><p>译自 <a href="https://swiftui-lab.com/" target="_blank" rel="noopener">The SwiftUI Lab</a> 的 <a href="https://swiftui-lab.com/swiftui-animations-part3/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 3: AnimatableModifier</a></p><p>本文的完整示例代码可在以下位置找到：</p><p><a href="https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798" target="_blank" rel="noopener">https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798</a></p><p>示例8 需要的图片资源。从这里下载：</p><p><a href="https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916" target="_blank" rel="noopener">https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/44ccd720a2cc827b4921c612d1dbf6f9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前的两篇文章&lt;a href=&quot;https://xiaozhuanlan.com/topic/9583407126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;animating paths&lt;/a&gt; 和 &lt;a href=&quot;https://xiaozhuanlan.com/topic/9685470312&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;transform matrices&lt;/a&gt; 对 Animatable 协议使用做了介绍，今天这篇文章将为大家介绍 AnimatableModifier，使用它可以完成更多的动画工作。&lt;/p&gt;
&lt;p&gt;AnimatableModifier 是一个 ViewModifier，符合 Animatable 协议，如果对这个协议不了解可以阅读之前发布的两篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画 — Part 2：GeometryEffect</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB-%E2%80%94-Part-2%EF%BC%9AGeometryEffect/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画-—-Part-2：GeometryEffect/</id>
    <published>2022-04-06T02:31:01.000Z</published>
    <updated>2022-04-06T02:38:03.010Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2022/c5eea293e62e03a91b514d2b1cea765f.png" alt=""></p><p>在本系列的第一部分，我介绍了<code>Animatable</code>协议，以及我们如何使用它来为路径制作动画。接下来，我们将使用一个新的工具: <code>GeometryEffect</code>，用同样的协议对变换矩阵进行动画处理。如果你没有读过第一部分，也不知道<code>Animatable</code>协议是什么，你应该先读一下。或者如果你只是对<code>GeometryEffect</code>感兴趣，不关心动画，你可以跳过第一部分，继续阅读本文。</p><a id="more"></a><h1 id="GeometryEffect"><a href="#GeometryEffect" class="headerlink" title="GeometryEffect"></a>GeometryEffect</h1><p><code>GeometryEffect</code>是一个符合<code>Animatable</code>和<code>ViewModifier</code>的协议。为了符合<code>GeometryEffect</code>协议，你需要实现以下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span></span><br></pre></td></tr></table></figure><p>假设你的方法叫<code>SkewEffect</code>，为了把它应用到一个视图上，你会这样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello"</span>).modifier(<span class="type">SkewEfect</span>(skewValue: <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><p><code>Text(&quot;Hello&quot;)</code>将被转换为由<code>SkewEfect.effectValue()</code>方法创建的矩阵。就这么简单。请注意，这些变化将影响视图，但不会影响其祖先或后代的布局。</p><p>因为<code>GeometryEffect</code>也符合<code>Animatable</code>，你可以添加一个<code>animatableData</code>属性，然后你就有了一个可动的效果。</p><p>你可能没有意识到，你可能一直在使用<code>GeometryEffect</code>。如果你曾经使用过<code>.offset()</code>，你实际上是在使用<code>GeometryEffect</code>。让我告诉你它是如何实现的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(x: CGFloat, y: CGFloat)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> modifier(_OffsetEffect(offset: <span class="type">CGSize</span>(width: x, height: y)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(<span class="number">_</span> offset: CGSize)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> modifier(_OffsetEffect(offset: offset))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_OffsetEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">CGSize</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGSize</span>.<span class="type">AnimatableData</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">CGSize</span>.<span class="type">AnimatableData</span>(offset.width, offset.height) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; offset = <span class="type">CGSize</span>(width: newValue.first, height: newValue.second) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: offset.width, y: offset.height))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Animation-Keyframes"><a href="#Animation-Keyframes" class="headerlink" title="Animation Keyframes"></a>Animation Keyframes</h1><p>大多数动画框架都有关键帧的概念。它是一种告诉动画引擎将动画分成若干块的方式。虽然 SwiftUI 没有这些功能，但我们可以模拟它。在下面的例子中，我们将创建一个水平移动视图的效果，但它也会在开始时倾斜，在结束时取消倾斜：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/8a7e081311517626f17a879214256f9c.gif" alt=""></p><p>倾斜效果需要在动画的第一个和最后一个20%期间增加和减少。在中间，倾斜效果将保持稳定。好了，现在我们有一个挑战，让我们看看如何解决这个问题。</p><p>我们将首先创建一个使我们的视图倾斜和移动的效果，而不必太注意20%的要求。如果你对变换矩阵了解不多，那也没关系。只需要知道：<code>CGAffineTransform</code> <code>c</code> 参数驱动倾斜，而 <code>tx</code> 则驱动 <code>x</code> 偏移。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/fb395e91688d2044f116e7d2993b814d.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkewedOffset</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">var</span> skew: <span class="type">CGFloat</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">AnimatablePair</span>(offset, skew) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            offset = newValue.first</span><br><span class="line">            skew = newValue.second</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(a: <span class="number">1</span>, b: <span class="number">0</span>, <span class="built_in">c</span>: skew, d: <span class="number">1</span>, tx: offset, ty: <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>好了，现在是有趣的部分。为了模拟关键帧，我们将定义一个可动画的参数，我们将其从 0 到 1 改变。当该参数为 0.2 时，我们达到了动画的前 20%。当该参数为 0.8 或更大时，我们就进入了动画的最后 20%。我们的代码应该利用这一点来改变相应的效果。最重要的是，我们还要告诉效果，我们是向右还是向左移动视图，所以它可以向一边倾斜，或者向另一边倾斜：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkewedOffset</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> goingRight: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(offset: <span class="type">CGFloat</span>, pct: <span class="type">CGFloat</span>, goingRight: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.offset = offset</span><br><span class="line">        <span class="keyword">self</span>.pct = pct</span><br><span class="line">        <span class="keyword">self</span>.goingRight = goingRight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;(offset, pct) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            offset = newValue.first</span><br><span class="line">            pct = newValue.second</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> skew: <span class="type">CGFloat</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pct &lt; <span class="number">0.2</span> &#123;</span><br><span class="line">            skew = (pct * <span class="number">5</span>) * <span class="number">0.5</span> * (goingRight ? -<span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> pct &gt; <span class="number">0.8</span> &#123;</span><br><span class="line">            skew = ((<span class="number">1</span> - pct) * <span class="number">5</span>) * <span class="number">0.5</span> * (goingRight ? -<span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            skew = <span class="number">0.5</span> * (goingRight ? -<span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(a: <span class="number">1</span>, b: <span class="number">0</span>, <span class="built_in">c</span>: skew, d: <span class="number">1</span>, tx: offset, ty: <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，只是为了好玩，我们将把这个效果应用于多个视图，但它们的动画将交错进行，使用<code>.delay()</code>动画修饰符。完整的代码可在本页面顶部链接的gist文件中 <strong>实例6</strong> 获得。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/cd77c096eb465b1fe95c16a56c9bdb9b.gif" alt=""></p><h1 id="动画反馈"><a href="#动画反馈" class="headerlink" title="动画反馈"></a>动画反馈</h1><p>在下一个例子中，我将向你展示一个简单的技术，它将使我们的视图对效果动画的进展做出反应。</p><p>我们将创建一个效果，让我们进行三维旋转。虽然SwiftUI已经有了一个修饰符，即<code>.rotrotation3DEffect()</code>，但这个修饰符将是特别的。每当我们的视图旋转到足以向我们展示另一面时，一个布尔绑定将被更新。</p><p>通过对绑定变量的变化做出反应，我们将能够替换正在旋转动画的过程中的视图。这将创造一种错觉，即视图有两个面。下面是一个例子：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/c88e7be22086f5a0341777430c31a874.gif" alt=""></p><h2 id="落实我们的效果"><a href="#落实我们的效果" class="headerlink" title="落实我们的效果"></a>落实我们的效果</h2><p>让我们开始创建我们的效果。你会注意到，三维旋转变换可能与你在核心动画中的习惯略有不同。在SwiftUI中，默认的锚点是在视图的前角，而在Core Animation中是在中心。虽然现有的<code>.rotrotingg3DEffect()</code>修饰符可以让你指定一个锚点，但我们正在建立我们自己的效果。这意味着我们必须自己处理它。由于我们不能改变锚点，我们需要在组合中加入一些转换效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlipEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; angle &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; angle = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> flipped: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> angle: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> axis: (x: <span class="type">CGFloat</span>, y: <span class="type">CGFloat</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我们把修改安排在视图绘制完成后进行。</span></span><br><span class="line">        <span class="comment">// 否则，我们会收到一个运行时错误，表明我们正在改变</span></span><br><span class="line">        <span class="comment">// 视图正在绘制时改变状态。</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.flipped = <span class="keyword">self</span>.angle &gt;= <span class="number">90</span> &amp;&amp; <span class="keyword">self</span>.angle &lt; <span class="number">270</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> a = <span class="type">CGFloat</span>(<span class="type">Angle</span>(degrees: angle).radians)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> transform3d = <span class="type">CATransform3DIdentity</span>;</span><br><span class="line">        transform3d.m34 = -<span class="number">1</span>/<span class="built_in">max</span>(size.width, size.height)</span><br><span class="line">        </span><br><span class="line">        transform3d = <span class="type">CATransform3DRotate</span>(transform3d, a, axis.x, axis.y, <span class="number">0</span>)</span><br><span class="line">        transform3d = <span class="type">CATransform3DTranslate</span>(transform3d, -size.width/<span class="number">2.0</span>, -size.height/<span class="number">2.0</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> affineTransform = <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: size.width/<span class="number">2.0</span>, y: size.height / <span class="number">2.0</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(transform3d).concatenating(affineTransform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看几何效果代码，有一个有趣的事实。我们用<code>@Bindingd</code>属性<code>flipped</code>来向视图报告，哪一面是面向用户的。</p><p>在我们的视图中，我们将使用<code>flipped</code>的值来有条件地显示两个视图中的一个。然而，在这个具体的例子中，我们将使用一个更多的技巧。如果你仔细观察视频，你会发现这张牌一直在变化。背面总是一样的，但正面却每次都在变化。因此，这不是简单的为一面展示一个视图，为另一面展示另一个视图。我们不是基于<code>flipped</code>的值，而是要监测<code>flipped</code>的值的变化。然后每一个完整的回合，我们将使用不同的牌。</p><p>我们有一个图像名称的数组，我们想逐一查看。为了做到这一点，我们将使用一个自定义绑定变量。这个技巧最好用代码来解释：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RotatingCard</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flipped = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> animate3d = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rotate = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> imgIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> images = [<span class="string">"diamonds-7"</span>, <span class="string">"clubs-8"</span>, <span class="string">"diamonds-6"</span>, <span class="string">"clubs-b"</span>, <span class="string">"hearts-2"</span>, <span class="string">"diamonds-b"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> binding = <span class="type">Binding</span>&lt;<span class="type">Bool</span>&gt;(<span class="keyword">get</span>: &#123; <span class="keyword">self</span>.flipped &#125;, <span class="keyword">set</span>: &#123; <span class="keyword">self</span>.updateBinding($<span class="number">0</span>) &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Image</span>(flipped ? <span class="string">"back"</span> : images[imgIndex]).resizable()</span><br><span class="line">                .frame(width: <span class="number">265</span>, height: <span class="number">400</span>)</span><br><span class="line">                .modifier(<span class="type">FlipEffect</span>(flipped: binding, angle: animate3d ? <span class="number">360</span> : <span class="number">0</span>, axis: (x: <span class="number">1</span>, y: <span class="number">5</span>)))</span><br><span class="line">                .rotationEffect(<span class="type">Angle</span>(degrees: rotate ? <span class="number">0</span> : <span class="number">360</span>))</span><br><span class="line">                .onAppear &#123;</span><br><span class="line">                    withAnimation(<span class="type">Animation</span>.linear(duration: <span class="number">4.0</span>).repeatForever(autoreverses: <span class="literal">false</span>)) &#123;</span><br><span class="line">                        <span class="keyword">self</span>.animate3d = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    withAnimation(<span class="type">Animation</span>.linear(duration: <span class="number">8.0</span>).repeatForever(autoreverses: <span class="literal">false</span>)) &#123;</span><br><span class="line">                        <span class="keyword">self</span>.rotate = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateBinding</span><span class="params">(<span class="number">_</span> value: Bool)</span></span> &#123;</span><br><span class="line">        <span class="comment">// If card was just flipped and at front, change the card</span></span><br><span class="line">        <span class="keyword">if</span> flipped != value &amp;&amp; !flipped &#123;</span><br><span class="line">            <span class="keyword">self</span>.imgIndex = <span class="keyword">self</span>.imgIndex+<span class="number">1</span> &lt; <span class="keyword">self</span>.images.<span class="built_in">count</span> ? <span class="keyword">self</span>.imgIndex+<span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        flipped = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在本页顶部链接的gist文件中的 <strong>实例7</strong> 中找到。</p><p>=============================================================</p><p>如前所述，我们可能想使用两个完全不同的视图，而不是改变图像名称。这也是可以的，这里有一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span>.clear.overlay(<span class="type">ViewSwapper</span>(showFront: flipped))</span><br><span class="line">    .frame(width: <span class="number">265</span>, height: <span class="number">400</span>)</span><br><span class="line">    .modifier(<span class="type">FlipEffect</span>(flipped: $flipped, angle: animate3d ? <span class="number">360</span> : <span class="number">0</span>, axis: (x: <span class="number">1</span>, y: <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewSwapper</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> showFront: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Group</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> showFront &#123;</span><br><span class="line">                <span class="type">FrontView</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">BackView</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="让视图遵循一个路径"><a href="#让视图遵循一个路径" class="headerlink" title="让视图遵循一个路径"></a>让视图遵循一个路径</h1><p>接下来，我们将建立一个完全不同的<code>GeometryEffect</code>。在这个例子中，我们的效果将通过一个任意的路径移动一个视图。这个问题有两个主要挑战:</p><p>1.如何获取路径中特定点的坐标。</p><p>2.如何在通过路径移动时确定视图的方向。在这个特定的案例中，我们如何知道飞机的机头指向哪里（扰流板警告，一点三角函数就可以了）。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/d463cca79f4a1dea31de5d7567b9855a.gif" alt=""></p><p>这个效果的可动画参数将是 pct。它代表飞机在路径中的位置。如果我们想让飞机执行一个完整的转弯，我们将使用0到1的值。对于一个0.25的值，它意味着飞机已经前进了1/4的路径。</p><h2 id="寻找路径中的x、y位置"><a href="#寻找路径中的x、y位置" class="headerlink" title="寻找路径中的x、y位置"></a>寻找路径中的x、y位置</h2><p>为了获得飞机在给定的pct值下的x和y位置，我们将使用<code>Path</code>结构体的 <a href="">.trimmedPath()</a> 修饰符。给定一个起点和终点百分比，该方法返回一个<code>CGRect</code>。它包含了该段路径的边界。根据我们的需求，我们只需用使用非常接近的起点和终点来调用它。它将返回一个非常小的矩形，我们将使用其中心作为我们的X和Y位置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">percentPoint</span><span class="params">(<span class="number">_</span> percent: CGFloat)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">    <span class="comment">// percent difference between points</span></span><br><span class="line">    <span class="keyword">let</span> diff: <span class="type">CGFloat</span> = <span class="number">0.001</span></span><br><span class="line">    <span class="keyword">let</span> comp: <span class="type">CGFloat</span> = <span class="number">1</span> - diff</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// handle limits</span></span><br><span class="line">    <span class="keyword">let</span> pct = percent &gt; <span class="number">1</span> ? <span class="number">0</span> : (percent &lt; <span class="number">0</span> ? <span class="number">1</span> : percent)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> f = pct &gt; comp ? comp : pct</span><br><span class="line">    <span class="keyword">let</span> t = pct &gt; comp ? <span class="number">1</span> : pct + diff</span><br><span class="line">    <span class="keyword">let</span> tp = path.trimmedPath(from: f, to: t)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGPoint</span>(x: tp.boundingRect.midX, y: tp.boundingRect.midY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找方向"><a href="#寻找方向" class="headerlink" title="寻找方向"></a>寻找方向</h2><p>为了获得我们平面的旋转角度，我们将使用一点三角函数。使用上面描述的技术，我们将得到两点的X和Y的位置：当前位置和刚才的位置。通过创建一条假想线，我们可以计算出它的角度，这就是飞机的方向了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateDirection</span><span class="params">(<span class="number">_</span> pt1: CGPoint,<span class="number">_</span> pt2: CGPoint)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = pt2.x - pt1.x</span><br><span class="line">    <span class="keyword">let</span> b = pt2.y - pt1.y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> angle = a &lt; <span class="number">0</span> ? atan(<span class="type">Double</span>(b / a)) : atan(<span class="type">Double</span>(b / a)) - <span class="type">Double</span>.pi</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGFloat</span>(angle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把所有的内容结合在一起"><a href="#把所有的内容结合在一起" class="headerlink" title="把所有的内容结合在一起"></a>把所有的内容结合在一起</h2><p>现在，我们知道了实现目标所需的工具，我们将实现这种效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FollowEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> path: <span class="type">Path</span></span><br><span class="line">    <span class="keyword">var</span> rotate = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !rotate &#123; <span class="comment">// Skip rotation login</span></span><br><span class="line">            <span class="keyword">let</span> pt = percentPoint(pct)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: pt.x, y: pt.y))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pt1 = percentPoint(pct)</span><br><span class="line">            <span class="keyword">let</span> pt2 = percentPoint(pct - <span class="number">0.01</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> angle = calculateDirection(pt1, pt2)</span><br><span class="line">            <span class="keyword">let</span> transform = <span class="type">CGAffineTransform</span>(translationX: pt1.x, y: pt1.y).rotated(by: angle)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(transform)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">percentPoint</span><span class="params">(<span class="number">_</span> percent: CGFloat)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">        <span class="comment">// percent difference between points</span></span><br><span class="line">        <span class="keyword">let</span> diff: <span class="type">CGFloat</span> = <span class="number">0.001</span></span><br><span class="line">        <span class="keyword">let</span> comp: <span class="type">CGFloat</span> = <span class="number">1</span> - diff</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// handle limits</span></span><br><span class="line">        <span class="keyword">let</span> pct = percent &gt; <span class="number">1</span> ? <span class="number">0</span> : (percent &lt; <span class="number">0</span> ? <span class="number">1</span> : percent)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> f = pct &gt; comp ? comp : pct</span><br><span class="line">        <span class="keyword">let</span> t = pct &gt; comp ? <span class="number">1</span> : pct + diff</span><br><span class="line">        <span class="keyword">let</span> tp = path.trimmedPath(from: f, to: t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGPoint</span>(x: tp.boundingRect.midX, y: tp.boundingRect.midY)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">calculateDirection</span><span class="params">(<span class="number">_</span> pt1: CGPoint,<span class="number">_</span> pt2: CGPoint)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = pt2.x - pt1.x</span><br><span class="line">        <span class="keyword">let</span> b = pt2.y - pt1.y</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> angle = a &lt; <span class="number">0</span> ? atan(<span class="type">Double</span>(b / a)) : atan(<span class="type">Double</span>(b / a)) - <span class="type">Double</span>.pi</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(angle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在本页面顶部链接的gist文件中以 <strong>Example8</strong> 的形式提供。</p><h2 id="Ignored-By-Layout"><a href="#Ignored-By-Layout" class="headerlink" title="Ignored By Layout"></a>Ignored By Layout</h2><p>我们对<code>GeometryEffect</code>的最后技巧是方 <a href="https://developer.apple.com/documentation/swiftui/geometryeffect/ignoredbylayout(" target="_blank" rel="noopener">.ignoredByLayout()</a>/) 。让我们看看文档中是怎么说的：</p><blockquote><p>Returns an effect that produces the same geometry transform as this effect, but only applies the transform while rendering its view.</p><p>返回一个产生与此效果相同的几何变换的效果，但只在渲染其视图时应用该变换。</p><p>Use this method to disable layout changes during transitions. The view ignores the transform returned by this method while the view is performing its layout calculations.</p><p>使用此方法可以在转换期间禁用布局更改。在视图执行布局计算时，视图将忽略此方法返回的变换。</p></blockquote><p>我很快就会介绍过渡的内容。同时，让我介绍一个例子，使用<code>.ignoredByLayout()</code>有一些明显的效果。我们将看到<code>GeometryReader</code>是如何报告不同的位置的，这取决于效果是如何被添加的（即，有或没有<code>.ignoredByLayout()</code>）。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/6227090f80410efbd2de83afea234609.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> animate = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">5</span>)</span><br><span class="line">                .foregroundColor(.green)</span><br><span class="line">                .frame(width: <span class="number">300</span>, height: <span class="number">50</span>)</span><br><span class="line">                .overlay(<span class="type">ShowSize</span>())</span><br><span class="line">                .modifier(<span class="type">MyEffect</span>(x: animate ? -<span class="number">10</span> : <span class="number">10</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">5</span>)</span><br><span class="line">                .foregroundColor(.blue)</span><br><span class="line">                .frame(width: <span class="number">300</span>, height: <span class="number">50</span>)</span><br><span class="line">                .overlay(<span class="type">ShowSize</span>())</span><br><span class="line">                .modifier(<span class="type">MyEffect</span>(x: animate ? <span class="number">10</span> : -<span class="number">10</span>).ignoredByLayout())</span><br><span class="line">            </span><br><span class="line">        &#125;.onAppear &#123;</span><br><span class="line">            withAnimation(<span class="type">Animation</span>.easeInOut(duration: <span class="number">1.0</span>).repeatForever()) &#123;</span><br><span class="line">                <span class="keyword">self</span>.animate = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; x &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; x = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: x, y: <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShowSize</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"x = <span class="subst">\(Int(proxy.frame(<span class="keyword">in</span>: .global)</span>.minX))"</span>)</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接下来有什么内容？"><a href="#接下来有什么内容？" class="headerlink" title="接下来有什么内容？"></a>接下来有什么内容？</h1><p>我们今天所做的三个例子，几乎没有什么共同点，只是它们都使用相同的协议来实现其目标。<code>GeometryEffect</code>很简单：它只有一个方法需要实现，然而，它的可能性是无穷的，我们只需要运用一点想象力。</p><p>接下来，我们将介绍本系列的最后一个协议: <code>AnimatableModifier</code>。如果<code>GeometryEffect</code>很强大，那就等着看你能用<code>AnimatableModifier</code>做的所有精彩事情吧。下面是整个系列的一个快速预览:</p><p><a href="https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4" target="_blank" rel="noopener">https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4</a></p><blockquote><p>译自 <a href="https://swiftui-lab.com/" target="_blank" rel="noopener">The SwiftUI Lab</a> 的 <a href="https://swiftui-lab.com/swiftui-animations-part2/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 2: GeometryEffect</a></p><p>本文的完整示例代码可在以下位置找到：</p><p><a href="https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798" target="_blank" rel="noopener">https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798</a></p><p>示例8 需要的图片资源。从这里下载：</p><p><a href="https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916" target="_blank" rel="noopener">https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/c5eea293e62e03a91b514d2b1cea765f.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在本系列的第一部分，我介绍了&lt;code&gt;Animatable&lt;/code&gt;协议，以及我们如何使用它来为路径制作动画。接下来，我们将使用一个新的工具: &lt;code&gt;GeometryEffect&lt;/code&gt;，用同样的协议对变换矩阵进行动画处理。如果你没有读过第一部分，也不知道&lt;code&gt;Animatable&lt;/code&gt;协议是什么，你应该先读一下。或者如果你只是对&lt;code&gt;GeometryEffect&lt;/code&gt;感兴趣，不关心动画，你可以跳过第一部分，继续阅读本文。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画 — Part 1：Paths</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB-%E2%80%94-Part-1%EF%BC%9APaths/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画-—-Part-1：Paths/</id>
    <published>2022-04-06T02:30:47.000Z</published>
    <updated>2022-04-06T02:38:36.974Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2022/28c53aa3fd2e980731e70075a1857a27.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在本文中，我们将深入探讨一些创建 SwiftUI 动画的高级技术。我将广泛讨论 <a href="https://developer.apple.com/documentation/swiftui/animatable" target="_blank" rel="noopener">Animatable</a> 协议，它可靠的伙伴 <a href="https://developer.apple.com/documentation/swiftui/animatable/3046497-animatabledata" target="_blank" rel="noopener">animatableData</a>，强大但经常被忽略的 <a href="https://developer.apple.com/documentation/swiftui/geometryeffect" target="_blank" rel="noopener">GeometryEffect</a> 以及完全被忽视但全能的 <a href="https://developer.apple.com/documentation/swiftui/animatablemodifier" target="_blank" rel="noopener">AnimatableModifier</a> 协议。</p><p>这些都是被官方文档完全忽略的主题，在SwiftUI 的帖子和文章中也几乎没有提及。不过，它们还是为我们提供了创建一些相当不错的动画的工具。</p><p>在我们进入这些隐藏的瑰宝之前，我想对一些基本的 SwiftUI 动画概念做一个非常快速的总结。只是为了让我们能有共同语言，请耐心听我说。</p><a id="more"></a><h1 id="显式动画-VS-隐式动画"><a href="#显式动画-VS-隐式动画" class="headerlink" title="显式动画 VS 隐式动画"></a>显式动画 VS 隐式动画</h1><p>在SwiftUI中，有两种类型的动画。显式和隐式。<strong>隐式动画</strong>是你用 <code>.animation()</code> 修饰符指定的那些动画。每当视图上的可动画参数发生变化时，SwiftUI 就会从旧值到新值制作动画。一些可动画的参数包括大小(size)、偏移(offset)、颜色(color)、比例(scale)等。</p><p>显式动画是使用 <code>withAnimation{ … }</code> 指定的动画闭包。只有那些依赖于 <code>withAnimation</code> 闭包中改变值的参数才会被动画化。让我们尝试举一些例子来说明：</p><p>以下示例使用隐式动画更改图像的大小和不透明度：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example1</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> half = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> dim = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">"tower"</span>)</span><br><span class="line">            .scaleEffect(half ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .opacity(dim ? <span class="number">0.2</span> : <span class="number">1.0</span>)</span><br><span class="line">            .animation(.easeInOut(duration: <span class="number">1.0</span>))</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                <span class="keyword">self</span>.dim.toggle()</span><br><span class="line">                <span class="keyword">self</span>.half.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/d06e59d9851af539adf53d2a90bdd2df.gif" alt=""></p><p>下面的示例使用显式动画。在这里，缩放和不透明度都会更改，但只有不透明度会设置动画，因为它是 <code>withAnimation</code> 闭包中唯一更改的参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> half = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> dim = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">"tower"</span>)</span><br><span class="line">            .scaleEffect(half ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .opacity(dim ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                <span class="keyword">self</span>.half.toggle()</span><br><span class="line">                </span><br><span class="line">                withAnimation(.easeInOut(duration: <span class="number">1.0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.dim.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.xiaozhuanlan.com/photo/2022/e5d5999cb7891fa51bd59609c7cb190f.gif" alt=""></p><p>请注意，通过更改修饰符的前后顺序，可以使用隐式动画创建相同的效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> half = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> dim = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">"tower"</span>)</span><br><span class="line">            .opacity(dim ? <span class="number">0.2</span> : <span class="number">1.0</span>)</span><br><span class="line">            .animation(.easeInOut(duration: <span class="number">1.0</span>))</span><br><span class="line">            .scaleEffect(half ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                <span class="keyword">self</span>.dim.toggle()</span><br><span class="line">                <span class="keyword">self</span>.half.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要禁用动画，可以使用 <code>.animation(nil)</code>。</p><h2 id="动画是如何工作的"><a href="#动画是如何工作的" class="headerlink" title="动画是如何工作的"></a>动画是如何工作的</h2><p>在所有SwiftUI动画的背后，有一个名为 <strong>Animatable</strong> 的协议。我们将在后面讨论细节，但主要是，它拥有一个计算属性，其类型遵守 <code>VectorArithmetic</code> 协议。这使得框架可以随意地插值。</p><p>当给一个视图制作动画时，SwiftUI 实际上是多次重新生成该视图，并且每次都修改动画参数。这样，它就会从原点值渐渐走向最终值。</p><p>假设我们为一个视图的不透明度创建一个线性动画。我们打算从 0.3 到 0.8。该框架将多次重新生成视图，以小幅度的增量来改变不透明度。由于不透明度是以 <code>Double</code>表示的，而且<code>Double</code> 遵守 VectorArithmetic` 协议，SwiftUI 可以插值出所需的不透明度值。在框架代码的某个地方，可能有一个类似的算法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> from:<span class="type">Double</span> = <span class="number">0.3</span></span><br><span class="line"><span class="keyword">let</span> to:<span class="type">Double</span> = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">6</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pct = <span class="type">Double</span>(i) / <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> difference = to - from</span><br><span class="line">    difference.scale(by: pct)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> currentOpacity = from + difference</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"currentOpacity = <span class="subst">\(currentOpacity)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码将创建从起点到终点的渐进式更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentOpacity = 0.3</span><br><span class="line">currentOpacity = 0.4</span><br><span class="line">currentOpacity = 0.5</span><br><span class="line">currentOpacity = 0.6</span><br><span class="line">currentOpacity = 0.7</span><br><span class="line">currentOpacity = 0.8</span><br></pre></td></tr></table></figure><h1 id="为什么我关心-Animatable？"><a href="#为什么我关心-Animatable？" class="headerlink" title="为什么我关心 Animatable？"></a>为什么我关心 <code>Animatable</code>？</h1><p>你可能会问，为什么我需要关心所有这些小细节。SwiftUI 已经为不透明度制作了动画，而不需要我担心这一切。是的，这是真的，但只要 SwiftUI 知道如何将数值从原点插值到终点。对于不透明度，这是一个直接的过程，SwiftUI 知道该怎么做。然而，正如我们接下来要看到的，情况并非总是如此。</p><p>我想到了一些大的例外情况：路径(paths)、变换矩阵(matrices)和任意的视图变化（例如，文本视图中的文本、渐变视图中的渐变颜色或停顿，等等）。在这种情况下，框架不知道该怎么做。我们将在本文的第二和第三部分中讨论转换矩阵和视图变化。目前，让我们把重点放在形状(shapes)上。</p><h2 id="形状路径的动画化"><a href="#形状路径的动画化" class="headerlink" title="形状路径的动画化"></a>形状路径的动画化</h2><p>想象一下，你有一个形状，使用路径来绘制一个规则的多边形。我们的实现当然会让你指出这个多边形将有多少条边。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PolygonShape</span>(sides: <span class="number">3</span>).stroke(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line"><span class="type">PolygonShape</span>(sides: <span class="number">4</span>).stroke(<span class="type">Color</span>.purple, lineWidth: <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><img src="https://images.xiaozhuanlan.com/photo/2022/af3cc99556499081e410cfed1a59cf16.png" alt=""></p><p>下面是我们的<code>PolygonShape</code>的实现。请注意，我使用了一点三角学的知识。这对理解这篇文章的主题并不重要，但如果你想了解更多关于它的信息，我写了另一篇文章，阐述了基础知识。你可以在 “<a href="https://swiftui-lab.com/trigonometric-recipes-for-swiftui/" target="_blank" rel="noopener">SwiftUI 的三角公式</a> “中阅读更多内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="type">Path</span> &#123;        </span><br><span class="line">        <span class="comment">// hypotenuse</span></span><br><span class="line">        <span class="keyword">let</span> h = <span class="type">Double</span>(<span class="built_in">min</span>(rect.size.width, rect.size.height)) / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// center</span></span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">CGPoint</span>(x: rect.size.width / <span class="number">2.0</span>, y: rect.size.height / <span class="number">2.0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> path = <span class="type">Path</span>()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;sides &#123;</span><br><span class="line">            <span class="keyword">let</span> angle = (<span class="type">Double</span>(i) * (<span class="number">360.0</span> / <span class="type">Double</span>(sides))) * <span class="type">Double</span>.pi / <span class="number">180</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate vertex position</span></span><br><span class="line">            <span class="keyword">let</span> pt = <span class="type">CGPoint</span>(x: <span class="built_in">c</span>.x + <span class="type">CGFloat</span>(cos(angle) * h), y: <span class="built_in">c</span>.y + <span class="type">CGFloat</span>(sin(angle) * h))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                path.move(to: pt) <span class="comment">// move to first vertex</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path.addLine(to: pt) <span class="comment">// draw line to next vertex</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path.closeSubpath()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以更进一步，尝试使用与不透明度相同的方法对形状边数(<code>sides</code>)参数进行动画处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PolygonShape</span>(sides: isSquare ? <span class="number">4</span> : <span class="number">3</span>)</span><br><span class="line">    .stroke(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">    .animation(.easeInOut(duration: duration))</span><br></pre></td></tr></table></figure><p>你认为 SwiftUI 将如何把三角形转化为正方形？你可能猜到了。它不会的。当然，框架不知道如何给它做动画。你可以随心所欲地使用<code>.animation()</code>，但这个形状会从三角形跳到正方形，而且没有任何动画。原因很简单：你只教了 SwiftUI 如何画一个 3 边的多边形，或 4 边的多边形，但你的代码却不知道如何画一个 3.379 边的多边形!</p><p>因此，为了使动画发生，我们需要两件事:</p><ol><li><p>我们需要改变形状的代码，使其知道如何绘制边数为非整数的多边形。</p></li><li><p>让框架多次生成这个形状，并让可动画参数一点点变化。也就是说，我们希望这个形状被要求绘制多次，每次都有一个不同的边数数值：3、3.1、3.15、3.2、3.25，一直到 4。</p></li></ol><p>一旦我们把这两点做到位，我们将能够在任何数量的边数之间制作动画:</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/c12634ccd556d04558154aa3e50ba902.gif" alt=""></p><p><strong>创建可动画数据(<code>animatableData</code>)</strong></p><p>为了使形状可动画化，我们需要 SwiftUI 多次渲染视图，使用从原点到目标数之间的所有边值。幸运的是，<code>Shape</code>已经符合了<code>Animatable</code>协议的要求。这意味着，有一个计算的属性（<code>animatableData</code>），我们可以用它来处理这个任务。然而，它的默认实现被设置为<code>EmptyAnimatableData</code>。所以它什么都不做。</p><p>为了解决我们的问题，我们将首先改变边的属性的类型，从<code>Int</code>到<code>Double</code>。这样我们就可以有小数的数字。我们将在后面讨论如何保持该属性为<code>Int</code>，并仍然执行动画。但是现在，为了使事情简单，我们只使用<code>Double</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Double</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们需要创建我们的计算属性<code>animatableData</code>。在这种情况下，它非常简单。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> sides &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; sides = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用小数画边</strong></p><p>最后，我们需要教 SwiftUI 如何绘制一个边数为非整数的多边形。我们将稍微改变我们的代码。随着小数部分的增长，这个新的边将从零到全长。其他顶点将相应地平稳地重新定位。这听起来很复杂，但这是一个最小的变化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="type">Path</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hypotenuse</span></span><br><span class="line">        <span class="keyword">let</span> h = <span class="type">Double</span>(<span class="built_in">min</span>(rect.size.width, rect.size.height)) / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// center</span></span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">CGPoint</span>(x: rect.size.width / <span class="number">2.0</span>, y: rect.size.height / <span class="number">2.0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> path = <span class="type">Path</span>()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">let</span> extra: <span class="type">Int</span> = <span class="type">Double</span>(sides) != <span class="type">Double</span>(<span class="type">Int</span>(sides)) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="type">Int</span>(sides) + extra &#123;</span><br><span class="line">            <span class="keyword">let</span> angle = (<span class="type">Double</span>(i) * (<span class="number">360.0</span> / <span class="type">Double</span>(sides))) * <span class="type">Double</span>.pi / <span class="number">180</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate vertex</span></span><br><span class="line">            <span class="keyword">let</span> pt = <span class="type">CGPoint</span>(x: <span class="built_in">c</span>.x + <span class="type">CGFloat</span>(cos(angle) * h), y: <span class="built_in">c</span>.y + <span class="type">CGFloat</span>(sin(angle) * h))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                path.move(to: pt) <span class="comment">// move to first vertex</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path.addLine(to: pt) <span class="comment">// draw line to next vertex</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path.closeSubpath()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在文章顶部链接的 gist 文件中以 <strong>Example1</strong> 的形式提供。</p><p>如前所述，对于我们这个形状的用户来说，边的参数是一个<code>Double</code>，这可能显得很奇怪。人们应该期望边是一个<code>Int</code>参数。幸运的是，我们可以再次改变我们的代码，把这个事实隐藏在我们的形状的实现中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> sidesAsDouble: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> sidesAsDouble &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; sidesAsDouble = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(sides: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides = sides</span><br><span class="line">        <span class="keyword">self</span>.sidesAsDouble = <span class="type">Double</span>(sides)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些变化，我们在内部使用<code>Double</code>，但在外部则使用<code>Int</code>。现在它看起来更优雅了。不要忘记修改绘图代码，这样它就会使用<code>sidesAsDouble</code> 而不是<code>sides</code>。完整的代码可以在文章顶部链接的 gist 文件中的 <strong>Example2</strong> 中找到。</p><h2 id="设置多个参数的动画"><a href="#设置多个参数的动画" class="headerlink" title="设置多个参数的动画"></a>设置多个参数的动画</h2><p>很多时候，我们会发现自己需要对一个以上的参数进行动画处理。单一的<code>Double</code>是不够的。在这些时候，我们可以使用<code>AnimatablePair&lt;First, Second&gt;</code>。这里，第一和第二都是符合<code>VectorArithmetic</code>的类型。例如<code>AnimatablePair&lt;CGFloat, Double&gt;</code>。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/a9d74ce65e124f4181701f5f5616253e.gif" alt=""></p><p>为了演示 <code>AnimatablePair</code> 的使用，我们将修改我们的例子。现在我们的多边形形状将有两个参数：边和比例。两者都将用<code>Double</code>来表示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> scale: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">AnimatablePair</span>&lt;<span class="type">Double</span>, <span class="type">Double</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">AnimatablePair</span>(sides, scale) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sides = newValue.first</span><br><span class="line">            scale = newValue.second</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在文章顶部链接的 gist 文件中的 <strong>Example3</strong> 中找到。同一个文件中的<strong>Example4</strong>，有一个更复杂的路径。它基本上是相同的形状，但增加了一条连接每个顶点的线。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/cc060bf316c70d480d9c64dcf75f562d.gif" alt=""></p><h2 id="超过两个可动画的参数"><a href="#超过两个可动画的参数" class="headerlink" title="超过两个可动画的参数"></a>超过两个可动画的参数</h2><p>如果你浏览一下 SwiftUI 的声明文件，你会发现该框架相当广泛地使用<code>AnimatablePair</code>。比如说。<code>CGSize</code>、<code>CGPoint</code>、<code>CGRect</code>。尽管这些类型不符合<code>VectorArithmetic</code>，但它们可以被动画化，因为它们确实符合<code>Animatable</code>。</p><p>他们都以这样或那样的方式使用<code>AnimatablePair</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span> : <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnimatableData</span> = <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> animatableData: <span class="type">CGPoint</span>.<span class="type">AnimatableData</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span> : <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnimatableData</span> = <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> animatableData: <span class="type">CGSize</span>.<span class="type">AnimatableData</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGRect</span> : <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnimatableData</span> = <span class="type">AnimatablePair</span>&lt;<span class="type">CGPoint</span>.<span class="type">AnimatableData</span>, <span class="type">CGSize</span>.<span class="type">AnimatableData</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> animatableData: <span class="type">CGRect</span>.<span class="type">AnimatableData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你仔细注意一下 <code>CGRect</code>，你会发现它实际上是在使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnimatablePair</span>&lt;<span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;, <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;&gt;</span><br></pre></td></tr></table></figure><p>这意味着矩形的 x、y、宽度和高度值可以通过 <code>first.first</code>、<code>first.second</code>、<code>second.first</code>和<code>second.second</code>访问。</p><h2 id="使你自己的类型动画化（通过VectorArithmetic）"><a href="#使你自己的类型动画化（通过VectorArithmetic）" class="headerlink" title="使你自己的类型动画化（通过VectorArithmetic）"></a>使你自己的类型动画化（通过<code>VectorArithmetic</code>）</h2><p>以下类型默认实现了 <code>Animatable</code> : <code>Angle</code>, <code>CGPoint</code>, <code>CGRect</code>, <code>CGSize</code>, <code>EdgeInsets</code>, <code>StrokeStyle</code> 和 <code>UnitPoint</code>。以下类型符合<code>VectorArithmetic</code>。<code>AnimatablePair</code>, <code>CGFloat</code>, <code>Double</code>, <code>EmptyAnimatableData</code> 和 <code>Float</code>。你可以使用它们中的任何一种来为你的形状制作动画。</p><p>现有的类型提供了足够的灵活性来实现任何东西的动画。然而，如果你发现自己有一个想做动画的复杂类型，没有什么能阻止你添加自己的<code>VectorArithmetic</code>协议的实现。事实上，我们将在下一个例子中这样做。</p><p>为了说明这一点，我们将创建一个模拟时钟形状。它将根据一个自定义的可动画的参数类型移动它的指针：<code>ClockTime</code>。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/631640b6fd2099e4ccd9bcce295dade7.gif" alt=""></p><p>我们将像这样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClockShape</span>(clockTime: show ? <span class="type">ClockTime</span>(<span class="number">9</span>, <span class="number">51</span>, <span class="number">15</span>) : <span class="type">ClockTime</span>(<span class="number">9</span>, <span class="number">55</span>, <span class="number">00</span>))</span><br><span class="line">    .stroke(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">    .animation(.easeInOut(duration: duration))</span><br></pre></td></tr></table></figure><p>首先，我们开始创建我们的自定义类型<code>ClockTime</code>。它包含三个属性（小时、分钟和秒），几个有用的初始化器，以及一些辅助计算的属性和方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClockTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hours: <span class="type">Int</span>      <span class="comment">// Hour needle should jump by integer numbers</span></span><br><span class="line">    <span class="keyword">var</span> minutes: <span class="type">Int</span>    <span class="comment">// Minute needle should jump by integer numbers</span></span><br><span class="line">    <span class="keyword">var</span> seconds: <span class="type">Double</span> <span class="comment">// Second needle should move smoothly</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initializer with hour, minute and seconds</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> h: <span class="type">Int</span>, <span class="number">_</span> m: <span class="type">Int</span>, <span class="number">_</span> s: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.hours = h</span><br><span class="line">        <span class="keyword">self</span>.minutes = m</span><br><span class="line">        <span class="keyword">self</span>.seconds = s</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initializer with total of seconds</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> seconds: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> h = <span class="type">Int</span>(seconds) / <span class="number">3600</span></span><br><span class="line">        <span class="keyword">let</span> m = (<span class="type">Int</span>(seconds) - (h * <span class="number">3600</span>)) / <span class="number">60</span></span><br><span class="line">        <span class="keyword">let</span> s = seconds - <span class="type">Double</span>((h * <span class="number">3600</span>) + (m * <span class="number">60</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.hours = h</span><br><span class="line">        <span class="keyword">self</span>.minutes = m</span><br><span class="line">        <span class="keyword">self</span>.seconds = s</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compute number of seconds</span></span><br><span class="line">    <span class="keyword">var</span> asSeconds: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Double</span>(<span class="keyword">self</span>.hours * <span class="number">3600</span> + <span class="keyword">self</span>.minutes * <span class="number">60</span>) + <span class="keyword">self</span>.seconds</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// show as string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: <span class="string">"%2i"</span>, <span class="keyword">self</span>.hours) + <span class="string">":"</span> + <span class="type">String</span>(format: <span class="string">"%02i"</span>, <span class="keyword">self</span>.minutes) + <span class="string">":"</span> + <span class="type">String</span>(format: <span class="string">"%02f"</span>, <span class="keyword">self</span>.seconds)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，为了符合<code>VectorArithmetic</code>协议，我们需要编写以下方法和计算属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ClockTime</span>: <span class="title">VectorArithmetic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> zero: <span class="type">ClockTime</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClockTime</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> magnitudeSquared: <span class="type">Double</span> &#123; <span class="keyword">return</span> asSeconds * asSeconds &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -= <span class="params">(lhs: <span class="keyword">inout</span> ClockTime, rhs: ClockTime)</span></span> &#123;</span><br><span class="line">        lhs = lhs - rhs</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> - <span class="params">(lhs: ClockTime, rhs: ClockTime)</span></span> -&gt; <span class="type">ClockTime</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClockTime</span>(lhs.asSeconds - rhs.asSeconds)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> += <span class="params">(lhs: <span class="keyword">inout</span> ClockTime, rhs: ClockTime)</span></span> &#123;</span><br><span class="line">        lhs = lhs + rhs</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> + <span class="params">(lhs: ClockTime, rhs: ClockTime)</span></span> -&gt; <span class="type">ClockTime</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClockTime</span>(lhs.asSeconds + rhs.asSeconds)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">scale</span><span class="params">(by rhs: Double)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="type">Double</span>(<span class="keyword">self</span>.asSeconds)</span><br><span class="line">        s.scale(by: rhs)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> ct = <span class="type">ClockTime</span>(s)</span><br><span class="line">        <span class="keyword">self</span>.hours = ct.hours</span><br><span class="line">        <span class="keyword">self</span>.minutes = ct.minutes</span><br><span class="line">        <span class="keyword">self</span>.seconds = ct.seconds</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一要做的，就是写出形状来适当地定位针头。时钟形状的完整代码，可在本文顶部链接的gist文件中的  <strong>Example5</strong> 中找到。</p><h1 id="SwiftUI-Metal"><a href="#SwiftUI-Metal" class="headerlink" title="SwiftUI + Metal"></a>SwiftUI + Metal</h1><p>如果你发现自己正在编写复杂的动画，你可能会开始看到你的设备受到影响，同时试图跟上所有的绘图。如果是这样，你肯定会从启用金属的使用中受益。这里有一个例子，说明启用 Metal 后，一切都会变得不同。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/1f7298958b84e19cf6b5ca133e2c8fd5.gif" alt=""></p><p>在模拟器上运行时，你可能感觉不到有什么不同。然而，在真正的设备上，你会发现。视频演示来自iPad第六代（2016）。完整的代码在 gist 文件中，名称为 <strong>Example6</strong>。</p><p>幸运的是，启用 Metal，是非常容易的。你只需要添加 <code>.drawingGroup()</code> 修饰符:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FlowerView</span>().drawingGroup()</span><br></pre></td></tr></table></figure><p>根据 WWDC 2019, Session 237（<a href="https://developer.apple.com/videos/play/wwdc2019/237/" target="_blank" rel="noopener">用SwiftUI构建自定义视图</a>）：绘图组是一种特殊的渲染方式，但只适用于图形等东西。它基本上会将 SwiftUI 视图平铺到一个单一的 NSView/UIView 中，并用 Metal 进行渲染。跳到 WWDC 视频到37:27 了解更多细节。</p><p>如果你想尝试一下，但你的形状还没有复杂到让设备挣扎的地步，添加一些渐变和阴影，你会立即看到不同。</p><h1 id="接下来有什么内容？"><a href="#接下来有什么内容？" class="headerlink" title="接下来有什么内容？"></a>接下来有什么内容？</h1><p>在本文的第二部分，我们将学习如何使用 <code>GeometryEffect</code> 协议。它将打开改变我们的视图和动画的新方法的大门。与 <code>Paths</code> 一样，SwiftUI 没有关于如何在两个不同的变换矩阵之间转换的内置知识。<code>GeometryEffect</code>将有助于我们这样做。</p><p>目前，SwiftUI 没有关键帧功能。我们将看到我们如何用一个基本的动画来模拟一个。</p><p>在文章的第三部分，我们将介绍AnimatableModifier，这是一个非常强大的工具，它可以让我们对视图中任何可以变化的东西进行动画处理，甚至是文本！在这个系列的第三部分中，我们将介绍一些动画实例。关于这三部分系列中的一些动画例子，请看下面的视频: </p><p><a href="https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4" target="_blank" rel="noopener">https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4</a></p><blockquote><p>译自 The SwiftUI Lab 的 <a href="https://swiftui-lab.com/swiftui-animations-part1/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 1: Paths</a></p><p>本文的完整示例代码可在以下网址找到：<br><a href="https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798" target="_blank" rel="noopener">https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798</a></p><p>示例8 需要的图片资源，可在这里下载：<br><a href="https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916" target="_blank" rel="noopener">https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/28c53aa3fd2e980731e70075a1857a27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在本文中，我们将深入探讨一些创建 SwiftUI 动画的高级技术。我将广泛讨论 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/animatable&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Animatable&lt;/a&gt; 协议，它可靠的伙伴 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/animatable/3046497-animatabledata&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;animatableData&lt;/a&gt;，强大但经常被忽略的 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/geometryeffect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GeometryEffect&lt;/a&gt; 以及完全被忽视但全能的 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/animatablemodifier&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AnimatableModifier&lt;/a&gt; 协议。&lt;/p&gt;
&lt;p&gt;这些都是被官方文档完全忽略的主题，在SwiftUI 的帖子和文章中也几乎没有提及。不过，它们还是为我们提供了创建一些相当不错的动画的工具。&lt;/p&gt;
&lt;p&gt;在我们进入这些隐藏的瑰宝之前，我想对一些基本的 SwiftUI 动画概念做一个非常快速的总结。只是为了让我们能有共同语言，请耐心听我说。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 29 两数相除</title>
    <link href="https://fanbaoying.github.io/LeetCode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <id>https://fanbaoying.github.io/LeetCode-29-两数相除/</id>
    <published>2022-04-01T08:59:35.000Z</published>
    <updated>2022-04-01T09:02:30.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 29 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p><p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code>。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7/-3 = truncate(-2.33333..) = -2</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>被除数和除数均为 <code>32</code> 位有符号整数。</li><li>除数不为 <code>0</code>。</li><li>假设我们的环境只能存储 <code>32</code> 位有符号整数，其数值范围是 <code>[−231,  231 − 1]</code>。本题中，如果除法结果溢出，则返回 2^31 − 1。</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DivideTwoIntegers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> dividend: Int, <span class="number">_</span> divisor: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> isPositive = (dividend &lt; <span class="number">0</span>) == (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> dividend = <span class="built_in">abs</span>(dividend), divisor = <span class="built_in">abs</span>(divisor), <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor &#123;</span><br><span class="line">            <span class="keyword">var</span> shift = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> dividend &gt;= (divisor &lt;&lt; shift) &#123;</span><br><span class="line">                shift += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dividend -= divisor &lt;&lt; (shift - <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">count</span> += (<span class="number">1</span> &lt;&lt; (shift - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> refactorCount(<span class="built_in">count</span>, isPositive)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refactorCount</span><span class="params">(<span class="number">_</span> <span class="built_in">count</span>: Int, <span class="number">_</span> isPositive: Bool)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="type">INTMAX</span> = <span class="number">2147483647</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">count</span> = <span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isPositive &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="type">INTMAX</span> &#123;</span><br><span class="line">                <span class="built_in">count</span> = <span class="type">INTMAX</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">count</span> *= -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用左移和减法得到每个数字的个数。</li><li>时间复杂度： O(logn)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/divide-two-integers/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 29 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 28 实现 strStr()</title>
    <link href="https://fanbaoying.github.io/LeetCode-28-%E5%AE%9E%E7%8E%B0-strStr/"/>
    <id>https://fanbaoying.github.io/LeetCode-28-实现-strStr/</id>
    <published>2022-04-01T08:59:27.000Z</published>
    <updated>2022-04-01T09:02:05.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 27 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>实现 <code>strStr()</code> 函数。</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code>，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  <code>-1</code> 。</p><p><strong>说明：</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <code>strstr()</code> 以及 Java 的 <code>indexOf()</code> 定义相符。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;&quot;, needle = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= haystack.length, needle.length &lt;= 5 * 10^4</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrStr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(<span class="number">_</span> haystack: String, <span class="number">_</span> needle: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> hChars = <span class="type">Array</span>(haystack.characters), nChars = <span class="type">Array</span>(needle.characters)</span><br><span class="line">        <span class="keyword">let</span> hLen = hChars.<span class="built_in">count</span>, nLen = nChars.<span class="built_in">count</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">guard</span> hLen &gt;= nLen <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> nLen != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...hLen - nLen &#123;</span><br><span class="line">            <span class="keyword">if</span> hChars[i] == nChars[<span class="number">0</span>] &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;nLen &#123;</span><br><span class="line">                    <span class="keyword">if</span> hChars[i + j] != nChars[j] &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> j + <span class="number">1</span> == nLen &#123;</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：保留一个索引，向前移动时将该索引处的元素与 val 进行比较</li><li>时间复杂度： O(nm)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/implement-strstr/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 27 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 27 移除元素</title>
    <link href="https://fanbaoying.github.io/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>https://fanbaoying.github.io/LeetCode-27-移除元素/</id>
    <published>2022-04-01T08:59:04.000Z</published>
    <updated>2022-04-01T09:02:09.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 26 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <code>原地</code> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <code>原地</code> <strong>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">inout</span> nums: [Int], <span class="number">_</span> val: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        nums = nums.<span class="built_in">filter</span> &#123; (num) <span class="keyword">in</span> num != val &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：保留一个索引，向前移动时将该索引处的元素与 val 进行比较</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/remove-element/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 26 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 26 删除有序数组中的重复项</title>
    <link href="https://fanbaoying.github.io/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://fanbaoying.github.io/LeetCode-26-删除有序数组中的重复项/</id>
    <published>2022-04-01T08:58:52.000Z</published>
    <updated>2022-04-01T09:01:39.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 25 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你 <code>原地</code> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组 nums 的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。</p><p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p><p>不要使用额外的空间，你必须在 <code>原地</code> <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 已按 <strong>升序</strong> 排列</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">inout</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">where</span> num != nums[index] &#123;</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            nums[index] = num</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：保留一个索引，将该索引处的元素与前面的元素进行比较。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 25 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 25 K 个一组翻转链表</title>
    <link href="https://fanbaoying.github.io/LeetCode-25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://fanbaoying.github.io/LeetCode-25-K-个一组翻转链表/</id>
    <published>2022-04-01T08:58:40.000Z</published>
    <updated>2022-04-01T09:02:50.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 24 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个链表，每 <code>k</code> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>进阶：</strong></p><ul><li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/e7ffe2c592e735c37fd28ed34ffd2e68.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="https://files.mdnice.com/user/17787/1b3ebe4c-bfcf-4bbc-8254-7431d966463b.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 1</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>列表中节点的数量在范围 <code>sz</code> 内</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseNodesInKGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(<span class="number">_</span> head: ListNode?, <span class="number">_</span> k: Int)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> prev = dummy                             <span class="comment">// prev = A</span></span><br><span class="line">        <span class="keyword">while</span> prev.next != <span class="literal">nil</span> &#123;                     <span class="comment">// A-&gt;B-&gt;C-&gt;D-&gt;E =&gt; A-&gt;D-&gt;C-&gt;B-&gt;E</span></span><br><span class="line">            <span class="keyword">var</span> groupTail : <span class="type">ListNode</span>? = prev</span><br><span class="line">            <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...k &#123;</span><br><span class="line">                groupTail = groupTail?.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="number">_</span> = groupTail <span class="keyword">else</span> &#123;            <span class="comment">// groupTail = D</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> nextGroupHead = groupTail!.next      <span class="comment">// nextGroupHead = E</span></span><br><span class="line">            <span class="keyword">var</span> last = nextGroupHead                 <span class="comment">// last = E</span></span><br><span class="line">            <span class="keyword">var</span> current : <span class="type">ListNode</span>? = prev.next      <span class="comment">// current = B</span></span><br><span class="line">            <span class="keyword">while</span> current != <span class="literal">nil</span> &amp;&amp; current !== nextGroupHead &#123;</span><br><span class="line">                <span class="keyword">let</span> next = current!.next             <span class="comment">// next = C</span></span><br><span class="line">                current!.next = last                 <span class="comment">// B -&gt; E</span></span><br><span class="line">                last = current                       <span class="comment">// last = B</span></span><br><span class="line">                current = next                       <span class="comment">// current = C</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            groupTail = prev.next</span><br><span class="line">            prev.next = last</span><br><span class="line">            prev = groupTail!</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：在一个循环中反转一组。 从后往前构造一个反向组。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 24 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 24 两两交换链表中的节点</title>
    <link href="https://fanbaoying.github.io/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://fanbaoying.github.io/LeetCode-24-两两交换链表中的节点/</id>
    <published>2022-04-01T08:58:14.000Z</published>
    <updated>2022-04-01T09:03:12.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 23 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，<strong>只能进行节点交换</strong>）。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-8a9584ea0c71c357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwapNodesInPairs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head: ListNode?)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> prev: <span class="type">ListNode</span>? = dummy</span><br><span class="line">        <span class="keyword">var</span> current = dummy.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">nil</span> &amp;&amp; current!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> next = current!.next</span><br><span class="line">            <span class="keyword">let</span> post = current!.next!.next</span><br><span class="line">            </span><br><span class="line">            prev!.next = next</span><br><span class="line">            next!.next = current</span><br><span class="line">            current!.next = post</span><br><span class="line">           </span><br><span class="line">            prev = current</span><br><span class="line">            current = post</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：三个指针，每次改变指针的方向。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/swap-nodes-in-pairs/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 23 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的抽象类型和方法</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://fanbaoying.github.io/Swift-中的抽象类型和方法/</id>
    <published>2022-03-31T02:03:26.000Z</published>
    <updated>2022-03-31T02:07:26.125Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象的编程中，抽象类型提供了一个基础实现，其他类型可以从中继承，以获得某种共享的、共同的功能。抽象类型与普通类型的区别在于，它们永远不会被当作原样使用（事实上，一些编程语言甚至阻止抽象类型被直接实例化），因为它们的唯一目的是作为一组相关类型的共同父类。</p><p>例如，假设我们想统一我们通过网络加载某些类型的模型的方式，通过提供一个共享的API，我们将能够用来分离关注点，使<a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift" target="_blank" rel="noopener">依赖注入</a>和<a href="https://www.swiftbysundell.com/articles/mocking-in-swift" target="_blank" rel="noopener">模拟</a>变得容易，并在我们的项目中保持方法名称的一致性。</p><a id="more"></a><p>一个基于抽象类型的方法是使用一个基类，它将作为我们所有模型加载类型的共享、统一的接口。因为我们不希望这个类被直接使用，所以我们要让它在基类的实现被错误调用时触发一个<code>fatalError</code>:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loadable</span>&lt;<span class="title">Model</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"load(from:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，每个<code>Loadable</code>子类将重载上述<code>load</code>方法，以提供其加载功，如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果上述模式看起来很熟悉，那可能是因为它本质上与我们在<a href="https://www.swiftbysundell.com/basics/protocols" target="_blank" rel="noopener">Swift中通常使用的协议</a>的多态性完全相同。也就是说，当我们想定义一个接口，一个契约，多个类型可以通过不同的实现来遵守。</p><p>不过，协议确实比抽象类有一个显着的优势，因为编译器将强制它们的所有需求都得到正确实现——这意味着我们不再需要依赖运行时错误（例如 <code>fatalError</code>）来防止不当使用，因为我们无法实例化协议。</p><p>因此，如果我们采用面向协议的方案，而不是使用抽象基类，那么我们之前的 <code>Loadable</code> 和 <code>UserLoader</code> 类型可能看起来像这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Loadable</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Model</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意我们现在是如何使用一个相关的类型来使每个<code>Loadable</code>实现决定它想要加载的确切<code>Model</code>的——这给了我们一个在完全类型安全和巨大灵活性之间的很好的综合。</p><p>所以，一般来说，协议肯定是在Swift中声明抽象类型的首选方式，但这并不意味着它们是完美的。事实上，我们基于协议的<code>Loadable</code>实现目前有两个主要缺点:</p><ul><li><p>首先，由于我们不得不为我们的协议添加一个相关的类型，以保持我们的设计是泛型的和类型安全的，这意味着<code>Loadable</code>不能再<a href="https://www.swiftbysundell.com/questions/referencing-generic-protocols" target="_blank" rel="noopener">被直接引用了</a>。</p></li><li><p>其次，由于协议不能包含任何形式的存储。如果我们想添加任何存储属性，让所有的<code>Loadable</code>实现都能使用，我们就必须在每一个具体的实现中重新声明这些属性。</p></li></ul><p>这个属性存储方面确实是我们以前基于抽象类设计的一个巨大优势。因此，如果我们将<code>Loadable</code>还原成一个类，那么我们就能够将我们的子类所需要的所有对象直接存储在我们的基类中——不再需要在多种类型中重复声明这些属性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loadable</span>&lt;<span class="title">Model</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> networking: <span class="type">Networking</span></span><br><span class="line"><span class="keyword">let</span> cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(networking: <span class="type">Networking</span>, cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.networking = networking</span><br><span class="line">        <span class="keyword">self</span>.cache = cache</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"load(from:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedUser = cache.value(forKey: url) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedUser</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> await networking.data(from: url)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>所以，我们在这里处理的基本上是一个典型的权衡方案，两种方法（抽象类与协议）都给我们带来了不同的优点和缺点。但是，如果我们能把这两种方法结合起来，得到两个方案的优点，会怎么样呢？</strong></p><p>如果我们仔细想想，基于抽象类的方法唯一真正的问题是，我们必须在每个子类需要实现的方法中加入<code>fatalError</code>，那么如果我们只为这个特定的方法使用一个协议呢？那么我们仍然可以在基类中保留我们的<code>networking</code>和<code>cache</code>属性——像这样:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Model</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoadableBase</span>&lt;<span class="title">Model</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> networking: <span class="type">Networking</span></span><br><span class="line"><span class="keyword">let</span> cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(networking: <span class="type">Networking</span>, cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.networking = networking</span><br><span class="line">        <span class="keyword">self</span>.cache = cache</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但这种方法的主要缺点是，所有的具体实现现在都必须对<code>LoadableBase</code>进行子类化，并声明它们符合我们新的<code>LoadableProtocol</code>协议：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">LoadableBase</span>&lt;<span class="title">User</span>&gt;, <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这可能不是一个巨大的问题，但可以说它确实使我们的代码不那么优雅。不过，好消息是，我们实际上可以通过使用通用类型别名来解决这个问题。由于Swift的组合运算符<code>&amp;</code>支持将一个类和一个协议结合起来，我们可以将我们的<code>Loadable</code>类型作为<code>LoadableBase</code>和<code>LoadableProtocol</code>之间的组合重新引入：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Loadable</span>&lt;<span class="type">Model</span>&gt; = <span class="type">LoadableBase</span>&lt;<span class="type">Model</span>&gt; &amp; <span class="type">LoadableProtocol</span></span><br></pre></td></tr></table></figure></p><p>这样，具体的类型（如<code>UserLoader</code>）可以简单地声明它们是基于<code>Loadable</code>的，而编译器将确保所有这些类型实现我们协议的<code>load</code>方法——同时仍然使这些类型能够使用我们基类中声明的属性:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserLoader</span>: <span class="title">Loadable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">User</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedUser = cache.value(forKey: url) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedUser</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> await networking.data(from: url)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很好! 上述方法的唯一真正的缺点是，<code>Loadable</code>仍然不能被直接引用，因为它仍然是部分的泛型协议。但这实际上可能不是一个问题——如果这成为一种情况，那么我们总是可以使用诸如<a href="https://xiaozhuanlan.com/topic/8295601734" target="_blank" rel="noopener">类型擦除</a>的技术来解决这些问题。</p><p>对于我们新的基于类型别名的<code>Loadable</code>设计方案，另一个轻微的警告是这种组合类型别名不能被扩展，如果我们想提供一些我们不想（或不能）在<code>LoadableBase</code>类中直接实现的便利API，这可能会成为一个问题。</p><p>不过，解决这个问题的一个方法是，在我们的协议中声明实现这些便利API所需要的一切，这将使我们能够自行扩展该协议：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Model</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> networking: <span class="type">Networking</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> cache: <span class="type">Cache</span>&lt;<span class="type">URL</span>, <span class="type">Model</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LoadableProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadWithCaching</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Model</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedModel = cache.value(forKey: url) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedModel</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> model = <span class="keyword">try</span> await load(from: url)</span><br><span class="line">        cache.insert(model, forKey: url)</span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是在Swift中使用抽象类型和方法的几种不同方式。子类化目前可能不像以前那样流行（在其他编程语言中也是如此），但我仍然认为这些技术在我们整个Swift开发工具箱中是非常好的。</p><p>感谢您的阅读 🚀</p><blockquote><p>译自 John Sundell 的 <a href="https://www.swiftbysundell.com/articles/abstract-types-and-methods/" target="_blank" rel="noopener">Abstract types and methods in Swift</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象的编程中，抽象类型提供了一个基础实现，其他类型可以从中继承，以获得某种共享的、共同的功能。抽象类型与普通类型的区别在于，它们永远不会被当作原样使用（事实上，一些编程语言甚至阻止抽象类型被直接实例化），因为它们的唯一目的是作为一组相关类型的共同父类。&lt;/p&gt;
&lt;p&gt;例如，假设我们想统一我们通过网络加载某些类型的模型的方式，通过提供一个共享的API，我们将能够用来分离关注点，使&lt;a href=&quot;https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;依赖注入&lt;/a&gt;和&lt;a href=&quot;https://www.swiftbysundell.com/articles/mocking-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模拟&lt;/a&gt;变得容易，并在我们的项目中保持方法名称的一致性。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中风味各异的类型擦除</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E9%A3%8E%E5%91%B3%E5%90%84%E5%BC%82%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <id>https://fanbaoying.github.io/Swift-中风味各异的类型擦除/</id>
    <published>2022-03-31T02:03:18.000Z</published>
    <updated>2022-03-31T02:06:26.201Z</updated>
    
    <content type="html"><![CDATA[<p>Swift的总体目标是既强大到可以用于底层系统编程，又足够容易让初学者学习，这有时会导致相当有趣的情况——当Swift的类型系统的力量要求我们部署相当高级的技术来解决乍一看可能更微不足道的问题。</p><p>大多数Swift开发人员会在某一时刻或另一时刻（通常是马上，而不是日后）会遇到这样一种情况，即需要某种形式的类型擦除才能引用通用协议。从本周开始，让我们看一下是什么使类型擦除在Swift中成为必不可少的技术，然后继续探索实现它的不同 <em>“风味(Flavors)”</em>，以及每种风味为何各有优缺点。</p><a id="more"></a><h2 id="什么时候需要类型擦除？"><a href="#什么时候需要类型擦除？" class="headerlink" title="什么时候需要类型擦除？"></a>什么时候需要类型擦除？</h2><p>一开始，<em>“类型擦除”</em>一词似乎与 Swift 给我们的关注类型和编译时类型安全性的第一感觉相反，因此，最好将其描述为<em>隐藏类型</em>，而不是完全擦除它们。目的是使我们能够更轻松地与通用协议进行交互，因为这些通用协议对将要实现它们的各种类型具有特定的要求。</p><p>以标准库中的<code>Equatable</code>协议为例。由于所有目的都是为了根据相等性比较两个相同类型的值，因此<code>Self</code>元类型为其唯一要求的参数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码使任何类型都可以符合<code>Equatable</code>，同时仍然需要<code>==</code>运算符两侧的值都为同一类型，因为在实现上述方法时符合协议的每种类型都必须“填写”自己的类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">User</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: User, rhs: User)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.id == rhs.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的优点在于，它不可能意外地比较两个不相关的相等类型（例如 <code>User</code> 和 <code>String</code> ），但是，它也导致不可能将<code>Equatable</code>引用为独立协议（例如创建 <code>[Equatable]</code> ），因为编译器需要知道实际上确切符合协议的确切类型才能使用它。</p><p>当协议包含关联的类型时，也是如此。例如，在这里我们定义了一个<code>Request</code>协议，使我们可以在一个统一的实现中隐藏各种形式的数据请求（例如网络调用，数据库查询和缓存提取）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">Response</span></span><br><span class="line">    associatedtype <span class="type">Error</span>: <span class="type">Swift</span>.<span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Handler</span> = (<span class="type">Result</span>&lt;<span class="type">Response</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(then handler: @escaping Handler)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的方法为我们提供了与<code>Equatable</code>相同的权衡方法——它非常强大，因为它使我们能够为任何类型的请求创建通用抽象，但也使得无法直接引用<code>Request</code>协议本身，例如这：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 报错: protocol 'Request' can only be used as a generic</span></span><br><span class="line">    <span class="comment">// constraint because it has Self or associated type requirements</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> request: Request,</span></span></span><br><span class="line"><span class="function"><span class="params">             handler: @escaping Request.Handler)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决上述问题的一种方法是完全按照报错消息的内容进行操作，即不直接引用<code>Request</code>，而是将其用作一般约束：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;R: Request&gt;<span class="params">(<span class="number">_</span> request: R,</span></span></span><br><span class="line"><span class="function"><span class="params">                         handler: @escaping R.Handler)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的方法起作用了，因为现在编译器能够保证所传递的处理程序确实与作为请求传递的<code>Request</code>实现兼容——因为它们都基于泛型<code>R</code>，而后者又被限制为符合<code>Request</code>协议。</p><p><strong>但是</strong>，尽管我们解决了方法的签名问题，但仍然无法对传递的请求进行实际的处理，因为我们无法将其存储为<code>Request</code>属性或<code>[Request]</code>数组，这将使继续构建我们的<code>RequestQueue</code>变得困难。也就是说，除非我们开始进行类型擦除。</p><h2 id="通用包装器类型擦除"><a href="#通用包装器类型擦除" class="headerlink" title="通用包装器类型擦除"></a>通用包装器类型擦除</h2><p>我们将探讨的第一种类型擦除实际上并没有涉及擦除任何类型，而是将它们包装在一个我们可以更容易引用的通用类型中。继续从之前的<code>RequestQueue</code>示例开始，我们首先创建该包装器类型——该包装器类型将捕获每个请求的<code>perform</code>方法作为闭包，以及在请求完成后应调用的处理程序：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将使我们将 Request 协议的实现包装在一个</span></span><br><span class="line"><span class="comment">// 与 Request 协议具有相同的响应和错误类型的泛型中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyRequest</span>&lt;<span class="title">Response</span>, <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Handler</span> = (<span class="type">Result</span>&lt;<span class="type">Response</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> perform: (@escaping <span class="type">Handler</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">let</span> handler: <span class="type">Handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们还将把<code>RequestQueue</code>本身转换为相同的<code>Response</code>和<code>Error</code>类型的泛型——使得编译器可以保证所有关联的类型和泛型类型对齐，从而使我们可以将请求存储为独立的引用并作为数组的一部分——像这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span>&lt;<span class="title">Response</span>, <span class="title">Error</span>: <span class="title">Swift</span>.<span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">typealias</span> <span class="type">TypeErasedRequest</span> = <span class="type">AnyRequest</span>&lt;<span class="type">Response</span>, <span class="type">Error</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = [<span class="type">TypeErasedRequest</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ongoing: <span class="type">TypeErasedRequest</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们修改了'add'方法，以包含一个'where'子句，</span></span><br><span class="line">    <span class="comment">// 该子句确保传递的请求已关联的类型与队列的通用类型匹配。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;R: Request&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> request: R,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: @escaping R.Handler</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> <span class="keyword">where</span> <span class="type">R</span>.<span class="type">Response</span> == <span class="type">Response</span>, <span class="type">R</span>.<span class="type">Error</span> == <span class="type">Error</span> &#123;</span><br><span class="line">        <span class="comment">//要执行类型擦除，我们只需创建一个实例'AnyRequest'，</span></span><br><span class="line">        <span class="comment">//然后将其传递给基础请求将“perform”方法与处理程序一起作为闭包。</span></span><br><span class="line">        <span class="keyword">let</span> typeErased = <span class="type">AnyRequest</span>(</span><br><span class="line">            perform: request.perform,</span><br><span class="line">            handler: handler</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于我们要实现队列，因此我们不想一次有两个请求，</span></span><br><span class="line">        <span class="comment">// 所以将请求保存下拉，以防稍后有一个正在执行的请求。</span></span><br><span class="line">        <span class="keyword">guard</span> ongoing == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.append(typeErased)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perform(typeErased)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> request: TypeErasedRequest)</span></span> &#123;</span><br><span class="line">        ongoing = request</span><br><span class="line"></span><br><span class="line">        request.perform &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">            request.handler(result)</span><br><span class="line">            <span class="keyword">self</span>?.ongoing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果队列不为空，则执行下一个请求</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>请注意，上面的示例以及本文中的其他示例代码都不是线程安全的——为了使事情变得简单。有关线程安全的更多信息，请查看<a href="https://www.swiftbysundell.com/articles/avoiding-race-conditions-in-swift" target="_blank" rel="noopener">“避免在Swift 中竞争条件”</a>。</p></blockquote><p>上面的方法效果很好，但有一些缺点。我们不仅引入了新的<code>AnyRequest</code>类型，还需要将<code>RequestQueue</code>转换为泛型。这给我们带来了一点灵活性，因为我们现在只能将任何给定的队列用于具有相同 响应/错误类型 组合的请求。具有讽刺意味的是，如果我们想组成多个实例，将来可能还需要我们自己实现队列擦除。</p><h2 id="闭包类型擦除"><a href="#闭包类型擦除" class="headerlink" title="闭包类型擦除"></a>闭包类型擦除</h2><p>我们不引入包装类型，而是让我们看一下如何使用闭包来实现相同的类型擦除，同时还要使我们的<code>RequestQueue</code>非泛型且通用，足以用于不同类型的请求。</p><p>使用闭包擦除类型时，其思想是捕获在闭包内部执行操作所需的所有类型信息，并使该闭包仅接受非泛型（甚至是<code>Void</code>）输入。这样一来，我们就可以引用，存储和传递该功能，而无需实际知道功能内部会发生什么，从而为我们提供了更强大的灵活性。</p><p>更新<code>RequestQueue</code>以使用基于闭包的类型擦除的方法如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = [() -&gt; <span class="type">Void</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPerformingRequest = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;R: Request&gt;<span class="params">(<span class="number">_</span> request: R,</span></span></span><br><span class="line"><span class="function"><span class="params">                         handler: @escaping R.Handler)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 此闭包将同时捕获请求及其处理程序，而不会暴露任何类型信息</span></span><br><span class="line">        <span class="comment">// 在其外部，提供完全的类型擦除。</span></span><br><span class="line">        <span class="keyword">let</span> typeErased = &#123;</span><br><span class="line">            request.perform &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">                handler(result)</span><br><span class="line">                <span class="keyword">self</span>?.isPerformingRequest = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">self</span>?.performNextIfNeeded()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.append(typeErased)</span><br><span class="line">        performNextIfNeeded()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">performNextIfNeeded</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !isPerformingRequest &amp;&amp; !queue.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isPerformingRequest = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> closure = queue.removeFirst()</span><br><span class="line">        closure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然过分依赖闭包来捕获功能和状态有时会使我们的代码难以调试，但也可能使完全封装类型信息成为可能——使得像<code>RequestQueue</code>这样的对象可以在没有真正了解在底层工作的类型的任何细节的情况下进行工作。</p><blockquote><p>有关基于闭包的类型擦除及其更多不同方法的更多信息，请查看<a href="https://www.jianshu.com/p/8464cea6abb5" target="_blank" rel="noopener">“Swift 使用闭包实现类型擦除”</a>。</p></blockquote><h2 id="外部特化（External-specialization）"><a href="#外部特化（External-specialization）" class="headerlink" title="外部特化（External specialization）"></a>外部特化（External specialization）</h2><p>到目前为止，我们已经在<code>RequestQueue</code>本身中执行了所有类型擦除，这有一些优点——它可以让任何外部代码使用我们的队列，而不需要知道我们使用什么类型的类型擦除。然而，有时在将协议实现传递给API之前进行一些轻量级转换，既可以使事情变得更简单，又可以巧妙地封装类型擦除代码本身。</p><p>对于我们的<code>RequestQueue</code>，一种方法是要求在将每个<code>Request</code>实现添加到队列之前对其进行特化——这将把它转换为<code>RequestOperation</code>，如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RequestOperation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> closure: (@escaping () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(then handler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        closure(handler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与我们之前使用闭包在<code>RequestQueue</code>中执行类型擦除的方式类似，上面的<code>RequestOperation</code>类型将使我们能够在扩展<code>Request</code>时执行该操作：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeOperation</span><span class="params">(with handler: @escaping Handler)</span></span> -&gt; <span class="type">RequestOperation</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">RequestOperation</span> &#123; finisher <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 我们其实想在这里捕获'self'，因为不这样话</span></span><br><span class="line">            <span class="comment">// 我们将冒着无法保留基本请求的风险。</span></span><br><span class="line">            <span class="keyword">self</span>.perform &#123; result <span class="keyword">in</span></span><br><span class="line">                handler(result)</span><br><span class="line">                finisher()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法的优点在于，无论是公共API还是内部实现，它都让我们的<code>RequestQueue</code>更加简单。它现在可以完全专注于作为一个队列，而不必关心任何类型的类型擦除：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> queue = [<span class="type">RequestOperation</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ongoing: <span class="type">RequestOperation</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为类型擦除现在发生在request被传递给 queue 之前，</span></span><br><span class="line">    <span class="comment">// 它可以简单地接受一个具体的“RequestOperation”的实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> operation: RequestOperation)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> ongoing == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            queue.append(operation)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        perform(operation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> operation: RequestOperation)</span></span> &#123;</span><br><span class="line">        ongoing = operation</span><br><span class="line"></span><br><span class="line">        operation.perform &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.ongoing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果队列不为空，则执行下一个请求</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，这里的缺点是，在将每个请求添加到队列之前，我们必须手动将其转换为<code>RequestOperation</code>——虽然这不会在每个调用点添加大量代码，但这取决于必须完成相同转换的次数，它最终可能会有点像样板。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管 Swift 提供了一个功能强大得难以置信的类型系统，可以帮助我们避免大量的bug，但有时它会让人觉得我们必须与系统抗争，才能使用通用协议之类的功能。必须进行类型擦除最初看起来像是一件不必要的杂务，但它也带来了一些好处——比如从不需要关心这些类型的代码中隐藏特定类型信息。</p><p>在未来，我们可能还会看到 Swift 中添加了新的特性，可以自动化创建类型擦除包装类型的过程，也可以通过使协议也被用作适当的泛型（例如能够定义像<code>Request&lt;Response，Error&gt;</code>这样的协议）来消除对它的大量需求，而不仅仅依赖于相关的类型）。</p><p>什么样的类型擦除是最合适的——无论是现在还是将来——当然很大程度上取决于上下文，以及我们的功能是否可以在闭包中轻松地执行，或者完整包装器类型或泛型是否更适合这个问题。</p><p>感谢阅读！🚀</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift的总体目标是既强大到可以用于底层系统编程，又足够容易让初学者学习，这有时会导致相当有趣的情况——当Swift的类型系统的力量要求我们部署相当高级的技术来解决乍一看可能更微不足道的问题。&lt;/p&gt;
&lt;p&gt;大多数Swift开发人员会在某一时刻或另一时刻（通常是马上，而不是日后）会遇到这样一种情况，即需要某种形式的类型擦除才能引用通用协议。从本周开始，让我们看一下是什么使类型擦除在Swift中成为必不可少的技术，然后继续探索实现它的不同 &lt;em&gt;“风味(Flavors)”&lt;/em&gt;，以及每种风味为何各有优缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中风味各异的依赖注入</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E9%A3%8E%E5%91%B3%E5%90%84%E5%BC%82%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>https://fanbaoying.github.io/Swift-中风味各异的依赖注入/</id>
    <published>2022-03-31T02:03:09.000Z</published>
    <updated>2022-03-31T02:07:11.672Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，我们看了一些使用依赖注入的不同方法，以实现Swift应用中更多的解耦和可测试架构。例如， <a href="https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift" target="_blank" rel="noopener">“在Swift中使用工厂的依赖注入”</a>中把依赖注入和工厂模式结合起来，以及<em><a href="https://www.swiftbysundell.com/articles/avoiding-singletons-in-swift" target="_blank" rel="noopener">“在Swift中避免使用单例”</a></em> 中利用依赖注入取代单利。</p><p>到目前为止，我的大部分文章和例子都使用了基于初始化器的依赖注入。然而，就像大多数编程技术一样，依赖注入有多种“风味(Flavors)”，每一种都有自己的优点和缺点。本周，让我们来看看三种不同方式的依赖注入，以及它们如何在Swift中使用。</p><a id="more"></a><h1 id="基于初始化器"><a href="#基于初始化器" class="headerlink" title="基于初始化器"></a>基于初始化器</h1><p>让我们先快速回顾一下最常见的依赖注入方式——基于初始化器的依赖注入，即对象在被初始化时应该被赋予它所需要的依赖关系。这种方式的最大好处是，它保证我们的对象拥有它们所需要的一切，以便立即开展工作。</p><p>假设我们正在构建一个从磁盘上加载文件的<code>FileLoader</code>。为了做到这一点，它使用了两个依赖项——一个是系统提供的<code>FileManager</code>的实例，另一个是<code>Cache</code>。使用基于初始化器的依赖注入，可以这样实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> fileManager: <span class="type">FileManager</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> cache: <span class="type">Cache</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(fileManager: <span class="type">FileManager</span> = .<span class="keyword">default</span>,</span><br><span class="line">         cache: <span class="type">Cache</span> = .<span class="keyword">init</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fileManager = fileManager</span><br><span class="line">        <span class="keyword">self</span>.cache = cache</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面是如何使用默认参数的，以避免在使用单例或新实例时总是创建依赖关系。这使我们能够在生产代码中使用<code>FileLoader()</code>简单地创建一个文件加载器，同时仍然能够通过在测试代码中注入模拟数据或显式实例进行测试。</p><h1 id="基于属性"><a href="#基于属性" class="headerlink" title="基于属性"></a>基于属性</h1><p>虽然基于初始化器的依赖注入通常很适合你自己的自定义类，但有时当你必须从系统类继承时，它就有点难用了。一个例子是在构建视图控制器时，特别是当你使用 XIBs 或 Storyboards 来定义它们时，因为这样你就无法再控制你的类的初始化器了。</p><p>对于这些类型的情况，基于属性的依赖注入可以是一个很好的选择。与其在对象的初始化器中注入对象的依赖关系，不如在之后简单地将其分配。这种依赖注入的方式也可以帮助你减少模板文件，特别是当有一个好的默认值不一定需要注入的时候。</p><p>让我们来看看另一个例子——在这个例子中，我们要建立一个<code>PhotoEditorViewController</code>，让用户编辑他们库中的一张照片。为了发挥作用，这个视图控制器需要一个系统提供的<code>PHPhotoLibrary</code>类的实例（它是一个单例），以及一个我们自己的<code>PhotoEditorEngine</code>类的实例。为了在没有自定义初始化器的情况下实现依赖性注入，我们可以创建两个都有默认值的可变属性，就像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoEditorViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> library: <span class="type">PhotoLibrary</span> = <span class="type">PHPhotoLibrary</span>.shared()</span><br><span class="line">    <span class="keyword">var</span> engine = <span class="type">PhotoEditorEngine</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 <em><a href="https://www.swiftbysundell.com/articles/testing-swift-code-that-uses-system-singletons-in-3-easy-steps" target="_blank" rel="noopener">“通过 3 个简单的步骤测试使用了系统单例的 Swift 代码”</a></em>中的技术是如何通过使用协议来为系统照片库类提供一个更抽象的<code>PhotoLibrary</code>接口。这将使测试和数据模拟变得更加容易!</p><p>上述做法的好处是，我们仍然可以很容易地在测试中注入模拟数据，只需重新分配视图控制器的属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoEditorViewControllerTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testApplyingBlackAndWhiteFilter</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">PhotoEditorViewController</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配一个模拟照片库以完全控制里面存储了哪些照片</span></span><br><span class="line">        <span class="keyword">let</span> library = <span class="type">PhotoLibraryMock</span>()</span><br><span class="line">        library.photos = [<span class="type">TestPhotoFactory</span>.photoWithColor(.red)]</span><br><span class="line">        viewController.library = library</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行我们的测试命令</span></span><br><span class="line">        viewController.selectPhoto(atIndex: <span class="number">0</span>)</span><br><span class="line">        viewController.apply(<span class="built_in">filter</span>: .blackAndWhite)</span><br><span class="line">        viewController.savePhoto()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言结果是正确的</span></span><br><span class="line">        <span class="type">XCTAssertTrue</span>(photoIsBlackAndWhite(library.photos[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于参数"><a href="#基于参数" class="headerlink" title="基于参数"></a>基于参数</h1><p>最后，让我们看一下基于参数的依赖注入。当你想轻松地使遗留代码变得更容易测试且不必过多地改变其现有结构时，这种类型特别有用。</p><p>很多时候，我们只需要一个特定的依赖关系一次，或者我们只需要在某些条件下模拟它。我们不需要改变对象的初始化器或将属性暴露为可变的（这并不总是一个好方式），而是可以开放某个API来接受一个依赖关系作为参数。</p><p>让我们来看看一个<code>NoteManager</code>类，它是一个记事应用程序的一部分。它的工作是管理用户所写的所有笔记，并提供一个API用于根据查询来搜索笔记。由于这是一个可能需要一段时间的操作（如果用户有很多笔记的话，这是很有可能的），我们通常在一个后台队列中执行，像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadNotes</span><span class="params">(matching query: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                   completionHandler: @escaping <span class="params">([Note])</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line">            <span class="keyword">let</span> database = <span class="keyword">self</span>.loadDatabase()</span><br><span class="line">            <span class="keyword">let</span> notes = database.<span class="built_in">filter</span> &#123; note <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> note.matches(query: query)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completionHandler(notes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述方法对我们的生产代码来说是一个很好的解决方案，但在测试中，我们通常希望尽可能地避免异步代码和并行性，以<a href="https://www.swiftbysundell.com/articles/reducing-flakiness-in-swift-tests" target="_blank" rel="noopener">避免片状现象</a>。虽然使用初始化器或基于属性的依赖注入来指定<code>NoteManager</code>应始终使用的显式队列会很好，但这可能需要对类进行大的修改，而我们现在还不能/不愿意这样做。</p><p>这就是基于参数的依赖性注入的作用。与其重构我们的整个类，不如直接注入要在哪个队列上运行<code>loadNotes</code>操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadNotes</span><span class="params">(matching query: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                   on queue: DispatchQueue = .global<span class="params">(qos: .userInitiated)</span></span></span>,</span><br><span class="line">                   completionHandler: @escaping ([<span class="type">Note</span>]) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            <span class="keyword">let</span> database = <span class="keyword">self</span>.loadDatabase()</span><br><span class="line">            <span class="keyword">let</span> notes = database.<span class="built_in">filter</span> &#123; note <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> note.matches(query: query)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completionHandler(notes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使我们能够在测试代码中轻松地使用一个自定义队列，我们可以在上面等待。这几乎可以让我们在测试中把上述API变成一个同步的API，这让事情变得更容易和更可预测。</p><p>基于参数的依赖注入的另一个用例是当你想测试静态API的时候。对于静态API，我们没有初始化器，而且我们最好也不要静态地保持任何状态，所以基于参数的依赖注入成为一个很好的选择。让我们看一个当前依赖单例的静态<code>MessageSender</code> 类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> message: Message, to user: User)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="type">Database</span>.shared.insert(message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data: <span class="type">Data</span> = <span class="keyword">try</span> wrap(message)</span><br><span class="line">        <span class="keyword">let</span> endpoint = <span class="type">Endpoint</span>.sendMessage(to: user)</span><br><span class="line">        <span class="type">NetworkManager</span>.shared.post(data, to: endpoint.url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然理想的长期解决方案可能是重构<code>MessageSender</code>，使其成为非静态的，并在其使用的任何地方正确注入，但为了方便测试（例如，为了重现/验证一个错误），我们可以简单地将其依赖性作为参数注入，而不是依赖单例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> message: Message,</span></span></span><br><span class="line"><span class="function"><span class="params">                     to user: User,</span></span></span><br><span class="line"><span class="function"><span class="params">                     database: Database = .shared,</span></span></span><br><span class="line"><span class="function"><span class="params">                     networkManager: NetworkManager = .shared)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        database.insert(message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> data: <span class="type">Data</span> = <span class="keyword">try</span> wrap(message)</span><br><span class="line">        <span class="keyword">let</span> endpoint = <span class="type">Endpoint</span>.sendMessage(to: user)</span><br><span class="line">        networkManager.post(data, to: endpoint.url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次使用默认参数，除去为了方便的原因，但这里更重要的是为了能够在我们的代码中添加测试支持，同时仍然保持100%的向后兼容性👍。</p><p>感谢您的阅读 🚀</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，我们看了一些使用依赖注入的不同方法，以实现Swift应用中更多的解耦和可测试架构。例如， &lt;a href=&quot;https://www.swiftbysundell.com/articles/dependency-injection-using-factories-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“在Swift中使用工厂的依赖注入”&lt;/a&gt;中把依赖注入和工厂模式结合起来，以及&lt;em&gt;&lt;a href=&quot;https://www.swiftbysundell.com/articles/avoiding-singletons-in-swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“在Swift中避免使用单例”&lt;/a&gt;&lt;/em&gt; 中利用依赖注入取代单利。&lt;/p&gt;
&lt;p&gt;到目前为止，我的大部分文章和例子都使用了基于初始化器的依赖注入。然而，就像大多数编程技术一样，依赖注入有多种“风味(Flavors)”，每一种都有自己的优点和缺点。本周，让我们来看看三种不同方式的依赖注入，以及它们如何在Swift中使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 23 合并 K 个升序链表（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-23-合并-K-个升序链表（Top-100）/</id>
    <published>2022-03-25T10:23:17.000Z</published>
    <updated>2022-03-31T02:12:21.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:<a href="https://m.weibo.cn/u/1827884772" title="@故胤道长" target="_blank" rel="noopener">@故胤道长</a></strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 22 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeKSortedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists: [ListNode?])</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> lists.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = lists.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> lists = lists</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">right</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                lists[<span class="keyword">left</span>] = _mergeTwoLists(lists[<span class="keyword">left</span>], lists[<span class="keyword">right</span>])</span><br><span class="line">                <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_mergeTwoLists</span><span class="params">(l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> node = dummy</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> l1 = l1</span><br><span class="line">        <span class="keyword">var</span> l2 = l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> l1!.val &lt; l2!.val &#123;</span><br><span class="line">                node.next = l1</span><br><span class="line">                l1 = l1!.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = l2</span><br><span class="line">                l2 = l2!.next</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.next!</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.next = l1 ?? l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：Dummy Node来遍历两个列表，比较两个节点并指向右边的一个。</li><li>时间复杂度： O(mlogn) m 表示一个列表的长度，n 表示列表的个数。</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/merge-k-sorted-lists/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:&lt;a href=&quot;https://m.weibo.cn/u/1827884772&quot; title=&quot;@故胤道长&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@故胤道长&lt;/a&gt;&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 22 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 22 括号生成（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-22-括号生成（Top-100）/</id>
    <published>2022-03-25T10:23:02.000Z</published>
    <updated>2022-03-31T02:12:25.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 21 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。 </p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateParentheses</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">String</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> paths = [<span class="type">String</span>](), path = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        dfs(&amp;paths, path, n, n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> paths</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> paths: <span class="keyword">inout</span> [String], <span class="number">_</span> path: String, <span class="number">_</span> leftRemaining: Int, <span class="number">_</span> rightRemaining: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rightRemaining == <span class="number">0</span> &#123;</span><br><span class="line">            paths.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftRemaining &gt; <span class="number">0</span> &#123;</span><br><span class="line">            dfs(&amp;paths, path + <span class="string">"("</span>, leftRemaining - <span class="number">1</span>, rightRemaining)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> rightRemaining &gt; leftRemaining &#123;</span><br><span class="line">            dfs(&amp;paths, path + <span class="string">")"</span>, leftRemaining, rightRemaining - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：Dummy Node来遍历两个列表，比较两个节点并指向右边的一个。</li><li>时间复杂度： O(2^n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/generate-parentheses/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 21 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 21 合并两个有序链表（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-21-合并两个有序链表（Top-100）/</id>
    <published>2022-03-25T10:22:35.000Z</published>
    <updated>2022-03-31T02:12:28.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 20 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/3f183bac013b76804ef04a6f77930be5.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var next: ListNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.next = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeTwoSortedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> node = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> l1 = l1</span><br><span class="line">        <span class="keyword">var</span> l2 = l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> l1!.val &lt; l2!.val &#123;</span><br><span class="line">                node.next = l1</span><br><span class="line">                l1 = l1!.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = l2</span><br><span class="line">                l2 = l2!.next</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next!</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.next = l1 ?? l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：Dummy Node来遍历两个列表，比较两个节点并指向右边的一个。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/merge-two-sorted-lists/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 20 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 20 有效的括号</title>
    <link href="https://fanbaoying.github.io/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://fanbaoying.github.io/LeetCode-20-有效的括号/</id>
    <published>2022-03-24T02:36:23.000Z</published>
    <updated>2022-03-31T02:12:06.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 19 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-bb33acfd8ecc9401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsPhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(<span class="number">_</span> digits: String)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> digits.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">String</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> combinations = [<span class="type">String</span>](), combination = <span class="string">""</span></span><br><span class="line">        <span class="keyword">let</span> numberToStr = [<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]</span><br><span class="line">        </span><br><span class="line">        dfs(&amp;combinations, &amp;combination, numberToStr, digits, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> combinations</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> combinations: <span class="keyword">inout</span> [String], <span class="number">_</span> combination: <span class="keyword">inout</span> String, <span class="number">_</span> numberToStr: [String], <span class="number">_</span> digits: String, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> combination.<span class="built_in">count</span> == digits.<span class="built_in">count</span> &#123;</span><br><span class="line">            combinations.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentStr = fetchCurrentStr(from: digits, at: index, numberToStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> currentStr &#123;</span><br><span class="line">            combination.append(char)</span><br><span class="line">            dfs(&amp;combinations, &amp;combination, numberToStr, digits, index + <span class="number">1</span>)</span><br><span class="line">            combination.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchCurrentStr</span><span class="params">(from digits: String, at index: Int, <span class="number">_</span> numberToStr: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; digits.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid index"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentDigitChar = digits[digits.index(digits.startIndex, offsetBy: index)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> currentDigit = <span class="type">Int</span>(<span class="type">String</span>(currentDigitChar)), currentDigit &gt;= <span class="number">0</span>, currentDigit &lt; numberToStr.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid digits"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numberToStr[currentDigit]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索，首先创建电话板</li><li>时间复杂度： O(4^n)， n 表示数字长度</li><li>空间复杂度： O(n)， n 表示数字长度</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 19 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 19 删除链表的倒数第 N 个结点</title>
    <link href="https://fanbaoying.github.io/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://fanbaoying.github.io/LeetCode-19-删除链表的倒数第-N-个结点/</id>
    <published>2022-03-24T02:36:10.000Z</published>
    <updated>2022-03-31T02:12:38.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 18 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(<span class="number">_</span> head: ListNode?, <span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        <span class="keyword">var</span> prev: <span class="type">ListNode</span>? = dummy</span><br><span class="line">        <span class="keyword">var</span> post: <span class="type">ListNode</span>? = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move post</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">            post = post!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move prev and post at the same time</span></span><br><span class="line">        <span class="keyword">while</span> post!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">            prev = prev!.next</span><br><span class="line">            post = post!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prev!.next = prev!.next!.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：运动员技术</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 18 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 18 四数之和</title>
    <link href="https://fanbaoying.github.io/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://fanbaoying.github.io/LeetCode-18-四数之和/</id>
    <published>2022-03-24T02:35:56.000Z</published>
    <updated>2022-03-31T02:12:42.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 17 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code>（若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted(by: &lt;)</span><br><span class="line">        <span class="keyword">var</span> threeSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> twoSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt;= <span class="number">4</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            threeSum = target - nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> j == i + <span class="number">1</span> || nums[j] != nums[j - <span class="number">1</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                twoSum = threeSum - nums[j]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">left</span> = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] == twoSum &#123;</span><br><span class="line">                        res.append([nums[i], nums[j], nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>]])</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">repeat</span> &#123;</span><br><span class="line">                                <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] &lt; twoSum &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对数组进行排序并遍历，根据它们的和大于或小于等于目标，向左递增或向右递减</li><li>时间复杂度： O(n^3)</li><li>空间复杂度： O(nC4)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/4sum" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 17 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
