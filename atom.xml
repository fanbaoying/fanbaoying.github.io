<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2024-03-06T09:17:05.534Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift-周报-第四十八期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十八期/</id>
    <published>2024-03-06T09:11:00.000Z</published>
    <updated>2024-03-06T09:17:05.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第四十八期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>倚高山之巅，方见大河奔涌。读<strong>Swift社区</strong>，便知书海浩瀚。渺小与博大，总是同伴己身！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果突然不造车了，雷军：非常震惊！分析师：马斯克或是最大赢家</p><p>提案：自定义 SerialExecutor 的隔离检查</p><p>Swift 论坛：讨论在整个应用程序中共享变量</p><p>推荐博文：使用 MLX 和 Swift 进行设备端机器学习研究</p><p><strong>话题讨论：</strong> </p><p>如果 2024 年购车，你选择买那种车？</p><p><strong>上期话题结果</strong></p></blockquote><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/82e1c543-c37a-4a5a-8b65-3161c0661e4d.jpeg" alt=""></p><p>我认为应该鼓励人们在面对工作中的挑战和不如意时保持乐观和积极的态度。被裁员可能是一个人职业生涯中的一次挑战，但也是一个机会去探索新的职业道路和发展方向。因此，即使面对困难，也应该以积极的心态去应对，寻找新的机会和可能性。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果突然不造车了，雷军：非常震惊！分析师：马斯克或是最大赢家"><a href="#苹果突然不造车了，雷军：非常震惊！分析师：马斯克或是最大赢家" class="headerlink" title="苹果突然不造车了，雷军：非常震惊！分析师：马斯克或是最大赢家"></a>苹果突然不造车了，雷军：非常震惊！分析师：马斯克或是最大赢家</h3><p>苹果的造车项目最终还是黄了。</p><p>于 2014 年正式启动的“泰坦计划”曾经承载着苹果的美好憧憬：分食全球近两千亿美元的电动车市场。然而，十年过去，苹果却未能让其野心开花结果，项目在高管更迭和试驾事故等波折中反复挣扎，并于 2 月 27 日走向终局。</p><p>据彭博社，放弃“泰坦计划”是由苹果首席运营官杰夫·威廉姆斯 (Jeff Williams) 和负责造车项目的副总裁凯文·林奇 (Kevin Lynch) 共同做出的。随着造车项目被叫停，相关项目小组（内部称为“特殊项目小组”或 SPG）的近 2000 名员工也面临着未知的前路。</p><p>据悉，SPG 部分人员将在高管约翰·詹南德雷亚 (John Giannandrea) 的领导下专注于生成式AI项目。而其他数百名成员（其中许多是硬件工程师和汽车设计师）要么可以在苹果内部申请另一份工作，要么将被解雇。目前尚不清楚将有多少人会被裁员。</p><p>从整个大环境看，苹果大举砍掉造车项目的背后也是电动车市场的转冷。据彭博社预测，2024 年美国电动汽车销量的增长将不超过 9%，而过去三年的复合年增长率高达 65%。苹果的这一决策公开后，特斯拉 CEO 马斯克在X上进行了回应。在竞争激烈的市场环境中，特斯拉作为行业领头羊，或许会是苹果此次抉择的最大受益者。</p><p>“泰坦计划”折戟之后，苹果能否如愿在生成式AI的天地中重塑其辉煌，外界只能拭目以待。</p><p><img src="https://tmp-file-1252627319.cos.ap-shanghai.myqcloud.com/wx_article_img/CFF20LXzkOzP9RNPkLFCxvHE42MgHicib2R858blKVJZiciahvFicxniadhdAtpD5UCpmSOJoUSuHGqib49WOmcZvT2kg.jpg" alt=""></p><p>对此，正在造车的小米创始人雷军在微博发文称：看到这个新闻，非常震惊！小米战略是“人车家全生态”，我们深知造车难度，3 年前依然做了无比坚定的战略选择，认认真真为米粉造一辆好车！”</p><p><img src="https://tmp-file-1252627319.cos.ap-shanghai.myqcloud.com/wx_article_img/CFF20LXzkOzP9RNPkLFCxvHE42MgHicib21wa54X6iaY0YhPkkwOjdw0b4oJnkJScJrd5SQEpQXUtQUWtsCCYlSgg.jpg" alt=""></p><p>理想汽车 CEO 李想 2 月 28 日在微博发文称，苹果放弃造车，选择聚焦人工智能是绝对正确的战略选择，时间点也合适。李想表示，战略层面，新业务能聚焦一个，就决不做两个。另外，选择那个最大的，以及距离自己核心优势最近的，知难而上大概率不是好战略。</p><p><img src="https://tmp-file-1252627319.cos.ap-shanghai.myqcloud.com/wx_article_img/CFF20LXzkOzP9RNPkLFCxvHE42MgHicib2aCenHKWIy1HLmD5Mcn2JBPYXwzVht1OtfKxJicCsIf3iagsOb2eF1rIQ.png" alt=""></p><p>特斯拉首席执行官埃隆·马斯克则在社交媒体网站X上发了一个敬礼的表情符号和一支香烟。有中国网友戏称，马斯克的“香烟”表情是在给苹果汽车“上香”。</p><p><img src="https://tmp-file-1252627319.cos.ap-shanghai.myqcloud.com/wx_article_img/CFF20LXzkOzP9RNPkLFCxvHE42MgHicib218MvDL7RfngK5JQRQXZ5Z9rOXAibuc3uib47BgibI9407b6N40bP1GibYA.png" alt=""></p><h3 id="你会爱上的开发者活动"><a href="#你会爱上的开发者活动" class="headerlink" title="你会爱上的开发者活动"></a>你会爱上的开发者活动</h3><p>2024 年 2 月 14 日</p><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/02C54728-A44D-49AF-923D-EC54D9EBF3DC/2048.jpeg" alt=""></p><p>Apple 开发者活动正在火热进行中，让我们来看看具体都有哪些活动：</p><p>参加 App Store 专家主持的在线讲座：了解如何如何最大程度地减少用户流失并赢回订阅者。<br>共庆国际妇女节：参加在班加罗尔、库比蒂诺、上海、新加坡、悉尼和东京举办的特别线下活动。<br>参加世界各地的 Apple Vision Pro 开发者实验室 (库比蒂诺、伦敦、柏林、新加坡、悉尼和东京皆有举办)：测试和完善你的 App，让它们在无边的空间画布中提供出色的体验。<br>与 Apple 团队成员会面，探讨为遵守《数字市场法》而对在欧盟分发的 App 产生影响的 iOS、Safari 浏览器以及 App Store 的变更。<br>全年我们都将以线上和线下的形式，举办各种涵盖多种语言的活动。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0422-caller-side-default-argument-macro-expression.md" title="SE-0422" target="_blank" rel="noopener">SE-0422</a> <strong>表达式宏作为调用方默认参数</strong> 提案通过审查。该提案已在 <strong>四十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0421-generalize-async-sequence.md" title="SE-0421" target="_blank" rel="noopener">SE-0421</a> <strong>推广 AsyncSequence 和 AsyncIteratorProtocol 的效果多态性</strong> 提案通过审查。该提案已在 <strong>四十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0420-inheritance-of-actor-isolation.md" title="SE-0420" target="_blank" rel="noopener">SE-0420</a> <strong>继承 actor 隔离性</strong> 提案通过审查。该提案已在 <strong>四十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0419-backtrace-api.md" title="SE-0419" target="_blank" rel="noopener">SE-0419</a> <strong>Swift Backtrace API</strong> 提案通过审查。该提案已在 <strong>四十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0423-dynamic-actor-isolation.md" title="SE-0423" target="_blank" rel="noopener">SE-0423</a> <strong>非严格并发上下文中的动态 actor 隔离执行</strong> 提案正在审查。</p><p>许多 Swift 程序需要与用 C/C++/Objective-C 编写的框架进行交互，这些框架的实现无法参与静态数据竞争安全性。同样，许多 Swift 程序依赖项尚未采用严格的并发性检查。<code>@preconcurrency import</code> 语句会降级与并发相关的错误消息，因为程序员无法解决的根本问题在其中一个依赖项中。为了在与预并发依赖项一起工作时加强 Swift 的数据竞争安全性保证，该提案在运行时为同步隔离函数添加了 actor 隔离检查。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0424-custom-isolation-checking-for-serialexecutor.md" title="SE-0424" target="_blank" rel="noopener">SE-0424</a> <strong>自定义 SerialExecutor 的隔离检查</strong> 提案正在审查。</p><p>SE-0392（自定义 Actor 执行器）增加了对自定义 actor 执行器的支持，但其支持还不完整。像 <code>Actor.assumeIsolated</code> 这样的安全检查在通过任务在 actor 上运行代码时能够正常工作，但当代码被安排在 actor 的执行器上通过其他机制运行时则无法正常工作。</p><p>例如，如果一个 actor 使用串行 <code>DispatchQueue</code> 作为其执行器，那么使用 <code>DispatchQueue.async</code> 直接将函数调度到队列时，无法使用 assumeIsolated 来断言 actor 当前是否被隔离。该提案通过允许自定义 actor 执行器为这些安全检查提供自己的逻辑来解决此问题。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-resolve-distributedactor-protocols-for-server-client-apps/69933" title="解决 DistributedActor 协议（针对服务器/客户端应用程序）" target="_blank" rel="noopener">解决 DistributedActor 协议（针对服务器/客户端应用程序）</a></p><p><strong>内容大概</strong></p><p>讨论了解决 Swift 中服务器/客户端应用程序的 DistributedActor 协议的提案。 该提案旨在促进分布式系统之间的通信，同时仍然有效地利用参与者。 发帖人赞赏所提出的优雅解决方案，特别强调了宏的使用。 他们提出了有关在客户端实现分布式系统的简化版本、跨不同语言创建共享 API 的潜力的问题，并询问有关类似概念的现有框架或研究论文。 </p><p>这篇文章还提到了分布式 Actor 的多功能性，并引用了 Akka 和 Orleans 的例子，表明它们适合实时和耦合系统。 此外，它还提到了 2023 年 Google 研究人员发表的一篇论文，该论文倡导受参与者模型启发的分布式系统，强调了位置透明的好处。</p><p>根据这个建议，可以编写以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// API module</span></span><br><span class="line"><span class="keyword">import</span> Distributed</span><br><span class="line"></span><br><span class="line">@<span class="type">DistributedProtocol</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Greeter</span>: <span class="title">DistributedActor</span></span></span><br><span class="line"><span class="class">    <span class="title">where</span> <span class="title">ActorSystem</span>: <span class="title">DistributedActorSystem</span>&lt;<span class="title">any</span> <span class="title">Codable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  distributed <span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name: String)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client module</span></span><br><span class="line"><span class="keyword">import</span> API <span class="comment">// declared Greeter</span></span><br><span class="line"><span class="keyword">import</span> Distributed</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someActorSystem = <span class="comment">// &lt;the actor system you're using&gt;</span></span><br><span class="line"><span class="keyword">let</span> remote = <span class="keyword">try</span> $<span class="type">Greeter</span>.resolve(id: id, using: someActorSystem)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reply = <span class="keyword">try</span> await remote.greet(name: <span class="string">"Caplin"</span>)</span><br><span class="line"><span class="built_in">print</span>(reply) <span class="comment">// Dzień dobry, Caplin!</span></span><br><span class="line"><span class="comment">// oh, we didn't know the remote implementation is PolishGreeter!</span></span><br></pre></td></tr></table></figure><p>这允许开发人员发布具有协议描述的 API 包，并对客户端应用程序完全隐藏服务器实现类型。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-bitwisecopyable-marker-protocol/69943" title="按位复制标记协议" target="_blank" rel="noopener">按位复制标记协议</a></p><p><strong>内容大概</strong></p><p>该提案建议在 Swift 中引入一种名为 BitwiseCopyable 的新标记协议，以识别可以有效复制、移动和销毁的类型。 该协议将允许通过启用直接内存操作（例如 memcpy）来优化低级代码。 通过将泛型函数限制为 BitwiseCopyable 类型，开发人员可以减少开销并提高性能，特别是对于涉及批量内存复制的操作。 </p><p>该提案概述了标准库中的基本类型和开发人员定义的类型如何符合 BitwiseCopyable，并由编译器推断某些情况下的一致性。 但是，对于其他模块中定义的类型或可能并不总是满足 BitwiseCopyable 要求的类型，需要显式一致性。 此外，讨论还深入探讨了泛型类型的 BitwiseCopyable 一致性的可确定性以及库演化的注意事项。</p><p>完整的提案可以在这里找到：<a href="https://github.com/apple/swift-evolution/pull/2314/" target="_blank" rel="noopener">BitwiseCopyable</a></p><p>3) 提议<a href="https://forums.swift.org/t/pitch-piecewise-consumption-of-noncopyable-values/70045" title="不可复制值的分段消耗" target="_blank" rel="noopener">不可复制值的分段消耗</a></p><p><strong>内容大概</strong></p><p>该提案建议放宽对某些不可复制类型的限制，以允许它们在特定场景中分段使用，旨在促进 Swift 代码中对不可复制值的更自然的操作。 目前，处理聚合中的不可复制字段面临着挑战，例如在不可复制的 Pair 类型中交换值等函数的编写困难。 所提出的解决方案建议允许在逐个字段的基础上使用非弹性、不可复制的聚合而不使用反初始化器，从而实现诸如在 Pair 内交换值之类的操作。 然而，该提案有意保留了限制：它不支持带有反初始化器的聚合的部分消耗或已消耗字段的重新初始化，并且弹性聚合永远不能被部分消耗。 讨论还包括对源代码破坏性更改的考虑以及了解部分消耗的类型布局的必要性。</p><p>完整的提案可以在这里找到：<a href="https://github.com/apple/swift-evolution/pull/2317" target="_blank" rel="noopener">https://github.com/apple/swift-evolution/pull/2317</a></p><p>4) 讨论<a href="https://forums.swift.org/t/how-to-identify-associate-swiftinterface-declarations-with-original-declarations/70342" title="如何识别/关联 swiftinterface 声明与原始声明？" target="_blank" rel="noopener">如何识别/关联 swiftinterface 声明与原始声明？</a></p><p><strong>内容大概</strong></p><p>讨论围绕识别 <code>.swiftinterface</code> 文件中的声明并将其与其原始声明关联起来，主要是为了提取有关 Swift 库中 <code>@_spi</code> 属性的信息。 但是，将 .swiftinterface 文件中的完整签名映射到 <code>lib/SymbolGraphGen</code> 发出的部分签名存在不确定性，因为它缺乏 <code>@_spi</code> 意识。 提出了各种建议，包括扩展 SymbolGen 以发出相关信息或使用索引存储来弥合 USR 和解析的源位置之间的差距。 对话还涉及为 Swift 包生成文档以及与工具链兼容性相关的挑战。 </p><p>此外，还考虑使用夜间工具链编译包，同时使用不同版本的工具链发出符号图 JSON。 总的来说，讨论探讨了潜在的解决方法和解决方案，以解决将 Swift 接口声明与其原始对应项关联的问题。</p><p>5) 讨论<a href="https://forums.swift.org/t/sharing-variables-throughout-the-application/70352" title="在整个应用程序中共享变量？" target="_blank" rel="noopener">在整个应用程序中共享变量？</a></p><p><strong>内容大概</strong></p><p>这篇文章讨论了 Swift 应用程序中全局变量的使用，特别是在多个视图之间共享数据。 用户创建一个 Global.swift 文件，在其中使用 @State 属性包装器声明一些变量。然后他们询问是否正确使用这些全局变量。 </p><p>然而，出于安全考虑，另一位用户建议不要将用户凭据等敏感信息存储在全局变量中，并建议使用用户的钥匙串。 此外，他们警告不要共享可变状态，并建议研究 @EnvironmentObject 和 @Environment 以在 SwiftUI 中的视图之间共享通用逻辑。</p><p>6) 宣布<a href="https://forums.swift.org/t/announcing-time-1-0-0-type-safe-calendar-calculations/70366" title="类型安全的日历计算" target="_blank" rel="noopener">类型安全的日历计算</a></p><p><strong>内容大概</strong></p><p>该公告推出了 Time 1.0.0，这是一个专为 Swift 中类型安全日历计算而设计的包。 它庆祝其前身 Time 0.9.0 一周年，并强调其已升级至 1.0.0 版本。 Time 提供了广泛的日期和时间操作功能，强调安全性和便利性。 主要功能包括获取设备时间、舍入时间值、按特定间隔提前时间、检索日历信息以及格式化时间数据。 </p><p>Time 通过 Swift 的类型系统确保正确性，并为无效操作提供错误处理。 它可在 GitHub 上获取，并具有有关 Swift 包索引的全面文档。 此外，Time 还提供高级功能，例如创建自定义时钟、监听时间变化、时区和区域设置之间的转换、计算日历值之间的差异等等。 总体而言，Time 简化了日期和时间操作，同时确保准确性和安全性。</p><p>7) 讨论<a href="https://forums.swift.org/t/migrating-a-threadsafe-class-to-use-modern-concurrency/70349" title="迁移 ThreadSafe 类以使用最新的并发" target="_blank" rel="noopener">迁移 ThreadSafe 类以使用最新的并发</a></p><p><strong>内容大概</strong></p><p>讨论了寻求迁移线程安全类的指导，该类利用异步写入和同步读取的同步技术，以使用现代并发技术，例如 Swift Actors。 他们提供了 A 类的代码示例，该类通过共享队列将任务发送到另一个类（缓存）来同步读取和异步写入。 他们询问在迁移到 Actor 或现代并发时如何在类之间执行类似的同步。 A 类（<code>ThreadSafeClassA</code>）包含读取和写入消息的方法，而 B 类（<code>ThreadSafeClassB</code>）则异步处理消息检索。 用户有兴趣在迁移过程中维持这种同步模式。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/mlx-swift/" title="使用 MLX 和 Swift 进行设备端机器学习研究" target="_blank" rel="noopener">使用 MLX 和 Swift 进行设备端机器学习研究</a></p><p><strong>摘要：</strong>  文章介绍了使用MLX和Swift进行设备上机器学习研究的新方法。 Swift 编程语言具有与 Python 类似的易用性和高级语法，同时又具有类似 C++ 的编译语言的速度。 MLX 是专为在苹果芯片上进行机器学习研究而设计的数组框架，提供了硬件加速和自动微分等关键功能。 </p><p>MLX Swift 将 MLX 扩展到 Swift 语言，为机器学习研究人员提供了一个全面的实验平台。该平台包括全面的 Swift API、高级神经网络和优化器包，以及文本生成和MNIST训练等示例。这一步骤标志着ML研究人员可以更轻松地在苹果设备上进行机器学习实验，并且所有组件都以MIT许可证开放源代码。通过本文，读者可以了解到如何快速开始使用 MLX Swift ，并利用其在机器学习研究中的潜力。</p><p><a href="https://juejin.cn/post/7340464722279907339/" title="Swift 字面量" target="_blank" rel="noopener">Swift 字面量</a></p><p><strong>摘要：</strong>  这篇博客主要讨论了 Swift 中的字面量（Literal）的概念及其在编写代码时的重要性。文章以 Franz Boas 在 1911 年的观察为引子，指出不同语言对于相同概念的命名方式可能存在差异，从而呈现出语言相对性的现象。Swift 提供了多种类型的字面量，包括标准字面量和自定义类型支持的字面量初始化方法。通过示例展示了如何自定义类型支持字面量初始化，以及如何扩展已有类型以支持不同类型的字面量初始化。</p><p>文章还介绍了未来可能出现的一些发展趋势，如原始字符串字面量和通过强制执行的字面初始化，以及它们对 Swift 语言和开发者的影响。最后，强调了编程语言中的词汇选择对开发者的思维方式和代码编写方式的影响，鼓励开发者利用 Swift 提供的特性使代码更加自然和高效。</p><p><a href="https://juejin.cn/post/7340471458949644351/" title="在 Swift 中创建服务层" target="_blank" rel="noopener">在 Swift 中创建服务层</a></p><p><strong>摘要：</strong>  本文介绍了在Swift中创建服务层的方法。服务层允许将与框架和 API 相关的逻辑转移到它们自己的类或结构体中，通过创建协议并实现方法和属性，可以使代码更具可重用性、可测试性和可读性。</p><p>示例项目使用了 UIKit、MVVM 设计模式和 Combine 框架的一部分。文章通过代码示例详细说明了如何创建服务层、编写单元测试以及实现模拟服务等内容。通过添加服务层，可以使代码库保持模块化，并从可重用性、单元测试覆盖率、可读性和可替换性中受益。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>如果 2024 年购车，你选择买那种车？</p><ul><li>油车</li><li>混动</li><li>电车</li></ul><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第四十八期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;倚高山之巅，方见大河奔涌。读&lt;strong&gt;Swift社区&lt;/strong&gt;，便知书海浩瀚。渺小与博大，总是同伴己身！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果突然不造车了，雷军：非常震惊！分析师：马斯克或是最大赢家&lt;/p&gt;
&lt;p&gt;提案：自定义 SerialExecutor 的隔离检查&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论在整个应用程序中共享变量&lt;/p&gt;
&lt;p&gt;推荐博文：使用 MLX 和 Swift 进行设备端机器学习研究&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;如果 2024 年购车，你选择买那种车？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十七期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十七期/</id>
    <published>2024-03-06T09:10:55.000Z</published>
    <updated>2024-03-06T09:16:41.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十七期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>倘若穷途末路，那便势如破竹。<strong>Swift社区</strong>在你心里种花，人生才不会荒芜！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：营收有望再创新高 巴克莱或将惨遭打脸？</p><p>提案：Swift Backtrace API</p><p>Swift 论坛：讨论为什么不支持 <code>var myArray: [weak MyClass]</code></p><p>推荐博文：Swift 有些场景其实不必加 final</p><p><strong>话题讨论：</strong> </p><p>把“被裁”说成“主动离职”算撒谎吗? </p><p><strong>上期话题结果</strong></p></blockquote><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/d70a6cc9-7e83-4a59-842a-066702ceb689.jpg" alt=""></p><p>技术型人才都转行跑滴滴，送外卖，做销售。那么未来的新科技研发何去何从。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果财报来袭：营收有望再创新高-巴克莱或将惨遭打脸？"><a href="#苹果财报来袭：营收有望再创新高-巴克莱或将惨遭打脸？" class="headerlink" title="苹果财报来袭：营收有望再创新高 巴克莱或将惨遭打脸？"></a>苹果财报来袭：营收有望再创新高 巴克莱或将惨遭打脸？</h3><p>鉴于本月初巴克莱、Piper Sandler 和 Redburn Atlantic 接连下调了苹果的股票评级，同时苹果爆料“一哥”郭明预计 iPhone出货量将下降 15% ，此次苹果的财报尤为受到关注。</p><p>对于投资者来说，他们不仅希望了解苹果的销售表现，还希望更深入地了解 iPhone 的销售业绩和前景，尤其是在中国的销售业绩。</p><p>大中华区营收预计减少</p><p>从华尔街分析师们的预期来看，市场仍然多数预计苹果能够在该财季取得强劲表现，并预计 iPhone 销售前景依旧乐观。假如果真如此，可能会开始扭转该公司近期相对疲软的股票表现。</p><p>据华尔街分析师预计，苹果第一财季每股盈利为 2.11 美元，营收为 1179 亿美元，都将比去年有所增长——去年同期苹果公布每股盈利为 1.88 美元，营收为 1172 亿美元。</p><p>市场调查机构 IDC 和 Canalys 近期分别发布的最新报告称，2023 年苹果成为智能手机全球销量第一，这也是苹果首次超过三星登顶智能手机年度销量冠军。基于 iPhone 去年的强劲表现，华尔街已经有分析师预测，苹果第一财季营收将创下历史新高，。</p><p>不过，苹果在大中华区的整体营收预计将从 239 亿美元降至 235 亿美元。大中华区是苹果仅次于北美和欧洲的第三大销售区域。</p><p>分析人士表示，华为高端智能手机带来竞争压力，以及中国市场需求走软，正在削弱苹果在该地区的销售前景。</p><p>iPhone 营收依旧乐观</p><p>分部门来看，华尔街预计苹果 iPhone 的营收将达到 686 亿美元，较去年同期的 657.8 亿美元有所上升。</p><p>苹果的 Mac 收入可能也将略有回升，分析师预计该季度销售额为 79 亿美元，而去年同期为 77 亿美元。</p><p>但分析师预计苹果 iPad 的营收将从去年的 94 亿美元下降逾 20 亿美元，至 70.6 亿美元。有分析称，鉴于苹果将在 3 月份推出新款 ipad 和 mac 电脑，这可能有助于提高这两个业务部门在未来一年的销量。</p><p>可穿戴设备、家居和配件本季度将带来 120 亿美元的收入，预计低于去年第一季度的 135 亿美元。这主要是由于去年末苹果公司与医疗设备制造商 Masimo 进行但专利战，迫使苹果公司暂时将这款设备下架。在那之后，虽然苹果已经从其 Series 9和Ultra 2 手表中删除了引发争议的血氧传感器组件，但目前尚不清楚这对销售有多大影响。</p><p>与此同时，苹果服务部门的销售额预计将从 208 亿美元增至 234 亿美元。</p><h3 id="Apple-为在全球范围内提供迷你-App-和游戏访问的流媒体游戏服务和-App-发布新选项"><a href="#Apple-为在全球范围内提供迷你-App-和游戏访问的流媒体游戏服务和-App-发布新选项" class="headerlink" title="Apple 为在全球范围内提供迷你 App 和游戏访问的流媒体游戏服务和 App 发布新选项"></a>Apple 为在全球范围内提供迷你 App 和游戏访问的流媒体游戏服务和 App 发布新选项</h3><p>2024 年 1 月 25 日</p><p>三月份将上线新的分析报告，供全球范围内的开发者使用</p><p>开发者还可以为其 App 启用新的登录选项</p><p>Apple 发布了与 App 向用户提供 App 内体验的方式相关的新选项，涉及流媒体游戏和迷你程序。这些新选项适用于全球范围内的 App。开发者现在可以提交单个 App 来流式传输其目录中提供的所有游戏。</p><p>App 还将能够为其中的流媒体游戏、迷你 App、迷你游戏、聊天机器人和插件提升曝光率。</p><p>此外，迷你 App、迷你游戏、聊天机器人和插件将能够接入 Apple 的 App 内购买系统，从此即可向用户提供付费数字内容或服务，例如单个聊天机器人的订阅。</p><p>App Store 上的 App 中提供的每项体验都必须遵守《App Store 审核指南》中的所有适用准则，而托管 App 的年龄分级将取决于该 App 中包含的最高年龄分级内容。</p><p>Apple 宣布的这些变化反映了 Apple 开发者社区的反馈，并践行了 App Store 的使命 — 即为用户提供一个值得信赖的平台来探索喜爱的 App 并助力全球开发者发展自己的业务。托管此内容的 App 有责任确保其中包含的所有软件符合 Apple 在用户体验和安全性上的高标准。</p><p>新的 App 分析报告<br>Apple 为开发者提供了强大的面板和报告，帮助他们通过“App 分析”、“销售和趋势”以及“支付和财务”报告来衡量 App 的表现。Apple 将为全球范围内的开发者上线新的分析报告，以帮助他们更深入地了解自己的业务和 App 的表现，这些新的报告将继续保持 Apple 的长期承诺，确保用户的个人身份无法被识别。</p><p>Apple 将通过 App Store Connect API 提供 50 多个新报告，其中包含以下方面的更多指标，以帮助开发者分析 App 的表现和发现优化机会：</p><p>参与度 — 增加了 App Store 上与开发者的 App 互动或将 App 分享给其他人的用户数量的信息；</p><p>商务 — 增加了下载次数、销售额、收入、预购量以及使用 App Store 的安全 App 内购买系统完成的交易数量的信息；</p><p>App 使用 — 增加了崩溃次数、活跃设备数、安装次数、App 删除次数等的信息。</p><p>框架使用 — 增加了 App 与操作系统功能 (例如 PhotoPicker、小组件和 CarPlay 车载) 交互的信息。</p><p>我们将于 3 月份向开发者提供有关报告详情和访问权限的更多信息。</p><p>开发者将能够通过 API 方便地向第三方授予其报告的访问权限。</p><p>App 中的登录选项更加灵活<br>Apple 正在更新其《App Store 审核指南》中关于使用“通过 Apple 登录”的内容，以践行 Apple 保护用户隐私的使命。“通过 Apple 登录”让用户能够使用其 Apple ID 轻松登录 App 和网站，此功能从设计之初就以隐私保护和安全性为重。从今天开始，在 App 中提供第三方或社交登录服务的开发者将可以选择提供“通过 Apple 登录”，或提供同等注重隐私保护的其他登录服务。</p><h3 id="Swift-Student-Challenge-将于-2-月-5-日开放申请"><a href="#Swift-Student-Challenge-将于-2-月-5-日开放申请" class="headerlink" title="Swift Student Challenge 将于 2 月 5 日开放申请"></a>Swift Student Challenge 将于 2 月 5 日开放申请</h3><p>2024 年 1 月 23 日</p><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/5D41BDFB-09E7-4A11-8376-C037FBF3DCF3/2048.jpeg" alt=""></p><p>2024 年 Swift Student Challenge 将于 2 月 5 日开放申请，我们非常期待。</p><p>正在寻找灵感？ 了解挑战赛的往届获奖者，深入了解他们打造 App 的动力。</p><p>刚刚上手？ 获取工具、提示和指导，了解创建出色 App Playground 所需的一切。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0417-task-executor-preference.md" title="SE-0417" target="_blank" rel="noopener">SE-0417</a> <strong>任务执行器偏好</strong> 提案通过审查。该提案已在 <strong>四十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0422-caller-side-default-argument-macro-expression.md" title="SE-0422" target="_blank" rel="noopener">SE-0422</a> <strong>表达式宏作为调用方默认参数</strong> 提案正在审查。</p><p>该提案旨在取消之前在 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382 表达式宏" target="_blank" rel="noopener">SE-0382 表达式宏</a>中设定的限制，以允许非内置表达式宏作为调用方默认参数表达式。</p><blockquote><p>SE-0382 表达式宏提案在24期周报中做了详细介绍。</p></blockquote><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0421-generalize-async-sequence.md" title="SE-0421" target="_blank" rel="noopener">SE-0421</a> <strong>推广 AsyncSequence 和 AsyncIteratorProtocol 的效果多态性</strong> 提案正在审查。</p><p>该提案在两个方面推广了 <code>AsyncSequence</code>：</p><ol><li>通过采用类型化的 throws 实现了适当的 throws 多态性。</li><li><code>AsyncIteratorProtocol</code> 上 <code>next</code> 要求的新重载包括一个隔离参数，以抽象化 <code>actor</code> 的隔离。</li></ol><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0420-inheritance-of-actor-isolation.md" title="SE-0420" target="_blank" rel="noopener">SE-0420</a> <strong>继承 actor 隔离性</strong> 提案正在审查。</p><p>在 Swift 的 actor 设计下，Swift 中的每个函数都具有 actor 隔离性：它要么是隔离到某个特定的 actor，要么是非隔离的。有时候，将函数赋予与其调用方相同的 actor 隔离性是有用的，这样可以让函数访问 actor 隔离的数据，或者仅仅是为了避免不必要的暂停。该提案允许异步函数选择使用这种行为。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0419-backtrace-api.md" title="SE-0419" target="_blank" rel="noopener">SE-0419</a> <strong>Swift Backtrace API</strong> 提案正在审查。</p><p>今年我们通过向 Swift 添加对回溯的一流支持，来提高 Swift 在命令行和服务器端开发中的可用性。</p><p>回溯支持包括两个部分：第一个是实际的回溯实现，第二个是 Swift 标准库中的新 API 界面。该提案涉及到后者。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-custom-isolation-checking-for-serialexecutor/69786" title="SerialExecutor 的自定义隔离检查" target="_blank" rel="noopener">SerialExecutor 的自定义隔离检查</a></p><p><strong>内容大概</strong></p><p>该提案建议通过为 SerialExecutor 引入自定义隔离检查来改进 Swift Concurrency 中的动态隔离检查。 该提案解决了由于同步、非隔离函数中缺乏静态信息而导致当前动态隔离断言失败的情况。 其动机通过一个示例来说明，其中参与者直接使用自定义执行器，从而导致错误的参与者执行器假设。 该提案旨在允许检查通过并恢复隔离信息，即使 Swift 并发运行时无法证明但目标执行器可以证明这一点。 该提案包括简介、动机、提出的解决方案、详细设计、扩展执行器比较机制、对异步代码的影响、未来方向、考虑的替代方案和修订。 完整的提案可以在这里找到。连接：<a href="https://github.com/ktoso/swift-evolution/blob/wip-executor-checkIsolated/proposals/NNNN-custom-isolation-checking-for-serialexecutor.md#proposed-solution" target="_blank" rel="noopener">https://github.com/ktoso/swift-evolution/blob/wip-executor-checkIsolated/proposals/NNNN-custom-isolation-checking-for-serialexecutor.md#proposed-solution</a></p><p>2) 讨论<a href="https://forums.swift.org/t/creating-an-attributed-string-from-a-local-html-file/69753/1" title="从本地 HTML 文件创建属性字符串" target="_blank" rel="noopener">从本地 HTML 文件创建属性字符串</a></p><p><strong>内容大概</strong></p><p>用户尝试在 Mac 应用程序的临时目录中显示来自 HTML 文件和 CSS 文件的属性字符串。 他们已使用所提供文章中的代码成功创建了临时目录，并确认已创建具有预期内容的 HTML 文件。</p><p>但是，当尝试使用以 URL 作为参数的 NSAttributedString 初始值设定项从 HTML 文件创建 NSAttributedString 时，会遇到代码 65806 的错误，并且控制台消息为“(null)”。 尽管 Google 搜索没有产生与此错误代码相关的结果，但用户尝试了另一种方法，即使用 String 结构的 write 方法将文本写入 URL。 不幸的是，这也会导致相同的 65806 错误代码。</p><p>此外，用户尝试使用 NSAttributedString 类方法 loadFromHTML 创建属性字符串，但此方法返回 Void 而不是属性字符串。</p><p>用户寻求有关如何从本地 HTML 文件成功创建属性字符串并解决神秘的 65806 错误的指导。</p><p>3) 讨论<a href="https://forums.swift.org/t/reducer-state-keeps-recomputing-every-time-an-outside-state-updates-even-with-observablestate/69788" title="每次外部状态更新时，Reducer 状态都会重新计算，即使使用 @ObservableState" target="_blank" rel="noopener">每次外部状态更新时，Reducer 状态都会重新计算，即使使用 @ObservableState</a></p><p><strong>内容大概</strong></p><p>用户在使用可组合架构 (TCA) 构建的 SwiftUI 应用程序中重新计算减速器状态时遇到问题。 具体来说，他们注意到 ShareLinkButtonView 在其自身范围之外发生的每次状态更新时都会消失。 该问题似乎与每次外部状态更新并触发整个视图重新渲染时视图重新计算或重新初始化有关。</p><p>ShareLinkButtonView 设计为仅在满足特定条件（ideaSnapshot 非零）时显示按钮。 用户正在 RootStore 中使用 @ObservableState 属性包装器来管理状态，但他们不确定为什么状态会被不必要地重新计算。</p><p>用户正在寻求有关如何防止对 RootStore 状态进行不必要的重新计算的指导。 他们在 RootStore.State 结构中使用 @ObservableState 属性包装器，并为 ShareLinkButtonView 和 RootStore 提供了相关代码片段。 这些操作涉及从 Firebase 初始化和检索 IdeaSnapshotModel，所需的行为是仅在成功检索 ideaSnapshot 时显示按钮。</p><p>潜在的解决方案可能涉及审查 @ObservableState 的使用，考虑数据流和依赖性，并确保在可组合架构中适当处理状态突变。 检查状态更新如何触发重新渲染以及是否存在影响 ShareLinkButtonView 可见性的任何意外副作用也可能会有所帮助。</p><p>4) 讨论<a href="https://forums.swift.org/t/why-not-support-var-myarray-weak-myclass/69764/2" title="为什么不支持 var myArray: [weak MyClass]" target="_blank" rel="noopener">为什么不支持 var myArray: [weak MyClass]</a></p><p><strong>内容大概</strong></p><p>为什么不支持 var myArray: [weak MyClass] - 使用 Swift - Swift 论坛<br>我认为 [weak MyClass] 不存在的原因是它在释放引用时的行为。 弱变量必须是可选的，因为当引用被释放时它会变成 nil。 无主只是假设它已分配，如果没有分配则崩溃。</p><p>在 [weak MyClass] 中，如果其中一个引用被释放，会发生什么？ 它会将自己从数组中删除吗？ 当元素随机失效时，这可能会引起一些混乱。 它会像一个可选的并且变为零吗？ 那么定义 [weak MyClass] 可能不足以清楚地表明它不是 [MyClass] 而是 [MyClass?]。</p><p>当然，可能已经有一些方法可以通过属性包装器或其他方式在 swift 中实现弱数组。 然而，要在 swift 中轻松完成此操作的语法可能需要在添加之前进行一些修改。</p><p>那么定义 [weak MyClass] 可能不足以清楚地表明它不是 [MyClass] 而是 [MyClass?]。</p><p>这个问题本身可以很容易地通过要求使用 [weak MyClass?] 来解决，就像弱属性一样。</p><p>虽然我不知道是否还有其他更令人担忧的方面（例如，由于数组的行为类似于值类型，但在底层的堆上进行内存分配和释放而导致不可忽略的性能影响），但我解释这一点的方式 语法会产生歧义：<br>从字面上理解，这意味着一旦弱实例集合中的某个对象被释放，它就会被替换为 nil。 这就是属性的处理方式。 虽然这可能没问题，但我认为人们通常会认为它已从集合中删除。<br>这也引发了一个有趣的问题，即有多少人会通过保留 nil 对象的集合来“浪费”内存……:smiley:</p><p>当然，这两种选择都是可能的，我的观点是，在我看来，[weak MyClass] 不够精确，不足以成为一种语言功能（就像这样）。 @sveinhal 的示例表明了这一点：弱集合需要有自己的自定义实现，该实现是根据所需的任何具体行为量身定制的。 也许一个提供一些更常见方法来做到这一点的小包会是一个很好的项目？</p><p>5) 讨论<a href="https://forums.swift.org/t/array-constructor-from-mirror-subject/69781" title="来自镜像主题的数组构造函数？" target="_blank" rel="noopener">来自镜像主题的数组构造函数？</a></p><p><strong>内容大概</strong></p><p>该提案建议在 Swift 中为数组类型引入一个新的初始值设定项，允许从镜像主题创建它。 该初始化程序专门针对提高元组的可用性，目前这在某些操作方面提出了挑战。</p><p>作者发现了使用元组作为固定大小数组的问题，特别是在尝试逐个元素打印其内容时。 虽然元组是表示固定大小数组的常见方法，但由于它们的预期用途是用作临时值，因此将它们视为集合仍存在一些顾虑。 该提案考虑了异构元组的潜在问题，例如迭代和映射的困难。</p><p>为了解决这些问题，作者建议允许从镜像主题初始化数组。 它们为数组类型的扩展提供了一个代码片段，该代码片段利用镜像类型来启用此初始化。 概述的好处包括鼓励将元组转换为数组以供长期使用，提供对 Collection 和 Array 方法的访问，改进使用数组而不是元组的函数参数传递，以及限制异构元组的转换。</p><p>该提案承认潜在的缺点，例如将结构转换为数组的能力以及是否需要结构到数组转换的一般问题。 总的来说，所提出的初始化程序旨在通过方便地转换为数组来增强使用元组的实用性和多功能性。</p><p>6) 讨论<a href="https://forums.swift.org/t/app-crashing-when-using-swiftdata/69748" title="使用 swiftdata 时应用程序崩溃" target="_blank" rel="noopener">使用 swiftdata 时应用程序崩溃</a></p><p><strong>内容大概</strong></p><p>用户在 iPad Pro 上的 Swift Playground 中使用 SwiftData 时遇到应用程序崩溃的情况。 尝试保存类模型时会出现此问题，并且在预览窗口和运行应用程序时都会发生此问题，特别是在输入特定导航链接（时间表）时。 用户为其应用中的不同文件提供了代码片段，包括 MyApp、ContentView、Schedule、UnitConversions、Assignment、AssignmentView 和 AddAssignment。</p><p>遇到的错误消息是：“在 ModelContainer.swift 的第 144 行发现致命错误，未能找到当前活动的分配容器。”</p><p>用户怀疑该问题可能与 ContentView 中 @Environment(.modelContext) 的使用以及 ContentView 内 VStack 上 <code>.modelContainer(for:Assignment.self)</code> 的放置有关。 他们寻求帮助来了解可能导致坠机的原因和潜在的解决方案。</p><p>建议的修复方法是从 ContentView 中删除 modelContext 并考虑将 .modelContainer（用于：Assignment.self）放在 MyApp 中的 WindowGroup 上，因为应用程序中似乎只使用了一个模型和存储。</p><p>6) 讨论<a href="https://forums.swift.org/t/appending-literals-in-string-interpolation/69749" title="在字符串插值中附加文字" target="_blank" rel="noopener">在字符串插值中附加文字</a></p><p><strong>内容大概</strong></p><p>用户正在询问字符串插值中 appendLiteral 方法的用法和潜在限制。 <code>public mutating funcappendLiteral(_literal:String)</code> 的文档提到它不应该直接调用，并且由编译器在解释字符串插值时使用。</p><p>用户在特定情况下希望自定义字符串插值的行为，特别是在本地化字符串的上下文中。 他们提供了一个示例，其中使用可变大小写的字符串插值动态构造本地化字符串键。 当使用变量进行插值时，默认行为会插入 %@ 说明符，这不是所需的结果。</p><p>为了克服这个问题，用户建议使用名为 asLiteral 的自定义 appendInterpolation 方法来扩展 LocalizedStringKey.StringInterpolation，该方法在内部调用appendLiteral。 此自定义方法允许他们避免 %@ 说明符并构建所需的本地化密钥。 用户担心未来潜在的问题或违反最佳实践的行为。</p><p>他们寻求澄清这种方法是否可以接受，或者是否有更好的解决方案可以在不违反任何规则的情况下实现预期结果。</p><p>该摘要捕获了用户对 appendLiteral 的正确使用以及他们在 Swift 中为本地化字符串键自定义字符串插值的具体情况的询问。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/swift-openapi-generator-1.0/" title="Swift OpenAPI Generator 1.0 版本发布" target="_blank" rel="noopener">Swift OpenAPI Generator 1.0 版本发布</a></p><p><strong>摘要：</strong>  Swift OpenAPI Generator 是一个用于生成类型安全、符合惯例的 Swift 代码的工具，根据 OpenAPI 文档自动生成 API 调用和服务器实现所需的代码。支持 OpenAPI 规范版本 3.0 和 3.1 ，提供更灵活的抽象方式，使开发人员能够以 API 优先的方式进行服务器开发。</p><p>生成的客户端代码为每个操作提供了一个方法，可与任何提供 Swift OpenAPI Generator 集成包的 HTTP 库一起使用。生成的服务器代码通过 “APIProtocol” 协议定义了每个操作的方法要求，适用于任何提供Swift OpenAPI Generator集成包的Web框架。</p><p><a href="https://swiftwithmajid.com/2024/01/30/visionos-ornaments-in-swiftui/" title="SwiftUI 中的 visionOS ornament" target="_blank" rel="noopener">SwiftUI 中的 visionOS ornament</a></p><p><strong>摘要：</strong>  这篇博客介绍了在 Swift 中使用 SwiftU I构建 visionOS 应用程序的方法，重点介绍了新的 SwiftUI API 中的 ornament 概念。ornament 是一种用于在不干扰窗口内容的情况下呈现与窗口相关的控件和信息的用户界面组件。文章首先展示了如何使用 TabView 创建一个基本的 ornamen t，然后介绍了如何使用 SwiftUI 的 Toolbar API 在 ornament 中添加操作控件。</p><p>此外，文章还详细讲解了如何创建自定义 ornaments ，包括控制其位置、外观和感觉。最后，总结了如何使用 SwiftUI 框架来改善 visionOS 上应用程序的用户体验。以帮助开发人员更好地适应 visionOS 平台。</p><p><a href="https://juejin.cn/post/7313242001113677862/" title="Swift 有些场景其实不必加 final" target="_blank" rel="noopener">Swift 有些场景其实不必加 final</a></p><p><strong>摘要：</strong>  这篇文章深入探讨了在 Swift 中使用 final 关键字的场景和最佳实践。作者首先介绍了 final 关键字的作用，包括防止类被继承和优化执行性能。文章指出了一些场景下是不必手动添加 final 的，比如私有类/属性和具有默认访问权限（internal）的类。特别是在使用 Whole Module Optimization（WMO）编译模式时，编译器能够自动推断是否需要添加 final。</p><p>然而，对于公共类，作者强调了需要主动考虑是否添加 final ，特别是当提供库给上层调用时，以确保性能和防止意外继承。文章在最后提到在维护项目时，主动添加 final 可以作为一种强文档的方式，提醒未来的使用者。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>近日，有网友在社交平台爆料称自己因为隐瞒裁员经历说成是主动离职而被取消了 offer 。在职场中，有些人可能选择将自己被裁员的情况描述为主动离职。把“被裁”说成“主动离职”算撒谎吗? </p><ol><li>算，不诚实</li><li>算适度美化而已</li><li>不算，很正常</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十七期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;倘若穷途末路，那便势如破竹。&lt;strong&gt;Swift社区&lt;/strong&gt;在你心里种花，人生才不会荒芜！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：营收有望再创新高 巴克莱或将惨遭打脸？&lt;/p&gt;
&lt;p&gt;提案：Swift Backtrace API&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论为什么不支持 &lt;code&gt;var myArray: [weak MyClass]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;推荐博文：Swift 有些场景其实不必加 final&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;把“被裁”说成“主动离职”算撒谎吗? &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十六期/</id>
    <published>2024-03-06T09:10:51.000Z</published>
    <updated>2024-03-06T09:16:17.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十六期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>没有永远的上游，但我们可以永远向上游。<strong>Swift社区</strong>让你如鱼得水，激流勇进！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：卖不动了？iPhone 15 系列跌破 5000 元大关</p><p>提案：Low-Level Atomic Operations 提案通过审查</p><p>Swift 论坛：讨论 <code>1 &lt;&lt; x</code> 类型推断</p><p>推荐博文：Swift 的内购测试</p><p><strong>话题讨论：</strong> </p><p>你是否设想过自己35岁之后该做什么工作呢？</p></blockquote><a id="more"></a><h3 id="卖不动了？iPhone-15-系列跌破-5000-元大关"><a href="#卖不动了？iPhone-15-系列跌破-5000-元大关" class="headerlink" title="卖不动了？iPhone 15 系列跌破 5000 元大关"></a>卖不动了？iPhone 15 系列跌破 5000 元大关</h3><p>【环球网科技综合报道】连日来，苹果全线产品在官方旗舰店以及线上平台迎来降价。<br>1 月 15 日早间，苹果（中国大陆）官网发布降价信息，1 月 18 日 - 21 日苹果部分产品新春促销，iPhone 15 全系列参与活动，手机产品最高降价 500 元，苹果笔记本电脑产品最高降价 800 元。<br>继苹果官网降价后，京东也宣布年货节活动，苹果产品京东自营旗舰店 iPhone 15 系列最高可减 1050 元、iPhone 14 最高可减750 元。其中，iPhone 15 Pro Max 256GB 版到手价 8949 元，iPhone 15 Pro 256GB 版到手价 7949 元，iPhone 15 128GB 版到手价 4949 元，以上机型全部可享限时 12 期免息。此外，iPad 指定产品最高优惠 700 元、 MacBook指定型号最高可优惠 1400 元。</p><p><img src="https://files.mdnice.com/user/17787/a1224b4a-e662-4acd-b636-8e6048943a94.png" alt=""></p><p>不难看出，相比 1 月 15 日苹果官网所公布的新春降价，此次电商平台优惠力度明显更大。业内人士称，产品接连降价，难道苹果卖不动了？<br>根据苹果公司 2023 财年财报（截至 2023 年 9 月 30 日），三季度，苹果大中华区营收为 150.84 亿美元，同比下降 2.5%；整体营收为 894.98 亿美元，下降 0.72% ，且除了 iPhone 业务以外的其他所有硬件业务均出现了同比下滑。<br>而在不久前，据美国投行杰富瑞（Jefferies）分析师发布的报告，苹果公司 iPhone 在中国市场销量下滑的颓势正在加剧，iPhone 销量在 2024 年第一周就出现了断崖式下跌，较上年同期暴跌 30% 。<br>但 Counterpoint Research 方面指出，苹果依然是高端手机市场无可争议的领导者，不过与 2022 年相比，其市场份额确有所下降。2023 年三季度，苹果手机销量同比下滑 10%，市场占有率由 2022 年同期 15.3% 下降至 14.2% 。华为、小米同期市占率分别提升了 3.8 个百分点和 1 个百分点。</p><h3 id="StoreKit-和审核指南更新"><a href="#StoreKit-和审核指南更新" class="headerlink" title="StoreKit 和审核指南更新"></a>StoreKit 和审核指南更新</h3><p>2024 年 1 月 16 日</p><p>从即日起，根据美国法院近期的一项判决，《App Store 审核指南》第 3.1.1 部分已更新，以推出 StoreKit 购买链接授权 (美国)。该授权适用于在美国店面的 iOS 或 iPadOS App Store 上提供 App 内购买项目的 App，获得授权的开发者可在 App 内包含自己网站的链接，以告知用户还有其他购买数字商品或服务的方式。</p><p>我们认为，Apple 的 App 内购买项目系统是用户购买数字商品和服务极为安全可靠的方式。因此，对于 App 内的数字商品和服务购买，你仍需使用 App 内购买项目系统。如果你考虑同时使用此授权，请务必了解，在你的网站上购买项目的顾客将无法使用某些 App Store 功能，例如“购买前询问”或“家人共享”。而且，Apple 将无法协助顾客处理退款、购买历史记录、订阅管理以及购买数字商品和服务时遇到的其他问题。你将需要与顾客一起解决此类问题。</p><p>对于通过 StoreKit 购买链接授权 (美国) 促成的数字购买，Apple 将收取一定的收益抽成。</p><h3 id="将你的-App-提交到-Apple-Vision-Pro-的-App-Store"><a href="#将你的-App-提交到-Apple-Vision-Pro-的-App-Store" class="headerlink" title="将你的 App 提交到 Apple Vision Pro 的 App Store"></a>将你的 App 提交到 Apple Vision Pro 的 App Store</h3><p>2024 年 1 月 8 日</p><p>Apple Vision Pro 将拥有全新的 App Store，帮助用户发现并下载各款出色的 visionOS App。我们提供了一个新的页面介绍如何准备 App 并将其提交到 App Store，非常适用于已构建了新的 visionOS App 的开发者，以及将向 Apple Vision Pro 用户提供 iPad 或 iPhone App 的开发者。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0410-atomics.md" title="SE-0410" target="_blank" rel="noopener">SE-0410</a> <strong>Low-Level Atomic Operations</strong> 提案通过审查。该提案已在 <strong>四十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0413-typed-throws.md" title="SE-0413" target="_blank" rel="noopener">SE-0413</a> <strong>Typed throws</strong> 提案通过审查。该提案已在 <strong>四十二期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-default-values-for-string-interpolations/69381" title="字符串插值的默认值" target="_blank" rel="noopener">字符串插值的默认值</a></p><p><strong>内容概括</strong></p><p>该提案建议向 Swift 添加一项新功能，以解决涉及可选值的字符串插值的挑战。 目前，当在字符串中插入可选值时，开发人员面临警告和提供默认值的选项有限的问题。 所提出的解决方案建议引入新的字符串插值重载，该重载允许开发人员指定默认字符串，而不管可选值的类型如何。</p><p><strong>介绍</strong></p><p>Pitch 建议在插入可选值时使用新的默认值字符串插入语法。</p><p><strong>动机</strong></p><p>字符串插值很强大，但在处理可选值时会变得复杂。<br>当前的解决方案在处理可选值时涉及繁琐的代码或不需要的输出。</p><p><strong>例子</strong></p><p>演示插入可选字符串和可选整数时的挑战。<br>当前的解决方案涉及笨拙的代码或零合并运算符的限制。</p><p><strong>建议的解决方案</strong></p><p>引入新的插值重载，允许将预期默认值指定为字符串，而不管值的类型如何。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="type">Int</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Your age: <span class="subst">\(age, <span class="keyword">default</span>: "missing")</span>"</span>)</span><br></pre></td></tr></table></figure><p><strong>详细设计</strong></p><p>这个新的插值重载的实现如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">StringInterpolation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">appendInterpolation</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> value: T?, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">default</span>: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.appendLiteral(value.<span class="built_in">map</span>(<span class="type">String</span>.<span class="keyword">init</span>(describing:)) ?? `<span class="keyword">default</span>`())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 讨论<a href="https://forums.swift.org/t/swift-rational-swift-package-for-working-with-rational-numbers/69344" title="Swift Rational - 用于处理有理数的 Swift 包" target="_blank" rel="noopener">Swift Rational - 用于处理有理数的 Swift 包</a></p><p><strong>内容概括</strong></p><p>Swift Rational 提供了 RationalModule 模块，用于在 Swift 中处理有理数。</p><p>RationalModule 导出 Rational 结构。 它符合标准 Swift 协议，如 AdditiveArithmetic、Numeric、Hashable、Comparable 等。</p><p>您可以使用分数初始值设定项创建有理值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> half = <span class="type">Rational</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x.numerator)<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(x.denominator).<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>您还可以使用整数初始值设定项。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> one = <span class="type">Rational</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>或者只是一个整数文字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> two: <span class="type">Rational</span>&lt;<span class="type">Int</span>&gt; = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>Rational 支持标准算术和比较运算符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">4</span>)<span class="comment">// Rational(3, 4)</span></span><br><span class="line"><span class="type">Rational</span>(<span class="number">1</span>)    - <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// Rational(1, 2)</span></span><br><span class="line"><span class="type">Rational</span>(<span class="number">2</span>)    * <span class="type">Rational</span>(<span class="number">3</span>, <span class="number">4</span>)<span class="comment">// Rational(3, 2)</span></span><br><span class="line"><span class="type">Rational</span>(<span class="number">1</span>)    / <span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// Rational(2, 1)</span></span><br><span class="line"><span class="type">Rational</span>(<span class="number">1</span>, <span class="number">2</span>) &lt; <span class="type">Rational</span>(<span class="number">3</span>, <span class="number">4</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Github库连接：<a href="https://github.com/abdel-17/swift-rational" target="_blank" rel="noopener">https://github.com/abdel-17/swift-rational</a></p><p>3) 讨论<a href="https://forums.swift.org/t/1-x-type-inference/69417" title="1 &lt;&lt; x 类型推断" target="_blank" rel="noopener">1 &lt;&lt; x 类型推断</a></p><p><strong>提问</strong></p><p>发现了这个区别：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">UInt64</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(type(of: <span class="number">1</span> + x))  <span class="comment">// UInt64</span></span><br><span class="line"><span class="built_in">print</span>(type(of: <span class="number">1</span> &lt;&lt; x)) <span class="comment">// Int</span></span><br></pre></td></tr></table></figure><p>第二个结果是错误还是功能？ 我也希望在那里得到 UInt64 。</p><p><strong>回答</strong></p><p>移位值中的位完全来自左侧，并且移位的限制也来自左侧，因此结果类型始终与左侧匹配。 这使您可以使用 Int8 固定字段来描述 UInt64 值的移位，这完全没问题，因为最大有用移位量为“64”。</p><p>4) 讨论<a href="https://forums.swift.org/t/how-does-type-casting-work/69350" title="类型转换是如何工作的？" target="_blank" rel="noopener">类型转换是如何工作的？</a></p><p>类型转换如何，例如 as？ 运算符，实施了吗？<br>例如，考虑 eqZero 函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eqZero</span>&lt;T&gt;<span class="params">(<span class="number">_</span> x: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> x = x <span class="keyword">as</span>? <span class="type">Int</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x 参数是否带有类型标记来检查它是否可以在运行时向下转换？<br>如果是这样，如果不使用此类转换操作，编译器是否足以优化掉此类标签？</p><p><strong>回答</strong></p><p>从技术上讲，传入的不是一个框，它“只是”一个指针，类型作为单独的参数传递。 这对于值已经在堆栈或堆上的情况很有帮助。 当您使用 Any 或 any Blah 时，会出现“box”形式，因为这样值必须与其类型保持关联，但对于泛型和某些 Blah 来说，单独传递它们会更灵活，并且可以减少分配流量。 这也意味着当在参数列表中多次使用该类型时，只需传递一次。</p><p>5) 讨论<a href="https://forums.swift.org/t/copyable-and-completion-handlers/69383" title="~Copyable 和 Completion Handlers" target="_blank" rel="noopener">~Copyable 和 Completion Handlers</a></p><p>我想编写一些代码，在其中我可以静态地确保将调用完成处理程序。 像这样的东西：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompletionHandler</span>&lt;<span class="title">T</span>&gt;: ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> f: (<span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">init</span>(f: consuming @escaping (<span class="type">T</span>) -&gt; <span class="type">Void</span>) &#123; <span class="keyword">self</span>.f = f &#125;</span><br><span class="line">    consuming <span class="function"><span class="keyword">func</span> <span class="title">callAsFunction</span><span class="params">(<span class="number">_</span> t: T)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        f(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上，这个想法是，这里的清理需要调用处理程序，因为处理程序的闭包已捕获需要释放或以其他方式解析的资源。<br>我希望将这种类型的实例传递给另一个函数，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invokeHandler</span>&lt;A&gt;<span class="params">(<span class="number">_</span> completion: consuming CompletionHandler&lt;A&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// don't invoke the handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将无法编译，因为尚未调用该类型的唯一消耗路径。<br>但这段代码看起来不错，我假设 bc 消耗可以简单地取消初始化完成处理程序。 我正在尝试做的事情是否可能或可能已计划但尚未实施？</p><p><strong>回答</strong></p><p>由于提前退出和仿制药等问题，它变得很棘手。 一种思考方式是 ~Ignorable 是与 ~Copyable 类似的条件，但又不同。 其技术术语是“线性类型”或“相关类型”，您可以在此论坛上找到一些先前的讨论。</p><p>@escaping 闭包是可复制类型，并且可复制类型的借用/消耗实际上并不能保证对值的生命周期产生静态影响，因为您始终可以通过复制值来延长生命周期。 当调用者可能拥有对值的唯一剩余引用时，使用消费是一种优化，允许调用者存储参数或将其用作聚合返回值的一部分而不复制它，或者只是提前结束其生命周期 。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2024/01/09/storekit-testing-in-swift/" title="Swift 的内购测试" target="_blank" rel="noopener">Swift 的内购测试</a></p><p><strong>摘要：</strong>  这篇博客介绍了在 Swift 中使用 StoreKitTest 框架进行应用内购买测试的方法。作者首先概述了最近 StoreKit 框架的重大变化，强调了新版本充分采用了 Swift 语言的异步和等待特性。</p><p>随后，博客详细介绍了 <code>StoreKitTest</code> 框架，该框架允许我们编写测试用例以验证应用在应用内购买、退款、ask-to-buy 和订阅过期等方面的处理能力。通过示例代码，演示了如何使用 SKTestSession 类型执行购买、管理交易、模拟退款以及测试应用对交易更新的反应。博客还提到了创建 StoreKit 配置文件的必要性。</p><p><a href="https://www.avanderlee.com/swift/swift-evolution-proposals/" title="Swift Evolution：阅读提案并从中学习" target="_blank" rel="noopener">Swift Evolution：阅读提案并从中学习</a></p><p><strong>摘要：</strong>  这篇博客介绍了 Swift 编程语言的演进过程，重点关注了通过阅读和学习 Swift Evolution 提案来了解语言变化的方式。作者指出 Swift 的不断演进源于 Swift Evolution 仓库内的公开提案，这些提案是了解最新发展的良好途径。</p><p>博客解释了 Swift Evolution 的定义和作用，强调了语言开源的特点，任何人都可以通过提出好的想法来影响未来功能和方向。提案经过讨论和批准后成为发布目标，可以在官方 Swift 网站上进行跟踪。作者还简要概述了从提出一个提案到将其纳入 Swift 发布的过程，强调了提案经历多个状态。读者被鼓励查阅 Swift Evolution 过程文档获取最新状态概述。</p><p><a href="https://juejin.cn/post/7326265442837528586/" title="ElasticSearch 与 Swift 集成" target="_blank" rel="noopener">ElasticSearch 与 Swift 集成</a></p><p><strong>摘要：</strong>  本篇博客详细介绍了 <code>Elasticsearch</code> 与 Swift 的集成，旨在帮助开发者将强大的搜索引擎功能整合到 Swift 应用程序中，提升用户体验。文章首先介绍了 Elasticsearch 和 Swift 的背景，分别强调了 Elasticsearch 作为基于 Lucene 的搜索引擎的特性，以及 Swift 作为苹果主要开发语言的优势。</p><p>核心概念与联系部分深入解释了集成前需要了解的核心概念，包括 Elasticsearch 的索引、查询、分词、词典等原理，以及 Swift 的类型安全、自动引用计数、高性能等特点。接着，文章详细探讨了集成的操作步骤，包括安装 Elasticsearch 、创建索引、使用 Swift 访问 <code>Elasticsearch</code> 、执行搜索查询等步骤。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>每个年轻人都会慢慢长大，每个程序员也会逐渐变老，你是否设想过自己 35 岁之后该做什么工作呢？</p><ol><li>努力成为中高层领导</li><li>继续专研技术成为高级程序员</li><li>成为培训老师</li><li>成为独立开发者带队出来接项目</li><li>创业单干，成就梦想</li><li>出国，国外程序员对年龄要求甚小</li><li>转行跑滴滴，送外卖，做销售。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十六期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;没有永远的上游，但我们可以永远向上游。&lt;strong&gt;Swift社区&lt;/strong&gt;让你如鱼得水，激流勇进！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：卖不动了？iPhone 15 系列跌破 5000 元大关&lt;/p&gt;
&lt;p&gt;提案：Low-Level Atomic Operations 提案通过审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 &lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt; 类型推断&lt;/p&gt;
&lt;p&gt;推荐博文：Swift 的内购测试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你是否设想过自己35岁之后该做什么工作呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十五期/</id>
    <published>2024-03-06T09:10:46.000Z</published>
    <updated>2024-03-06T09:15:50.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十五期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>我能有什么办法，失去和拥有都由不得我.<strong>Swift社区</strong>也和你一样伤心无奈，但新的一年还是要积极坚强的生活！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果或将扩充健康版图，为 Apple Watch X 铺路</p><p>提案：推断方法和关键路径文本的 Sendable 提案通过审查</p><p>Swift 论坛：讨论在循环中初始化强制属性的推荐方法？</p><p>推荐博文：手把手教你用 Swift 实现命令行工具</p><p><strong>话题讨论：</strong> </p><p>过去的 2023 年你完成了哪些目标？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/f0928233-780d-461d-b200-298fc1467e91.jpg" alt=""></p><p>根据投票结果可以看出在晋升过程中，组内成员普遍认为实际项目贡献至关重要。然而，领导风格、人际关系以及对未来发展的长远考量也受到了一定程度的重视。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果或将扩充健康版图，为Apple-Watch-X铺路"><a href="#苹果或将扩充健康版图，为Apple-Watch-X铺路" class="headerlink" title="苹果或将扩充健康版图，为Apple Watch X铺路"></a>苹果或将扩充健康版图，为Apple Watch X铺路</h3><p><img src="https://files.mdnice.com/user/17787/6e5c9342-1de5-45a6-8838-c2a2fce353c1.png" alt=""></p><p>全球市值最大的科技公司 + 前全球最大社交健身公司，会碰撞出什么样的火花？想想就能脑补出一部强强联合横扫全球的励志热血片。</p><p>上周，深水资产管理公司（Deepwater Asset Management）发布了 2024 年预测报告，其中一项预测就是苹果收购派乐腾（Peloton）公司。深水作为全球知名的资产管理公司，其预测报告还是有一定的可信度的。</p><p>大家对苹果肯定很熟悉了，那这个派乐腾又是何方神圣呢？派乐腾主营业务是销售可以联网的健身器材硬件，以及提供付费订阅的流媒体健身课程，在巅峰时期还加设了服装产品线。在 2020 年乘着「居家经济」的东风，派乐腾的股价频频上涨，屡创历史新高，一度登上了全球最大社交健身公司的宝座。</p><p>深水资产管理公司预测，如果苹果收购派乐腾，除了能通过健身器材来完善智能手表和健身追踪软件外，还能为苹果的订阅收入增加约 17 亿美元（约合人民币 121.38 亿元）。</p><p>首先，从品牌层面上看，派乐腾在居家健身领域无疑是先行者，凭借健身器材与订阅课程相结合的模式强化了用户的体验感，其中「大屏观感」是许多用户选择派乐腾的直接原因。如果完成收购，派乐腾的品牌效应会直接提升苹果在健康领域的影响力，收获大批经过筛选的忠实用户。</p><p>Apple Watch X，收购案的最大收益者。医疗健康将是苹果未来的发展方向，想不到还有其他什么产品比它更重要。这是苹果首席运营官威廉姆斯（Jeff Williams）在一场公开活动上发表的原话。</p><p>回顾苹果健康业务 9 年的发展历程，战略上主要分为两个方向。一是打造运动和健身功能吸引消费者；二是与传统医疗系统或医学机构开展合作。</p><p>Apple Watch和iPhone则是苹果健康业务的重要载体，负责给用户提供健康和健身领域的功能。其中大部分的功能都是围绕 Apple Watch 展开的，包括心率测量、睡眠监控、女性健康等。2022 年公布的 iOS 16 和 watchOS 9 中，就涵盖了多达 17 种健康功能，如今更是加入了心理健康、视力健康。</p><p>因此此时传出苹果收购派乐腾的风声，相信很可能是苹果为 Apple Watch 发布十周年之作做准备。</p><p>早在去年 1 月，就有某供应链透露消息，指苹果将在 Apple Watch 发布十周年推出类似于 iPhone X 的重大设计调整。大意是跳过 Apple Watch Series 9，直接发布 Apple Watch X。</p><p>据彭博社科技记者马克·古尔曼（Mark Gurman）报道，Apple Watch X 有望成为迄今为止 Apple Watch 最大的一次更新。有望采用更薄的表壳和新的表带，磁吸设计的表带连接方式，以及 Micro LED 显示屏。</p><p>当然，无论 Apple Watch X 在产品方面有多大调整，始终觉得智能功能才是智能手表区别于传统手表的核心。收购派乐腾将补充 Apple Watch 在健身器材上的空缺，用户在运动监测类型上的选择将更加丰富。两者建立连接，也会在一定程度上提升用户体验感。</p><h3 id="更新后的《Apple-Developer-Program-许可协议》现已发布"><a href="#更新后的《Apple-Developer-Program-许可协议》现已发布" class="headerlink" title="更新后的《Apple Developer Program 许可协议》现已发布"></a>更新后的《Apple Developer Program 许可协议》现已发布</h3><p>2023 年 12 月 22 日</p><p>《Apple Developer Program 许可协议》已经过修订，以便为更新后的政策提供支持，并对相关内容做出阐释。具体修订内容包括：</p><ul><li>定义，第 3.3.3 (N) 节：将“Tap to Present ID”更新为“ID Verifier (证件验证系统)”</li><li>定义，第 14.10 节：更新了有关管辖法律和地点的术语</li><li>第 3.3 节：为了清晰起见，对条款进行了重新组织和分类</li><li>第 3.3.3 (B) 节：阐释了隐私和第三方 SDK</li><li>第 6.7 节：更新了有关分析的条款</li><li>第 12 节：阐释了保修免责声明</li><li>附件 1：更新了 Apple 推送通知服务和本地通知的使用条款</li><li>附件 9：Apple Developer Program 会员资格中包含 Xcode Cloud 计算时间的更新条款</li></ul><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0418-inferring-sendable-for-methods.md" title="SE-0418" target="_blank" rel="noopener">SE-0418</a> <strong>推断方法和关键路径文本的 Sendable</strong> 提案通过审查。该提案已在 <strong>四十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0416-keypath-function-subtyping.md" title="SE-0416" target="_blank" rel="noopener">SE-0416</a> <strong>键路径文字作为函数的子类型</strong> 提案通过审查。该提案已在 <strong>四十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-generalize-asyncsequence-and-asynciteratorprotocol/69283" title="概括“AsyncSequence”和“AsyncIteratorProtocol”" target="_blank" rel="noopener">概括“AsyncSequence”和“AsyncIteratorProtocol”</a></p><p>文章详细介绍了 AsyncSequence 和 AsyncIteratorProtocol 的两个基本问题的解决方案：定制和限制的 <code>@rethrows</code> 属性，以及迭代 AsyncSequence 时的 Sendable 检查问题。 这包括在 提议-并发模块中的类型化抛出中描述的 AsyncSequence 和 AsyncIteratorProtocol 中采用类型化抛出，以及采用隔离参数，以便 <code>AsyncSequence</code> 和 <code>AsyncIteratorProtocol</code> 在抛出的错误类型和参与者隔离上都是多态的。</p><p>您可以在 GitHub 上查看提案草案，网址为 swift-evolution/proposals/NNNN-generalize-async-sequence.md</p><p>2) 讨论<a href="https://forums.swift.org/t/recommended-way-to-initialise-a-mandatory-property-in-a-loop/69280/4" title="在循环中初始化强制属性的推荐方法？" target="_blank" rel="noopener">在循环中初始化强制属性的推荐方法？</a></p><p><strong>内容概括</strong><br>讨论的目的是寻求有关在循环等迭代过程中初始化 Swift 结构中的强制属性 (let) 的建议。 他们尝试在结构体的 init() 函数中使用 while 循环，但由于编译器要求在退出初始化程序之前初始化所有属性而遇到错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> bang: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="comment">// do something iterative</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="comment">/* some condition */</span> &#123;</span><br><span class="line">                bang = <span class="string">"bong"</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他们考虑了各种方法：</p><ol><li>为属性设置默认值，该值适用于简单类型，但不适用于更复杂的类型。</li><li>当满足条件时使用带有break的repeat-while循环，在可读性、安全性和清晰度之间提供平衡。<br>承认解决这个问题类似于停止问题，并且编译器通常很难进行此类分析。</li><li>讨论 Swift 中循环表达式的可能性，类似于 Rust 或 Haskell 等函数式语言，其中循环可以“生成”一个值，帮助编译器进行必要的检查。<br>他们欣赏形式化循环“生成”值的想法的潜在好处，从而实现更好的编译器检查，但发现与围绕一切都是表达式构建的语言相比，针对此类功能提出的语法有点笨拙。</li></ol><p>总之，他们寻求一种特定于 Swift 的解决方案，用于在迭代过程中初始化结构中的强制属性，并讨论在 Swift 中针对此类场景引入循环表达式的挑战和潜在好处。</p><p>3) 讨论<a href="https://forums.swift.org/t/why-is-self-a-strong-reference/69264" title="为什么 self 是一个强引用？" target="_blank" rel="noopener">为什么 self 是一个强引用？</a></p><p><strong>内容概括</strong></p><p>讨论发现，通过将<a href="https://github.com/attractivechaos/plb2/pull/36" target="_blank" rel="noopener">类转换为结构</a>，消除分析结果中观察到的保留和释放调用，他们的 Swift 基准测试有了显着的性能改进。 他们质疑为什么这些调用在某些方法中是必要的，特别是当应保证 self 在整个方法执行过程中有效时。</p><p>回答认为 Swift 隐式 main 中的变量是全局变量，容易被重新赋值，需要额外的保留来保护。 他们提出了替代方案，例如将变量更改为常量或重组代码以使用真正的局部范围。</p><p>此外，他们还提到了对代码所做的更改，通过用 UnicodeScalar 数组替换 String 来减轻保留和释放调用，并强调了 String 由于处理字素簇而导致的复杂性以及分配、保留和释放调用的潜力。</p><p>也有人警告在性能至关重要时不要使用字符串或字符，并建议避免使用此类类型以减轻 ARC（自动引用计数）流量。 他们还建议在分析 ARC 行为时删除打印语句以排除与字符串相关的代码，尽管无需运行或分析修改后的代码。</p><p>4) 讨论<a href="https://forums.swift.org/t/generic-function-that-accepts-a-type-and-returns-instance-of-that-type/69269/1" title="接受 Type 并返回该 Type 的实例的通用函数" target="_blank" rel="noopener">接受 Type 并返回该 Type 的实例的通用函数</a></p><p><strong>问题</strong></p><p>该问题是由于尝试在 Swift 协议函数中使用类型参数根据条件返回特定类型实例 (shadowFilter) 而引起的。 协议 ObjectRequestable 有一个方法 getObject<t>(type: T.Type) -&gt; T? 旨在返回特定类型的实例（如果在一致类中可用）。</t></p><p>然而，在 FilterManager 的实现中，尝试将 ShadowFilter 返回为 T 会导致编译器错误，因为无法将 ShadowFilter 直接转换为泛型类型 T。编译器还会标记 ShadowFilter.self 的表达式模式与泛型类型之间的不匹配。 T 型。</p><p>这里的挑战在于尝试在协议函数内有条件地返回特定类型实例，而不需要直接类型转换。</p><p>为了实现所需的功能，可能需要替代方法或不同的代码结构方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObjectRequestable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getObject</span>&lt;T&gt;<span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShadowFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> width: <span class="type">Float</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RainbowFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterManager</span>: <span class="title">ObjectRequestable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> shadowFilter = <span class="type">ShadowFilter</span>(width: <span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getObject</span>&lt;T&gt;<span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">ShadowFilter</span>.<span class="keyword">self</span>: <span class="keyword">return</span> shadowFilter</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filterManager = <span class="type">FilterManager</span>()</span><br><span class="line"><span class="comment">// Should contain the shadowFilter instance.</span></span><br><span class="line"><span class="keyword">let</span> shadow = filterManager.getObject(type: <span class="type">ShadowFilter</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">// Should contain nil.</span></span><br><span class="line"><span class="keyword">let</span> rainbow = filterManager.getObject(type: <span class="type">RainbowFilter</span>.<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>这样写可行的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getObject</span>&lt;T&gt;<span class="params">(type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> v = shadowFilter <span class="keyword">as</span>? <span class="type">T</span> &#123; <span class="keyword">return</span> v &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5) 讨论<a href="https://forums.swift.org/t/overriding-default-protocol-implementations/69260" title="覆盖默认协议实现" target="_blank" rel="noopener">覆盖默认协议实现</a><br>我最近试图为协议 Foo 设置一个默认实现，它可以根据对象是否也符合另一个协议 Bar 为其属性 baz 返回不同的值。 当执行下面的操作时，结果是运行时崩溃 EXC_BAD_ACCESS。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> baz: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>: <span class="title">Foo</span>, <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBaz</span>: <span class="title">Foo</span>, <span class="title">Codable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> baz: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">Bar</span>)?.baz ?? <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fooBar = <span class="type">FooBar</span>()</span><br><span class="line"><span class="keyword">let</span> fooBaz = <span class="type">FooBaz</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(with foo: Foo)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(foo.baz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(with: fooBar)</span><br><span class="line">doSomething(with: fooBaz)</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>FooBar 符合 Foo。 Foo 有一个带有属性 baz 的扩展。 因此，FooBar包含一个名为 baz 的成员属性。</p><p>FooBar 符合 Bar。 Bar 需要名为 baz 的属性的实现。 由于 FooBar 包含一个名为 baz 的成员属性，其签名与 Bar 的要求（它从 Foo 获得的属性）相同，因此编译器选择它来满足要求。</p><p>当您获取 FooBar 实例上的属性 baz 时，它将 self 转换为 Bar，然后获取其 baz 属性。 但是，由于 Foo 的 baz 属性满足了 Bar 的 baz 属性要求，因此该属性最终会递归调用其 getter 直到堆栈溢出</p><p>6) 讨论<a href="https://forums.swift.org/t/sswg-0027-mongokitten/69249" title="SSWG-0027: MongoKitten" target="_blank" rel="noopener">SSWG-0027: MongoKitten</a><br><a href="https://github.com/swift-server/sswg/blob/main/proposals/0027-mongokitten.md" target="_blank" rel="noopener">SSWG-0027：MongoKitten</a> 的审核现已开始，持续两周，直至 2024 年 1 月 17 日。</p><p><strong>介绍</strong></p><p>MongoDB 是一种流行的 NoSQL 数据库管理系统，它使用面向文档的数据模型。 MongoKitten 是一个 MongoDB 客户端库，支持所有非企业功能。 它通过 BSON 的编码器和解码器支持 Codable，并且供应商专门提供基于 async/await 的 API。</p><p><strong>动机</strong></p><p>MongoKitten 是 Swift 生态系统的一个长期库，自 2015 年以来一直在开发。MongoDB 还创建了另一个数据库驱动程序，该驱动程序提供了包装其内部 C 实现的 Swift API。 然而，该驱动程序是生态系统中的一个相对较新的成员，自此已停产。</p><p>为 MongoDB 提供解决方案对于 Swift 生态系统至关重要，因为它服务于数据库市场的很大一部分。</p><p><strong>建议的解决方案</strong></p><p>MongoKitten 分为多个模块。</p><p>MongoCore 包含 MongoDB 有线协议的基本实现。</p><p>MongoClient包含一个基于该协议的MongoDB客户端。 它包含用户与 MongoDB 通信所需的所有工具。 它具有发送和接收消息以及进行身份验证的能力。 此外，MongoClient 还具有用于发送/读取消息的帮助程序，在此类连接上发送和接收符合 Codable 的消息。 最后，MongoClient 有一个 MongoDB Cluster 客户端实现，充当连接池，同时还观察集群拓扑的变化。</p><p>MongoKittenCore 是一个包含以 Codable 类型实现的最常用消息的模块。</p><p>MongoKitten 模块本身导入上述所有内容，并提供更高级别的 API 用于与 MongoDB 交互。 这是大多数用户最终与之交互的库。</p><p>最后，Meow 模块提供类似 ORM 的帮助程序，通过使您的 Codable 类型符合模型协议，可以快速存储和读取 MongoDB 中的实体。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7317288133455937599" title="swift 中的冻结枚举和非冻结枚举" target="_blank" rel="noopener">swift 中的冻结枚举和非冻结枚举</a></p><p><strong>摘要：</strong>  本博客探讨了在 Swift 中的冻结枚举和非冻结枚举的概念。回顾了在传统的 Objective-C 和 C 中，枚举类型是一个整数列表，并介绍了非冻结枚举和冻结枚举的概念，类比了 OC 中的 NS_ENUM 和NS_CLOSED_ENUM 。在 Swift中，用户定义的枚举基本上都是冻结枚举。</p><p>对于非冻结枚举，讨论了在使用 switch 语句时需要增加 @unknown default 来处理未来可能的case新增情况。相对于 default， <code>@unknown default</code> 在未列举 case 时会产生警告，而 default 不会。博客最后总结了处理非冻结枚举时的最佳实践，强调了使用 @unknown default 或 <code>@unknown case</code>  来做兜底处理的必要性，以避免在枚举有新增 case 时导致异常情况的发生。</p><p><a href="https://juejin.cn/post/7310448854628859919" title="手把手教你用 Swift 实现命令行工具" target="_blank" rel="noopener">手把手教你用 Swift 实现命令行工具</a></p><p><strong>摘要：</strong>  这篇博客讲解了用 Swift 实现命令行工具，选择 Swift 的原因包括对 Swift 开发者友好以及 Swift 作为完全开源的语言具有更强的语言抽象能力、类型系统安全性和性能。通过一个计算器示例，教读者创建项目、引入依赖（ ArgumentParser 库），以及实现加法和汇率转换功能。详细介绍了 ArgumentParser 的优点和核心逻辑，同时展示了命令行调试和发布安装的方法，最后鼓励使用Swift进行小工具开发。</p><p><a href="https://swdevnotes.com/swift/2023/conways-game-of-life-with-swiftui" title="使用 SwiftUI 创建康威生命游戏" target="_blank" rel="noopener">使用 SwiftUI 创建康威生命游戏</a></p><p><strong>摘要：</strong>  这篇博客中作者使用 SwiftUI 创建康威生命游戏（Conway’s Game of Life）。Conway’s Game of Life 是一款自动游戏，由一个 2D 网格组成，其中的细胞可以是活的或死的。每个细胞在下一代的状态基于其周围细胞在当前一代中的状态，遵循一些简单的规则。</p><p>文章首先，使用 SwiftUI 的 Grid 容器视图展示游戏状态并在游戏变化时进行动画处理；其次，实现根据游戏的四个规则从一代到下一代改变细胞状态的逻辑。展示了使用 Canvas 视图的不同方法，包括从 2D 数组和从模型获取数据的两种方式。</p><p>文章还介绍了使用 SwiftUI 创建康威生命游戏的不同视图，包括使用 Grid 和 Canvas 的不同布局方式。LifeModel 用于包含和控制生命游戏的核心逻辑，而 LifeViewModel 则用于在模型和视图之间进行桥接，实现数据的传递和控制。CanvasFromModelView 演示了如何使用 Canvas 视图显示来自 LifeModel 的数据。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>过去的 2023 年你完成了哪些目标？（多选）</p><ol><li>健康生活：保持健康饮食，维持理想的体重和健康状态。</li><li>职业发展：升职加薪，或者转换到自己满意的工作领域。</li><li>学业进步：获得更高的学历，提升专业技能。</li><li>财务自由：投资取得收益，实现财务独立和自由。</li><li>幸福家庭：建立和谐家庭关系，或者迎接新成员的到来。</li><li>旅行冒险：探索新的旅行地，或者完成一次特别的旅行。</li><li>精神成长：培养更多的兴趣爱好，深化对某领域的了解。</li><li>社交关系：建立更多深厚的友谊，拓展社交圈。</li><li>志愿者服务：参与社区服务或慈善事业。</li><li>爱情奇迹：寻找到理想的爱情关系。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十五期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;我能有什么办法，失去和拥有都由不得我.&lt;strong&gt;Swift社区&lt;/strong&gt;也和你一样伤心无奈，但新的一年还是要积极坚强的生活！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果或将扩充健康版图，为 Apple Watch X 铺路&lt;/p&gt;
&lt;p&gt;提案：推断方法和关键路径文本的 Sendable 提案通过审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论在循环中初始化强制属性的推荐方法？&lt;/p&gt;
&lt;p&gt;推荐博文：手把手教你用 Swift 实现命令行工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;过去的 2023 年你完成了哪些目标？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十四期/</id>
    <published>2024-03-06T09:10:40.000Z</published>
    <updated>2024-03-06T09:15:30.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十四期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>每天接受一点正能量，拥抱积极向上的生活态度，就像<strong>Swift社区</strong>，逐渐变得闪闪发光！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果中国工厂正加速生产Vision Pro，有望于明年2月上市</p><p>提案：推断方法和关键路径文本的 Sendable</p><p>Swift 论坛：讨论在 Raspberry Pi Pico 上运行的嵌入式 Swift</p><p>推荐博文：使用 Swift 的异步 Operation 实现并发执行任务</p><p><strong>话题讨论：</strong> </p><p>想在组内晋升的速度更快，你认为以下哪个标准更重要呢？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/b677ed19-4ebe-4e2e-a83f-823336dbb178.jpg" alt=""></p><p>根据投票结果显示了程序猿对于职业领域中性别平等的关注，强调了专业能力和领导风格的重要性。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果中国工厂正加速生产-Vision-Pro，有望于明年2月上市"><a href="#苹果中国工厂正加速生产-Vision-Pro，有望于明年2月上市" class="headerlink" title="苹果中国工厂正加速生产 Vision Pro，有望于明年2月上市"></a>苹果中国工厂正加速生产 Vision Pro，有望于明年2月上市</h3><p><img src="https://pics6.baidu.com/feed/359b033b5bb5c9ea824950a5c6b0f10d3bf3b350.jpeg@f_auto?token=e96ace0fc5e825697f2c5ce5614ebec5" alt=""></p><p>苹果 Vision Pro 离消费者越来越近了。</p><p>12 月 21 日消息，据外媒援引知情人士消息称，苹果公司正加速拓展 Vision Pro 混合现实头显的产能，为 2 月份的发售做好准备。</p><p>报道中提及，这款新头显设备的生产工作正在中国工厂全速进行，并且已持续了数周，目标是在明年 1 月底之前准备好面向客户的产品，并计划在 2 月首次亮相零售店。</p><p>与此同时，周三苹果还向软件开发人员发送了一封电子邮件，鼓励他们使用最新的工具测试他们的应用程序，并将他们的软件反馈发送给苹果，从而为 Vision Pro “做好准备”。</p><p>Vision Pro 于 2023 年 6 月发布，搭载了 12 个摄像头、5 个传感器和 6 个麦克风，采用双芯片设计，包含 M2 芯片以及苹果专门为 Vision Pro 设计的 R1 芯片。该产品凭借着出色的交互性和顶级的硬件堆叠受到业内关注。</p><p>但也受制于其设计复杂性，此前一度有苹果被迫大幅削减 Vision Pro 产量预测的消息传出。7 月，《金融时报》援引与苹果和中国代工商立讯精密关系密切的两名人士称，苹果仅准备在 2024 年生产不到 40 万台 Vision Pro ，同时推出更实惠版本的 Vision Pro 计划已被推迟。</p><p>随后有关 Vision Pro 生产的消息不断传出，今年 9 月，立讯精密董事长王来春曾透露，公司正在为明年初上市的苹果头显 Vision Pro 做生产准备。12 月 12 日，界面新闻从供应链获悉，因为 OLEDoS 显示屏的产能瓶颈被中国内地公司突破并进入一供，目前供应链已经做好了年产 100 万台的准备。</p><p>Vision Pro 是苹果公司自 2015 年开始销售智能手表以来推出的又一个新产品类别，对于苹果的重要程度不言而喻。据了解，苹果已经在开发该设备操作系统的下一版本 VisionOS ，该软件预计将于 2024 年晚些时候推出，同时还将推出与苹果其他主要设备相关的操作系统。</p><h3 id="美媒：苹果将在美暂停销售最新款智能手表"><a href="#美媒：苹果将在美暂停销售最新款智能手表" class="headerlink" title="美媒：苹果将在美暂停销售最新款智能手表"></a>美媒：苹果将在美暂停销售最新款智能手表</h3><p>参考消息网 12 月 20 日报道 据美国《纽约时报》网站 12 月 18 日报道，苹果公司 18 日表示，将从 21 日开始暂停其最新款智能手表的线上销售。该款手表在实体店的销售也将在 12 月 24 日之后暂停。</p><p>两个月前，苹果公司输掉了关于其智能手表用来检测人们脉搏的技术专利案。该公司被要求在圣诞节后停止销售苹果 Series 9 和 Ultra 2 这两款智能手表，这可能会在假日购物的最后一周引发该手表销量的激增。</p><p>苹果公司采取这一举措前，美国国际贸易委员会今年 10 月的裁决认定，苹果公司的几款智能手表侵犯了位于美国加利福尼亚州马西莫公司的专利。</p><p>法庭上，马西莫公司详细讲述了苹果公司如何挖走其高管和其他十几名员工，紧跟着如何又发布了一款配备脉搏血氧计的手表。而该技术是马西莫公司的专利。</p><p>为了避免全面禁止销售，苹果公司曾有两个月与马西莫公司达成协议，以获得该公司的技术许可，或者也可以请求拜登政府推翻这一裁决。</p><p>马西莫公司首席执行官乔·基亚尼在接受采访时说，但苹果公司没有就相关技术许可与其谈判。相反，苹果公司已推动拜登总统否决国际贸易委员会的裁决，基亚尼之所以知道这些，是因为政府就苹果公司的请求与马西莫公司进行了接触。</p><p>基亚尼在谈到国际贸易委员会时说：“他们试图让该机构看起来像在帮助专利流氓。”</p><p>对基亚尼的言论，苹果公司没有回应置评请求。苹果公司在一份声明中称：“苹果公司强烈反对这一命令，正在寻求一系列法律和技术方案，以确保消费者可以买到苹果手表。”拜登政府没有立即回应置评请求。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0412-strict-concurrency-for-global-variables.md" title="SE-0412" target="_blank" rel="noopener">SE-0412</a> <strong>全局变量的严格并发性</strong> 提案通过审查。该提案已在 <strong>四十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0418-inferring-sendable-for-methods.md" title="SE-0418" target="_blank" rel="noopener">SE-0418</a> <strong>推断方法和关键路径文本的 Sendable</strong> 提案正在审查。</p><p>此提案聚焦于在使用并发时围绕函数作为值和关键路径文本语言的一些边缘情况。我们建议为部分和未应用的方法推断 <code>Sendability</code>。我们还建议通过允许开发人员控制关键路径文本是否是 Sendable，来解除 SE-0302 放置在关键路径文本上的 Sendability 限制。目标是在不对 Swift 进行重大更改的情况下提高灵活性、简便性和人机工程学。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0417-task-executor-preference.md" title="SE-0417" target="_blank" rel="noopener">SE-0417</a> <strong>任务执行器偏好</strong> 提案正在审查。</p><p>Swift Concurrency 使用任务和 actor 来建模并发，并主要依赖于 actor 隔离来确定特定代码应在何处执行。</p><p>SE-0392 最近引入的自定义 actor 执行器允许自定义特定 <code>SerialExecutor</code> 实现代码应该在其中运行，同时隔离到特定的 actor。这使得开发人员可以对 actor 的确切线程语义获得一定控制，例如，通过确保特定 actor 执行的所有工作都在专用队列或线程上完成。</p><p>然而，目前一般任务和非隔离的异步函数没有同样的灵活性，非隔离的异步函数总是在由 Swift Concurrency 管理的默认全局并发线程池上执行。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0416-keypath-function-subtyping.md" title="SE-0416" target="_blank" rel="noopener">SE-0416</a> <strong>键路径文字作为函数的子类型</strong> 提案正在审查。</p><p>目前，键路径文字只能被狭义地转换为与参数和返回类型完全匹配的函数。该提案允许键路径文字参与到我们允许在任意函数类型之间进行的完全泛化的转换中，使得以下代码能够在没有错误的情况下编译：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="number">_</span>: (<span class="type">String</span>) -&gt; <span class="type">Int</span>? = \.<span class="built_in">count</span></span><br></pre></td></tr></table></figure><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0415-function-body-macros.md" title="SE-0415" target="_blank" rel="noopener">SE-0415</a> <strong>函数体 Macros</strong> 提案被驳回。该提案已在 <strong>四十三期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0414-region-based-isolation.md" title="SE-0414" target="_blank" rel="noopener">SE-0414</a> <strong>基于区域的隔离</strong> 提案被驳回。该提案已在 <strong>四十三期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/embedded-swift-running-on-the-raspberry-pi-pico/69001" title="在 Raspberry Pi Pico 上运行的嵌入式 Swift" target="_blank" rel="noopener">在 Raspberry Pi Pico 上运行的嵌入式 Swift</a></p><p><strong>内容概括</strong></p><p>Nikolai Ruhe 和一位合作者成功在 Raspberry Pi Pico 10 微控制器 (RP2040 MCU) 上运行嵌入式 Swift 26 代码。 该代码可在 GitHub 上找到，通过使用 Swift 直接操作 MCU 的内存映射寄存器来闪烁 Pico 的板载 LED。</p><p>该设置涉及在 Raspberry Pi Pico C/C++ SDK 3 上构建的主 C 程序，并使用 CMake 作为构建系统。 定义了一个名为 SwiftLib 的 Swift 库，使用 CMake 进行编译，并静态链接到主可执行文件中。 主 C 程序和 SwiftLib 之间的通信是通过 C 标头实现的。</p><p>为了控制 LED，Swift 代码利用 RP2040 MCU I/O 块的特定内存地址，根据 C 代码调用的函数切换 GPIO 引脚。 虽然这一成就令人兴奋，但也强调了一些需要改进的领域：</p><ol><li>从 <code>CMake</code> 过渡到 Swift Package Manager (SwiftPM)，以便更轻松地进行构建管理和其他 Swift 库的集成。 然而，由于 SDK 的复杂性以及与 CMake 的密切联系，将 Pico C SDK 与 SwiftPM 集成可能具有挑战性。</li><li>Swift-MMIO 的集成，由于 SwiftPM 尝试在嵌入式 Swift 模式下构建 <code>SwiftSyntax</code> 不兼容，因此遇到了困难。 解决此问题需要指定 SwiftPM 应为主机和目标平台构建哪些目标。</li><li>解决由于缺少内存分配和原子等运行时函数而导致的链接器错误。 虽然空的实现使链接器保持沉默，但这并不是一个理想的解决方案。 嵌入式 Swift 中的 <code>-no-allocations</code> 模式可能会部分解决这个问题，尽管它可能无法涵盖所有必要的运行时函数。</li></ol><p>该团队热衷于改进这些方面，并希望简化在 Raspberry Pi Pico 上运行嵌入式 Swift 的流程，同时集成更多 Swift 库并增强与构建系统的兼容性。</p><p>2) 提议<a href="https://forums.swift.org/t/accepted-se-0413-typed-throws/69099" title="SE-0413: Typed throws" target="_blank" rel="noopener">SE-0413: Typed throws</a></p><p><strong>内容概括</strong></p><p>SE-0413，Typed Throws 的提案，经过 11 月 16 日至 12 月 7 日的审核后已被接受。</p><p>审查过程中，重点关注了以下具体细节：</p><ol><li>括号：有人讨论了在 throws 声明语法中使用括号的问题，其中一些人表示不喜欢 throws(CatError) 格式。 虽然承认不喜欢括号，但它被认为是目前解决语法中潜在歧义的最佳选择。 如果经验表明不会引入歧义，未来的修订可能会考虑删除它们。</li><li>显式错误类型注释：审核期间的反馈强调了在 do/catch 块中对显式错误类型注释的需求。 该提案已更新为允许（但不强制）通过语法 do throws(ErrorType) 指定错误类型。</li><li>Rethrows 关键字：关于类型化抛出可能会使 rethrows 关键字变得多余的讨论已得到认可。 然而，目前尚未做出有关其未来的决定。 该提案概述了替代方案，但推迟了决定以供稍后考虑。</li></ol><p>Steve Canon 对社区的参与表示感谢，并指出尽管进行了漫长而激烈的讨论，但仍产生了宝贵的见解并有助于完善提案。</p><p>总体而言，该过程虽然广泛，但受到了积极评价，并认可了社区在塑造和增强 Swift 作为一种语言方面所做的贡献。</p><p>3) 讨论<a href="https://forums.swift.org/t/what-to-do-about-static-func-main-throws/69031" title="对于 static func main() throws 该怎么办？" target="_blank" rel="noopener">对于 static func main() throws 该怎么办？</a></p><p><strong>内容概括</strong></p><p>讨论围绕 Swift 中 static func main() throws 的行为以及潜在的改进展开。</p><ol><li>处理 Main() 中的错误：有人建议，从 main() 中抛出错误应该打印错误，然后以状态代码退出（例如 exit(1)），而不是崩溃。 这种行为被认为是合理的默认行为。</li><li>标准化系统错误类型：有人提出了标准化系统错误类型的想法，当抛出该类型时，会触发特定的预定义行为。 然而，由于其潜在的特定于应用程序的性质，人们对标准化持怀疑态度。</li><li>提案探索：之前曾尝试过解决方案，但遇到了障碍，包括关于直接暴露退出以及 Linux 上 <code>CommandLine.arguments</code> 中不一致的讨论。 有一个潜在的计划提出一个更全面的主入口点，包括传递参数和返回代码，尽管这可能不是主要用于抛出目的。</li><li>从顶级代码返回：Doug 关于直接从顶级代码返回的能力（尤其是在保护块内）的建议引起了人们的兴趣。 在某些情况下，例如从 main 提前退出，此功能可以取代当前的 fatalError。</li></ol><p>然而，由于时间和资源的限制，立即推动这些提案存在不确定性。</p><p>讨论涉及改进 main() 中的错误处理、探索标准化错误类型的潜力，以及考虑早期退出和顶级代码中的错误处理的替代方案。 尽管人们对这些想法很感兴趣，但由于资源限制，立即实施尚不确定。</p><p>4) 讨论<a href="https://forums.swift.org/t/how-does-the-swift-runtime-actually-respond-to-memory-pressure/69024" title="swift 运行时实际上如何应对内存压力？" target="_blank" rel="noopener"> swift 运行时实际上如何应对内存压力？</a></p><p><strong>内容概括</strong></p><p>讨论的重点是 Swift 的内存管理行为以及操作系统级内存限制下的处理。</p><ol><li>观察 Swift 的内存使用情况：值得注意的是，除非施加操作系统级别的内存限制（例如 MemoryHigh 或 MemoryMax），否则 Swift 的内存使用量往往会持续增长。 在守护进程配置中实现这些限制似乎可以使 Swift 重用分配的内存，而不是不断地从操作系统请求新的内存页面。</li><li>接近内存限制的行为：尽管设置了这些内存限制，但当提交大量连续的内存密集型工作时，应用程序在接近这些限制时有时会变得无响应。 即使当前内存使用量与设置限制之间存在很小的差距（大约 1.1MB），也会发生这种情况。</li><li>无响应的根本原因：无响应的原因是守护进程级内存限制，而不是系统级内存耗尽。 没有观察到交换，并且操作系统保持响应。 如果没有内存限制，随着时间的推移，Swift 往往会消耗所有可用内存，从而影响包括 SSH 在内的其他进程，并需要重新启动系统来中断。<br>提出的主要问题是：</li></ol><p>Swift 运行时如何对操作系统级内存限制做出反应？</p><p>如何防止或减轻接近这些限制时的冻结行为？</p><p>本质上，该调查旨在深入了解 Swift 在施加内存限制方面的行为，并寻求解决方案来防止应用程序在接近这些限制时冻结，尽管在守护进程级别强制执行内存上限。</p><p><strong>回复</strong></p><p>Swift 运行时会传递到 malloc 和 free，因此你实际上只是在此处分析系统分配器的内存使用模式。 不同的 malloc 实现可能会以你喜欢的方式重复使用内存。</p><p>标准 glibc 分配器的行为通常不太好，我们在服务器生态系统中听到了大量报告，人们转而使用替代分配器，并看到了一种更稳定的内存使用方式。 然而，很难普遍地说 tcmalloc 或 jemalloc 是最好的分配器，因为它总是取决于分配模式。 我希望在 Swift 中看到的是能够像 Rust 的 GlobalAllocator 4 所允许的那样挂钩全局分配器。</p><p>这将允许我们为各种分配器出售包，人们可以根据包进行切换，而不是捆绑和预加载分配器</p><p>5) 讨论<a href="https://forums.swift.org/t/surprising-compilation-performance-of-nested-init-vs-constructable/69052" title="嵌套 .init() 与 Constructable() 令人惊讶的编译性能" target="_blank" rel="noopener">嵌套 .init() 与 Constructable() 令人惊讶的编译性能</a></p><p><strong>内容概括</strong></p><p>用户在 Swift 中执行性能测试，涉及使用两种不同方法初始化嵌套结构：<strong>类型化 init 和裸 init</strong>。 使用不同的 Xcode 版本对代码进行了测试，一致地，.init 方法比类型化 init 方法更快。</p><p>该测试涉及重复创建嵌套结构的实例（从 0 到 999），尽管类型化 init 方法需要类型推导，但它在多个 Xcode 版本中始终比 .init 方法慢。 这种差异很明显，Xcode 15.2 中 .init 方法的速度是原来的两倍多。</p><p>用户对观察到的性能差异感到困惑，因为类型化的 init 方法应该推断类型，通常会导致更快的执行。 他们提到了使用嵌套 .init 方法导致性能显着降低的实例，需要键入所有内容才能提高性能。</p><p>讨论涉及探索 Swift 嵌套结构初始化中类型化 init 和 .init 方法之间意外的性能差异。 尽管由于类型推导，类型化 init 理论上会更快，但 .init 方法在特定测试场景中始终表现出卓越的性能。</p><p>6) 提议<a href="https://forums.swift.org/t/swift-async-algorithms-proposal-asyncbackpressuredstream/69067" title="Swift 异步算法提案：AsyncBackPressuredStream" target="_blank" rel="noopener">Swift 异步算法提案：AsyncBackPressuredStream</a></p><p><strong>内容概括</strong></p><p>讨论涉及提议将 SE-0406 包含到 swift-async-algorithms 包中，SE-0406 引入了对 AsyncStream 的反压支持。 该提案附有修订后的提案以及特定拉取请求 (PR) 中提供的实现。</p><p>该提案中概述的主要变化包括：</p><ol><li>在 AsyncAlgorithms 中引入新的 Async[NonThrowing]BackPressuredStream 类型，而不是向 Async[Throwing]Stream 添加新的工厂方法。</li><li>为水印策略添加自定义元素大小计算，当流的元素是集合时特别有用，允许考虑水印集合的元素计数。</li></ol><p>该提案邀请对 SE-0406 的纳入和修改提供反馈和想法。 社区响应普遍表示支持将此功能合并到异步算法包中，因为它对于确保正确的异步数据流具有重要意义。</p><p>人们一致认为，此类功能至关重要，但正确实施具有挑战性，因此拥有 Apple 支持的中心实施地点是有益的。 一些成员表示更喜欢包方法，而不是直接将这些功能嵌入到标准库中，因为它提供了按照自己的节奏进行演变和调整的自由，尽管包依赖性存在潜在的缺点。</p><p>总体而言，该提案因其增强异步数据流的重要性和潜力而获得了积极的反馈，同时还讨论了将这些功能集成到包中而不是标准库中的优点。</p><p>7) 提议<a href="https://forums.swift.org/t/accepted-se-0270-add-collection-operations-on-noncontiguous-elements/69080" title="SE-0270：在非连续元素上添加 Collection 操作" target="_blank" rel="noopener">SE-0270：在非连续元素上添加 Collection 操作</a></p><p><strong>内容概括</strong></p><p>SE-0270 的第四次审查于 12 月 6 日至 18 日进行，重点是添加对非连续元素的收集操作。 这次审查的目的是重新评估标准库接受的提案，并考虑审查公告中概述的小修改。</p><p>审核期间的反馈主要围绕语言指导小组 (LSG) 讨论的两个关键问题。</p><ol><li>RangeSet包含：争论的焦点是RangeSet作为一种特殊的数据结构是否适合包含在标准库中。 虽然 LSG 通常不愿独立添加此类专用结构，但这里的上下文是在非连续集合元素上添加算法。 为了有效地表达这些算法，使用像 RangeSet 这样的类型变得至关重要。 考虑到这些算法的更广泛必要性，LSG 发现包含 RangeSet 等专门集合以提高 API 效率更为明智。</li><li>API 命名：讨论了各种 API 的命名，特别是 RangeSet 和索引方法。 一些审稿人认为命名不一致并建议进行修改。</li></ol><p>然而，LSG 对提议的名称感到满意。 RangeSet 被认为是更通用的结构，并且像 <code>index(of:)</code> 这样的方法名称被认为是合适的，因为 RangeSet<indextype> 代表了比单独的集合索引集更广泛的概念。</indextype></p><p>经过讨论和考虑，SE-0270 已被接受纳入标准库。 审核经理 John McCall 对所有贡献者的宝贵参与表示感谢，并强调他们在推动 Swift 作为一种语言发展方面所发挥的作用。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7078881864030617607" title="iOS - 渲染原理" target="_blank" rel="noopener">iOS - 渲染原理</a></p><p><strong>摘要：</strong>  文章详细介绍了 iOS 中的渲染原理。首先，讲解了图像渲染流水线的步骤，包括应用处理阶段、几何处理阶段、光栅化阶段和屏幕成像。接着，讨论了渲染流水线可能引发的问题，如屏幕撕裂和掉帧，并提出了解决方法。</p><p>然后，介绍了 iOS 中的渲染框架，包括 CALayer 和 Core Animation ，以及它们在渲染流程中的作用。最后，详细解释了 Core Animation 渲染的全流程，包括事件处理、布局、绘制、打包和显示等步骤。整篇文章深入浅出地介绍了 iOS 中的渲染原理和相关框架，对理解iOS应用的图像渲染过程具有一定的帮助。</p><p><a href="https://juejin.cn/post/7309313938785124371" title="Swift 编译优化 - 代码优化" target="_blank" rel="noopener">Swift 编译优化 - 代码优化</a></p><p><strong>摘要：</strong>  本文讨论了 Swift 编译优化中的代码优化问题。首先介绍了复杂的运算对编译耗时的影响，建议避免过多次运算和超过两种运算符号的计算式。接着通过几个示例展示了不同类型推断方式对编译耗时的影响，包括简单的类型推断、加法计算、加法和减法计算、多种运算符号计算等。</p><p>然后讨论了字符串的拼接方式，推荐使用 “(str1) + (str2)” 的方式。接下来介绍了类型推断中的变量定义和明确类型声明对编译时间的影响，并给出了具体示例。另外，还讨论了 CGSize、CGRect、Dictionary 和Array 等类型中避免计算、解包和三目运算等优化建议。最后，提到了删除 Xib 文件和转换为 String 的优化方法，并给出了相关示例。</p><p><a href="https://juejin.cn/post/7314093226956554250" title="使用 Swift 的异步 Operation 实现并发执行任务" target="_blank" rel="noopener">使用 Swift 的异步 Operation 实现并发执行任务</a></p><p><strong>摘要：</strong>  文章介绍了使用 Swift 的异步 Operation 实现并发执行任务的方法。通过异步 Operation，可以在其内部执行耗时任务而不阻塞主线程 UI，提高用户体验。异步操作相比同步操作更灵活，可以手动启动、执行耗时任务、将任务派发到另一个队列，并且易于管理任务的执行顺序和依赖关系。</p><p>文章还演示了创建异步 Operation 的步骤，包括重写 isAsynchronous 属性和管理异步 Operation 状态的方法。通过使用多线程和 KVO ，确保任务能够正常异步工作，提高代码的可读性和维护性。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>想在组内晋升的速度更快，你认为以下哪个标准更重要呢？</p><ol><li>工作经验/时间长短</li><li>对项目贡献多业绩多</li><li>掌控细节并且获得组员的信任</li><li>喜欢创新和求知，对自己也高要求</li><li>对项目的发展有长远的大局观</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十四期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;每天接受一点正能量，拥抱积极向上的生活态度，就像&lt;strong&gt;Swift社区&lt;/strong&gt;，逐渐变得闪闪发光！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果中国工厂正加速生产Vision Pro，有望于明年2月上市&lt;/p&gt;
&lt;p&gt;提案：推断方法和关键路径文本的 Sendable&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论在 Raspberry Pi Pico 上运行的嵌入式 Swift&lt;/p&gt;
&lt;p&gt;推荐博文：使用 Swift 的异步 Operation 实现并发执行任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;想在组内晋升的速度更快，你认为以下哪个标准更重要呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十三期/</id>
    <published>2024-03-06T09:10:37.000Z</published>
    <updated>2024-03-06T09:15:07.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十三期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>命是弱者的借口，运是强者的谦辞，辉煌与否？且看<strong>Swift社区</strong>强中意！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone 破发促销、印度市场寻增量，苹果再攀 3 万亿美元高点</p><p>提案：函数体 Macros 提案正在审查中</p><p>Swift 论坛：Swift 中引入函数体宏</p><p>推荐博文：在 SwiftUI 中实战使用 MapKit API</p><p><strong>话题讨论：</strong> </p><p>你是更能接受同性上司还是更能接受异性上司？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/5fd68ce5-d014-45ed-b021-6285dc8d8abe.jpg" alt=""></p><p>投票结果反映，大多数开发者还是比较担心自己的头发，另外就是身体变胖。久坐缺乏运动会导致一系列的身体健康问题。建议大家抽时间多运动，避免久坐。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="关于-App-Store-提交的隐私更新"><a href="#关于-App-Store-提交的隐私更新" class="headerlink" title="关于 App Store 提交的隐私更新"></a>关于 App Store 提交的隐私更新</h3><p>2023 年 12 月 7 日，第三方 SDK 隐私清单和签名。 第三方软件开发工具包 (SDK) 能够为 App 提供强大的功能，同时也可能会影响用户隐私，而这些影响可能对开发者和用户来说并不明显。请注意，当你将第三方 SDK 与你的 App 搭配使用时，你需要对 App 中使用的相应 SDK 包含的所有代码负责，并且需要了解 SDK 的数据收集和使用实践。</p><p>在 WWDC23 (简体中文字幕) 上，我们宣布了新的 SDK 隐私清单和签名，以帮助 App 开发者更好地了解第三方 SDK 如何使用数据、保护软件依赖项并为用户提供额外的隐私保护。从 2024 年春季开始，如果你提交的新 App 或 App 更新添加了 App Store 上的 App 中常用的第三方 SDK，那么你需要包含相应 SDK 的隐私清单。将 SDK 用作二进制文件依赖项时，也需要包含签名。此功能对于所有 App 来说都是向前迈出的重要一步，我们鼓励所有 SDK 采用这项功能，以更好地支持依赖于相应 SDK 的 App。</p><p>需要声明原因的 API 的新用例。 如果你上传到 App Store Connect 的新 App 或 App 更新使用了需要声明原因的 API (包括第三方 SDK 使用的 API)，而你没有在 App 的隐私清单中提供批准的原因，那么你会收到通知。根据我们收到的开发者反馈，批准的原因列表已扩展到包含更多用例。如果你的用例可让用户直接受益，但未在现有批准原因列表中，请提交请求 (英文) 以便我们添加新的原因。</p><p>从 2024 年春季开始，若要将新 App 或 App 更新上传到 App Store Connect，你需要在 App 的隐私清单中注明批准的原因，以准确反映你的 App 如何使用相应 API。</p><h3 id="iPhone-破发促销、印度市场寻增量，苹果再攀-3-万亿美元高点"><a href="#iPhone-破发促销、印度市场寻增量，苹果再攀-3-万亿美元高点" class="headerlink" title="iPhone 破发促销、印度市场寻增量，苹果再攀 3 万亿美元高点"></a>iPhone 破发促销、印度市场寻增量，苹果再攀 3 万亿美元高点</h3><p><img src="https://pics5.baidu.com/feed/8cb1cb1349540923a29e57537f7ee504b2de49df.jpeg@f_auto?token=8e4dedccfd364ba7338ad8a0f473afb1" alt=""></p><p>作为全球科技公司的标杆，苹果公司的市值在今年 8 月初创下了新高，突破了 3 万亿美元的大关。不过，由于手机、PC 等市场的波动，加上外部多种因素的影响，近几月的时间，苹果公司的股价起起伏伏，市场也都在等待苹果何时能够再次站上 3 万亿美元的高点。</p><p>四个月的等待后，这一节点被定格在了美国当地时间 12 月 5 日。截至美股当日收盘，苹果公司股价报收于 193.42 美元，上涨 2.11% ，总市值达 3.01 万亿美元。</p><p><img src="https://pics1.baidu.com/feed/b7fd5266d0160924145e91b4312101f7e7cd34dd.jpeg@f_auto?token=509090cf3dfb0bf361fc007a1a56c038" alt=""></p><p>临近 2023 年年底，苹果公司股价 3 万亿美元的再次冲关，也算是给过去起伏的一年收了个尾。回望过去的一年，作为贡献出近一半收入的产品，iPhone 也未能幸免于整个大环境的下滑。为了提振销量，渠道商不得不降价促销，而新品开售破发加速、华为 5G 的回归更是给了苹果重重一击。</p><p>不过，依然需要指出的是，在绝大部分手机品牌亏本做买卖的同时，苹果公司则是赚走了全球超 8 成的利润。另外，印度市场的崛起，也让苹果公司找到了新增量。</p><p>Counterpoint 高级分析师 Ivan Lam 对钛媒体 App 表示，“印度俨然已经成为了人口第一大国，而且出生率还不错，年轻群体庞大且消费活跃。对于苹果来说，是未来十年的一个重要潜力市场。”</p><h3 id="假日将至，请为你的-App-做好准备"><a href="#假日将至，请为你的-App-做好准备" class="headerlink" title="假日将至，请为你的 App 做好准备"></a>假日将至，请为你的 App 做好准备</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/11B79680-81C3-4BFE-B897-9EF81F273D99/2048.jpeg" alt=""></p><p>App Store 最繁忙的季节即将到来！确保及时更新你的 App 和游戏，并在岁末假日到来之前做好准备。整个假日季期间同样会开放 App 提交，我们非常期待看到你提交的 App。平均而言，90% 的提交内容会在 24 小时内得到审核。但请注意，在 12 月 22 日至 27 日，完成审核所需的时间可能略长一些。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0411-isolated-default-values.md" title="SE-0411" target="_blank" rel="noopener">SE-0411</a> <strong>隔离的默认值表达式</strong> 提案通过审查。该提案已在 <strong>四十期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0414-region-based-isolation.md" title="SE-0414" target="_blank" rel="noopener">SE-0414</a> <strong>基于区域的隔离</strong> 提案正在审查。</p><p>Swift Concurrency 将值分配给由 actor 和任务边界确定的隔离域。在不同隔离域中运行的代码可以并发执行，并且通过 Sendable 检查，防止非 Sendable 值跨越隔离边界传递，从而彻底消除对共享可变状态的并发访问。在实践中，这是一个重要的语义限制，因为它禁止了无数据竞争的自然编程模式。</p><p>在本文档中，我们提出通过引入一种新的控制流敏感的诊断来放宽这些规则，该诊断确定非 Sendable 值是否可以安全地在隔离边界上传递。通过引入隔离区域的概念，编译器可以保守地推断两个值是否可能相互影响。通过使用隔离区域，语言可以证明在将非 Sendable 值传递过隔离边界后，该值（以及可能引用它的任何其他值）在调用者中不会被使用，从而防止竞争的发生。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0415-function-body-macros.md" title="SE-0415" target="_blank" rel="noopener">SE-0415</a> <strong>函数体 Macros</strong> 提案正在审查。</p><p>宏通过附加代码来增强 Swift 程序，其中包括新的声明、表达式和语句。目前，宏系统不支持可能希望增强代码的关键方式之一，即合成或更新函数的主体。可以创建具有自己函数主体的新函数，但不能为用户声明的函数提供、增强或替换函数主体。</p><p>该提案引入了函数体宏，确切地说：允许根据声明全面合成函数主体，以及通过更多功能增强现有函数主体。这为宏提供了许多新的用例，包括：</p><ul><li>根据函数声明和一些元数据（例如自动合成传递提供的参数的远程过程调用）全面合成函数主体。</li><li>通过执行日志/跟踪、检查前置条件或建立不变量来增强函数主体。</li><li>根据提供的实现替换函数主体。例如，将主体移入在其他地方执行的闭包中，或将主体视为宏“降低”为可执行代码的特定领域语言。</li></ul><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/se-0415-function-body-macros/68847" title="SE-0415：函数体宏" target="_blank" rel="noopener">SE-0415：函数体宏</a></p><p><strong>内容概括</strong></p><p>SE-0415 提议在 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0415-function-body-macros.md" title="Swift 中引入函数体宏" target="_blank" rel="noopener">Swift 中引入函数体宏</a>。 该提案的审核期截至 2023 年 12 月 20 日。该提案建议启用一项可通过带有 -enable-experimental-feature BodyMacros 标志的主干开发快照访问的功能。</p><p>审核过程鼓励反馈以改进提案。 它要求审阅者评估所解决问题的重要性、提案是否符合 Swift 的方向，并将其与其他语言或库中的类似功能（如果适用）进行比较。 Tony Allevato 作为审核经理负责监督此审核流程。</p><p>讨论的序言中提出的一个具体问题提到，所提议的宏可能无法有效地处理从函数体抛出的错误。 有人建议使用一种新的延迟块来捕获抛出的错误，从而允许访问块内的这些错误以进行处理。</p><p>所提出的语法示例演示了一个概念，其中 defer 块可能会捕获从函数体抛出的错误并执行报告错误和重新抛出错误等操作。</p><p>2) 讨论<a href="https://forums.swift.org/t/enum-case-typed-signature-interpolation/68833" title="枚举案例类型签名/插值" target="_blank" rel="noopener">枚举案例类型签名/插值</a></p><p><strong>内容概括</strong></p><p>讨论围绕获取具有关联值的枚举情况的字符串表示，特别是寻求一种为每种情况生成类型化签名或插值的方法。 一个示例枚举了具有关联值及其预期输出签名的各种情况。</p><p>当前的方法涉及使用反射，但由于反射元数据对应用程序二进制大小的影响，因此存在可能删除反射元数据的担忧。 另一种考虑的方法是使用宏，但这些可能不适用于较旧的操作系统版本，从而带来兼容性挑战。</p><p>该对话强调了与处理重复的枚举案例名称相关的编译器错误，该错误使枚举实例的唯一性变得复杂。</p><p>核心需求是为某些枚举案例的所有实例导出一个稳定的 hashValue，无论它们的关联值如何，旨在将具有相同案例名称但不同关联值的实例视为相同的存储目的。 然而，传统的 Hashable 实现不足以实现此目的。</p><p>一个探索的想法涉及利用 String(describing:) 生成枚举案例的字符串表示形式，但如果客户端为枚举实现 CustomStringConvertible，则这种方法可能会失败。 人们有兴趣了解如何调用枚举描述的默认 Swift 标准库实现，以解决 CustomStringConvertible 的客户端实现所产生的问题。</p><p>3) 讨论<a href="https://forums.swift.org/t/unavailable-deinit-in-copyable-types/68627" title="~Copyable 类型中不可用的 deinit" target="_blank" rel="noopener">~Copyable 类型中不可用的 deinit</a></p><p><strong>内容概括</strong></p><p>讨论围绕着 ~Copyable 类型中不存在不可用的 deinit 以及它对程序员构建代码以与本地数据流分析保持一致的依赖展开。</p><p>不可破坏类型的概念旨在增强本地数据流分析并提供编译时保证。 它类似于函数的想法，从技术上讲，函数承诺返回一些东西，但实际上却没有，而编译器静态地证明了理论上的不可能。</p><p>该提案引入了不可破坏类型（~Destructible）作为取代~Copyable 的新根类型。 它设想了类型不需要显式反初始化的场景，依赖编译器的静态分析来强制执行预期的清理例程。</p><p>讨论对比了使用和不使用此功能时 API 使用的难度，强调了需要显式清理时面临的潜在挑战。 对 API 文档、运行时检查和潜在风险的仔细研究与用于防止错误使用的编译时诊断进行了比较。</p><p>对话承认实现此功能的潜在复杂性以及收益是否值得付出努力的不确定性。 它引用了 Scott Meyers 关于使接口易于正确使用且难以错误使用的名言，强调了编程接口简单性和清晰性的重要性。</p><p>4) 展示<a href="https://forums.swift.org/t/advent-of-code-2023/68749" title="Advent of Code 2023" target="_blank" rel="noopener">Advent of Code 2023</a></p><p><strong>内容概括</strong></p><p>Swift 社区受邀参加“Advent of Code”，这是一项从 12 月 1 日到 12 月 25 日举办的年度编码挑战赛。 这项挑战由 Eric Wastl 组织，涉及日常编码练习，开始时很简单，逐渐变得更具挑战性。</p><p>参与者可以使用任何编程语言，但有一个 Swift 团队模板可供那些喜欢 Swift 的人使用。 该模板提供了解决挑战的起点。</p><p>加入：</p><ol><li>克隆 Swift 团队的入门模板（可选）。</li><li>在 Advent of Code 网站上创建一个帐户（参与排行榜所需）。</li><li>使用ID 3315857-f51d8ce5加入Swift社区排行榜。</li></ol><p>我们鼓励参与者每天使用 Swift 尝试挑战。 排行榜跟踪完成时间，但分数只是为了好玩，可以忽略。</p><p>排行榜允许那些想要分享解决方案的人链接到 GitHub 帐户，为参与者提供了互相学习方法的机会。</p><p>这是一个社区活动，并不正式隶属于 Swift 项目，旨在整个 12 月享受乐趣、提高 Swift 技能并享受一些编码挑战。 参与者被警告，随着挑战变得更加严峻，挫败感可能会出现！</p><p>5) 讨论<a href="https://forums.swift.org/t/swift-openapi-generator-1-0-0-alpha-1-release-candidate-released-multipart-base64-filtering-recursive-types-and-more/68703" title="Swift OpenAPI Generator 1.0.0-alpha.1（候选发布版）已发布（Multipart、base64、过滤、递归类型等）" target="_blank" rel="noopener">Swift OpenAPI Generator 1.0.0-alpha.1（候选发布版）已发布（Multipart、base64、过滤、递归类型等）</a></p><p><strong>内容概括</strong></p><p>Swift OpenAPI Generator 团队已发布版本 1.0.0-alpha.1，该版本作为即将发布的 1.0 版本的候选版本，预计将在大约两周内发布。 1.0 的主要重点是增强文档和示例，没有计划更改代码。</p><p>自 2023 年 5 月以 0.1.0 版本首次开源以来，Swift OpenAPI Generator 已经取得了实质性进展。 合并了 200 多个拉取请求，产生了 24 项更新并引入了重要的新功能。</p><p>主要亮点：</p><ul><li>新功能包括对 Base64 编码数据的支持、文档过滤、递归类型支持、服务器 URL 模板变量支持以及具有类型安全和流式传输的多部分内容类型支持。</li><li>此外，生成代码的可自定义访问修饰符允许在公共、包（默认）和内部可见性之间进行选择。</li><li>该版本还包含各种改进和错误修复，例如将 Swift 5.9 更新为最低支持版本、错误处理增强以及生成的代码注释的细化。</li></ul><p>重大变更和迁移：</p><ul><li>该版本包括 API 反馈所必需的重大更改。 提供了将代码从版本 0.3.x 迁移到 1.0.0-alpha.1 的指南，详细说明了潜在的构建错误及其解决方案。</li></ul><p>下一步是什么：</p><ul><li>版本 1.0.0-alpha.1 作为候选版本，邀请反馈意见被考虑用于计划在两周内发布的最终 1.0.0 版本。 鼓励用户测试 alpha 版本以确保与其项目的兼容性。</li></ul><p>该团队对贡献者表示感谢，并邀请通过 Swift OpenAPI Generator GitHub 存储库进一步参与。</p><p>6) 讨论<a href="https://forums.swift.org/t/encodable-incorrect-json-string-with-url-and-decimal-existentials/68713/1" title="可编码不正确的 Json 字符串，包含 URL 和十进制存在值" target="_blank" rel="noopener">可编码不正确的 Json 字符串，包含 URL 和十进制存在值</a></p><p><strong>内容概括</strong></p><p>该对话探讨了 Swift Codable 协议在处理存在类型时的细微差别，特别是涉及 URL、Decimal 和 AnyEncodable 的可编码行为。</p><p>讨论解决了使用存在类型时期望与实际行为之间的差异。 值得注意的是，当抽象具有预期行为（例如，meow()）的 Cat 等类型的实例时，预期 Cat 的所有实例都将统一表现出该行为。 当使用encode()时，内部表示（例如Decimal类型）会出现在最终的JSON字符串中，这会让人感到惊讶，从而导致方法分派和类型编码的混乱。</p><p>该演讲深入探讨了 Codable 的基础知识以及存储类型信息以进行解码的必要性。 出于安全性和互操作性原因，可编码省略了编码数据中的类型信息，因此需要在代码中预定义以进行解码。 这种方法允许解码不明确的值，但对类型擦除的值（如 AnyEncodable）带来了挑战，使得在解码期间难以对类型进行逆向工程。 如果解码时不知道类型，则不可能重建原始数据。</p><p>所讨论的警告方面围绕着未来可能需要解码的场景。 如果在不考虑未来解码要求的情况下做出编码决策，则可能会使数据检索变得复杂。</p><p>最后，讨论暗示了从枚举案例数组中收集枚举时的挑战和注意事项，强调了编码和解码策略的复杂性以及在设计导出或序列化工具时深思熟虑的重要性。</p><p>7) 讨论<a href="https://forums.swift.org/t/is-it-possible-to-automatically-validate-a-value-change-and-throw-error/68647" title="是否可以自动验证值更改并抛出错误？" target="_blank" rel="noopener">是否可以自动验证值更改并抛出错误？</a></p><p><strong>内容概括</strong></p><p>本讨论围绕自动验证值更改的概念展开，旨在消除 CRUD 方法中出现的显式验证调用。 对话的重点是在 Swift 构造中实现自动验证的挑战。</p><p>该示例使用 Name 结构来探索拦截值访问以进行实时验证的潜在方法。 然而，诸如计算属性或属性观察器之类的现有机制缺乏对在验证过程中抛出错误的直接支持。 这一限制对在 Swift 结构中无缝实现自动验证造成了重大障碍。</p><p>这次对话强调了手动验证的必要性，即使是基本类型，因为从这些基本类型构建的复杂类型会产生复杂性。 例如，讨论介绍了 Employee 结构体，并说明了对其 addr1 和 addr2 属性的手动验证规则的需求，强调尽管基本类型具有验证机制，但手动验证在复杂类型级别至关重要。</p><p>尽管函数体宏被认为是另一种潜在的方法，但讨论主要集中在计算变量或动态查找功能是否可以支持自动验证，最终表达了对在 Swift 现有机制中实现它的可行性的怀疑。</p><p>提出了两种建议的“手动”方法：</p><ol><li>使用 let 代替 var 字段，并在构造函数中加入验证逻辑，使其失败。</li><li>在外部执行验证，如果验证失败，则利用 didSet 恢复到之前的值。</li></ol><p>这些手动方法旨在在更改期间同步强制验证，确保值保持一致。 但是，后一种方法可能会暂时使不变量无效，但可能适用于可接受同步验证的场景，例如避免由于暂时不正确的值导致的 UI 闪烁。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://tech.meituan.com/2021/02/25/swift-objective-c.html" title="从预编译的角度理解 Swift 与 Objective-C 及混编机制" target="_blank" rel="noopener">从预编译的角度理解 Swift 与 Objective-C 及混编机制</a></p><p><strong>摘要：</strong>  这篇博客讨论了 Objective-C 的预编译工作机制和与 Xcode 相关的技术细节。Clang Module 提升了编译的健壮性和扩展性，而使用 hmap 技术可以提高编译效率。</p><p>Xcode Phases 构建系统中的不同类型代表不同的文件。使用 cocoapods-hmap-built 插件可以节省大型项目的编译时间。Clang Module 和 Swift Module 有相似的概念，而 Swift 与 Objective-C 混编有几种方法可选。利用 VFS 机制可以提升编译效率。</p><p><a href="https://juejin.cn/post/7307146455537614875" title="在 SwiftUI 中实战使用 MapKit API" target="_blank" rel="noopener">在 SwiftUI 中实战使用 MapKit API</a></p><p><strong>摘要：</strong>  这篇 Swift 博客介绍了在 SwiftUI 中使用 MapKit 的基础知识。最新版本的 SwiftUI 引入了新的 MapKit 集成 API ，提供了更全面的功能。</p><p>文章示例了如何使用 Marker 和 Annotation 类型在地图上放置标记和自定义视图。还介绍了控制地图初始位置和交互类型的方法。</p><p>该博客将在接下来的几周继续深入讨论相机操作、地图样式和用户位置跟踪等主题。</p><p><a href="https://juejin.cn/post/7309549170375786506?searchId=2023120719043685E070931C364C2168D4/" title="计算机编程语言原理与源码实例讲解：Swift 函数和闭包" target="_blank" rel="noopener">计算机编程语言原理与源码实例讲解：Swift 函数和闭包</a></p><p><strong>摘要：</strong>  这篇 Swift 博客介绍了计算机编程语言原理与源码实例中的 Swift 函数和闭包。文章首先介绍了 Swift 作为一种强类型、编译型、面向对象的编程语言的背景。</p><p>然后，详细讲解了函数和闭包的核心概念和联系，包括函数的定义、调用和返回值，以及闭包的定义、调用和返回值。</p><p>接下来，文章深入探讨了函数和闭包的算法原理，包括函数的接收输入参数、执行操作和返回输出结果的过程，以及闭包的类似过程。</p><p>最后，文章通过具体的代码实例展示了函数和闭包的使用方法，并讨论了它们未来的发展趋势和可能面临的挑战。附录部分回答了一些常见问题，帮助读者更好地理解 Swift 函数和闭包的概念和用法。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>你是更能接受同性上司还是更能接受异性上司？</p><ol><li>性别无关：不在意上司的性别，更关注他们的能力和领导风格。</li><li>同性上司：同性上司更容易理解自己的处境和需求。</li><li>异性上司：异性上司会带来不同的观点和经验。</li><li>不确定：没有明确的偏好，根据情况判断是否接受同性或异性上司。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十三期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;命是弱者的借口，运是强者的谦辞，辉煌与否？且看&lt;strong&gt;Swift社区&lt;/strong&gt;强中意！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：iPhone 破发促销、印度市场寻增量，苹果再攀 3 万亿美元高点&lt;/p&gt;
&lt;p&gt;提案：函数体 Macros 提案正在审查中&lt;/p&gt;
&lt;p&gt;Swift 论坛：Swift 中引入函数体宏&lt;/p&gt;
&lt;p&gt;推荐博文：在 SwiftUI 中实战使用 MapKit API&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你是更能接受同性上司还是更能接受异性上司？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十二期/</id>
    <published>2024-03-06T09:10:32.000Z</published>
    <updated>2024-03-06T09:14:43.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十二期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>最热烈的火焰，封锁在最沉默的火山深处。最朴实纯真的智慧，就浅藏在<strong>Swift社区</strong>里！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果 CEO 库克透露接班计划，希望继任者来自公司内部</p><p>提案：Typed throws 提案正在审查</p><p>Swift 论坛：讨论 MainActor 上的上下文切换和线程数</p><p>推荐博文：SwiftUI 中的作用域动画</p><p><strong>话题讨论：</strong> </p><p>那个活在记忆中的帅气少年，已慢慢变成了大叔模样。岁月无情呀，那么各位程序猿和攻城狮们，你们心中最担心的容貌变化是哪一个呢？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/14af3e92-0eee-4ed1-8bd1-06d37adf3ca9.jpg" alt=""></p><p>这个结果反映了员工在工作和生活平衡方面的个体差异。一些人更注重通勤时间的利用效率，而另一些人则更注重在自己的房子中获得更大的舒适感和生活空间。这对公司提供灵活的工作安排和住房福利可能有一定的启示。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果-CEO-库克透露接班计划，希望继任者来自公司内部"><a href="#苹果-CEO-库克透露接班计划，希望继任者来自公司内部" class="headerlink" title="苹果 CEO 库克透露接班计划，希望继任者来自公司内部"></a>苹果 CEO 库克透露接班计划，希望继任者来自公司内部</h3><p>11 月 21 日消息，63 岁的苹果公司首席执行官蒂姆库克近日透露，苹果已经为他的继任者做好了 “ 非常详细 “ 的接班计划，但他也表示，他目前还没有离开苹果的打算。</p><p><img src="https://zkres2.myzaker.com/202311/655cd4718e9f0911b077b37a_1024.jpg" alt=""></p><p>在 BBC Sounds 播客《Dua Lipa: At Your Service》的一次 45 分钟的采访中，库克向歌手 Dua Lipa 坦承，他不知道自己还会在苹果待多久。” 我爱这里，” 他说，回顾了自己在苹果的 25 年，” 我无法想象没有苹果的生活，所以我还会在这里一段时间。”<br>但是，当被问及苹果是否有任何 CEO 接班计划时，库克称：” 我们是一家相信制定接班计划的公司，所以我们有非常详细的接班计划。因为总会发生一些不可预测的事情。我明天可能会走错路边，希望不会发生这种事，我祈祷不会。”</p><p>Dua Lipa 问道：” 你能说出谁是接班人吗？” 库克回答称，” 我不能说，但我想说的是，我的工作是找到几个有能力接班的人，我真的希望下一任首席执行官是来自苹果内部的人。所以这是我的角色：让董事会有几个人可以选择。”</p><p>在这次采访中，库克讲述了自己作为苹果 CEO 的一天，分享了他在阿拉巴马州一个蓝领家庭长大的经历，以及最终成为苹果 CEO。(文章来源：IT 之家)</p><h3 id="消息称苹果自研-5G-调制解调器开发再“难产”，将推迟到-2026-年"><a href="#消息称苹果自研-5G-调制解调器开发再“难产”，将推迟到-2026-年" class="headerlink" title="消息称苹果自研 5G 调制解调器开发再“难产”，将推迟到 2026 年"></a>消息称苹果自研 5G 调制解调器开发再“难产”，将推迟到 2026 年</h3><p>IT之家 11 月 17 日消息，彭博社的马克・古尔曼（Mark Gurman）发布最新一期 Power On 时事通讯，表示苹果的自研 5G 调制解调器计划遇到麻烦。</p><p>IT之家注：苹果公司于 2019 年收购了英特尔大部分智能手机业务，并开始认真开发自己的调制解调器硬件，但开发过程并不顺利。</p><p><img src="https://pics6.baidu.com/feed/64380cd7912397dd18a035baa6f4a9bad1a28733.jpeg@f_auto?token=fab61a6b05898db7419af695da5bd6d5" alt=""></p><p>苹果公司原本计划 2024 年推出自研 5G 调制解调器芯片，并率先装备在 iPhone SE 机型上，但随后有消息称延后到 2025 年。</p><p>古尔曼在最新时事通讯中表示，苹果计划再次延后推出自研 5G 调制解调器芯片时间，目前已经推迟到 2025 年年底或者 2026 年年初。</p><p>古尔曼在文章中透露，苹果的自研 5G 调制解调器芯片目前还处于早期阶段，可能落后竞争对手“数年”时间。</p><p>消息称苹果目前自研的 5G 调制解调器芯片并不支持 mmWave 技术，目前主要存在 2 个难题：第一是英特尔遗留代码，需要苹果重写，而添加新功能可能会中断现有功能；第二是开发芯片过程中，要小心绕过不侵犯高通的专利。</p><p>一位苹果员工表示：“我们接手了英特尔的一个失败项目，我们盲目自信地认为可以成功”。据说苹果的硬件技术部门在众多项目中“捉襟见肘”，各项资源没有向其倾斜，导致难以解决错误。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0413-typed-throws.md" title="SE-0413" target="_blank" rel="noopener">SE-0413</a> <strong>Typed throws</strong> 提案正在审查。</p><p>Swift 的错误处理模型允许标记为 throws 的函数和闭包指示它们可以通过引发错误来退出。错误值本身始终被类型擦除为 <code>any Error</code>。这种方法鼓励以通用方式处理错误，并且对于大多数代码来说仍然是一个很好的默认选项。然而，有一些情况下类型擦除是不幸的，因为它不允许在可能且有必要处理所有错误的狭窄位置进行更精确的错误类型化，或者在类型擦除的成本很高的情况下。</p><p>该提案引入了指定函数和闭包只能引发特定具体类型错误的能力。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-multi-statement-if-switch-do-expressions/68443" title="多语句 if/switch/do 表达式" target="_blank" rel="noopener">多语句 if/switch/do 表达式</a></p><p><strong>内容概括</strong></p><p>该提案基于 SE-0380，引入了“then”关键字来处理 if 或 switch 表达式中的多个语句，从而促进更清晰的语法并提高可读性。 “then”关键字允许这些表达式每个分支有多个语句，从而简化了以前需要立即执行闭包或显式键入的场景。 此外，它还引入了“do”表达式，使代码结构更加清晰，并处理 API 需要价值创建和后续突变的情况。</p><p>该提案概述了详细设计，引入“then”作为上下文关键字，指定其在 if、switch 和 do 表达式中的用法。 它强调了解析歧义和可能的替代方案，探索诸如在 Swift 中使用最后一个表达式或受 Rust 启发的分号终止等变体，同时讨论它们对代码可读性和语言设计的影响。</p><p>总体而言，该提案旨在增强 Swift 的表达能力而不影响 ABI 稳定性，并邀请讨论引入的“then”关键字的替代方案和潜在的解析复杂性。</p><p><strong>介绍</strong></p><p>该提案引入了 then 关键字，用于确定单个分支中包含多个语句的 if 或 switch 表达式的值。 它还介绍了 do 表达式。</p><p><strong>动机</strong></p><p>SE-0380 引入了使用 if 和 switch 语句作为表达式的功能。 正如该提案所述，这可以大大改进语法，例如在初始化变量时：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> width = <span class="keyword">switch</span> scalar.value &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">0x80</span>: <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x80</span>..&lt;<span class="number">0x0800</span>: <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0800</span>..&lt;<span class="number">0x1_0000</span>: <span class="number">3</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则需要诸如立即执行闭包或显式类型确定初始化之类的技术。<br>然而，该提案将让 switch 分支包含多个语句的能力作为未来的方向：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> width = <span class="keyword">switch</span> scalar.value &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">0x80</span>: <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x80</span>..&lt;<span class="number">0x0800</span>: <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0800</span>..&lt;<span class="number">0x1_0000</span>: <span class="number">3</span></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      log(<span class="string">"this is unexpected, investigate this"</span>)</span><br><span class="line">      <span class="number">4</span>  <span class="comment">// error: Non-expression branch of 'switch' expression may only end with a 'throw'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要这样的分支时，当前用户必须退回到旧技术。<br>该提案引入了一个新的上下文关键字，它允许 switch 保留为表达式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> width = <span class="keyword">switch</span> scalar.value &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">0x80</span>: <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x80</span>..&lt;<span class="number">0x0800</span>: <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0800</span>..&lt;<span class="number">0x1_0000</span>: <span class="number">3</span></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      log(<span class="string">"this is unexpected, investigate this"</span>)</span><br><span class="line">      then <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>then 可以类似地用于允许 if 表达式中的多语句分支。<br>该关键字的引入还使得独立的 do 表达式更加可行。 它们有两个用例：</p><ol><li>要从 do/catch 块的成功路径和失败路径生成值：</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: <span class="type">String</span> = <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> bar()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="string">"Error <span class="subst">\(error)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当使用单个表达式无法轻松完成变量初始化时，能够初始化变量：</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> icon: <span class="type">IconImage</span> = <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> image = <span class="type">NSImage</span>(</span><br><span class="line">                    systemSymbolName: <span class="string">"something"</span>, </span><br><span class="line">                    accessibilityDescription: <span class="literal">nil</span>)!</span><br><span class="line">    <span class="keyword">let</span> preferredColor = <span class="type">NSColor</span>(named: <span class="string">"AccentColor"</span>)!</span><br><span class="line">    then <span class="type">IconImage</span>(</span><br><span class="line">            image, </span><br><span class="line">            isSymbol: <span class="literal">true</span>, </span><br><span class="line">            isBackgroundSupressed: <span class="literal">true</span>, </span><br><span class="line">            preferredColor: preferredColor.cgColor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的内容可以组成一个表达式，但声明单独的变量然后使用它们会更清晰。</p><p>在其他情况下，这是无法完成的，因为 API 的结构要求您首先创建一个值，然后更改其中的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> motionManager: <span class="type">CMMotionManager</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> manager = <span class="type">CMMotionManager</span>()</span><br><span class="line">    manager.deviceMotionUpdateInterval = <span class="number">0.05</span></span><br><span class="line">    <span class="keyword">return</span> manager</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>这种立即执行的闭包模式在 Swift 代码中很常见。 以至于在某些情况下，用户认为即使是单个表达式也必须包含在闭包中。 do 表达式将提供更清晰的习惯用法来对这些进行分组。</p><p>2) 讨论<a href="https://forums.swift.org/t/design-concerns-for-borrowing-and-inout-pattern-matching/68396" title="借用和输入输出模式匹配的设计问题" target="_blank" rel="noopener">借用和输入输出模式匹配的设计问题</a></p><p><strong>内容概括</strong></p><p>讨论围绕着通过启用借用和输入输出模式匹配来增强 Swift 的模式匹配、允许在不复制或消耗值的情况下进行值匹配以及在模式匹配期间启用枚举的就地突变来增强 Swift 的模式匹配。 主要设计问题包括：</p><ol><li>新的绑定模式：引入“借用 x”和“inout x”分别作为借用和变异模式绑定的语法。 这些将允许借用或改变部分匹配值而不消耗它。</li><li>模式的所有权行为：分析 Swift 中的各种模式类型以了解其所有权含义。 诸如绑定、通配符、元组、枚举、可选展开、布尔值、动态转换和表达式模式之类的模式将根据其所有权行为进行评估。</li><li>确定模式匹配所有权：探索确定模式匹配的所有权行为的方法。 聚合模式（元组和枚举）遵循其组件之间最严格的所有权行为：借用、变异或消费。</li><li>确定开关的效果：讨论如何通过句法标记或从应用模式推断所有权来确定开关对其主题的总体效果。 有人建议使用“&amp;”标记来改变模式匹配。</li><li>条件中的所有权控制：考虑“if let”和“if case”构造中借用和 inout 模式绑定的含义。 这些新的绑定形式可用于可选展开，并且其行为类似于根据其所有权要求切换主题。</li></ol><p>总体而言，我们的目标是在 Swift 中引入更细致的模式匹配，允许在不消耗值的情况下进行借用和变异，并探索这些增强功能在各种语言结构（如 switch 语句和条件）中的含义。</p><p>3) 讨论<a href="https://forums.swift.org/t/how-do-you-depend-on-swiftpm-as-a-library/68574" title="如何依赖 SwiftPM 作为一个库？" target="_blank" rel="noopener">如何依赖 SwiftPM 作为一个库？</a></p><p><strong>问题</strong></p><p>理论上，SPM 是一个普通的 swift 包，您可以将其（使用工具链附带的 SPM）构建为普通的 swift 包。但 swift-package-manager 存储库没有最新的 semver 标签，它使用“工具链”标记方案（swift-5.9.1-RELEASE）。<br>如何依赖 SPM 作为library？</p><p><strong>回答</strong></p><p>截至目前，libSwiftPM 尚未维护可以遵循语义版本控制的稳定 API。 您使用自己的 libSwiftPM 构建的软件包将从当前的 Swift 安装中提取 PackageDescription 模块，这可能与您使用的 libSwiftPM 版本不兼容。 这种不兼容性将表现为用于传递包清单和插件信息的不同序列化格式（本身是私有 API），这将导致模糊且难以诊断的错误。</p><p>作为以前维护过基于 libSwiftPM 构建的 CLI 工具，现在维护 SwiftPM 本身的人，我建议不要将其添加为依赖项。 它不适合在一起版本化并随 Swift 工具链分发的工具集之外使用。</p><p>如果您需要一个可以在包上操作的 CLI 界面，请改用 SwiftPM 命令插件，它们确实提供了稳定的 API。</p><p>4) 讨论<a href="https://forums.swift.org/t/context-switch-on-mainactor-and-number-of-threads/68386" title="MainActor 上的上下文切换和线程数" target="_blank" rel="noopener">MainActor 上的上下文切换和线程数</a></p><p><strong>提问</strong></p><p>我正在观看 <a href="https://developer.apple.com/videos/play/wwdc2021/10254/" title="Swift 并发：幕后" target="_blank" rel="noopener">Swift 并发：幕后</a>我了解到，作为使用 Swift 并发的开发人员，我们不应该违反不阻塞线程的运行时契约。 看来 Swift 的目标是运行与设备中 CPU 核心数量一样多的线程。 然而，会议结束时提出的一个观点引起了一些混乱。 演讲者提到，当我们调用 MainActor 的方法时，会发生上下文切换，因为主线程与协作池中的线程是分开的。 这引发了几个问题：</p><p>1、协作池中有多少个线程？ </p><p>2、如果不包括主线程，这是否意味着实际的协作线程数是 numberOfCoresInDevice - 1？</p><p>3、为什么主线程不是协作池的一部分？ </p><p>我的假设是，这可能是出于优化目的，允许主线程专注于 UI 任务； 否则，任何线程的任何继续都可以在挂起后在主线程上恢复。</p><p>4、这里是否违反了运行时契约：当我们将上下文切换到主线程时，我们当前的线程应该被阻塞？ </p><p>5、或者这个合约只针对我们，开发者，系统可以随意违反吗？ </p><p>无论如何，看起来在这种情况下我们有一个线程被阻塞。</p><p>也许，这个问题将作为前三个问题的答案得到回答，但无论如何：为什么主线程不能像协作池中的线程一样工作？ 只是接收必须在主线程上执行的延续？ 这将解决上下文切换问题。</p><p><strong>回答</strong></p><p>主线程主要通过 NSRunLoop 进行管理，因为它的存在时间比 Swift 存在的时间要长得多，更不用说 Swift 并发了。 当在默认模式下不可重入运行时，主调度队列由主运行循环提供服务。 在 Swift Concurrency 中，主要参与者的执行者负责将工作分派到该队列上，就像常规参与者的执行者（默认执行者）将工作分派到协作队列上一样，如您链接的文章中所述</p><p>但并非所有进程都有主线程； 它主要是一个与 UI 相关的概念，像守护进程这样的非 UI 进程不需要它。</p><p>5) 讨论<a href="https://forums.swift.org/t/enum-case-key-paths-an-update/68436" title="枚举案例关键路径：更新" target="_blank" rel="noopener">枚举案例关键路径：更新</a></p><p><strong>内容概述</strong></p><p>讨论围绕使用 Swift 宏增强对枚举的关键路径支持，特别是引入“案例关键路径”以更好地处理枚举案例。</p><ol><li><code>@CasePathable</code> 宏：该宏为枚举案例生成实际的关键路径，称为“案例关键路径”。 这些关键路径提供动态案例查找功能，并且可以与常规关键路径类似地使用。</li><li>使用示例：<code>@CasePathable</code> 宏允许实现各种功能：<ul><li>通过下标访问枚举案例。</li><li>使用 <code>callAsFunction</code> 嵌入新的有效负载。</li><li>简化枚举案例检查和有效负载提取。</li><li>利用 SwiftUI 绑定的大小写键路径，启用基于枚举大小写的导航和表单控件使用。</li><li>使用大小写键路径组合应用程序功能，在构建和组合不同的应用程序功能时特别有用。</li></ul></li><li>对库的影响：<code>SwiftUINavigation</code> 和 <code>Composable Architecture</code> 等库已更新，以合并案例键路径，使用 Swift 键路径语法增强其功能、结构和可组合性。</li></ol><p>提供的示例和案例研究旨在展示案例关键路径的多功能性和实用性，强调它们在简化代码、增强 SwiftUI 绑定、组合应用程序功能等方面的潜力。 希望展示这些用例将鼓励将案例关键路径纳入语言中，并激发进一步的创新应用程序。</p><p><strong>案例研究：SwiftUI Bindings</strong></p><p>大小写键路径使从枚举而不是一堆独立选项驱动 SwiftUI 导航成为可能。 例如，如果一个视图可以导航到两个不同的、互斥的功能，那么最好像这样建模：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FeatureView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">var</span> destination: <span class="type">Destination</span>?</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> activity(<span class="type">ActivityModel</span>)</span><br><span class="line">    <span class="keyword">case</span> settings(<span class="type">SettingsModel</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但构建对 Destination 枚举的每种情况的绑定可能很困难，以便您可以使用 <code>sheet(item:)</code>、<code>popover(item:)</code>（以及更多）视图修饰符。<br>但是如果你的枚举用 <code>@CasePathable</code> 注释</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">CasePathable</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以利用绑定上的“动态大小写查找”，允许它们通过点链语法转换为 SwiftUI 现有视图修饰符所期望的形状：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.sheet(item: <span class="keyword">self</span>.$destination.activity) &#123; model <span class="keyword">in</span> </span><br><span class="line">  <span class="type">ActivityView</span>(model: model)</span><br><span class="line">&#125;</span><br><span class="line">.popover(item: <span class="keyword">self</span>.$destination.settings) &#123; model <span class="keyword">in</span> </span><br><span class="line">  <span class="type">SettingsView</span>(model: model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用 String 或 Bool 来驱动表单控件，例如 TextFields 和 Toggles，否则这些控件将被困在枚举案例中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">CasePathable</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> inStock(quantity: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> outOfStock(isOnBackOrder: <span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">Binding</span> <span class="keyword">var</span> status: <span class="type">Status</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">self</span>.item.status &#123;</span><br><span class="line"><span class="keyword">case</span> .inStock:</span><br><span class="line">  $status.inStock.<span class="built_in">map</span> &#123; $quantity <span class="keyword">in</span></span><br><span class="line">    <span class="type">Section</span> &#123;</span><br><span class="line">      <span class="type">Stepper</span>(<span class="string">"Quantity: <span class="subst">\(quantity)</span>"</span>, value: $quantity)</span><br><span class="line">      <span class="type">Button</span>(<span class="string">"Mark as sold out"</span>) &#123;</span><br><span class="line">        status = .outOfStock(isOnBackOrder: <span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; header: &#123; <span class="type">Text</span>(<span class="string">"In stock"</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">case</span> .outOfStock:</span><br><span class="line">  $status.outOfStock.<span class="built_in">map</span> &#123; $isOnBackOrder <span class="keyword">in</span></span><br><span class="line">    <span class="type">Section</span> &#123;</span><br><span class="line">      <span class="type">Toggle</span>(<span class="string">"Is on back order?"</span>, isOn: $isOnBackOrder)</span><br><span class="line">      <span class="type">Button</span>(<span class="string">"Is back in stock!"</span>) &#123;</span><br><span class="line">        status = .inStock(quantity: <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; header: &#123; <span class="type">Text</span>(<span class="string">"Out of stock"</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想尝试其中任何一个，我们的 <code>SwiftUINavigation</code> 库已更新，可以在使用 <code>CaseKeyPath</code> 进行绑定时定义动态成员查找。</p><p><strong>案例研究：Composing App Features</strong></p><p>近 4 年前我们开发案例路径的主要推动力是我们的可组合架构库，它提供了一种定义功能并将它们组合在一起的结构化方法。 功能使用枚举来枚举应用程序中所有可能的用户操作，并且这些枚举嵌套在父/子域层中，并且需要案例路径来编写可以将这些功能抽象地粘合在一起的代码。</p><p>我们还更新了该库以使用案例键路径，这允许人们通过使用简单且熟悉的键路径语法隔离子状态和操作来将功能组合在一起：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reduce</span> &#123; state, action <span class="keyword">in</span> </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">-.ifLet(\.child, action: /<span class="type">Action</span>.child) &#123;</span><br><span class="line">+.ifLet(\.child, action: \.child) &#123;</span><br><span class="line">   <span class="type">ChildFeature</span>()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这使我们能够利用本机键路径给我们带来的所有好处，例如 Xcode 自动完成和类型推断。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7304831120710156340/" title="基于 UI 交互意图理解的异常检测方法" target="_blank" rel="noopener">基于 UI 交互意图理解的异常检测方法</a></p><p><strong>摘要：</strong>  本文介绍了利用页面多模态信息在UI测试领域的探索与实践经验。针对意图信息识别问题，我们利用图像+文本+渲染布局属性信息探索出了一种交互意图簇识别模型，验证了基于自注意力的多模态方向可行性。</p><p>此模型可以识别出渲染树元素多维度的意图属性信息，同时利用聚类算法将节点聚成交互意图簇，可以为后续的任务提供结构化决策信息。在标注数据较少的情况下仍体现了较好的准确率以及泛化能力。后续计划通过扩大数据集、加强预训练等方式继续提升模型识别的精度。</p><p><a href="https://swiftwithmajid.com/2023/11/21/scoped-animations-in-swiftui/" title="SwiftUI 中的作用域动画" target="_blank" rel="noopener">SwiftUI 中的作用域动画</a></p><p><strong>摘要：</strong>  文章介绍了在 SwiftUI 中使用作用域动画的新方法。首先，我们回顾了以前在 SwiftUI 中处理动画的方式，并指出了其中的一些缺点。随后，我们展示了如何使用带有 value 参数的 animation 视图修饰符来限定动画范围，以及如何处理多个可动画属性的情况。</p><p>接着，我们介绍了 SwiftUI 中引入的 animation 视图修饰符的新变体，允许我们使用 ViewBuilder 闭包来限定动画范围。最后，我们还提到了在视图层次结构中维护作用域事务的方法。这些新方法为我们在 SwiftUI 中创建精确且有限范围的动画提供了更灵活的选择。</p><p><a href="https://www.avanderlee.com/concurrency/thread-dispatching-actor-execution/" title="线程调度和 Actors 的执行方式" target="_blank" rel="noopener">线程调度和 Actors 的执行方式</a></p><p><strong>摘要：</strong>  本文讨论了在 Swift 中使用线程调度和 Actors 时的执行机制。Actors 可以确保代码在特定线程上执行，如主线程或后台线程，并帮助同步访问可变状态以防止数据竞争。</p><p>然而，开发人员常常误解 Actors 在非异步上下文中的线程调度，这是为了避免意外崩溃而至关重要的。作者建议在深入研究调度的具体细节之前，先阅读他的两篇文章：《Actors in Swift: how to use and prevent data races》和《MainActor usage in Swift explained to dispatch to the main thread》，因为它们会向您介绍 Actors 的概念。在本文中，探讨了调用带有任何 actor 属性标记的方法的影响。</p><p>在异步上下文中，文章讨论了使用 Actors 时的线程调度。通常情况下，您可能会在异步环境中使用 Actors 。如果您的调用代码访问带有 actor 属性的方法，您必须使用任务（task）或采用相同的全局 actor 。文章提供了相关的示例代码，并说明了编译器如何防止在非异步上下文中调度到 actor 线程。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>那个活在记忆中的帅气少年，已慢慢变成了大叔模样。岁月无情呀，那么各位程序猿和攻城狮们，你们心中最担心的容貌变化是哪一个呢？</p><ol><li>最担心越吃越肥胖，横向发展。</li><li>最担心逐渐变厚的高度镜片。</li><li>最担心青丝若雪，白发横生。</li><li>最担心秀发稀疏，日渐秃然。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十二期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;最热烈的火焰，封锁在最沉默的火山深处。最朴实纯真的智慧，就浅藏在&lt;strong&gt;Swift社区&lt;/strong&gt;里！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果 CEO 库克透露接班计划，希望继任者来自公司内部&lt;/p&gt;
&lt;p&gt;提案：Typed throws 提案正在审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 MainActor 上的上下文切换和线程数&lt;/p&gt;
&lt;p&gt;推荐博文：SwiftUI 中的作用域动画&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;那个活在记忆中的帅气少年，已慢慢变成了大叔模样。岁月无情呀，那么各位程序猿和攻城狮们，你们心中最担心的容貌变化是哪一个呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十一期/</id>
    <published>2024-03-06T09:10:28.000Z</published>
    <updated>2024-03-06T09:14:07.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十一期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>生活的富足并非完美无缺，适当的缺憾更能感触幸福。<strong>Swift社区</strong>邀你一起，保持积极向上的心！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：现推出超过 30 个新的开发者活动</p><p>提案：全局变量的严格并发性</p><p>Swift 论坛：Swift 6 语言模式的进展</p><p>推荐博文：Swift 中的崩溃回溯</p><p><strong>话题讨论：</strong> </p><p>如果公司在市中心，你会选择那种方式？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/c606080b-63c9-439a-8f56-1baf27323195.png" alt=""></p><p>根据投票结果分析，极兔速递的 IPO 在受众中引起了相当的关注。顺丰和京东物流依然是物流行业备受看好的龙头企业，分别占据相当大的比例。菜鸟虽然有一定支持，但在此次投票中表现相对较弱。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="2024-年-Swift-Student-Challenge-公布"><a href="#2024-年-Swift-Student-Challenge-公布" class="headerlink" title="2024 年 Swift Student Challenge 公布"></a>2024 年 Swift Student Challenge 公布</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/5D41BDFB-09E7-4A11-8376-C037FBF3DCF3/2048.jpeg" alt=""></p><p>Apple 很自豪能够支持和激励下一代学生开发者、创作者和企业家。挑战赛为数以千计的学生提供了机会，让他们可以展现自身的创造力和编程能力，并培养可以在职业生涯和更多地方运用的实际技能。从帮助同伴找到合适的心理健康资源，到发现在校园内支持可持续发展工作的方式，Swift Student Challenge 参赛者将发挥他们的创造力，通过开发 App 来解决他们关注的问题。</p><p>我们发布了新的编程资源、与社区合作伙伴积极合作，而且比往年更早公布了挑战赛，以便学生们能深入研究 Swift 和整个开发过程，同时教育工作者也能抢先一步为他们提供支持。</p><p>申请将在 2024 年 2 月开放三周。</p><p>2024 年挑战赛新增了一项机制，我们将在 350 名获奖者中选出 50 名杰出获奖者，并对这些提交了优秀作品的杰出获奖者予以表彰，邀请他们明年夏天前往位于库比提诺的 Apple 园区度过难忘的三天。</p><h3 id="现推出超过-30-个新的开发者活动"><a href="#现推出超过-30-个新的开发者活动" class="headerlink" title="现推出超过 30 个新的开发者活动"></a>现推出超过 30 个新的开发者活动</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/E37E35FD-D28B-4204-8107-425410EF41F5/2048.jpeg" alt=""></p><p>2023 年 11 月 7 日</p><p>准备好提升你的 App 或游戏功能了吗？在整个 11 月和 12 月，欢迎参加面向全球开发者量身打造的一系列面对面或在线举办的全新实验室、咨询和讲座等活动。</p><p>你将能探索：</p><p>App Store 活动：了解关于探索、互动、App 内活动、自定产品页面、订阅推荐做法等众多精彩内容。<br>Apple Vision Pro 开发者实验室：申请参加位于库比提诺、伦敦、慕尼黑、纽约、上海、新加坡、悉尼或东京的实验室。</p><p>Apple Vision Pro 活动：了解如何为 visionOS 设计和构建全新的 App 和游戏世界。</p><p>设计和技术咨询：报名获取关于 App 设计、技术实施等方面的一对一指导。</p><p>探索在多个时区以多种语言进行的活动。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0412-strict-concurrency-for-global-variables.md" title="SE-0412" target="_blank" rel="noopener">SE-0412</a> <strong>全局变量的严格并发性</strong> 提案正在审查。</p><p>该提案定义了在不产生数据竞争的情况下使用全局变量的选项。在此提案中，全局变量涵盖任何静态持续时间的存储：在全局范围声明的 <code>let</code> 和存储 <code>var</code>，或者作为静态成员变量。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315" title="Swift 6 语言模式的进展" target="_blank" rel="noopener">Swift 6 语言模式的进展</a></p><p>自上次更新为 Swift 6 语言模式 94 制定设计优先事项以来，该项目一直在稳步推进，朝着这个下一个里程碑迈进。然而，先前提出的一些目标包括尚处于开放式研究阶段的问题。在 Swift 6 的工作进展的同时，语言指导组正在将 Swift 6 剩余变更的重点缩小到默认情况下的数据竞争安全。</p><p><strong>数据竞争安全的准备情况</strong></p><p>在严格的并发检查下，Sendable 检查模型中仍存在许多错误和漏洞，允许数据竞争。同样重要的是，严格的并发检查目前会发出大量错误报告数据竞争，使得完整的检查难以进行编程。</p><p>只有当语言指导组确定编程模型是有效和可用的时，Swift 6 语言模式才会被宣布准备就绪。完成 Swift 6 语言模式的数据竞争安全所需的剩余语言工作将分为两类：</p><ol><li>填补严格并发模型中的所有漏洞，以便静态地或在静态安全无法证明的情况下动态地诊断数据竞争。</li><li>缓解已被证明是安全的模式对数据竞争的虚假报告。</li></ol><p>Swift 5.10 包含了许多与 actor 隔离和 Sendable 检查有关的重大错误修复。此外，以下语言更改目前正在进行设计和实施，以接受 Swift 演进审查过程：</p><ol><li>SE-0411: 孤立的默认值表达式 23</li><li>为方法和键路径文字推断 @Sendable 18</li><li>全局和静态变量的严格并发检查 12</li><li>改进对闭包 actor 隔离的控制 16</li><li>通过孤立值区域解除对非 @Sendable 值的限制 15</li></ol><p>这些变化共同填补了严格并发检查中的剩余主要漏洞，并通过引入更多的 <code>@Sendable</code> 推断和启用安全的方式在隔离边界传递非 <code>@Sendable</code> 值，提高了严格并发检查的可用性。语言指导组承认，并发领域的其他语言更改也很重要，但以上更改对于定义 Swift 6 语言模式是必要的。其他并发特性是附加的，可以独立探索。</p><p><strong>Swift 6 迁移</strong></p><p>即将推出的功能 16 对于迁移到 Swift 6 语言模式至关重要：可以逐个启用单个即将推出的功能，以逐步将代码库移向 Swift 6，然后再采用完整的语言模式。有许多先前接受的即将推出的功能将在 Swift 6 中默认启用：</p><ol><li>SE-0274: 简洁的魔术文件名 93 (<code>ConciseMagicFile</code>)</li><li>SE-0286: 用于尾随闭包的正向扫描匹配 55 (<code>ForwardTrailingClosures</code>)</li><li>SE-0337: 增量迁移到并发检查 18 (<code>StrictConcurrency</code>)</li><li>SE-0354: 正则表达式文字 23 (<code>BareSlashRegexLiterals</code>)</li><li>SE-0383: 弃用 <code>@UIApplicationMain</code> 和 <code>@NSApplicationMain</code> 70 (<code>DeprecateApplicationMain</code>)</li><li>SE-0384: 导入前向声明的 Objective-C 接口和协议 31 (<code>ImportObjcForwardDeclarations</code>)</li><li>SE-0401: 由属性包装器引起的去除 Actor 隔离推断 22 (<code>DisableOutwardActorInference</code>)</li><li>SE-0409: 导入声明上的访问级别修饰符 55 (<code>InternalImportsByDefault</code>)</li></ol><p>语言指导组已决定，先前接受的即将推出的功能 ExistentialAny 将不会在 Swift 6 中默认启用。SE-0335: 引入存在的任何 33 引入了 any 关键字以识别存在类型。该提案还规定，“裸” 协议名称将不再被允许用作类型——它们必须使用任何或一些，视情况而定——在即将推出的功能标志 ExistentialAny 下。鉴于关于向一致使用存在的任何语言迁移的担忧，以及期望会出现可能影响该迁移最终结果的其他语言改进，语言指导组正在将 SE-0335 中的源不兼容更改推迟到将来的语言修订中。</p><p>其他 Swift 6 可能包括源不兼容更改的演进提案，语言指导组将在评估这类提案是否相对于源不兼容的成本对语言的价值时逐个进行评估。例如，足够有价值的更改可能包括为完成主要功能（例如类型化抛出）而必需的轻微类型推断更改，或者为了实现数据竞争安全而进行的语义更改。</p><p>一旦为 Swift 6 准备好所有即将推出的功能，语言指导组将提供一个迁移指南，建议以一种最佳路径逐步启用项目中的严格并发检查，并提供有关如何处理某些常见代码模式中的严格并发违规的实际指导。社区对这些指南的反馈对于评估 Swift 6 迁移是至关重要的。</p><p>2) 修订<a href="https://forums.swift.org/t/amendment-se-0192-handling-future-enum-cases/68321" title="SE-0192：处理未来的枚举案例" target="_blank" rel="noopener">SE-0192：处理未来的枚举案例</a></p><p>自核心团队宣布对 SE-0192（处理未来枚举案例，又称为非尽事枚举）实施修改以来已经过去了五年。</p><p>换句话说，专门用于非尽事枚举的要求，即添加 @unknown 默认情况，以处理未来的枚举案例，已从 “Swift 4 中的警告/Swift 5 中的错误” 降级为 “Swift 4 中的运行时陷阱/Swift 5 中的警告”，以减轻源代码兼容性的影响。</p><p>直到今天，缺乏 <code>@unknown default</code> 情况仍然是一个警告而不是错误；忽略该警告意味着如果遇到未来的枚举案例，则会发生运行时陷阱。</p><p>语言指导组在考虑到 Swift 6 语言模式的计划时讨论了 SE-0192 的当前状态，并且我们宣布我们将修改该提案以：</p><ol><li>将 Swift 6 中的警告升级为错误</li><li>为 Swift 5.x 添加一个即将推出的功能标志，以便用户可以逐步迁移其代码。</li></ol><p>正如我们在关于 Swift 6 进展的最新帖子中宣布的那样，我们已经使用即将推出的功能标志合并了一些不兼容源代码的更改，计划在 Swift 6 中默认启用这些标志。当初审查 SE-0192 时，这种引入不兼容源代码更改的方法是不可用的，但今天我们认为这是完成此功能的最合适，事实上是我们唯一明智的选择。我们做出了这个决定，考虑到了几个因素，其中包括：</p><ol><li><p>自 Swift 5 迁移以来已经过去了很多年，而且该警告始终是无法消除的，除非实际编写 <code>@unknown default</code> 情况。</p></li><li><p>忽略该警告意味着在遇到未来的枚举案例时留下了一个隐式的运行时陷阱 - 在最坏的情况下，通过编写像 <code>@unknown default: fatalError()</code> 这样的内容，这种行为在Swift 6中仍然可以轻松表达，但在明确处理时，用户可以选择上下文中有意义且不需要停止执行的其他默认行为（例如，返回nil）。</p></li></ol><p>这个有限的修订与启用非扩展枚举的正交、增量工作无关，该工作适用于非弹性库。</p><p>3) 讨论<a href="https://forums.swift.org/t/listing-stored-properties-of-a-type/68351" title="列出类型的存储属性" target="_blank" rel="noopener">列出类型的存储属性</a></p><p>我心愿已久的一项功能是能够将类型的存储属性与计算属性分开进行分类。目前，通过生成的文档很难整理出所有实例属性，以了解类型的实际表示是什么。</p><p>我今天对这个想法进行了一些调查，发现 <code>lib/SymbolGraphGen</code> 目前将所有实例属性都分类为存储属性（vp 2）。</p><p>从发出的符号声明中也无法通过访问器的存在（<code>{ get }</code>，<code>{ get set }</code> 等）来推断这一点，因为这些也会出现在存储的公共 <code>private(set)</code> 属性中。</p><p><code>lib/SymbolGraphGen</code> 要发出这些信息需要什么条件？</p><p><strong>回答</strong></p><p>有些相关的是，今天晚上我需要了解各种结构的实际布局 - 例如 <code>UnsafeMutableBufferPointer</code> - 最终我不得不深入挖掘 Swift stdlib 源代码中深藏的一些 gyb 模板（然后仔细阅读，以确保我找到了所有的存储属性，因为它们的声明实际上可以出现在文件的任何地方）。</p><p>如果你不知道要专门去 GitHub 并具体搜索苹果的 “Swift” 存储库，然后调整语言设置以使其实际显示这些模板文件，你永远找不到它们。搜索引擎非常努力地不显示 GitHub 源代码的结果。</p><p>如果它们只是在文档中列出，即使只是在附录或脚注中，我会感到更高兴。</p><p>请注意，在这种情况下，顺序也很重要。我需要知道完整的布局，以便将其映射到寄存器等等。</p><p>4) 讨论<a href="https://forums.swift.org/t/navigationstackstore-without-reducer-protocol/68359" title="没有 Reducer 协议的 NavigationStackStore" target="_blank" rel="noopener">没有 Reducer 协议的 NavigationStackStore</a></p><p>我们有一个大型项目，从 TCA 的第一个版本开始，目前我们正在使用版本 0.57.0</p><p>我们计划迁移到 TCA 的最新版本，但这需要一些时间，而我们需要使用 <code>NavigationStackStore</code>，但由于我们所有的 reducer 都是 AnyReducer 类型，我找不到一种实现的方法。</p><p>找到了在 AnyReducer 中使用 Reducer 协议的方法，但找不到一种方法在 Reducer 协议内部使用 AnyReducer 或混合它们</p><p>有什么建议吗？</p><p><strong>回答</strong></p><p>我认为你需要在 <code>Reduce</code> 中封装 <code>AnyReducer</code>。类似这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> reducer: <span class="type">AnyReducer</span>&lt;<span class="type">State</span>, <span class="type">Action</span>, <span class="type">Void</span>&gt; = .combine(</span><br><span class="line">+     <span class="type">AnyReducer</span>(</span><br><span class="line">        <span class="type">Reduce</span>(</span><br><span class="line">            .<span class="keyword">init</span> &#123; state, action, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">            &#125;,</span><br><span class="line">            environment: ()</span><br><span class="line">        )</span><br><span class="line">        .forEach(\<span class="type">State</span>.path, action: /<span class="type">Action</span>.path) &#123;</span><br><span class="line">            <span class="type">Path</span>()</span><br><span class="line">        &#125;</span><br><span class="line">+     )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>5) 讨论<a href="https://forums.swift.org/t/extend-condition-list-abilities/68328" title="扩展条件列表能力" target="_blank" rel="noopener">扩展条件列表能力</a></p><p>这只是一个小想法。如果有人愿意接手并制定正式提案和实施，随时可以着手。</p><p>在使用了相对新但规模较小的 Verse 编程语言几个月后，我开始喜欢能够在 if 语句的条件列表中创建中间常量和变量，以及执行常规函数的能力。</p><p>我开始思考为什么 Swift 没有这样相当方便的功能。与 Verse 不同，Swift 不将抛出错误视为条件。这是可以接受的，我并不打算改变这一点。</p><p>以下是我希望在 Swift 中被允许的示例。</p><p>之前：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">  <span class="keyword">var</span> someVariable = ...</span><br><span class="line">  <span class="comment">// 使用 `condition1` 进行计算并改变 `someVariable`</span></span><br><span class="line">  callSideEffect(on: &amp;someVariable)</span><br><span class="line">  callSideEffect()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行失败分支（模拟 A）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// A: 执行失败分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> </span><br><span class="line">  condition1,</span><br><span class="line">  <span class="keyword">var</span> someVariable = ..., <span class="comment">// 新增（非条件）</span></span><br><span class="line">  callSideEffect(on: &amp;someVariable), <span class="comment">// 新增（非条件）</span></span><br><span class="line">  callSideEffect(), <span class="comment">// 新增（非条件）</span></span><br><span class="line">  condition2</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// A: 执行失败分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了简化问题，将常规的 let 和 var 视为非条件。这有点类似于我们如何在结果构建器中创建本地常量，这些常量不会立即被它消耗。</p><p>这个想法将扩展 if、guard 和 while 的条件列表。</p><p><strong>回答</strong></p><p>将条件列表重构为一个单独的函数使我们能够简化代码为单一的 if/else 分支结构。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldRun</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> condition <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> someVariable = ...</span><br><span class="line">    callSideEffect(on: &amp;someVariable)</span><br><span class="line">    callSideEffect()</span><br><span class="line">    <span class="keyword">return</span> condition2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> shouldRun() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 执行失败分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6) 讨论<a href="https://forums.swift.org/t/whats-the-type-of-any-task/68372" title="any Task 是什么类型" target="_blank" rel="noopener">any Task 是什么类型</a></p><p>假设我想要将一个任意的任务记录在一个变量中，以便稍后可以取消它。这个变量的类型应该是什么？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> task: <span class="type">Task</span>&lt;<span class="type">Any</span>, <span class="type">Never</span>&gt;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line">task = foo <span class="comment">// Cannot assign value of type 'Task&lt;String, Never&gt;' to type 'Task&lt;Any, Never&gt;'</span></span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Cancellable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span>: <span class="title">Cancellable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> task: <span class="type">Cancellable</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task = foo</span><br><span class="line">task.cancel()</span><br></pre></td></tr></table></figure><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>如果公司在市中心，你会选择那种方式？</p><ul><li>方案一：租住公司附近，节省通勤时间，房租压力大</li><li>方案二：租住离公司远，通勤时间长，房租压力小</li><li>方案三：住自己的房子</li></ul><p>欢迎在文末留言参与讨论。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/swift-5.9-backtraces/" title="Swift 中的崩溃回溯" target="_blank" rel="noopener">Swift 中的崩溃回溯</a></p><p><strong>摘要：</strong>  这篇博客讨论了 Swift 5.9 版本中所包含的一些新的调试代码功能，一个能在实时检查崩溃的外部互动性极强的崩溃处理器，一个可以触发调试器进行即时调试的功能，以及一个可以提升理解在一个使用结构化并发的程序中的控制流程的并发意识后退功能。</p><p>在 Swift 5.9 版本之前，一旦你的程序运行失败，你只能看到来自父进程（通常是 shell ）的消息告诉你子进程崩溃了。而现在，你得到的信息将会更具有详细性。</p><p>作者还提出了一个名为”交互式后退”的概念。在许多情况下，你可能会发现你在终端开发的程序崩溃了，但你无法复现问题。没有适当的崩溃日志，这可能会让你非常沮丧，你知道你的程序有一个 bug ，但你不知道问题出在哪里，也不知道如何复现它。这个特性的主要思想就是在程序崩溃后将其挂起，从而给你机会附加一个调试器，或对崩溃过程进行更深入的查看。</p><p>最后，后退功能支持结构化并发，并且能够正确地逆向穿过异步框架。无论你在哪个平台上，这个新功能都无需特殊要求，只需要回退追踪器能够查找到符号以确定给定框架是否是异步的。</p><p><a href="https://swiftwithmajid.com/2023/10/31/mastering-contentunavailableview-in-swiftui/" title="掌握 SwiftUI 中的 ContentUnavailableView " target="_blank" rel="noopener">掌握 SwiftUI 中的 ContentUnavailableView </a></p><p><strong>摘要：</strong>  这篇博客介绍了如何在 SwiftUI中 掌握使用 <code>ContentUnavailableView</code> 类型。<code>ContentUnavailableView</code> 类型允许我们在应用中表现空状态、错误状态或其他任何内容不可用的状态。</p><p>文章通过实例演示了 <code>ContentUnavailableView</code> 的基本用法以及如何在其中定义描述文本和操作按钮。还介绍了 SwiftUI 为我们提供的一种预制的 <code>ContentUnavailableView</code> 实例，可在搜索屏幕中使用。总的来说，我们学会了如何利用 <code>ContentUnavailableView</code> 以用户友好的方式显示空状态。</p><p><a href="https://swiftwithmajid.com/2023/11/07/visual-effects-in-swiftui/" title="SwiftUI 中的 visual effects" target="_blank" rel="noopener">SwiftUI 中的 visual effects</a></p><p><strong>摘要：</strong> 这篇博客介绍了 SwiftUI 在 WWDC2023 中引入的一种叫做 <code>visualEffect</code> 的新视图修饰符。 visualEffect 允许我们通过访问特定视图的布局信息来附加一组可动画的视觉效果。</p><p>通过上述示例，我们可以看到定义了一个文本视图并附加了 <code>visualEffect</code> 视图修饰符。<code>attach visualEffect</code> 视图修饰符时，你需要指定闭包以应用所需的所有效果。</p><p>闭包提供了两个参数：第一个参数是附加到视图的效果集合的初始状态，是 <code>EmptyVisualEffect</code> 类型的实例；第二个参数是 <code>GeometryProxy</code> 类型的实例，包含可能需要的视图所有布局信息，比如框架、安全区等。现在，所有这些视觉效果都遵循 <code>VisualEffect</code> 协议，可以在 <code>visualEffect</code> 闭包中使用它们。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十一期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;生活的富足并非完美无缺，适当的缺憾更能感触幸福。&lt;strong&gt;Swift社区&lt;/strong&gt;邀你一起，保持积极向上的心！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：现推出超过 30 个新的开发者活动&lt;/p&gt;
&lt;p&gt;提案：全局变量的严格并发性&lt;/p&gt;
&lt;p&gt;Swift 论坛：Swift 6 语言模式的进展&lt;/p&gt;
&lt;p&gt;推荐博文：Swift 中的崩溃回溯&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;如果公司在市中心，你会选择那种方式？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第四十期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%9B%9B%E5%8D%81%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第四十期/</id>
    <published>2024-03-06T09:10:23.000Z</published>
    <updated>2024-03-06T09:13:41.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第四十期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>世间万般兵刃，唯有过往伤人最深。<strong>Swift社区</strong>邀你走出低谷，迈向山巅！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：53.5亿美元！传苹果今明两年或将采购2.3万台AI服务器！</p><p>提案：隔离的默认值表达式</p><p>Swift 论坛：讨论为什么 CaseIterable 比 Set 更快</p><p>推荐博文：掌握 swift 中  Preview macro 的用法</p><p><strong>话题讨论：</strong> </p><p>在诸多物流行业，你最看好哪一家？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/b4e1d72d-e137-40ba-8792-7ee684a256a7.jpg" alt=""></p><p>投票结果显示大多数人更倾向于保持薪资不变或者期望薪资增加，而只有少数人愿意接受较小幅度的薪资降低。小编认为公司在决定远程办公政策时需要综合考虑员工的期望和需求。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="53-5亿美元！传苹果今明两年或将采购-2-3-万台-AI-服务器！"><a href="#53-5亿美元！传苹果今明两年或将采购-2-3-万台-AI-服务器！" class="headerlink" title="53.5亿美元！传苹果今明两年或将采购 2.3 万台 AI 服务器！"></a>53.5亿美元！传苹果今明两年或将采购 2.3 万台 AI 服务器！</h3><p><img src="https://files.mdnice.com/user/17787/74aa9817-a2f6-4eb7-a2d3-5e7080d3596c.png" alt=""></p><p>10 月 25 日消息，根据最新的研究显示，苹果公司计划在 2023 年采购约 2000 - 3000 台 AI 服务器，2024 年或将增长至 1.8 万 - 2 万台，采购的主要目标是满足苹果对AI算力的需求，尤其是在训练和推理生成式 AI 方面。</p><p>报告称，苹果主要采购的是英伟达的 HGX H100 8-GPU 系统，由 8 个 H100 SXM5 模块加上 4 个 NVSwitch Chip 在同一个 System board 上。这款 AI 服务器以其强大的性能和稳定的表现成为业界热门选择，单台价格高达 25 万美元（约合人民币 183 万元）。</p><p>据天风国际分析师郭明錤预测，在 2023 年和 2024 年期间，苹果将分别采购约 6.2 亿美元（约合人民币 45.38 亿元）和 47.5 亿美元（约合人民币 347.7 亿元）的 AI 服务器，总投额资达 53.3 亿美元。虽然投资额巨大，但考虑到苹果的品牌影响力和技术需求，这一投入无疑是值得的。</p><p>目前各行各业对 AI 技术应用持续渗透，对于 AI 算力的需求暴增，全球 AI 服务器市场将迎来更大规模的增长。郭明錤也指出，在未来几年中，全球 AI 服务器市场将继续保持强劲增长，并为相关企业带来更多机会。因此，对于那些想要在这个领域取得成功的企业来说，关注并积极参与 AI 服务器市场的扩张至关重要。（来源：芯智讯）</p><h3 id="TestFlight-让管理测试员变得更加简单"><a href="#TestFlight-让管理测试员变得更加简单" class="headerlink" title="TestFlight 让管理测试员变得更加简单"></a>TestFlight 让管理测试员变得更加简单</h3><p><img src="https://files.mdnice.com/user/17787/a743075b-d7aa-48f5-a206-ac5461e7ad81.png" alt=""></p><p>2023 年 10 月 24 日</p><p>借助 TestFlight，你可轻松获取有关 App Beta 版的反馈，以便放心地在 App Store 上进行发布。现在，使用 App Store Connect 中经改进的控件，你可更有效地评估测试员的参与度并管理参与情况，以充分利用 Beta 测试。你可按状态和参与度指标 (例如会话、崩溃和反馈) 对测试员进行排序，并删除参与度较低的非活跃测试员。你还可以按设备和操作系统进行筛选，甚至选择相关测试员，以将其添加到新的群组中。</p><h3 id="推送通知控制面板现已推出新交付指标"><a href="#推送通知控制面板现已推出新交付指标" class="headerlink" title="推送通知控制面板现已推出新交付指标"></a>推送通知控制面板现已推出新交付指标</h3><p><img src="https://files.mdnice.com/user/17787/345f138a-5923-41ec-9c9b-613a06ffb979.png" alt=""></p><p>2023 年 10 月 19 日</p><p>推送通知控制面板现在包含在生产环境中通过 Apple 推送通知服务 (APNs) 发送的通知的指标。借助控制面板的直观界面，你可以查看交付状态的聚合视图，深入了解通知的各种统计数据 (包括基于推送类型和优先级的详细细分)。</p><p>我们在 WWDC23 (简体中文字幕) 公布的推送通知控制面板，将能帮助你轻松地通过 APNs 向 Apple 设备发送测试通知。</p><h3 id="Apple-Vision-Pro-开发者实验室现已扩展到纽约市和悉尼"><a href="#Apple-Vision-Pro-开发者实验室现已扩展到纽约市和悉尼" class="headerlink" title="Apple Vision Pro 开发者实验室现已扩展到纽约市和悉尼"></a>Apple Vision Pro 开发者实验室现已扩展到纽约市和悉尼</h3><p><img src="https://files.mdnice.com/user/17787/469efa54-6995-47ae-8117-c793957ef8e7.png" alt=""></p><p>2023 年 10 月 17 日</p><p>我们非常兴奋能看到世界各地的开发者对 Apple Vision Pro 开发者实验室的期待和热情。很高兴能在此宣布，我们已在纽约市和悉尼设立新的实验室。欢迎参加我们的开发者实验室活动，直接在设备上进行测试，与 Apple 专家沟通交流以获得帮助，一起探索如何让你的 visionOS、iPadOS 和 iOS App 在这个激动人心的新平台上更进一步。我们还分别在库比蒂诺、伦敦、慕尼黑、上海、新加坡和东京设立了实验室。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0410-atomics.md" title="SE-0410" target="_blank" rel="noopener">SE-0410</a> <strong>Low-Level Atomic Operations </strong> 提案正在审查。</p><p>该提案为标准库添加了一组有限的低级原子操作，包括 C++ 风格的内存排序的原生拼写。我们的目标是使编写系统级代码的勇敢的图书馆作者和开发人员能够直接在 Swift 中构建同步结构。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0411-isolated-default-values.md" title="SE-0411" target="_blank" rel="noopener">SE-0411</a> <strong>隔离的默认值表达式</strong> 提案正在审查。</p><p>默认值表达式允许用于默认参数和默认存储属性值。当前默认值表达式的 actor 隔离规则存在一些问题：<strong>存储属性的规则容许数据竞争，默认参数值的规则过于限制，而在不同的默认值表达式使用位置之间的规则相互矛盾，导致 actor 隔离模型更难理解</strong>。</p><p>该提案统一了默认值表达式的 actor 隔离规则，消除了数据竞争，通过安全地允许默认值的隔离来提高表现力。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/find-how-a-symbol-was-imported/68052" title="查找符号是如何导入的？" target="_blank" rel="noopener">查找符号是如何导入的？</a></p><p>我有一个使用特定 API 的源文件，但没有导入定义它的包。据我所知，在该文件的导入中，即使是传递性的，也不会导入该包。 </p><p>然而，该文件在构建时“正确”编译（尽管 Xcode 15 的实时编译同意我的观点，即 API 不应该可见并生成实时错误）。</p><p>我正在使用 Xcode，该文件是一个测试，如果其中任何一个对答案有任何影响。</p><p>有没有办法可以调试此 API 的导入方式？ 除了 import 之外，是否还有其他机制可以让 swift API 可供 swift 源文件使用？</p><p><strong>回答</strong></p><p>从技术上讲，只有当你想要使用类型的名称时，才需要将其导入到该文件中。 你可以使用该类型的实例，无需：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.swift</span></span><br><span class="line"><span class="keyword">let</span> calendar = myCalendar()</span><br><span class="line"><span class="keyword">let</span> currentYear = calendar.component(.year, from: now())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"It's <span class="subst">\(currentYear)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This all works fine with no errors.</span></span><br><span class="line"><span class="comment">// The type of `calendar` is NSCalendar, but if we had written</span></span><br><span class="line"><span class="comment">//   let calendar: NSCalendar = myCalendar()</span></span><br><span class="line"><span class="comment">// that would be an error.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myCalendar</span><span class="params">()</span></span> -&gt; <span class="type">NSCalendar</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">NSCalendar</span>(calendarIdentifier: .gregorian)!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">now</span><span class="params">()</span></span> -&gt; <span class="type">Date</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Date</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 讨论 <a href="https://forums.swift.org/t/backdeployed-is-operating-as-an-override-instead-of-only-for-use-in-unsupported-platforms-versions/68071" title="@backDeployed 作为 override 运行，而不是仅用于不受支持的平台版本" target="_blank" rel="noopener">@backDeployed 作为 override 运行，而不是仅用于不受支持的平台版本</a></p><p>自 Xcode 15 和 iOS 17 发布以来，我们最近一直面临很多令人头痛的问题，因为我们 <code>@backDeployed</code> 的 API 的意外行为。 </p><p>长话短说，我发现我们 @backDeployed 的任何 API 不仅在平台部署版本“之前”的操作系统上被调用，而且也在平台部署版本“之后”的操作系统上被调用。</p><p>这可以通过单元测试或 playground 来重现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Locale</span>.<span class="title">LanguageCode</span> </span>&#123;</span><br><span class="line">  @backDeployed(before: macOS <span class="number">14.0</span>, iOS <span class="number">17.0</span>, watchOS <span class="number">10.0</span>, tvOS <span class="number">17.0</span>)</span><br><span class="line">  <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123; <span class="comment">// &lt;-- introduced in iOS 17</span></span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> #available(iOS <span class="number">17</span>, macOS <span class="number">14.0</span>, *) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"17"</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.identifier</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> locale = <span class="type">Locale</span>(identifier: <span class="string">"en_US"</span>)</span><br><span class="line">  <span class="keyword">let</span> languageCode = locale.language.languageCode!</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> desc = languageCode.debugDescription</span><br><span class="line">  <span class="comment">// ^ This print should yield "en" on iOS 16 &amp; 17</span></span><br><span class="line">  <span class="comment">// but it yields "17" on iOS 17 (proving the @backDeployed API is actually being treated as an override instead thunking to the platform deployed version).</span></span><br><span class="line">  <span class="comment">// You can comment out the @backDeployed `debugDescription` above to see it go back to correct behavior</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>实际上，我们使用 @backDeployed 来 override 任何我们喜欢的 API，而不仅仅是向后部署。</p><p>这是否可以在 Swift 的错误修复修订版中解决（最好在退出 beta 之前部署到 Xcode 15.1）？</p><p><strong>回答</strong></p><p>我认为你误解了 @backDeployed 属性的作用以及它的用途。@backDeployed 设计用于实现操作系统附带的框架。</p><p>该属性的设计目的不是为你提供一种为 SDK 中的任意函数提供你自己的 polyfill 的方法，因此，如果我正确解释了你想要完成的任务，我认为它不会达到你想要的效果 。</p><p>在你的示例中，你已为 <code>Locale.LanguageCode</code> 声明了自己的计算属性 <code>debugDescription</code>。 你的声明不会“覆盖”基金会中的声明；它只是作为可以调用的不同函数同时存在于你的模块中。是否在任何给定的调用站点调用你的实现取决于编译器将 debugDescription 静态解析为哪个声明。</p><p>如果编译器解析对你的声明的调用，而不是来自 SDK 的调用，那么你的实现上的 @backDeployed 属性将导致编译器发出对中间 thunk 的调用，该中间 thunk 调用你的原始函数或函数的副本，它不会完成任何有用的事情，因为它是同一模块中的函数，并且原始副本和后备副本将始终具有相同的实现。</p><p>3) 讨论<a href="https://forums.swift.org/t/new-swiftnio-async-apis/68056" title="新的 SwiftNIO 异步 API" target="_blank" rel="noopener">新的 SwiftNIO 异步 API</a></p><p>我很高兴与大家分享，我们刚刚发布了一些软件包的新版本，其中包括全新的异步 API。</p><ul><li>swift-nio : <a href="https://github.com/apple/swift-nio/releases/tag/2.60.0" target="_blank" rel="noopener">2.60.0</a></li><li>swift-nio-transport-services : <a href="https://github.com/apple/swift-nio-transport-services/releases/tag/1.20.0" target="_blank" rel="noopener">1.20.0</a></li><li>swift-nio-http2 : <a href="https://github.com/apple/swift-nio-http2/releases/tag/1.29.0" target="_blank" rel="noopener">1.29.0</a></li></ul><p>一段时间以来，我们一直致力于新 API 的开发，让它们在 AsyncChannel SPI 后面进行烘焙。 在最新版本中，我们将 SPI 升级为稳定的 API。</p><p>新异步 API 的目标是让开发人员能够轻松、安全地在 NIO Channels 和 Swift Concurrency 之间建立桥梁。 新 API 的一个重要部分是它们携带有关 ChannelPipeline 的类型信息，同时保持灵活性，这是通过利用泛型的强大功能实现的。 </p><p>你可以在我们全新的 <a href="https://swiftpackageindex.com/apple/swift-nio/2.60.0/documentation/niocore/swift-concurrency" title="NIO 和 Swift Concurrency 文章" target="_blank" rel="noopener">NIO 和 Swift Concurrency 文章</a>中找到有关新 API 的更多文档。如果你有兴趣阅读更多有关新 API 背后的想法并查看跨包的 API 添加的概述，请随时查看 我们的<a href="https://github.com/apple/swift-nio/blob/main/docs/public-async-nio-apis.md" target="_blank" rel="noopener">开发者文档</a>.</p><p>我想指出的一件重要的事情是，新的 API 在业务逻辑和网络之间提供了明确的关注点分离。</p><p>网络协议存在于通道管道中，业务逻辑应直接在通道管道之外的 Swift Concurrency 中实现。 许多现有应用程序都驻留在通道管道内，我们强烈建议将业务逻辑移出。</p><p>我们迫不及待地想看看社区使用新 API 构建了什么，并期待你的反馈！</p><p>4) 讨论<a href="https://forums.swift.org/t/what-s-the-right-way-to-create-a-command-line-tool-using-argumentparser-swift-package-or-xcode-create-mac-command-line-tool-project/68050" title="使用 ArgumentParser 创建命令行工具的正确方法是什么？ swift package 或 Xcode 创建 Mac 命令行工具项目？" target="_blank" rel="noopener">使用 ArgumentParser 创建命令行工具的正确方法是什么？ swift package 或 Xcode 创建 Mac 命令行工具项目？</a></p><p>我相信创建 ArgumentParser 命令行工具的正确方法是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package <span class="keyword">init</span> --type tool --name <span class="type">MyTool</span></span><br></pre></td></tr></table></figure><p>然后在 Xcode 中打开 Package.swift。 但是我无法添加这个包：<a href="https://github.com/dominicegginton/spinner" target="_blank" rel="noopener">https://github.com/dominicegginton/spinner</a></p><p>添加依赖项后，“My Mac” target 消失了。</p><p>当我从 Xcode 内部创建 macOS 命令行工具项目时，我可以找到 spinner 包并使用它。 如果我添加 ArgumentParser，运行崩溃。</p><p>我应该怎么办？</p><p><strong>回答</strong></p><p>你可以尝试分叉 Spinner，更新其软件包清单以使用 Rainbow 4+ ，取决于你的 fork，而不是原始 fork，然后看看有什么问题……</p><p>如果没有任何问题，你可以将该更改作为 PR 提交到 Spinner 项目。</p><p>5) 讨论<a href="https://forums.swift.org/t/performselector-retaincount/68055" title="performSelector(&quot;retainCount" target="_blank" rel="noopener">performSelector(“retainCount”)</a>“)</p><p>另一个线程提示我一个调用禁止的保留计数的问题——可能对调试目的有用。 我知道一些获取对象的保留计数的技术（例如，通过驻留在非 ARC obj-c 文件中的 C 帮助程序进行调用，因此能够调用保留计数，即引用线程中显示的技术）或阅读 通过 “withUnsafeBytes” 直接从 Swift 中保留 Swift 对象的原始位。 那么这个基于 performSelector 的其他方法呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="type">NSObject</span>()</span><br><span class="line"><span class="keyword">let</span> x = obj.perform(<span class="string">"retainCount"</span>)!</span><br><span class="line"><span class="comment">// p x</span></span><br><span class="line"><span class="comment">// (Unmanaged&lt;AnyObject&gt;) &#123;</span></span><br><span class="line"><span class="comment">//  _value = (object = 0x0000000000000002)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">// crash</span></span><br><span class="line"><span class="keyword">let</span> y = x.toOpaque() <span class="comment">// crash</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="keyword">let</span> z = x.takeUnretainedValue() <span class="comment">// crash</span></span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>可以对其进行调整以使其工作吗？ 它似乎工作正常，返回正确的 UnmanagedObject，我可以通过 “print” 命令在调试器中看到它，但如何从应用程序中获取它？ 我是否需要使用一些 unsafeBitCast 来读取该值？</p><p><strong>回答</strong></p><p><code>PerformSelector:</code> 返回一个对象； 它名义上仅用于返回对象的方法，而不是基元。</p><p>在 Objective-C 中，你可能可以通过将结果转换为原始类型来滥用它，但如果它不是指针大小或平台的调用约定使用不同的寄存器来返回指针与整数，你将得到垃圾（或更糟）。</p><p>我不确定你是否可以在 Swift 中执行此转换，因为 Unmanaged 假设它确实包含有效的对象引用，并且会尝试适当地保留和释放它。</p><p>6) 讨论<a href="https://forums.swift.org/t/find-how-a-symbol-was-imported/68052" title="为什么 CaseIterable 比 Set 更快" target="_blank" rel="noopener">为什么 CaseIterable 比 Set 更快</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VaccineCodeSet</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> covidModerna = <span class="string">"207"</span></span><br><span class="line">    <span class="keyword">case</span> covidBioNTech = <span class="string">"208"</span></span><br><span class="line">    <span class="keyword">case</span> covidAstraZeneca = <span class="string">"210"</span></span><br><span class="line">    <span class="keyword">case</span> covidNovax = <span class="string">"211"</span></span><br><span class="line">    <span class="keyword">case</span> covidJohnson = <span class="string">"212"</span></span><br><span class="line">    <span class="keyword">case</span> covidValneva = <span class="string">"213"</span></span><br><span class="line">    <span class="keyword">case</span> hepatitesB = <span class="string">"45"</span></span><br><span class="line">    <span class="keyword">case</span> whoopingCough = <span class="string">"11"</span></span><br><span class="line">    <span class="keyword">case</span> measles = <span class="string">"05"</span></span><br><span class="line">    <span class="keyword">case</span> mumps = <span class="string">"07"</span></span><br><span class="line">    <span class="keyword">case</span> rubella = <span class="string">"06"</span></span><br><span class="line">    <span class="keyword">case</span> chickenpox = <span class="string">"21"</span></span><br><span class="line">    <span class="keyword">case</span> tbe = <span class="string">"77"</span></span><br><span class="line">    <span class="keyword">case</span> hepatitesA = <span class="string">"85"</span></span><br><span class="line">    <span class="keyword">case</span> yellowFever = <span class="string">"184"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> allCases: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [</span><br><span class="line">        <span class="type">Self</span>.covidModerna.rawValue,</span><br><span class="line">        <span class="type">Self</span>.covidBioNTech.rawValue,</span><br><span class="line">        <span class="type">Self</span>.covidAstraZeneca.rawValue,</span><br><span class="line">        <span class="type">Self</span>.covidNovax.rawValue,</span><br><span class="line">        <span class="type">Self</span>.covidJohnson.rawValue,</span><br><span class="line">        <span class="type">Self</span>.covidValneva.rawValue,</span><br><span class="line">        <span class="type">Self</span>.hepatitesB.rawValue,</span><br><span class="line">        <span class="type">Self</span>.whoopingCough.rawValue,</span><br><span class="line">        <span class="type">Self</span>.measles.rawValue,</span><br><span class="line">        <span class="type">Self</span>.mumps.rawValue,</span><br><span class="line">        <span class="type">Self</span>.rubella.rawValue,</span><br><span class="line">        <span class="type">Self</span>.chickenpox.rawValue,</span><br><span class="line">        <span class="type">Self</span>.tbe.rawValue,</span><br><span class="line">        <span class="type">Self</span>.hepatitesA.rawValue,</span><br><span class="line">        <span class="type">Self</span>.yellowFever.rawValue</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">printTimeElapsedWhenRunningCode(title: <span class="string">"VaccineCodeSet"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">VaccineCodeSet</span>.allCases.<span class="built_in">contains</span>(<span class="string">"184"</span>) &#123;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time elapsed to check: 0.006421875 s.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// V2</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VaccineCodeCaseIterable</span>: <span class="title">String</span>, <span class="title">CaseIterable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> covidModerna = <span class="string">"207"</span></span><br><span class="line">    <span class="keyword">case</span> covidBioNTech = <span class="string">"208"</span></span><br><span class="line">    <span class="keyword">case</span> covidAstraZeneca = <span class="string">"210"</span></span><br><span class="line">    <span class="keyword">case</span> covidNovax = <span class="string">"211"</span></span><br><span class="line">    <span class="keyword">case</span> covidJohnson = <span class="string">"212"</span></span><br><span class="line">    <span class="keyword">case</span> covidValneva = <span class="string">"213"</span></span><br><span class="line">    <span class="keyword">case</span> hepatitesB = <span class="string">"45"</span></span><br><span class="line">    <span class="keyword">case</span> whoopingCough = <span class="string">"11"</span></span><br><span class="line">    <span class="keyword">case</span> measles = <span class="string">"05"</span></span><br><span class="line">    <span class="keyword">case</span> mumps = <span class="string">"07"</span></span><br><span class="line">    <span class="keyword">case</span> rubella = <span class="string">"06"</span></span><br><span class="line">    <span class="keyword">case</span> chickenpox = <span class="string">"21"</span></span><br><span class="line">    <span class="keyword">case</span> tbe = <span class="string">"77"</span></span><br><span class="line">    <span class="keyword">case</span> hepatitesA = <span class="string">"85"</span></span><br><span class="line">    <span class="keyword">case</span> yellowFever = <span class="string">"184"</span></span><br><span class="line">&#125;</span><br><span class="line">printTimeElapsedWhenRunningCode(title: <span class="string">"Array"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> code = <span class="type">VaccineCodeCaseIterable</span>(rawValue: <span class="string">"184"</span>),</span><br><span class="line">       <span class="type">IllnessCodeCaseIterable</span>.allCases.<span class="built_in">contains</span>(code) &#123;</span><br><span class="line">       <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Time elapsed to check:: 0.005916875 s.</span></span><br></pre></td></tr></table></figure><p>为什么 V1 比 V2 慢？</p><p><strong>回答</strong></p><p>V2 确实还有一项工作要做：从 String 到 enum case。 但这可以优化（在 <code>init(rawValue:)</code> 实现中），因为编译器知道可能的有效字符串的完整集合，因此它最终比哈希查找更快。</p><p>事实上，由于所有字符串都很短，它甚至可以作为整数开关来完成，在检查长度后将字符串内容视为多字节整数。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/10/17/mastering-preview-macro-in-swift//" title="掌握 swift 中  Preview macro 的用法" target="_blank" rel="noopener">掌握 swift 中  Preview macro 的用法</a></p><p><strong>摘要：</strong>  本篇博客介绍了 Swift 中的新功能——预览宏（Preview macro），以及它对开发体验的改进。预览宏可以轻松地将 SwiftUI 视图、UIViewController 或 UIView 实例嵌入到预览中。文章还讨论了如何创建展示不同视图状态的多个预览，并通过传递标题参数来区分它们。此外，它还介绍了预览宏的 traits 参数，可以在预览中显示横向视图或指定尺寸。文章最后提到了如何将预览宏与 widget 结合使用来展示交互式的 widget 时间线。作者建议开发者可以利用预览宏来改善开发体验，并指出可以创建专门用于设计系统包的预览文件或示例用法的文件。</p><p><a href="https://onevcat.com/2022/10/spm-in-xcode/" title="Xcode 中使用 SPM 和 Build Configuration 的一些坑" target="_blank" rel="noopener">Xcode 中使用 SPM 和 Build Configuration 的一些坑</a></p><p><strong>摘要：</strong>  本文介绍了 Swift 中的值和类型参数包，并结合示例进行了详细解释。类型参数包和值参数包允许你编写一个接受任意数量具有不同类型参数的通用函数。在 Swift 5.9 中，由于 SE-393、SE-398 和SE-399 的提案，这一新特性得以实现。采用参数包的最显著影响之一是在 SwiftUI 中的10个视图限制已经不存在，这是由于在这些提案之后可实现了可变参数泛型。本文还解释了参数包的解决方案，它们帮助我们编写可重用的代码，避免编写大量的函数重载。从 Swift 5.9 开始，我们可以使用参数包重写类似的函数。</p><p><a href="https://www.avanderlee.com/swift/user-defaults-preferences/" title="Swift 中 User Defaults 的读取和写入" target="_blank" rel="noopener">Swift 中 User Defaults 的读取和写入</a></p><p><strong>摘要：</strong> 这篇文章讨论了在 Swift 中使用 User Defaults进行读取和写入的方法。User Defaults 是 Swift 应用程序中用于存储在应用程序启动期间保持不变的偏好设置的首选解决方案。它是一个基于属性列表（plist）文件的键值存储。文章介绍了一些与 User Defaults 工作时的最佳实践，并提供了一些特定的解决方案和建议。其中包括使用应用程序组与其他应用程序和扩展共享 User Defaults，以及类型支持和数据转换的注意事项。此外，文章还介绍了监听 User Defaults 更改的方法，并探讨了一些替代方案，如 Keychain 和 CloudKit。在文章的结尾，作者总结了使用 User Defaults 存储偏好设置的好处，并提醒读者在需要跨设备访问数据或存储敏感数据时考虑其他解决方案。。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>10月27日，起家于东南亚的极兔速递正式登陆港交所。此次IPO，发行价12港元/股,市值约1000亿港元，成为港交所2023年迄今开盘市值最高的IPO。在诸多物流行业，你最看好哪一家？</strong></p><ol><li>菜鸟</li><li>顺丰</li><li>京东物流</li><li>极兔</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第四十期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;世间万般兵刃，唯有过往伤人最深。&lt;strong&gt;Swift社区&lt;/strong&gt;邀你走出低谷，迈向山巅！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：53.5亿美元！传苹果今明两年或将采购2.3万台AI服务器！&lt;/p&gt;
&lt;p&gt;提案：隔离的默认值表达式&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论为什么 CaseIterable 比 Set 更快&lt;/p&gt;
&lt;p&gt;推荐博文：掌握 swift 中  Preview macro 的用法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;在诸多物流行业，你最看好哪一家？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十九期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十九期/</id>
    <published>2024-03-06T07:56:54.000Z</published>
    <updated>2024-03-06T08:04:17.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十九期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>梦想之所以遥不可及，是因为今天的你和昨天一样，并没有拉近与梦想的距离。<strong>Swift社区</strong>陪你努力每一天，一同迈向象牙塔！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：卖不动了 iPhone 在美国市场销量或陷入停滞</p><p>提案：在导入声明上使用访问级别修饰符</p><p>Swift 论坛：讨论从头开始的基本 HTTP 客户端</p><p>推荐博文：用示例解释了 Swift 中的值和类型参数包</p><p><strong>话题讨论：</strong> </p><p>如果公司允许远程办公但要降薪，薪资降多少可以接受？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/4e9ccec8-5750-40b8-9a4d-93d52d0260b5.jpg" alt=""></p><p>这个投票结果反映了人们在度过假期时的不同偏好，有些人喜欢冒险和旅行，有些人更愿意宅在家里，而还有一些人则追求休闲和享受。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="卖不动了-iPhone-在美国市场销量或陷入停滞"><a href="#卖不动了-iPhone-在美国市场销量或陷入停滞" class="headerlink" title="卖不动了 iPhone 在美国市场销量或陷入停滞"></a>卖不动了 iPhone 在美国市场销量或陷入停滞</h3><p>10 月 8 日消息，作为苹果公司总部的所在地，iPhone 在美国当地市场的销量一直是很可观的。之前就有报告披露 iPhone 在美国市场有 1.67 亿用户，要比安卓系统用户的 1.44 亿高出 2300 万。</p><p>不仅如此，美洲市场向来也是苹果主要的营收来源，常年在占据在 40% 左右。苹果的财报显示，在截至 7 月 1 日的 2023 财年第三财季，营收的 817.97 亿美元美洲市场贡献了 353.83 亿美元，远高于欧洲等市场。而在第二财季 948.36 亿美元的营收中，美洲市场则是贡献了 377.84 亿美元。</p><p>但是这一情况或将在明年有所改变，根据 Business Insider（BI）的第三轮专项年度调查数据显示。由于经济形势的不确定以及手机更新周期延长，在美国市场许多用户将会继续使用老款手机而不是升级到 iPhone 15，预计明年 iPhone 在美销量或将陷入停滞。</p><p>不过该调查还强调，虽然 iPhone 的销量会走低，但是苹果公司的营收仍有望增加。这主要还是因为消费者更偏向购买价格更高的 Pro Max 系列，这也在一定程度上保证在面临销量压力时能保持较高收入水平。</p><p>此外调查还发现，决定转用安卓系统的用户占比远高于转用苹果的用户，也有很多用户表示计划减少 iCloud 和 Apple TV+ 等增值服务。</p><p>据多家投行预测，iPhone 15 的出货量将在 7000 万到 8000 万部之间，低于去年同期的 iPhone 14 的 9000 万部以上。而根据 IDC 最新发布的数据，2023 年全球智能手机出货量预计同比减少 4.7% 至 11.5 亿部，创十年来新低。（来源：快科技）</p><h3 id="与-Apple-专家会面交流"><a href="#与-Apple-专家会面交流" class="headerlink" title="与 Apple 专家会面交流"></a>与 Apple 专家会面交流</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/053312EB-FF8B-40A6-A4D9-DCFE9BC7A628/2048.jpeg" alt=""></p><p>欢迎参加为全球开发者量身打造的各种讲座、咨询、实验室等，与我们一起探索相关问题。</p><p>Apple 开发者活动为处于开发之旅各个阶段的人士打造，全年以线上和线下的形式在世界各地举行。无论你是希望提升现有的 App 或游戏、完善设计还是启动新项目，总有活动适合你。</p><p>申请设计一对一咨询，2023 年 10 月 16 日 上午 10:00 – 下午 5:00 (GMT+8) ，30 分钟线上咨询，地点：Shanghai，与 Apple 专家远程交流，共同探索如何设计美观易用的出色 App。在时长 25 分钟的线上咨询中，你可以征询关于最新 UI/UX 设计原理、最佳实践、设计模式等方面的建议。活动语言为普通话。</p><p>App 曝光度和营销入门，2023 年 10 月 31 日 中午 11:00 – 中午 12:00 (GMT+8) ，线上讲座，地点：Beijing，在这个线上讲座中，了解如何提高你的 App 在 App Store 上的曝光度。探索人们如何在 App Store 上查找 App，了解优秀产品页应包含的要素，并学习如何提升 App 的曝光度。我们还将探讨搜索功能、推荐流量的作用以及可带来更多下载次数的推广功能。活动语言为普通话。</p><p>Apple Vision Pro 开发者实验室 - 上海，2023 年 10 月 31 日 上午 9:30 – 2023 年 11 月 2 日 下午 5:00 (GMT+8)，线下讲座，地点：上海设计开发加速器。参加为期一天的开发者实验室，体验在 Apple Vision Pro 上运行的 visionOS、iPadOS 或 iOS App。你将能够在 Apple 的帮助下测试、细化并优化你的 App 和游戏，让它们在无边的空间画布中提供卓越的体验。由于场地有限，我们会审核每个请求，然后你会收到一封告知申请状态的电子邮件。请务必详细回答所有必填问题。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md" title="SE-0409" target="_blank" rel="noopener">SE-0409</a> <strong>在导入声明上使用访问级别修饰符</strong> 提案通过审查。该提案已在 <strong>三十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0408-pack-iteration.md" title="SE-0408" target="_blank" rel="noopener">SE-0408</a> <strong>包迭代</strong> 提案通过审查。该提案已在 <strong>三十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/emitting-module-takes-25x-the-time-in-xcode-15-1-beta/67671" title="Emitting 模块花费的时间是 XCode 15.1 beta 的 25 倍" target="_blank" rel="noopener">Emitting 模块花费的时间是 XCode 15.1 beta 的 25 倍</a></p><p>XCode 15.0 ( Swift 5.9.0.128.108 ) 和 XCode 15.1 Beta ( Swift 5.9.2.1.6 ) 之间的构建“发出模块”阶段似乎存在一些退化。</p><p>我的 XCWorkspace 中有几个不同的框架和应用程序。 在 15.1 beta 中，大多数编译速度都差不多，或者稍快一些。 然而，我们拥有的一个框架的时间似乎是以前的 10 倍以上。 当在 Xcode 时间线中查看时，几乎所有时间都花在“Emitting Module”阶段。 </p><p>在干净的构建中，时间从约 56 秒缩短到约 1440 秒。 另外，有些文件的编译速度似乎确实慢了一些，但这是一个很大的瓶颈，除了当时的“发射模块”之外，时间线中没有其他真正发生的事情。 </p><p>如果我当时观看 Activity Monitor，我的 CPU 的 swift-frontend 进程在此期间将保持在 100%。 但除此之外似乎没有什么可疑的。 比较输出，框架的大小几乎相同，我没有看到任何其他真正值得注意的东西。</p><p>关于什么会导致这种巨大差异有什么想法吗？</p><p><strong>回答</strong></p><p>我刚刚发现并修复了 39 个案例，当模块中包含大量 Swift 文件时，我们会看到这种情况发生。 （大量宏展开也可能发生）。对于我们看到回归的项目，“发射模块”阶段从 300 秒下降到 32 秒。</p><p>它很可能与您所看到的相同。 如果您能够捕获一个旋转转储，我们可以使用旋转转储来验证这一点，或者如果您想尝试的话，我们可以启动工具链构建。</p><p>[编辑：对于那些好奇的人来说，编译器有一个线性时间算法，可以从源位置的内部表示映射到该位置所在的源文件。 该算法“永远”是线性时间的，但最近的错误修复将其置于热路径中。 解决方法是将其转换为具有单元素最近使用的缓存的对数算法。]</p><p>2) 讨论<a href="https://forums.swift.org/t/status-check-int128-uint128/67694" title="状态检查：Int128 和 UInt128" target="_blank" rel="noopener">状态检查：Int128 和 UInt128</a></p><p>Swift 标准库实际上包含 Int128 和 UInt128，它们只是没有作为公共 API 公开。 它们是作为 SE-0329 的先决条件添加的：时钟、即时和持续时间。 他们在公共 API 中的明显缺席甚至在该提案的[第三次]审查期间被提出，但因超出范围而被推迟。 多年来，一直有人对它们提出要求，甚至可以追溯到这些论坛存在之前。</p><p>swift-numerics（本质上）拥有自己的 128 位整数重新实现，现在基金会也正在考虑添加自己的。</p><p>更不用说各种第 3 方包，以及其他 Swift 库和程序中这些类型的大量私有重新实现。</p><p>复制粘贴扩散这样一个基本的数字类型似乎有点愚蠢，当它已经在标准库中时，只需要发布它即可。 不过，我怀疑这已经是实现这一目标的目标，所以我希望问题只是：预计到达时间？</p><p><strong>回答</strong></p><p>需要明确的是：Foundation 库不考虑添加自己的。 他们建议使用 Numerics 现有的 DoubleWidth 测试支持来进行测试。 我们很快就会为 stdlib 推荐 Int128，但即使它可用，由于可用性限制（至少在中期），Foundation 和 Numerics 仍应使用双宽度类型进行测试。 所以无论如何，这都是正确的前进道路。</p><p>3) 讨论<a href="https://forums.swift.org/t/do-i-have-to-manually-check-macro-parameters-to-be-literals/67687" title="我是否必须手动检查宏参数是否为文字？" target="_blank" rel="noopener">我是否必须手动检查宏参数是否为文字？</a></p><p>在做了一些实验来了解如何开发一个真正的宏之后，我遇到了一个问题：我试图开发一个 <code>@AddCompletionHandler</code> 宏（如 WWDC 演讲中提到的那样），并且我尝试将完成参数名称传递为 宏的参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@attached(peer, names: overloaded)</span><br><span class="line"><span class="keyword">public</span> macro <span class="type">AddCompletionHandler</span>(completionName: <span class="type">String</span> = <span class="string">"onCompletion"</span>) = #externalMacro(...)</span><br></pre></td></tr></table></figure><p>我应该得到一个字符串，我将使用它来构建要添加到函数签名的新参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionParameter: <span class="type">FunctionParameterSyntax</span> = <span class="string">"<span class="subst">\(raw: completionParameterName)</span>: @escaping (<span class="subst">\(returnType)</span>) -&gt; Void"</span></span><br></pre></td></tr></table></figure><p>并在新生成的函数块内调用完成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newCode: <span class="type">CodeBlockItemListSyntax</span> = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Task.detached &#123;</span></span><br><span class="line"><span class="string">        await <span class="subst">\(raw: completionParameterName)</span>(<span class="subst">\(functionDeclaration.wrappedInvocation)</span>)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><p>这样做的问题是宏声明接受任何返回字符串的表达式，因此您可以像这样调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">AddCompletionHandler</span>(completionName: <span class="string">"on"</span> + <span class="string">"Completion"</span>)</span><br></pre></td></tr></table></figure><p>我发现自己手动检查 AttributeSyntax 树是否包含一个名为completionName 的参数，该表达式的类型为 <code>StringLiteralExprSyntax</code>，只有一个段，最后提取该值作为该唯一段的 <code>.content.text</code>。 如果这些步骤中的任何一个失败，我都会发出一条诊断消息，要求该值是一个文字。</p><p>这是应该如何工作的吗？ 对于看似常见的用例来说，这似乎是一个极其繁琐的过程。 我在这里错过了什么吗？</p><p><strong>回答</strong></p><p>这是实现它的一种迂回方式，但您可以执行以下操作：</p><p>定义符合 <code>ExpressibleByStringLiteral</code> 的自定义类型，并使用该类型作为宏的参数而不是 String。 用户仍然可以将字符串文字直接传递给宏调用，但他们无法执行任何接近但不是文字的操作，例如 “hello”+“world”。</p><p>但是，这仍然会让有人这样做，这是你不希望的，因为你无法评估 x：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">YourCustomType</span> = <span class="string">"onCompletion"</span></span><br><span class="line">@<span class="type">AddCompletionHandler</span>(completionName: x)</span><br></pre></td></tr></table></figure><p>因此，下一个技巧是，当您在自定义类型中实现 init(stringLiteral:) 时，只需将其设置为 fatalError() 即可。 这将阻止任何人尝试创建它的实例并将其存储在某个地方。 但该类型在宏使用中仍然有效，因为在宏调用中使用宏时，该类型实际上并不调用 init(stringLiteral:) 。 它所要做的就是类型检查它是否有效，确实如此。 （如果有人确实尝试在某处创建显式实例，则直到运行时才会捕获该错误。）</p><p>使这变得更容易的是某种参数必须为常量的功能，这些功能之前已经在这些论坛上讨论过。</p><p>仅当用户尝试直接实例化新类型时才会发生运行时错误，否则除了在宏签名中命名之外，该新类型对他们是隐藏的。 将其命名为 <code>CompletionHandlerNameLiteral</code> 之类的名称，这样就不会混淆其用途。</p><p>没有编译时失败被转移到运行时，因为它严格阻止了编译器以前允许的使用：现在编译器不再允许像“hello”+“world”这样的表达式并要求宏检查它，而是 编译器会停止它，宏不再需要检查它。</p><p>这不是一个完美的解决方案，但我可以理解，用户并不都希望为“这是一个文字吗”之类的事情编写相同的检查，因此最好让编译器在可能的情况下为您完成工作。 在缺乏 const-value 强制功能的情况下，SwiftSyntax 将成为此类辅助 API 的良好家园，至少可以减轻负担。</p><p>4) 讨论<a href="https://forums.swift.org/t/swift-runtime-unable-to-suspend-thread-when-compiling-in-qemu/67676" title="从头开始的基本 HTTP 客户端" target="_blank" rel="noopener">从头开始的基本 HTTP 客户端</a></p><p>我想使用 Swift 从头开始创建基本的 HTTP 客户端，以达到学习目的，以了解互联网上 http 的发送者和接收者是如何工作的。 这只是出于原始学习目的，所以我只想使用套接字。 现在我正在本地主机中尝试，我在SO 1中发布了相同的内容。我尝试了下面的代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Darwin</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> host: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> port: <span class="type">UInt16</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(host: <span class="type">String</span>, port: <span class="type">UInt16</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.host = host</span><br><span class="line">        <span class="keyword">self</span>.port = port</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="number">_</span> completionHandler: @escaping<span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a socket</span></span><br><span class="line">        <span class="keyword">let</span> sock = socket(<span class="type">AF_INET</span>, <span class="type">SOCK_STREAM</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> serveraddr = sockaddr_in()</span><br><span class="line">        serveraddr.sin_family = sa_family_t(<span class="type">AF_INET</span>)</span><br><span class="line">        serveraddr.sin_port = <span class="keyword">self</span>.port</span><br><span class="line">        serveraddr.sin_addr.s_addr = inet_addr(<span class="keyword">self</span>.host)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect to the server</span></span><br><span class="line">          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Connecting...."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">withUnsafePointer</span>(to: &amp;serveraddr) &#123; sockaddrInPtr <span class="keyword">in</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">let</span> sockaddrPtr = <span class="type">UnsafeRawPointer</span>(sockaddrInPtr).assumingMemoryBound(to: sockaddr.<span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">let</span> connection = connect(sock, sockaddrPtr, socklen_t(<span class="type">MemoryLayout</span>&lt;sockaddr_in&gt;.size))</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> connection == <span class="number">0</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Form an HTTP GET request</span></span><br><span class="line">                <span class="keyword">let</span> request = <span class="string">"GET / HTTP/1.1\r\nHost: <span class="subst">\(<span class="keyword">self</span>.host)</span>\r\n\r\n"</span></span><br><span class="line">                <span class="keyword">let</span> bytes = [<span class="type">UInt8</span>](request.data(using: .utf8)!)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Send the request over the socket</span></span><br><span class="line">                send(sock, bytes, request.<span class="built_in">count</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // Receive and print the response</span></span><br><span class="line"><span class="comment">                var response = [UInt8](repeating: 0, count: 1024)</span></span><br><span class="line"><span class="comment">                let bytesRead = recv(sock, &amp;response, response.count, 0)</span></span><br><span class="line"><span class="comment">                if bytesRead &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">                    if let httpResponse = String(bytes: response, encoding: .utf8) &#123;</span></span><br><span class="line"><span class="comment">                        print(httpResponse)</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // Close the socket</span></span><br><span class="line"><span class="comment">                close(sock)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"not connected <span class="subst">\(connection)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> client: <span class="type">Client</span> = .<span class="keyword">init</span>(host: <span class="string">"127.0.0.1"</span>, port: <span class="number">8080</span>)</span><br><span class="line">client.<span class="keyword">get</span> &#123;</span><br><span class="line">                </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"GET request successfully executed!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用 python3 -m http.server 8080 作为包含一些文件的文件夹上的测试服务器。 它适用于浏览器和邮递员 GET 请求。</p><p>但问题是 cleint 退出，打印未连接 -1</p><p>我该如何解决此问题并成功请求？</p><p><strong>回答</strong></p><p>从 Swift 正确使用 BSD 套接字是一个严峻的挑战。 我自己在这个问题上反复讨论了很多次，最终选择了从 <a href="https://developer.apple.com/forums/thread/734124" title="Swift 调用 BSD 套接字中所示的方法" target="_blank" rel="noopener">Swift 调用 BSD 套接字中所示的方法</a>。 正如那篇顶级文章中所解释的，这并不适用于生产代码，而是适用于我们在这里讨论的测试项目。</p><p>至于您是否应该使用 BSD 套接字，这是我在 TN3151 <a href="https://developer.apple.com/documentation/technotes/tn3151-choosing-the-right-networking-api" title="选择正确的网络 API" target="_blank" rel="noopener">选择正确的网络 API</a> 中介绍的内容。</p><p>哦，实现一个正确的 HTTP 客户端非常困难，即使您将自己限制为 HTTP/1.1 而没有 HTTPS。 因此，虽然为这样的测试项目编写自己的 HTTP 代码很好，但如果您打算部署它，我建议您使用现有的 HTTP 库。<br>需要明确的是，ATS 仅适用于 URLSession 及以上版本。 低级 API，如网络框架和 BSD 套接字，只是忽略 ATS。</p><p>应用程序沙箱适用于所有网络连接，因此这是正确的举措（-：</p><p>5) 讨论<a href="https://forums.swift.org/t/different-macro-implementation-for-different-platforms/67693" title="不同平台不同的宏实现" target="_blank" rel="noopener">不同平台不同的宏实现</a></p><p>我正在尝试创建一个宏，允许我在资源包中按名称引用颜色。</p><p>例如，能够执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myColor = #color(<span class="string">"MyColor"</span>)</span><br></pre></td></tr></table></figure><p>在 macOS 上，我希望将其为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"NSColor(named: <span class="subst">\(argument)</span>) ?? NSColor.clear"</span></span><br></pre></td></tr></table></figure><p>在 iOS 上，我希望它是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"UIColor(named: <span class="subst">\(argument)</span>)"</span></span><br></pre></td></tr></table></figure><p>我写了以下宏：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">ColorMacro</span>: <span class="title">ExpressionMacro</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">expansion</span><span class="params">(of node: some FreestandingMacroExpansionSyntax, <span class="keyword">in</span> context: some MacroExpansionContext)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">ExprSyntax</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> argument = node.argumentList.first?.expression <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">MacroError</span>.invalidArguments</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> canImport(<span class="type">AppKit</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"NSColor(named: <span class="subst">\(argument)</span>) ?? NSColor.clear"</span></span><br><span class="line">#elseif canImport(<span class="type">UIKit</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UIColor(named: <span class="subst">\(argument)</span>)"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">        #error(<span class="string">"Unsupported platform"</span>)</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> canImport(<span class="type">AppKit</span>)</span><br><span class="line"><span class="keyword">import</span> AppKit</span><br><span class="line"></span><br><span class="line">@freestanding(expression)</span><br><span class="line"><span class="keyword">public</span> macro color(<span class="number">_</span> named: <span class="type">String</span>) -&gt; <span class="type">NSColor</span> = #externalMacro(module: <span class="string">"SwatchbookMacrosMacros"</span>, type: <span class="string">"ColorMacro"</span>)</span><br><span class="line">#elseif canImport(<span class="type">UIKit</span>)</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line">@freestanding(expression)</span><br><span class="line"><span class="keyword">public</span> macro color(<span class="number">_</span> named: <span class="type">String</span>) -&gt; <span class="type">UIColor</span> = #externalMacro(module: <span class="string">"SwatchbookMacrosMacros"</span>, type: <span class="string">"ColorMacro"</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在为 macOS 构建时效果很好，但在为 iOS 构建的目标中使用时，它似乎仍在尝试使用 AppKit 分支并引用 NSColor。</p><p>难道我做错了什么？ 是否使用正在构建的平台来确定可用性，而不是目标平台？</p><p><strong>回答</strong></p><p>这里的问题是 #if 块是 IfConfigDeclSyntax，而不是表达式。 不过，您可以将整个事情包装在立即执行的闭包中，使其成为一个表达式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    #if canImport(AppKit)</span></span><br><span class="line"><span class="string">      NSColor(named: <span class="subst">\(argument)</span>) ?? NSColor.clear</span></span><br><span class="line"><span class="string">    #elseif canImport(UIKit)</span></span><br><span class="line"><span class="string">      UIColor(named: <span class="subst">\(argument)</span>)</span></span><br><span class="line"><span class="string">    #else</span></span><br><span class="line"><span class="string">      #error("</span><span class="type">Unsupported</span> platform<span class="string">")</span></span><br><span class="line"><span class="string">    #endif</span></span><br><span class="line"><span class="string">  &#125;()</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><p>但如果您打算执行所有这些操作，那么在宏的库目标中创建一个辅助函数并调用它可能会更干净、更简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">__colorHelper</span><span class="params">(<span class="number">_</span> name: String)</span></span> &#123;</span><br><span class="line">  #<span class="keyword">if</span> canImport(<span class="type">AppKit</span>)</span><br><span class="line">    <span class="type">NSColor</span>(named: name) ?? <span class="type">NSColor</span>.clear</span><br><span class="line">  #elseif canImport(<span class="type">UIKit</span>)</span><br><span class="line">    <span class="type">UIColor</span>(named: name)</span><br><span class="line">  #<span class="keyword">else</span></span><br><span class="line">    #error(<span class="string">"Unsupported platform"</span>)</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并让您的宏实现调用该函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  YourModuleName.__colorHelper(<span class="subst">\(argument)</span>)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/whats-new-swift-debugging-5.9/" title="Swift 5.9 中的调试改进" target="_blank" rel="noopener">Swift 5.9 中的调试改进</a></p><p><strong>摘要：</strong>  本篇官方文章介绍了 Swift 5.9 在编译器和 LLDB 调试器中引入了许多新的调试功能。以下是三个改变，可以帮助你在日常调试工作中更加便捷。首先，通过使用快捷命令别名 p 和 po 进行变量检查可以更快速地进行操作。</p><p>其次，LLDB 的 dwim-print 命令提供了更加用户友好的方式来打印变量。而且，在 Swift 5.9中，使用 p 命令不再会创建像 $R0 这样的持久结果变量，这些变量常常在调试会话中未被使用。最后， LLDB 现在支持在表达式评估中使用泛型类型参数，这使得在调试过程中能更好地区分不同的变量。Swift 5.9 还引入了更精确的词法作用域信息，使得调试器能够更好地区分不同的变量。</p><p><a href="https://www.avanderlee.com/swift/value-and-type-parameter-packs/" title="用示例解释了 Swift 中的值和类型参数包" target="_blank" rel="noopener">用示例解释了 Swift 中的值和类型参数包</a></p><p><strong>摘要：</strong>  本文介绍了 Swift 中的值和类型参数包，并结合示例进行了详细解释。类型参数包和值参数包允许你编写一个接受任意数量具有不同类型参数的通用函数。在 Swift 5.9 中，由于 SE-393、SE-398 和SE-399 的提案，这一新特性得以实现。</p><p>采用参数包的最显著影响之一是在 SwiftUI 中的10个视图限制已经不存在，这是由于在这些提案之后可实现了可变参数泛型。本文还解释了参数包的解决方案，它们帮助我们编写可重用的代码，避免编写大量的函数重载。从 Swift 5.9 开始，我们可以使用参数包重写类似的函数。本文末尾总结了参数包的优势，并提供了进一步学习 Swift 的资源链接。</p><p><a href="https://juejin.cn/post/7288178532861886504/" title="SwiftData 中的并发编程" target="_blank" rel="noopener">SwiftData 中的并发编程</a></p><p><strong>摘要：</strong> 本文介绍了在 SwiftData 中进行并发编程的方法。尽管在 Core Data 中进行并发编程可能有一些陷阱，但 SwiftData 作为 Core Data 的继任者提供了更加安全和优雅的并发编程机制。文章讨论了如何使用串行队列来避免数据竞争问题，如何创建使用私有队列的 ModelContext ，以及如何使用 Actor 实现更优雅的并发编程。</p><p>此外，还介绍了通过 PersistentIdentifier 来获取数据以及在非主线程中修改主线程上的对象属性的方法。通过深入了解 SwiftData 的并发编程特性，开发者可以提高代码的安全性和可读性。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>如果公司允许远程办公但要降薪，薪资降多少可以接受？</strong></p><ol><li>10%以下</li><li>25%以下</li><li>50% 以下</li><li>保持，不接受降薪</li><li>应该加薪，工作量增加</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十九期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;梦想之所以遥不可及，是因为今天的你和昨天一样，并没有拉近与梦想的距离。&lt;strong&gt;Swift社区&lt;/strong&gt;陪你努力每一天，一同迈向象牙塔！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：卖不动了 iPhone 在美国市场销量或陷入停滞&lt;/p&gt;
&lt;p&gt;提案：在导入声明上使用访问级别修饰符&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论从头开始的基本 HTTP 客户端&lt;/p&gt;
&lt;p&gt;推荐博文：用示例解释了 Swift 中的值和类型参数包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;如果公司允许远程办公但要降薪，薪资降多少可以接受？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十八期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十八期/</id>
    <published>2024-03-06T07:56:49.000Z</published>
    <updated>2024-03-06T08:03:56.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十八期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>三餐四季，春夏秋冬，平凡如尔，与众不同。<strong>Swift社区</strong>陪你苦尽甘来，笑看山河星月！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通3年</p><p>提案：在导入声明上使用访问级别修饰符</p><p>Swift 论坛：讨论 Swift 测试的新方法</p><p>推荐博文：Swift 中使用 actors 实现线程安全</p><p><strong>话题讨论：</strong> </p><p>中秋遇上了国庆，诗和远方开始了躁动，假期将至，你准备怎么过？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/799581b0-b4e6-472e-84db-e9c53aed2b28.jpg" alt=""></p><p>从投票结果可以看出，苹果的品牌忠诚度和声誉在一些用户中仍然很高，而华为和小米等品牌则通过不同的性价比策略吸引了其他一些用户。手机市场竞争激烈，消费者有幸拥有多种选择，以满足他们的不同需求。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通-3-年"><a href="#苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通-3-年" class="headerlink" title="苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通 3 年"></a>苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通 3 年</h3><p>去年底的测试发现，苹果自研的调制解调器芯片速度太慢且容易过热，电路板尺寸太大，占据半个 iPhone 的面积，无法使用。这些芯片基本上比高通最好的调制解调器芯片落后 3 年。</p><p>熟悉该项目的苹果前工程师和高管透露，由于技术挑战、沟通不畅，以及高层对尝试设计芯片而不是购买芯片是否明智的问题存在分歧，苹果调制解调器芯片的工程团队工作进展缓慢，且设定了不切实际的目标。</p><p><img src="https://d.ifengimg.com/w1125_q90_webp/x0.ifengimg.com/res/2023/D3966516AE536448301F83F355C2A452F896CC5C_size627_w2000_h1200.jpg" alt=""></p><p>苹果硬件技术高级副总裁约翰尼·斯鲁吉（Johny Srouji）领导了芯片研发。</p><p>据苹果公司前工程师和高管透露，该公司原计划将其自研调制解调器芯片用在最新的 iPhone 机型中，但去年年底的测试发现，该芯片速度太慢且容易过热，电路板尺寸太大，占据半个 iPhone 的面积，无法使用。</p><p>调制解调器芯片的作用是连接手机与无线运营商，iPhone 目前依赖高通公司生产的调制解调器芯片。本月上旬，高通宣布将苹果的采购合同延长 3 年，业界推测苹果自主研发调制解调器芯片的计划遇到挫折。</p><p>2018 年，苹果首席执行官蒂姆·库克（Tim Cook）下达设计和制造调制解调器芯片的命令，并招聘数千名工程师。目标是切断苹果对高通的依赖。据估计，去年苹果已向高通支付了超过 72 亿美元芯片采购费用。在 2017 年的诉讼中，苹果指控高通对其专利使用费收取过高费用。</p><p>熟悉该项目的苹果前工程师和高管告诉《华尔街日报》，由于技术挑战、沟通不畅，以及高层对尝试设计芯片而不是购买芯片是否明智的问题存在分歧，苹果调制解调器芯片的工程团队工作进展缓慢。团队被孤立在美国和国外的不同小组中，没有全球领导者。一些高管不鼓励工程师传播有关延误或挫折的坏消息，从而导致设定不切实际的目标和最后期限。</p><p>苹果在十多年前就致力于生产用于其产品的各种芯片。2010 年 1 月，苹果创始人史蒂夫·乔布斯在第一代 iPad 发布会上低调展示了自研的 A4 芯片，这枚 45nm 制程的芯片由三星代工，一开始并不被业界看好。一年之后，苹果在 iPhone 4S 发布会上展示了第二代芯片 A5，性能提升巨大。此后，苹果构建了由 A 系列（手机和平板）、M 系列（桌面电脑）、H 系列（耳机）、S 系列（手表）等多个产品线的芯片家族。特别是在 2020 年，苹果用 M1 芯片替代 Mac 电脑中使用多年的英特尔处理器芯片，震动了市场。今年 9 月发布的 iPhone 15 Pro 系列更是搭载了全球首款 3nm 工艺制程芯片—— A17 Pro。</p><h3 id="App-Store-现已接受适用于最新版操作系统的-App-和游戏提交"><a href="#App-Store-现已接受适用于最新版操作系统的-App-和游戏提交" class="headerlink" title="App Store 现已接受适用于最新版操作系统的 App 和游戏提交"></a>App Store 现已接受适用于最新版操作系统的 App 和游戏提交</h3><p>iOS 17、iPadOS 17、macOS Sonoma、Apple tvOS 17 和 watchOS 10 即将面向全球用户推出。使用发布候选版 Xcode 15 和最新 SDK 构建你的 App 和游戏，通过 TestFlight 进行测试，然后提交到 App Store 以供审核。现在，你可以着手从 Xcode Cloud 将你的 App 和游戏无缝部署到 TestFlight 和 App Store。借助激动人心的新功能，以及针对各种语言、框架、工具和服务的重大改进，你可以在 Apple 平台上提供更加独特的体验。</p><p>Xcode 和 Swift：Xcode 15 提供增强的代码补齐功能、交互式预览和实时动画，可让你更快地推进 App 的编码和设计。Swift 通过引入宏解锁了多个新的 API 类型，不但表现力强，且直观易用。全新的 SwiftData 框架使用声明式代码，可轻松保留数据。SwiftUI 还支持使用相位和关键帧创建更复杂的动画，并通过新的 Observation 框架简化数据流。</p><p>小组件和实时活动：小组件现在支持交互操作，并且可以在新的位置运行，例如 iPhone 上的待机界面、iPad 上的锁定屏幕、Mac 上的桌面以及 Apple Watch 上的智能叠放。借助 SwiftUI，系统会根据情境调整小组件的颜色和间距，从而提高它在各个平台中的实用性。通过 WidgetKit 和 ActivityKit 构建的实时活动现已在 iPad 上推出，以帮助用户实时了解 App 中正在发生的事情。</p><p>Metal：借助新的游戏移植工具包，可以比以往更轻松地将游戏移植到 Mac，Metal 着色器转换器大大简化了游戏着色器和图形代码的转换过程。借助最新的光线追踪更新，可将你的游戏和产品渲染器扩展到更逼真、更细腻的场景。此外还能利用许多其他增强功能，在 Apple 芯片上更轻松地提供精彩的游戏和专业 App。</p><p>App 快捷指令：如果你适配了 App 快捷指令，App 的主要功能会自动出现在聚焦中，方便用户快速访问 App 中最重要的视图和操作。新的设计让 App 快捷指令的运行变得更加容易，新的自然语言功能让用户能够更加灵活地用自己的声音来执行你的快捷指令。</p><p>App Store：借助 StoreKit 中的全新 SwiftUI 视图，你现在可以更轻松地在所有平台上推销 App 内购买项目和订阅。利用 Xcode 中的 StoreKit 测试、Apple 沙盒环境以及 TestFlight 的最新增强功能，你还可以对更多产品内容进行测试。通过按地区预购功能，你可以在新地区提供 App 并设置不同的发布日期，让用户更期待你的 App 发布。App Store 提供极为灵活且个性化的 App 发现体验，根据用户的兴趣和偏好提供量身定制的推荐内容，帮助他们找到更多出色的 App。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0407-member-macro-conformances.md" title="SE-0407" target="_blank" rel="noopener">SE-0407</a> <strong>成员 Macro 一致性</strong> 提案通过审查。该提案已在 <strong>三十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md" title="SE-0409" target="_blank" rel="noopener">SE-0409</a> <strong>在导入声明上使用访问级别修饰符</strong> 提案正在审查。</p><p>通过在导入声明上使用访问级别修饰符来声明依赖项的可见性，可以强制规定哪些声明可以引用导入的模块。可以将依赖项标记为仅对源文件、模块、包或所有客户端可见。这将让声明的访问级别行为对依赖项和导入的声明也适用。此功能可以隐藏实现细节，有助于管理依赖项的扩散。</p><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0406-async-stream-backpressure.md" title="SE-0406" target="_blank" rel="noopener">SE-0406</a> <strong>对 AsyncStream 的 Backpressure 支持</strong> 提案被驳回。该提案已在 <strong>三十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/structural-sum-types-used-to-be-anonymous-union-types/67432" title="结构和类型（以前是匿名联合类型）" target="_blank" rel="noopener">结构和类型（以前是匿名联合类型）</a></p><p>从状态检查中衍生出一个关于匿名联合类型主题的新讨论<a href="https://forums.swift.org/t/status-check-typed-throws/66637" target="_blank" rel="noopener">线程：类型抛出</a>。</p><p>关于这个主题的衍生讨论是围绕这个<a href="https://forums.swift.org/t/status-check-typed-throws/66637/100" target="_blank" rel="noopener">评论</a>开始的。</p><p>类型化抛出就像类一样，是静态类型信息的重要载体。 你所说的相当于说“不应允许类实例在弹性库中具有特定的类类型，而应始终为 AnyObject”。 这显然是非常错误的。 不小心将自己锁定在特定错误类型中，然后在主要版本发布后后悔的可能性不是语言问题，而是工程无能问题。 作者应该采取预防措施，在设计错误类型时考虑到未来的扩展（例如，具有可选元数据的结构而不是裸枚举）。</p><p>当我们谈论这个话题时：</p><p>匿名联合类型 (A | B) 也是如此，它们只不过是某些通用枚举周围的语法糖（例如 Either<a, b="">）。 这不是什么新鲜事，Swift 已经完全能够表达这种类型，因此我不断听到的“由于编译器复杂性而经常被拒绝的提案”显然也是非常错误的。</a,></p><p><strong>结论：</strong></p><p>类型系统必须具有工程师认为合适的表达能力，以使他们的代码具有表达能力。 仅仅因为有人想不出保留静态类型信息的理由（通过使用特定的错误类型或使用匿名联合类型），并不意味着没有理由。</p><p>2) Swift使用<a href="https://forums.swift.org/t/announcing-swift-sdk-generator/67409" title="推出 Swift SDK 生成器" target="_blank" rel="noopener">推出 Swift SDK 生成器</a><br>我们很高兴地宣布推出新的<a href="https://github.com/apple/swift-sdk-generator" target="_blank" rel="noopener">开源实用程序</a>，它可以简化 Swift 包的交叉编译！</p><p>使用 Xcode 时，许多 Swift 开发人员每天都会使用从 macOS 到其他 Darwin 平台的交叉编译。 与此同时，使用命令行开发工具对 Linux 和 Swift 支持的其他平台进行交叉编译并不那么容易设置。 通过 SE-0387 35，我们希望缩小这一差距，并使交叉编译成为 SwiftPM 命令行界面中的一流功能。</p><p>虽然 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0387-cross-compilation-destinations.md" target="_blank" rel="noopener">SE-0387</a> 指定了 Swift SDK 捆绑包的格式和文件系统布局，但它没有规定如何生成这些捆绑包。 我们提供了此类生成器的参考实现，它支持 macOS 作为主机平台和一些主要的 Linux 发行版作为目标平台。</p><p>区分 Swift SDK 作者和 Swift SDK 用户非常重要。 新的 Swift SDK Generator 应主要由 Swift SDK 作者使用，他们可以根据自己的需求对其进行自定义并发布自己的 Swift SDK 捆绑包。 反过来，Swift SDK 用户可以依赖 Swift 5.9 中引入的 swift Experimental-sdk 命令来安装 Swift SDK 作者之前生成的捆绑包。</p><p>我们正在努力增加对 Swift 项目正式支持的所有 Linux 发行版的支持。</p><p>3) 讨论<a href="https://forums.swift.org/t/a-new-approach-to-testing-in-swift/67425" title="Swift 测试的新方法" target="_blank" rel="noopener">Swift 测试的新方法</a><br>大家好，</p><p>我很高兴地宣布一个新的开源项目，旨在探索 Swift 测试体验的改进。 我和我的同事最近几个月一直在致力于此工作，并取得了一些早期进展，我们很高兴与大家分享。</p><p>受到 Swift 宏的启发，我们构建了一个测试库 API，它可以：</p><p>使用名为 @Test 的附加宏提供有关各个测试的详细信息。 这使得许多新功能成为可能，例如表达需求、传递参数或添加自定义标签，所有这些都直接在代码中而不是单独的配置文件中实现。</p><p>使用拼写为 #expect(…) 的表达式宏，通过详细且可操作的故障信息验证测试中的预期条件。 它通过自动捕获传入表达式的值及其源代码来通知失败消息，并且比专门的断言函数更容易学习，因为它接受内置运算符表达式，如 <code>#expect(a == b)</code>。</p><p>通过向函数添加参数并在 @Test 属性中指定其参数，可以使用不同的输入轻松重复测试多次。</p><p>这是一个示例：它显示了一个测试函数，使用 @Test 表示，其中包含两个特征：自定义显示名称和决定测试是否应运行的条件。 该测试创建一辆食品卡车，在其中存放食物，然后使用 #expect 检查食物数量是否等于我们期望的值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span>(<span class="string">"The Food Truck has enough burritos"</span>,</span><br><span class="line">      .enabled(<span class="keyword">if</span>: <span class="type">FoodTruck</span>.isAvailable))</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foodAvailable</span><span class="params">()</span></span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> foodTruck = <span class="type">FoodTruck</span>()</span><br><span class="line">    <span class="keyword">try</span> await foodTruck.stock(.burrito, quanity: <span class="number">15</span>)</span><br><span class="line">    #expect(foodTruck.quantity(of: .burrito) == <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述测试失败，#expect 将捕获数量(of: .burrito) 等子表达式的值以及源代码文本。 这允许在输出中包含丰富的诊断信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">✘ <span class="type">Test</span> <span class="string">"The Food Truck has enough burritos"</span> recorded an issue at <span class="type">FoodTruckTests</span>.swift:<span class="number">8</span>:<span class="number">6</span>:</span><br><span class="line"><span class="type">Expectation</span> failed: (foodTruck.quantity(of: .burrito) → <span class="number">15</span>) == <span class="number">20</span></span><br></pre></td></tr></table></figure><p>使用这种方法，使用不同的输入多次重复测试（称为参数化测试 15）也很简单。 @Test 属性可以包含参数，并且该函数将被重复调用并传递每个参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span>(arguments: [<span class="type">Food</span>.burrito, .taco, .iceCream])</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foodAvailable</span><span class="params">(food: Food)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> foodTruck = <span class="type">FoodTruck</span>()</span><br><span class="line">    #expect(foodTruck.quantity(of: food) == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-testing/blob/main/Documentation/Vision.md" title="Swift 测试的新 API 方向" target="_blank" rel="noopener">Swift 测试的新 API 方向</a>深入探讨了我们的愿景，描述了项目的目标，并展示了我们提出的方法的更多示例。</p><p>这些想法已在名为 <a href="https://github.com/apple/swift-testing" target="_blank" rel="noopener">swift-testing</a> 的新包中原型化，该包目前被认为是实验性的，尚未推荐用于一般生产用途。 如果你感兴趣，我们鼓励你克隆它，探索它的实现，并尝试使用它为你的项目编写测试。</p><p>4) 讨论<a href="https://forums.swift.org/t/vscode-with-5-9-stopping-server-failed/67397" title="VSCode 5.9：停止服务器失败" target="_blank" rel="noopener">VSCode 5.9：停止服务器失败</a></p><p>自从升级到 5.9 以来，VSCode 上的 sourcekit-lsp 变得更加不稳定，我不断收到“客户端 SourceKit 语言服务器：与服务器的连接出错。 关闭服务器。” 问题，它打印的唯一日志输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Error - 4:44:34 PM] Stopping server failed</span><br><span class="line">  Message: Cannot call write after a stream was destroyed</span><br><span class="line">  Code: -32099</span><br></pre></td></tr></table></figure><p>我相信，这是应该解决该问题的 PR：<a href="https://github.com/apple/sourcekit-lsp/pull/828" target="_blank" rel="noopener">Don’t crash when unregistering for change notifications of a file that isn’t watched by ahoppen · Pull Request #828 · apple/sourcekit-lsp · GitHub</a></p><p>5) 讨论<a href="https://forums.swift.org/t/is-sendable-necessary-for-closures-passed-into-asynchronous-scope-functions/67403" title="对于传递到异步作用域函数的闭包来说，Sendable 是否是必需的？" target="_blank" rel="noopener">对于传递到异步作用域函数的闭包来说，Sendable 是否是必需的？</a></p><p>我一直在思考以下函数代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transaction</span>&lt;T&gt;<span class="params">(<span class="number">_</span> closure: @Sendable @escaping <span class="params">(Database)</span></span></span> async <span class="keyword">throws</span> -&gt; <span class="type">T</span>) async <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> await <span class="keyword">self</span>.transaction &#123; db -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> promise = <span class="keyword">self</span>.eventLoop.makePromise(of: <span class="type">T</span>.<span class="keyword">self</span>)</span><br><span class="line">            promise.completeWithTask&#123; <span class="keyword">try</span> await closure(db) &#125;</span><br><span class="line">            <span class="keyword">return</span> promise.futureResult</span><br><span class="line">        &#125;.<span class="keyword">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是来自 Vapor 框架的实际代码。</p><p>以下是供参考的网址：<a href="https://github.com/vapor/" target="_blank" rel="noopener">https://github.com/vapor/</a> Fluent-kit/blob/main/Sources/FluentKit/Concurrency/Database%2BConcurrency.swift 1</p><p>在这个事务函数中，参数闭包具有 <code>@Sendable</code> 和 <code>@escaping</code> 属性。</p><p>我想知道是否可以将两者删除。</p><p>特别是，<code>@Sendable</code> 属性意味着传递给闭包的类型必须是 Sendable，这施加了相当严格的限制。因此，如果我们可以省略它，那就方便多了。</p><p>我认为它可以被删除的原因是，虽然这个闭包确实被传递到事件循环线程，当它离开交易功能时，它正在等待 <code>EventLoopFuture.get()</code>,确保闭包的函数调用完成。</p><p>换句话说，两个不同线程不可能同时调用闭包。</p><p>确实，理论上由于 eventLoop 类型被抽象为任何 EventLoop，实现一种将传递给 <code>completeWithTask</code> 的闭包存储到全局变量或类似的东西中的方法是可能的，但这对于 EventLoop 和 EventLoopFuture 来说显然是不自然的行为，我认为没有什么可担心的。</p><p>此外，我认为出于同样的原因可以消除@escaping。 闭包实际上并没有逃脱。</p><p>上面的想法可能是对的吗？</p><p>我很想听听有更多见解的人的想法来权衡。</p><p>作为参考，具体实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transaction</span>&lt;T&gt;<span class="params">(<span class="number">_</span> closure: <span class="params">(any Database)</span></span></span> async <span class="keyword">throws</span> -&gt; <span class="type">T</span>) async <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> await withoutActuallyEscaping(closure) &#123; (closure) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> closureBox = <span class="type">UncheckedSendableBox</span>(closure)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> await <span class="keyword">self</span>.transaction &#123; db -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> dbBox = <span class="type">UncheckedSendableBox</span>(db)</span><br><span class="line">                <span class="keyword">let</span> promise = <span class="keyword">self</span>.eventLoop.makePromise(of: <span class="type">T</span>.<span class="keyword">self</span>)</span><br><span class="line">                promise.completeWithTask &#123;</span><br><span class="line">                    <span class="keyword">let</span> db = dbBox.value</span><br><span class="line">                    <span class="keyword">let</span> closure = closureBox.value</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">try</span> await closure(db)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> promise.futureResult</span><br><span class="line">            &#125;.<span class="keyword">get</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我相信这个想法可以推广。</p><p>我将这些接受值并允许使用闭包进行灵活处理的函数称为作用域函数。</p><p>这样的作用域函数确实可以是异步的，但是，即使它们是异步的，在我看来，只要作用域函数中的闭包执行是串行完成的，它们不一定必须是 <code>@Sendable</code> 或 <code>@escaping</code>。</p><p>你对此有何看法？</p><p><strong>回答</strong></p><p>这个问题很好理解，但解决方案不是放弃当前语言中的 Sendable 要求，而是让编译器可以推断出根本不需要它。 请参阅 <a href="https://forums.swift.org/t/pitch-safely-sending-non-sendable-values-across-isolation-domains/66566" target="_blank" rel="noopener">Pitch 跨隔离域安全发送非“可发送”值</a>，了解编译器如何增强此功能的示例。</p><p>我同意你的观点，只要我们排除异步代码中不安全的行为，这种使用模式可能是安全的，但此时我仍然不愿意删除注释。</p><p>6) 讨论<a href="https://forums.swift.org/t/whats-the-recommended-way-to-write-a-tcp-client-application/67433" title="编写 TCP 客户端应用程序的推荐方法是什么？" target="_blank" rel="noopener">编写 TCP 客户端应用程序的推荐方法是什么？</a></p><p>我需要为 TCP/IP 上的自定义专有协议编写一个客户端。 我希望它能够在 macOS、iOS 和 Linux 上使用。 推荐的方法是什么？</p><p>我有一组现有的 Objective-C 代码来执行此操作，并且我只使用原始 BSD 套接字。 它们很简单，并且由于不需要是高性能服务器，所以我非常乐意阻塞：我只需将代码粘贴在 NSOperation 中，在串行 NSOperationQueue 上运行它，并使用回调来传递结果。 在 Swift 中使用 BSD 套接字感觉就像我在与该语言作斗争：很多都陷入了 UnsafePointer 领域。</p><p>我查看了 Mojave 和 Swift-NIO 中引入的网络框架，但在这两种情况下，我真的不确定如何构建客户端。 我需要做很多来回操作：向事物发送命令，读回响应，发送下一个命令，读取响应等。通过单个通道读取处理程序（在 Swift-NIO 的情况下）感觉所有内容， 再次，就像我做错事一样。</p><p>有谁知道 Swift-NIO 类似的来回通信示例吗？ 或者我看错了方向？</p><p><strong>回答</strong></p><p>自从我上次查看我的代码以来已经过去很长时间了，我确信自那时起 API 已经发生了很大的变化，但对我帮助最大的是查看 Java 的 Netty 文档。 Swift-NIO 现在似乎有相当好的文档，所以我会先阅读一下。</p><p>同样，它已经很老了，而且事情可能已经发生了变化，但这里有一个简单的示例，说明 Swift-NIO 客户端和处理程序类如何<a href="https://github.com/jonathanwong/TCPClient/tree/master/Sources/TCPClient" title="协同工作" target="_blank" rel="noopener">协同工作</a>。 这个默认实现会让你遇到你提到的确切问题，但是如果你在 TCP 客户端类之外声明通道、处理程序、事件循环等，你可以处理处理程序类中发生的更改，例如断开连接或接收消息， 在客户端类的其他方法中。 我不确定这是否是“正确”的处理方式，但它足以让它在我正在构建的应用程序中顺利运行。</p><p>你可能会考虑由 IBM 开发并在 macOS、iOS 和 Linux 上运行的 BlueSocket。</p><p>我向这个库添加了对 Windows 的支持，并以 GreenSocket 的名称提供。</p><p>BlueSocket 此处（macOS、iOS、Linux）：<br><a href="https://github.com/Kitura/BlueSocket" target="_blank" rel="noopener">https://github.com/Kitura/BlueSocket</a><br><a href="https://github.com/litewrap/GreenSocket" target="_blank" rel="noopener">https://github.com/litewrap/GreenSocket</a></p><p>7) 讨论<a href="https://forums.swift.org/t/can-protocol-extension-define-class-api-overrides/67404/3" title="协议扩展可以定义类 API 覆盖吗？" target="_blank" rel="noopener">协议扩展可以定义类 API 覆盖吗？</a></p><p>我有几个符合协议的 UIViewController 子类（它们不共享相同的父类）。 我想添加几个 UIViewController API 重写的默认实现，以避免在每个子类中重写它们。 无论如何要让这项工作成功吗？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StylingController</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StylingController</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">        </span><br><span class="line">        becomeFirstResponder()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        resignFirstResponder()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>在这种情况下，只需创建两个父类而不是一个：一个基于 UIViewController，另一个基于 UITableViewController。 如果有很多重叠的功能，并且希望它尽可能DRY，可以进一步将通用功能提取到协议扩展中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseViewController</span>: <span class="title">UIViewController</span>, <span class="title">CommonVCFunctionality</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">        commonVCFunctionality()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTableViewController</span>: <span class="title">UITableViewController</span>, <span class="title">CommonVCFunctionality</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">        commonVCFunctionality()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CommonVCFunctionality</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">commonVCFunctionality</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CommonVCFunctionality</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">commonVCFunctionality</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/09/19/thread-safety-in-swift-with-actors/" title="Swift 中使用 actors 实现线程安全" target="_blank" rel="noopener">Swift 中使用 actors 实现线程安全</a></p><p><strong>摘要：</strong>  本文介绍了在 Swift 中使用 actors 实现线程安全的方法。首先，文章回顾了 Store 类型的定义，它允许我们可预测地实现状态管理，但这个类型不是线程安全的。为了解决这个问题，文章使用了一个 NSRecursiveLock 类型的实例来确保线程安全。然而，作者指出使用锁存在一些缺点，并引入了 actors 这个新的 Swift 语言特性。介绍了如何使用 actors 以及与使用锁相比的优点，并讨论了 actor 的重入问题。最后总结了actors在 Swift 中的重要性和优势。</p><p><a href="https://onevcat.com/2023/08/observation-framework/" title="深入理解 Observation - 原理，back porting 和性能" target="_blank" rel="noopener">深入理解 Observation - 原理，back porting 和性能</a></p><p><strong>摘要：</strong>  喵神这篇文章讨论了 SwiftUI 中的状态管理，特别是引用类型的状态管理，以及 Apple 在 iOS 14 中推出的新 Observation 框架。Observation 框架可以在 View 中实现属性粒度的订阅，避免不必要的刷新。它实质上通过添加 @ObservationTracked 宏将存储属性转换为计算属性，并添加与 ObservationRegistrar 相关的内容来实现。通过阅读本文，你将更了解 SwiftUI 中的新 Observation 框架及其优势。</p><p><a href="https://juejin.cn/post/7281159113882320915?searchId=20230922142040421750A2476F6B944434" title="货拉拉 iOS 用户端 10 万分位 Crash 率攻坚之战" target="_blank" rel="noopener">货拉拉 iOS 用户端 10 万分位 Crash 率攻坚之战</a></p><p><strong>摘要：</strong> 该文主要介绍了货拉拉 iOS 用户端在 Crash 治理方面的经验和技术方案。文章探讨了 iOS 平台下 Crash 监控方案的优缺点，并分享了自建 Crash 监控平台的思路和经验。随后，总结了 Crash 治理的思路和经验，包括分级治理、版本追踪、定期分析和团队合作。最后，文章分享了常见的 Crash 类型及其解决方案，并总结了长期 Crash 治理的经验和收益。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>中秋遇上了国庆，诗和远方开始了躁动，假期将至，你准备怎么过？</strong></p><ol><li>旅游团已报名，攻略方案已熟记，静待启程，我的青春我做主。</li><li>老婆孩子，三餐四季，和生活对线，已倾尽了所有，钱包已然羞涩，岁月静好足矣。</li><li>钱不钱的无所谓，主要是我爬山嫌累，涉水呛口，梦想也是会变的嘛，西瓜啤酒，空调刷剧也是极好的。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十八期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;三餐四季，春夏秋冬，平凡如尔，与众不同。&lt;strong&gt;Swift社区&lt;/strong&gt;陪你苦尽甘来，笑看山河星月！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通3年&lt;/p&gt;
&lt;p&gt;提案：在导入声明上使用访问级别修饰符&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Swift 测试的新方法&lt;/p&gt;
&lt;p&gt;推荐博文：Swift 中使用 actors 实现线程安全&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;中秋遇上了国庆，诗和远方开始了躁动，假期将至，你准备怎么过？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十七期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十七期/</id>
    <published>2024-03-06T07:56:43.000Z</published>
    <updated>2024-03-06T08:03:34.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十七期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>浅尝辄止必将黯然神伤，坚持不懈终会柳暗花明。<strong>Swift社区</strong>值得与之同行，一起成就卓越！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果跌近 3% 市值两天蒸发 1898亿 美元</p><p>提案：包迭代提案正在审查</p><p>Swift 论坛：提议用户定义的元组一致性</p><p>推荐博文：Swift 中的线程安全性和使用锁的方法</p><p><strong>话题讨论：</strong> </p><p>HUAWEI Mate 60 Pro 和 iPhone 15 你会如何选择？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/dc237f3b-c4d9-405f-96ef-1e913c5cfed3.jpg" alt=""></p><p>这个结果反映了人们对核污水排放问题的担忧，以及对个人健康和环境保护的重视。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果跌近-3-市值两天蒸发-1898-亿-美元"><a href="#苹果跌近-3-市值两天蒸发-1898-亿-美元" class="headerlink" title="苹果跌近 3% 市值两天蒸发 1898 亿 美元"></a>苹果跌近 3% 市值两天蒸发 1898 亿 美元</h3><p>苹果股价连续两天大跌，实属罕见。截至收盘，苹果报 177.56 美元，跌幅 2.92% ，最新市值 2.8万 亿美元。苹果连续两天累计跌幅 6.5% ，其市值两天蒸发 1898 亿 美元（约 13911 亿元）。</p><p><img src="https://files.mdnice.com/user/17787/bc24b290-75fc-4510-87fc-c43c618683ec.png" alt=""></p><p>消息面上，据中国基金报，一方面，下周公布 iPhone 15 系列手机，会跟目前卖爆的华为手机形成激烈竞争，另一方面有报道称 iPhone 手机在某些场合已被禁用。</p><p>另据报道，欧盟公布最严数字监管名单，苹果等科技巨头名列其中。</p><p>据上海证券报，欧盟将于周三公布首批受《数字市场法案》（简称 DMA ）监管的服务清单。这份清单将列出部分“守门人”，即处于绝对垄断地位的科技巨头。目前苹果、微软、亚马逊、Alphabet、Meta 和三星等已经在名单上，这些公司将承担不得滥用市场支配地位打压或并购竞争对手、与竞争对手建立链接等 DMA 规定的义务。</p><p>根据 DMA 的规定，“看门人”公司指在数字市场上扮演了关键的角色，拥有巨大的市场影响力，因此需要受到更严格的监管。具体条件为：公司年营业额超过 75亿 欧元、市值超过 750 亿 欧元(820 亿 美元)，在欧盟拥有 4500万 月活用户的平台。不过，在这些原始指标之外，欧盟方面对这些规定拥有一定的自由裁量权。</p><p>与此同时，欧盟委员会还启动了四项市场调查，以进一步评估微软 Bing、Edge 和微软广告以及苹果 iMessage 是否能获豁免。</p><p>苹果公司的一位发言人表示，该公司仍然“非常担心 DMA 给我们的用户带来的隐私和数据安全风险。”“我们的重点将是如何减轻这些影响，并继续为我们的欧洲客户提供最好的产品和服务。(来源：每日经济新闻)</p><h3 id="iPhone-15-系列订单量下滑，苹果公司面临双重市场冲击"><a href="#iPhone-15-系列订单量下滑，苹果公司面临双重市场冲击" class="headerlink" title="iPhone 15 系列订单量下滑，苹果公司面临双重市场冲击"></a>iPhone 15 系列订单量下滑，苹果公司面临双重市场冲击</h3><p>9 月 4 日，根据第三方机构的消息称，苹果公司预计 2023 年下半年全球智能手机市场将呈现疲软态势，因此订购的 iPhone 15 数量可能会减少。</p><p>此前，苹果公司宣布 2023 年的秋季新品发布会时间为北京时间 9 月 13 日凌晨一点，备受瞩目的 iPhone 15 系列智能手机也将在发布会上正式亮相。</p><p><img src="https://files.mdnice.com/user/17787/ef172311-dad7-475b-970b-f0a0d0723110.png" alt=""></p><p>随着发布会的时间临近，iPhone 15 系列的供应链备货情况也受到行业关注。</p><p>有分析师透露称，苹果公司在今年 8 月份就已经向供应链下达了 iPhone 15 系列在今年下半年的订单，订单量在 8000 万部到 9000 万部之间。</p><p>然而，2022 年 8 月份 iPhone 14 即将亮相的时候，苹果公司向供应链下达的 iPhone 14 系列订单在 9000万 部到 1 亿部之间，如今 iPhone 15 的订单量，相比去年 iPhone 14 的订单出现了大幅下滑！</p><p>8 月份的时候，苹果公司下达订单量主要考虑的是下半年的市场情况。对于订单量的下滑，苹果公司给出的原因是全球智能手机市场的疲软。</p><p>根据 Canalys 发布的研究数据显示，2023 年上半年，全球智能手机出货量达 5.28 亿部，同比下降 12% ，中国智能手机市场的出货量为 1.32 亿部，同比下滑 8% 。</p><p>无论是中国手机市场，还是全球手机市场，都没有从手机行业的下行中走出来，出货量仍在下跌。(来源：腾讯网新行情Pro)</p><h3 id="苹果的对手回来了"><a href="#苹果的对手回来了" class="headerlink" title="苹果的对手回来了"></a>苹果的对手回来了</h3><p>8 月 29 日中午，在没有任何预告、发布会的情况下，华为官方发布了《致华为用户的一封信》，信中称华为推出了“ HUAWEI Mate 60 Pro 先锋计划”，当天 12 时 08 分在华为商城正式上线华为 Mate 60 Pro。</p><p><img src="https://files.mdnice.com/user/17787/4332804f-27e3-47a3-b423-21d0c4357d26.png" alt=""></p><p>虽然毫无征兆，但是华为 Mate 60 Pro 依然受到了广泛关注，华为的消息一下子就冲上了微博热搜。</p><p>随后，在短短几个小时之内，华为商城首批 Mate 60 Pro 就被抢购一空，无数网友直呼华为赶紧出下一批！</p><p>更令人惊喜的是，华为 Mate 60 Pro 的网速已经达到了 5G 水平，还有卫星通话功能，这预示着手机内的芯片质量已经达到了 5G 芯片水平，华为真正劫后重生，王者归来。</p><p>这一下子，苹果公司直接慌了神，慌慌张张地宣布将于 9 月 13 日发布 iPhone 15 系列手机，作为对华为发布新手机的对冲。</p><p>苹果公司和华为，可以说是手机行业的老对手了。2019 年，如果不出意外的情况下，华为当年的手机销量、市场份额将会全面超越苹果，成为全球第一大手机厂商。</p><p>然而，在那之后所有人都看到了，华为的供应链出现了危机，不得不将荣耀子品牌脱离，甚至在手机全面进入 5G 时代的时候，只能推出 4G 的手机。</p><p>今年上半年，华为手机的销量已经彻底跌出了行业前 7 的位置，业内一度认为华为有可能会退出手机行业了。</p><p>然而，如今华为真正攻克了难关，携 Mate 60 王者归来，直接震撼了全球手机市场！</p><p>9 月 4 日，据媒体报道称，华为已将 Mate 60 系列手机的订单量提升至 1500 - 1700 万台。</p><p>业内人士预测，Mate 60 Pro 将有望成为华为 Mate 系列销量最高的手机，最终的订单量将在 1700 万台左右。(来源：腾讯网新行情Pro)</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0405-string-validating-initializers.md" title="SE-0405" target="_blank" rel="noopener">SE-0405</a> <strong>具有编码验证的 String Initializers</strong> 提案通过审查。该提案已在 <strong>三十五期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0408-pack-iteration.md" title="SE-0408" target="_blank" rel="noopener">SE-0408</a> <strong>包迭代</strong> 提案正在审查。</p><p>在基于值和类型参数包提案 SE-0393 的基础上，这个提案使允许在值参数包中对每个元素进行迭代，并使用 <code>for-in</code> 语法将每个值绑定到本地变量。</p><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0403-swiftpm-mixed-language-targets.md" title="SE-0403" target="_blank" rel="noopener">SE-0403</a> <strong>软件包管理器混合语言目标支持</strong> 提案被驳回。该提案已在 <strong>三十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-user-defined-tuple-conformances/67154" title="用户定义的元组一致性" target="_blank" rel="noopener">用户定义的元组一致性</a></p><p><strong>介绍</strong></p><p>元组无法符合当今的协议，这以明显的限制形式表现出来，例如无法使用可哈希值的元组作为字典键。</p><p><strong>动机</strong></p><p>SE-0283 的动机先前解决了元组符合某些标准库协议的愿望，该动机提出了对 Equatable、Comparable 和 Hashable 元组的内置语言支持。 独立地，Swift 并发工作添加了一个语言扩展，其中可发送值的元组本身就是可发送的。 我们建议将所有这些特殊情况行为与用户定义的元组一致性统一起来，现在可以使用参数包（SE-0393）来表达。 SE-0283 和 SE-0393 都将元组一致性列为未来方向。</p><p><strong>建议的解决方案</strong></p><p>我们建议引入参数化扩展语法，如泛型宣言中所述。 在一种特定情况下，允许使用此语法以最通用的形式声明元组一致性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> &lt;<span class="title">each</span> <span class="title">T</span>&gt; (<span class="title">repeat</span> <span class="title">each</span> <span class="title">T</span>): <span class="title">P</span> <span class="title">where</span> <span class="title">repeat</span> <span class="title">each</span> <span class="title">T</span>: <span class="title">P</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>我们还将允许描述元组的通用类型别名通过条件一致性进行扩展； 我们建议将以下元组类型别名添加到标准库中以方便实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Tuple</span>&lt;each <span class="type">Element</span>&gt; = (<span class="keyword">repeat</span> each <span class="type">Element</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Tuple</span>: <span class="title">Shape</span> <span class="title">where</span> <span class="title">repeat</span> <span class="title">each</span> <span class="title">Element</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">repeat</span> (each <span class="keyword">self</span>).draw()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回想一下，协议中的要求是由具体符合类型的见证人实现的。 在上面，我们声明了一个元组扩展，因此draw()的见证者在元组上实现了协议要求 draw()。 实际的实现对每个元素调用 draw()，它本身符合 Shape。 请注意在 draw() 主体的重复模式中每个 self 的使用。</p><p><strong>详细设计</strong></p><p>任何未标记元组都可以通过“最通用”未标记元组类型的类型替换来获得。 如果每个 T 都是某种类型参数包，则这个最通用的类型是（重复每个 T）； 即，由每个 T 的元素的包扩展形成的元组类型。</p><p>如今，扩展的扩展类型必须是名义类型，无论是结构、枚举、类还是协议。 我们建议允许扩展最通用的元组类型； 这称为元组扩展。 由于扩展可以声明协议一致性，因此元组扩展可以实现最通用元组类型的协议要求。 这称为元组一致性。</p><p>这意味着元组扩展中 self 的类型是（重复每个 T），其中每个 T 是声明一致性的扩展的通用参数。 由于 SE-0399，对包扩展表达式中每个 self 的引用将扩展到元组的元素上。</p><p>与结构、枚举和类的扩展一样，元组扩展中的 Self 指的是 self 的类型，即（重复每个 T）。</p><p>一旦声明了对某个协议 P 的元组一致性，只要元组的元素满足元组一致性的条件要求，任意元组类型都将满足 P 的一致性要求。 我们将在下面看到，条件要求必须恰好由重复每个 T:P 的一个要求组成。当对元组类型的值调用协议要求时，由元组类型的元素形成一个包； 这成为调用协议见证中每个 T 的通用参数。</p><p><strong>孤儿规则</strong></p><p>在大多数情况下，元组一致性的行为就好像它们是标准库类型上的用户定义的追溯一致性。 特别是，两个模块定义两个不同的元组符合同一协议是无效的。 因此，我们禁止元组符合定义模块之外的协议。</p><p><strong>单元素元组展开</strong></p><p>根据参数包提案中规定的规则，单元素元组类型在替换后展开。 这意味着元组一致性必须与此展开保持一致。</p><p>这对元组一致性可以采取的形式施加了一些限制。 我们可以通过交换图的形式理解以下所有限制。 最上面一行显示了最通用的元组类型、相应的元组一致性以及某些关联类型 A 的见证。现在，我们对每个对象应用替换，将每个 T 的类型参数包替换为包含单个具体类型的包， 说 X。我们要求图中所有在同一对象处开始和结束的路径都产生相同的结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">repeat</span> each <span class="type">T</span>) ---&gt; [(<span class="keyword">repeat</span> each <span class="type">T</span>): <span class="type">P</span>] ---&gt; (<span class="keyword">repeat</span> each <span class="type">T</span>).<span class="type">A</span></span><br><span class="line">      |                        |                        |</span><br><span class="line">      |                        |                        |</span><br><span class="line">      v                        v                        v</span><br><span class="line">      <span class="type">X</span> -------------------&gt; [<span class="type">X</span>: <span class="type">P</span>] -----------------&gt; <span class="type">X</span>.<span class="type">A</span></span><br></pre></td></tr></table></figure><p>具体而言，这些限制如下：</p><ul><li><p>元组扩展必须声明符合一个协议。</p></li><li><p>此一致性的条件要求必须精确重复每个 T: P，其中每个 T 是扩展的类型参数包，P 是一致性协议。</p></li><li><p>也就是说，一个元组扩展扩展 Tuple: P ，其中重复每个 T: Q 是没有意义的，因为在单元素情况下，它会衰减到 X: P 其中 X: Q; 当 P 和 Q 可能是不相关的协议时，一般情况下该陈述是错误的。</p></li><li><p>P 的关联类型要求 A 必须由其底层类型恰好为 (repeat (each T).A) 的类型别名见证； 也就是说，从每个元素投影 A 的元组类型。</p></li></ul><p>也就是说，如果 X.A 是 Int，Y.A 是 String，那么我们别无选择，只能要求 (X, Y).A 等于 (Int, String)。<br>请注意，由于所有这些规则，空 tuple() 将符合每个具有元组一致性的协议。</p><p><strong>动态行为</strong></p><p>上述规则使我们能够保证元组一致性见证永远不会被单元素包调用，在这种情况下调用将直接转发到元素一致性。 因此，元组一致性中 Self 的运行时类型必须始终是真正的元组类型，而不是未包装的元素。</p><p>如果某个函数本身使用参数包从包中形成元组值，则对该值调用协议要求将调用元组一致性见证或单个元素的见证，具体取决于包的大小。</p><p><strong>标记元组和方差</strong></p><p>元组标签不是参数包可以抽象的东西。 然而，表达式类型系统定义了标记元组和相应的未标记元组之间的子类型关系。</p><p>与类类比，如果在非最终类 C 上声明了一致性，并且存在 D 继承自 C 的子类关系，则该一致性也被 D 继承。</p><p>为了在类继承的情况下用 D 替换 C 是有效的，我们要求 Self 仅用于协变或逆变位置，而不是不变的。 因此，我们必须对元组施加与当前对非最终类相同的限制。</p><p>这允许以下操作：</p><ul><li>符合 Equatable 等协议，Self 出现在参数位置。</li><li>符合假设的 Clonable 协议，具有返回 Self 的 <code>func clone() -&gt; Self</code> 要求。</li></ul><p>另一方面，这是禁止的：</p><ul><li>符合要求Self位置不变的协议，例如 <code>func f() -&gt; G&lt;Self&gt;</code>。</li></ul><p>在这种情况下，采用标记元组并将 <code>G&lt;&gt;</code> 应用于相应的未标记元组类型并不完全合理。</p><p><strong>使用范围</strong></p><p>由于上面概述的微妙的静态和动态行为，我们期望元组一致性仍然是一项高级功能。 对于许多目的，最好通过 SE-0398 声明一个特殊用途的可变参数泛型结构，并使其符合协议，因为这提供了完全的灵活性，而不会在一致性方面出现任何复杂情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EggFactory</span>&lt;<span class="title">each</span> <span class="title">Bird</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EggFactory</span>: <span class="title">OmletMaker</span> <span class="title">where</span> <span class="title">repeat</span> <span class="title">each</span> <span class="title">Bird</span>: <span class="title">Chicken</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此模式还允许可变参数类型定义自定义构造函数和访问器以强制不变量等。</p><p>元组应该只符合具有明显“代数”实现的协议，该实现以归纳方式推广到元素类型的所有组合，例如上面讨论的三个标准库协议。</p><p>例如，使元组符合 IteratorProtocol 可能不是一个好主意，因为至少有两个明显的实现； 要么是压缩，要么是串联（在这种情况下，我们还需要要求所有序列具有相同的元素类型，这是元组一致性甚至无法表达的）。</p><p>2) 讨论<a href="https://forums.swift.org/t/is-dispatchprecondition-a-reasonable-way-to-implement-an-unchecked-sendable-type/67159" title="dispatchPrecondition 是实现 @unchecked Sendable 类型的合理方法吗？" target="_blank" rel="noopener">dispatchPrecondition 是实现 @unchecked Sendable 类型的合理方法吗？</a></p><p>我正在尝试提高我对何时使用 <code>@unchecked Sendable</code> 有意义的理解。</p><p>举个例子，使用 <code>dispatchPrecondition</code> 保证值只能在主线程上读取或修改：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A wrapper that guaruntees that its value is only read or modified on the main thread.</span></span><br><span class="line"><span class="comment">/// For simplicity assume `T` is a value type.</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">T</span>) &#123;</span><br><span class="line">    dispatchPrecondition(condition: .onQueue(.main))</span><br><span class="line">    _value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> value: <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      dispatchPrecondition(condition: .onQueue(.main))</span><br><span class="line">      <span class="keyword">return</span> _value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      dispatchPrecondition(condition: .onQueue(.main))</span><br><span class="line">      _value = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _value: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于讨论，我们假设包装的值是值类型（而不是引用类型），因此我们不需要考虑不经过值设置器的修改。</p><p>使用 <code>@unchecked Sendable</code> 一致性将该类型设置为可发送是否合理？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Is this reasonable, given the expectations of Sendable?</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainThreadWrapper</span>: @<span class="title">unchecked</span> <span class="title">Sendable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>使用这种类型时不可能出现数据竞争。 如果在错误的线程上使用了不正确的类型（例如，在主要参与者之外的任务中），<code>dispatchPrecondition</code> 将失败并阻止不允许的使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotSendable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper = <span class="type">MainThreadWrapper</span>(<span class="type">NotSendable</span>(value: <span class="string">"foo"</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">  <span class="comment">// Allowed by the compiler since wrapper is Sendable, </span></span><br><span class="line">  <span class="comment">// but a triggers a runtime error:</span></span><br><span class="line">  <span class="built_in">print</span>(wrapper.value)</span><br><span class="line"></span><br><span class="line">  await <span class="type">MainActor</span>.run &#123;</span><br><span class="line">    <span class="comment">// Safe, prints "NotSendable(value: "foo")"</span></span><br><span class="line">    <span class="built_in">print</span>(wrapper.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于这种类型可以安全地跨并发域传递，而不会出现数据竞争，我倾向于认为这是 <code>@unchecked Sendable</code> 的合理用例。</p><p>人们怎么看？ 我特别有兴趣听到任何潜在的反驳意见。</p><p><strong>回答</strong></p><p>这里的包装器确实保证了底层数据的“安全”，但如果该类型在主队列之外使用过，它会崩溃。 这仅适用于声明为 <code>@MainActor</code> 的类型…但是一旦你以这种方式对其进行注释，那么你就已经获得了跨并发域的保证，即你将成为主要演员。</p><p>关于“安全”对你意味着什么，<code>@unchecked Sendable</code> 是一个承诺，你的类型可以在任何并发域中使用，并且仍然保护其自己的状态。 我认为这样标记你的包装纸是不正确的。 它仍然只能安全地从主队列使用。 （如果不是这种情况，它就会快速而有效地崩溃。）</p><p>3) 讨论<a href="hhttps://forums.swift.org/t/swift-wont-compile-dictionary-with-referencewritablekeypath-unless-its-a-class-property/67148" title="Swift 不会使用 ReferenceWritableKeyPath 编译dictionary，除非它是一个类属性" target="_blank" rel="noopener">Swift 不会使用 ReferenceWritableKeyPath 编译dictionary，除非它是一个类属性</a></p><p>这段代码编译可以通过：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>Members <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DriversLicense1</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="built_in">map</span>: [<span class="type">String</span>: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">DriversLicense1</span>, <span class="type">String</span>&gt;] = [</span><br><span class="line">        <span class="string">"DAA"</span>: \<span class="type">DriversLicense1</span>.nameFull,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> nameFull: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (key, keyPath) <span class="keyword">in</span> <span class="built_in">map</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>[keyPath: keyPath] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这段代码编译不能通过 - 错误是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert value of type '<span class="type">KeyPath</span>&lt;<span class="type">DriversLicense2</span>, <span class="type">String</span>&gt;' to expected dictionary value type '<span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">DriversLicense2</span>, <span class="type">String</span>&gt;'</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">let</span> <span class="built_in">map</span>: [<span class="type">String</span>: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">DriversLicense2</span>, <span class="type">String</span>&gt;] = [</span><br><span class="line">    <span class="string">"DAA"</span>: \<span class="type">DriversLicense2</span>.nameFull,</span><br><span class="line">]</span><br><span class="line"><span class="meta">@objc</span>Members <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DriversLicense2</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> nameFull: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (key, keyPath) <span class="keyword">in</span> <span class="built_in">map</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>[keyPath: keyPath] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么？</p><p><strong>回答</strong><br>这绝对感觉像是一个诊断可能更有帮助的地方 - 如果你尝试直接在同一位置使用设置器，你会得到更好的消息：</p><p>无法分配给属性：“nameFull”设置器无法访问</p><p>似乎我们可以查看尝试 <code>KeyPath -&gt; (Reference)WritableKeyPath</code> 转换的情况，并提供特殊的诊断，如果我们可以在 setter 在当前范围内可见的情况下形成适当的可写密钥路径。</p><p>4) 讨论<a href="https://forums.swift.org/t/unable-to-call-swift-extension-method-from-objective-c-class/67174" title="无法从 Objective C 类调用 swift 扩展方法" target="_blank" rel="noopener">无法从 Objective C 类调用 swift 扩展方法</a></p><p>我为 ViewController 类创建了 swift 扩展，并在其中定义了一种方法。 当我尝试从同一个 Obj-c ViewController 调用相同的方法时，它给出了以下错误：</p><p><code>ViewController</code> 没有可见的 <code>@interface</code> 声明选择器 <code>testMe</code></p><p>我的代码如下：</p><p>Objective-C类</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface <span class="type">ViewController</span> : <span class="type">UIViewController</span></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation <span class="type">ViewController</span></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> testMe]; <span class="comment">// No visible @interface for 'ViewController' declares the selector 'testMe'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Swift extension:<br>// ViewController+extnesion.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testMe</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Vish"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>你的 .m 文件需要导入 Swift 编译器发出的兼容性标头。</p><p>5) 讨论<a href="https://forums.swift.org/t/generic-struct-using-type-pack-cant-store-closure-using-same-type-pack-in-property/67145" title="使用类型包的通用结构无法在属性中使用相同类型包存储闭包" target="_blank" rel="noopener">使用类型包的通用结构无法在属性中使用相同类型包存储闭包</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&lt;<span class="title">each</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> foo: (<span class="keyword">repeat</span> each <span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(</span><br><span class="line">        fn: @escaping (<span class="keyword">repeat</span> each <span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.foo = fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器使用 Xcode 15.0 beta 8 (15A5229m) 和 swift-DEVELOPMENT-SNAPSHOT-2023-09-04-a 工具链响应以下消息</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: type of expression <span class="keyword">is</span> ambiguous without a type annotation</span><br><span class="line">        <span class="keyword">self</span>.foo = fn</span><br><span class="line">        ~~~~~~~~~^~~~</span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7275590714712883256?searchId=20230908113707B1CB34D5F133E8B64AD9" title="SwiftDataKit：让你在 SwiftData 中使用 Core Data 的高级功能" target="_blank" rel="noopener">SwiftDataKit：让你在 SwiftData 中使用 Core Data 的高级功能</a></p><p><strong>摘要：</strong>  SwiftDataKit 旨在帮助开发者在 SwiftData 中使用 Core Data的高级功能。由于 SwiftData 是 Core Data 的继任者，它在多个方面都对 Core Data 进行了改进和扩展。然而，当前版本的 SwiftData 还不能完全实现 Core Data 的所有高级功能，这对一些开发者而言可能是一个困扰。</p><p>为了解决这个问题，作者创建了 <code>SwiftDataKit</code> 库，通过提取 SwiftData 中底层的 Core Data 对象，使开发者能够在 SwiftData 中使用 Core Data 的高级功能 </p><p><a href="https://swiftwithmajid.com/2023/09/05/thread-safety-in-swift-with-locks/" title="Swift 中的线程安全性和使用锁的方法" target="_blank" rel="noopener">Swift 中的线程安全性和使用锁的方法</a></p><p><strong>摘要：</strong>  这篇文章讨论了 Swift 中的线程安全性和使用锁的方法。首先介绍了线程安全性的重要性，并提到了在代码库中发现的相关问题。接着通过一个简单的示例代码演示了状态管理的概念，并说明了这种代码可能导致数据竞争和竞争条件的情况。</p><p>为了解决这个问题，作者介绍了使用锁机制来控制对共享变量的并发访问。为了实现线程安全，博客展示了如何在 Swift 中使用 <code>OSAllocatedUnfairLock</code> 和 <code>NSRecursiveLock</code> 两种类型的锁。最后，博客总结了保证类的线程安全性的重要性，并鼓励在开发过程中早期就投入时间来构建类型安全的代码。</p><p><a href="https://juejin.cn/post/7275225666029797433?searchId=20230908125940173984B583F745BF08A0" title=" Swift 语言底层原理剖析 - Array 系列-高阶函数" target="_blank" rel="noopener"> Swift 语言底层原理剖析 - Array 系列-高阶函数</a></p><p><strong>摘要：</strong> 文章介绍了Swift的数组中的 <code>filter</code>, <code>forEach</code>, <code>map</code> , <code>compactMap</code>, <code>flatMap</code>, <code>reduce</code> 等函数内部源码，剖析实现逻辑。Array系列的高阶函数其实是 <code>Collection</code> 的高阶函数，同样适合与 <code>Dictionary</code> ， Set 等其他集合类型。整体的设计也比较巧妙，用到了很多 Swift 特有的 <code>Protocol</code> 特性，对我们日后设计 Swift代 码也会有一些启发。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>近期华为推出了“ HUAWEI Mate 60 Pro 先锋计划”，真正劫后重生，王者归来。而苹果公司将于 9 月 13 日发布 iPhone 15 系列手机，真正的王者碰撞开始了，那么假如你近期考虑换手机的话，你会如何选择呢？</p><p>1.果粉无需抉择，犹豫一秒都是对苹果的不尊重。<br>2.果断选华为呀，超高的性价比，绝对理性的选择。<br>3.我觉得一两千块钱的小米就挺好的，我再买两斤排骨不香吗？</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十七期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;浅尝辄止必将黯然神伤，坚持不懈终会柳暗花明。&lt;strong&gt;Swift社区&lt;/strong&gt;值得与之同行，一起成就卓越！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果跌近 3% 市值两天蒸发 1898亿 美元&lt;/p&gt;
&lt;p&gt;提案：包迭代提案正在审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议用户定义的元组一致性&lt;/p&gt;
&lt;p&gt;推荐博文：Swift 中的线程安全性和使用锁的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;HUAWEI Mate 60 Pro 和 iPhone 15 你会如何选择？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十六期/</id>
    <published>2024-03-06T07:56:38.000Z</published>
    <updated>2024-03-06T08:03:05.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十六期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>一米阳光下阴雨绵绵，一米阳光上晴空万里，这就是生活。<strong>Swift社区</strong>伴你一起，走过风雨，沐浴暖阳！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通</p><p>提案：对 AsyncStream 的 Backpressure 支持</p><p>Swift 论坛：提议全局变量的严格并发</p><p>推荐博文：WWDC23 10105 - 打造响应更快的相机体验</p><p><strong>话题讨论：</strong> </p><p>日本核污水排海，你还会吃海鲜吗？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/85a89025-a0a8-48f0-bffe-bd7f7a5acde8.jpeg" alt=""></p><p>根据投票结果可以看出，大家有不同的想法。小编认为家长应该根据孩子的个性特点和兴趣爱好灵活调整，注重培养他们的创新精神和独立思考能力。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能"><a href="#消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能" class="headerlink" title="消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能"></a>消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能</h3><p>8 月 25 日消息，根据印度当地媒体 Business Today 报道，苹果印度地区的高管已经和当地财政部会面，探讨扩大 iPhone 在印度产能相关事宜。</p><p>消息称本次探讨涉及面很广，印度政府希望以苹果公司带头下，进一步推动本土智能手机制造业，并磋商相关的扶持政策。</p><p>而苹果公司在交流中也表示，印度是非常重要的生产地和消费市场，乐于扩大在印度市场的产能，但希望能获得更多的补贴，以及政策福利。</p><p>IT之家此前报道，根据市场调查机构 Counterpoint Research 公布的统计数据，2023 年第 2 季度印度市场营收表现首次超过法国和德国，成为苹果第五大 iPhone 市场。</p><p>苹果 iPhone 零售业在印度市场的快速增长的同时，苹果也加快了 iPhone 在印度制造的脚步。苹果加大了在印度市场的投资力度，希望供应链实现多元化发展。（来源：IT之家）</p><h3 id="iPhone-15-Pro-机型新增泰坦灰"><a href="#iPhone-15-Pro-机型新增泰坦灰" class="headerlink" title="iPhone 15 Pro 机型新增泰坦灰"></a>iPhone 15 Pro 机型新增泰坦灰</h3><p>新渲染图曝光，消息称苹果 iPhone 15 Pro 机型泰坦灰将替代金色 iPhone15Pro新增灰色。8 月 25 日消息，根据国外科技媒体 9to5Mac 报道，苹果今年将调整 iPhone 15 Pro 和 iPhone 15 Pro Max 两款机型的颜色选项，取消金色，新增灰色。<br>在最新报道称这种全新灰色官方名称为“泰坦灰”（Titan Gray），并分享了这种颜色的概念渲染图，可以看到“泰坦灰”颜色要比现有的银色 / 白色更深一些，但比深空黑要更淡一些。<br>该媒体还透露苹果今年推出的 iPhone 15 Pro 机型将会取消暗紫色，并由深蓝色替代。<br>注： iPhone 14 Pro 机型共有暗紫色、金色、银色和深空黑四种颜色。<br>苹果预估将于 9 月 12 日发布 iPhone 15 系列，其中 iPhone 15 系列标准版将有黑色，绿色，蓝色，黄色和粉红色。（来源：IT之家）</p><p><img src="https://files.mdnice.com/user/17787/1e3e2489-9b4e-4202-8189-a234f10d0559.png" alt=""></p><h3 id="iPhone-15-全系配-USB-C-苹果拒绝接口和安卓互通"><a href="#iPhone-15-全系配-USB-C-苹果拒绝接口和安卓互通" class="headerlink" title="iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通"></a>iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通</h3><p>8月19日消息，据供应链最新消息称，iPhone 15 全系将会配备 USB-C 接口，不过不同型号会被差异对待。</p><p>按照供应链说法，iPhone 15 标准版只是配备普通版本的 USB-C 接口，而 iPhone 15 Pro 系列则在速度上有明显的提升，同时这个功能只能在 MFi 认证的 USB 数据线下发挥功效。</p><p>具体来说就是，iPhone 15 标准版提供 USB 2.0 版本，传输速度最高 480 Mbps，与之前的 Lightning 接口差不多。而 iPhone 15 Pro 系列用的是 USB 3.2，传输速度能达到 20 Gbps，比标准版快 20 倍以上。</p><p>对于消费者来说，这将是多年来 iPhone 系列手机最大的改进之一。配备该端口后，iPhone 用户在旅行时不再需要为手机和其他移动设备携带两根不同的充电线，不过想法是好的，但苹果却不会这么干。</p><p>按照供应链配件商的说法，苹果不会让 iPhone 15 的 USB-C 接口与安卓通用，即便是有违法的行为，但依然会如此做，毕竟 MFi 认证背后一年是几十亿美元的盈利。</p><p>此外，从苹果的备货来看，Pro 系列占比超过 60%，他们也是想从这些细节的地方卡位用户，让大家主动去买高价版本。</p><p><img src="https://files.mdnice.com/user/17787/3eab2868-eefd-4141-92c3-a3e1835847c5.png" alt=""></p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0407-member-macro-conformances.md" title="SE-0407" target="_blank" rel="noopener">SE-0407</a> <strong>成员 Macro 一致性</strong> 提案正在审查。</p><p>SE-0402中从一致性宏到扩展宏的转变包括扩展宏能够了解类型已经遵循了哪些协议(例如，因为遵循了超类或在某处声明了显式一致性)，这样宏就可以避免添加不需要的声明和一致性。这也意味着添加的任何新声明都是扩展的一部分——而不是原始类型定义的一部分——这通常是有益的，因为这意味着(例如)新的初始化器不会抑制成员初始化器。将协议一致性拆分为各自的扩展通常也被认为是一种很好的形式。</p><p>然而，有时用于一致性的成员确实需要成为原始类型定义的一部分。例如:</p><ul><li>非 final 类中的初始化项必须是必需的初始化项，以满足协议要求。</li><li>非 final 类的可重写成员。</li><li>存储的属性或大小写只能在主类型定义中。</li></ul><p>对于这些情况，成员宏可以生成声明。然而，成员宏并没有提供任何关于应该为哪种协议一致性提供成员的信息，因此宏可能会错误地尝试将一致性成员添加到已经符合协议的类型中(例如，通过超类)。这可能使某些宏(例如实现 <code>Encodable</code> 或 <code>Decodable</code> 协议的宏)无法实现。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0406-async-stream-backpressure.md" title="SE-0406" target="_blank" rel="noopener">SE-0406</a> <strong>对 AsyncStream 的 Backpressure 支持</strong> 提案正在审查。</p><p>SE-0314引入了新的 <code>Async[Throwing]Stream</code> 类型，作为根异步序列。这两种类型允许从同步回调（如委托）桥接到异步序列。该提案增加了一种构建异步流的新方法，目的是将 Backpressure 系统桥接成异步序列。此外，该提案旨在澄清消费任务取消和生产方表示终止时的取消行为。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-macro-literal-protocols/66915" title="宏文字协议" target="_blank" rel="noopener">宏文字协议</a></p><p>目前仅允许在顶层使用宏。 然而，在某些情况下，嵌套宏会很有好处。</p><p>例如，我们可以添加具有宏要求的新文字协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ExpressibleByMacroIntegerLiteral</span> </span>&#123;</span><br><span class="line">  associatedtype <span class="type">IntegerLiteralType</span>: _ExpressibleByBuiltinIntegerLiteral</span><br><span class="line"></span><br><span class="line">  @freestanding(expression)</span><br><span class="line">  macro <span class="type">Init</span>(integerLiteral: <span class="type">IntegerLiteralType</span>) -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用编译器的魔法，酱子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">Decimal</span> = <span class="number">5.3</span></span><br></pre></td></tr></table></figure><p>可以变成酱子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = #<span class="type">Decimal</span>.<span class="type">Init</span>(integerLiteral: <span class="number">5.3</span>)</span><br></pre></td></tr></table></figure><p>然后将扩大</p><p>我知道宏的设计目标之一是避免这种不可见的宏使用，但是已经有很多编译器魔法可以通过 _ 文字协议来表达，这将使它们更加通用。</p><p>例如，当前如果类型是 <code>ExpressibleByStringLiteral</code> 但只有某些字符串文字有效，则唯一的选择是在运行时遇到无效字符串文字时捕获。 这违背了文字的编译时性质，而文字应该允许检查文字。 在基金会提出将 URL 改为 ExpressibleByStringLiteral 时，这个问题在某种程度上被掩盖了，但已经完全解决了。</p><p>这个语句：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadFile(at: <span class="string">"https://apple.com"</span>)</span><br></pre></td></tr></table></figure><p>看起来比这个好很多:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadFile(at: #<span class="type">URL</span>(<span class="string">"https://apple.com"</span>))</span><br></pre></td></tr></table></figure><p>2) 提议<a href="https://forums.swift.org/t/pitch-nested-if-let-and-guard-let/66927" title="嵌套 if let 和 guard let" target="_blank" rel="noopener">嵌套 if let 和 guard let</a></p><p><strong>介绍</strong></p><p>在 Swift 中，if let 语句通常用于可选的解包。 它通过处理可选值帮助开发人员编写更干净、更安全的代码。</p><p>目前，if let 语句解包单个可选值。 然而，在某些情况下，我们希望以更简洁的方式解开嵌套对象的可选属性。</p><p>该提案建议扩展 if let 和 Guard let 语句以支持嵌套可选展开。</p><p><strong>1. if let 嵌套</strong></p><p>嵌套 if let 的拟议语法将允许开发人员有条件地解包嵌套对象的可选属性。 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> myOptionalObject?.optionalValue &#123;</span><br><span class="line">    <span class="comment">// 'optionalValue' is now safely unwrapped and ready to use // *1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the case where 'optionalValue' is nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 嵌套的 guard let</strong></p><p>类似地，所提议的嵌套 Guard Let 语法将允许开发人员有条件地解开嵌套对象的可选属性。 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> myOptionalObject?.optionalValue <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the case where 'myOptionalObject' or 'optionalValue' is nil</span></span><br><span class="line">    <span class="comment">// This could include returning from the current function, loop, or throwing an error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'optionalValue' is now safely unwrapped and ready to use // *1</span></span><br></pre></td></tr></table></figure><p>3) 提议<a href="https://forums.swift.org/t/pitch-strict-concurrency-for-global-variables/66908" title="全局变量的严格并发" target="_blank" rel="noopener">全局变量的严格并发</a></p><p><strong>介绍</strong></p><p>该提案定义了无数据竞争的全局变量的使用选项。 在此提案中，全局变量包含静态持续时间的任何存储：在全局范围内声明或作为静态成员变量声明的 let 和存储变量。</p><p><strong>动机</strong></p><p>全局状态在并发性中提出了挑战，因为它是可以从任何程序上下文访问的内存。 全局变量在数据隔离检查中受到特别关注，因为它们违背了其他强制隔离的尝试。 </p><p>本地且未捕获的变量只能从本地上下文访问，这隐式地隔离了它们。 值类型的存储属性已经通过排他性规则隔离。 </p><p>可以通过使用可发送性强制或使用参与者限制来隔离引用类型的包含对象，从而隔离引用类型的存储属性。 但全局变量可以从任何地方访问，所以这些工具不起作用。</p><p><strong>建议的解决方案</strong></p><p>在严格的并发检查下，要求每个全局变量要么与全局参与者隔离，要么两者都隔离：</p><ul><li>不可变的（immutable）</li><li>可发送类型（Sendable）</li></ul><p>immutable 并且 Sendable 的全局变量可以从任何上下文安全地访问，否则需要隔离。</p><p><strong>详细设计</strong></p><p>这些要求可以在声明时在类型检查器中强制执行。</p><p><strong>源兼容性</strong></p><p>由于增加了限制，因此在使用严格的并发检查时可能需要更改某些类型声明。 然而，此类源代码更改仍然向后兼容任何具有并发功能的 Swift 版本。</p><p><strong>ABI兼容性</strong></p><p>该提案本身不会添加或影响 ABI(Application Binary Interface)，但是它可能对采用的项目引发的类型声明更改可能会影响该项目的 ABI。</p><p><strong>对采用的影响</strong></p><p>在采用严格并发检查的项目中，可能需要修改某些全局变量类型。</p><p><strong>考虑的替代方案</strong></p><p>为了隔离，我们可以隐式锁定变量的访问，而不需要全局参与者。 在提供内存安全的同时，这可能会给线程安全带来问题，因为开发人员可以轻松编写 non-atomic 的模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value of global may concurrently change between</span></span><br><span class="line"><span class="comment">// the read for the multiplication expression</span></span><br><span class="line"><span class="comment">// and the write for the assignment</span></span><br><span class="line">global = global * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>虽然如果我们需要在旧语言模式中做一些源兼容的事情，我们可以考虑隐式锁定，但通常我们的方法只是说旧语言模式是并发不安全的。 </p><p>它也不适用于非可发送类型，除非我们强制该值在访问它时保持隔离。我们可能可以通过提议的<a href="https://forums.swift.org/t/pitch-safely-sending-non-sendable-values-across-isolation-domains/66566" title="跨隔离域安全发送不可发送值" target="_blank" rel="noopener">跨隔离域安全发送不可发送值</a>功能来实现这一目标，但这可能是一个过于先进的功能，无法作为此类基本问题的解决方案来推动。</p><p>我们可以将所有需要隔离的全局变量默认为 <code>@MainActor</code>。 可以说，让开发人员考虑选择会更好（例如，也许它应该只是一个 let 常量）。</p><p>访问控制在理论上是有用的：例如，我们可以知道全局变量是并发安全的，因为它是文件私有的，并且该文件中的所有访问都来自单个全局参与者上下文，或者因为它永远不会 变异了。 </p><p>不过，这比我们通常希望在编译器中进行的分析更加全局化； 我们必须检查上下文中的所有内容，然后开发人员可能很难理解它为什么起作用。</p><p><strong>未来发展方向</strong></p><p>我们不一定需要明确地要求隔离全球参与者； 有空间推断正确的全球行动者。 全局角色约束类型的全局可变变量可以被推断为约束到该全局角色（尽管如果变量是不可变的，则没有必要，因为全局角色约束类类型是可发送的）。</p><p>4) 讨论<a href="https://forums.swift.org/t/method-marked-with-globalactor-modifying-property-in-class/66898" title="用 globalActor 标记的方法修改类中的属性" target="_blank" rel="noopener">用 globalActor 标记的方法修改类中的属性</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Po</span> </span>&#123;</span><br><span class="line">    @<span class="type">MainActor</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>: <span class="title">Po</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">""</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        str = <span class="string">"w"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"foo: <span class="subst">\(Thread.isMainThread)</span>"</span>) <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> #available(macOS <span class="number">10.15</span>, *) &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="type">Base</span>()</span><br><span class="line">        await b.foo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">RunLoop</span>.main.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我不明白为什么我可以直接在标有MainActor的方法中修改属性？</p><p>因为这对我来说似乎是错误的。<br>我相信 Base 及其属性不在 MainActor 上运行。</p><p><strong>回答</strong></p><p>您在顶层创建 Task，这隐式地使其在 main actor 上运行。 由于 Base 只是一个类（而不是 actor），因此它的方法在其调用者所在的任何上下文中运行，在本例中这是 main actor。<br>属性和方法可以单独与特定参与者相关联，包括作为协议要求的一部分。 在这种情况下 foo 隐式是 @MainActor，因为 Po 协议如此声明它。</p><p>这可能有点太神奇了 - foo 也是隐式异步的，尽管它从未真正被标记为异步，即使在原始协议声明中也是如此。</p><p>为了进一步测试这一点，如果您添加到 Base 例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将收到编译器错误 <code>Call to main actor-isolated instance method &#39;foo()&#39; in a synchronous nonisolated context</code>，表明编译器将 foo 视为 @MainActor（但 Base 的其余部分不是）。</p><p>5) 讨论<a href="https://forums.swift.org/t/self-used-before-super-init-call-conflicts-with-property-not-initialized-at-super-init-call/66896" title="在 &quot;super.init&quot; 调用之前使用的 &quot;self&quot; 与 &quot;在 super.init 调用时未初始化属性&quot; 冲突" target="_blank" rel="noopener">在 “super.init” 调用之前使用的 “self” 与 “在 super.init 调用时未初始化属性” 冲突</a></p><p>我需要在 init 中创建一个捕获 self 的闭包来初始化属性，但我无法使用 self，因为 super.init 尚未被调用。 但是，我无法调用 super.init，因为该属性尚未初始化！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>: <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer: <span class="type">Timer</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// option 1 - try to initialize the property</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// ERROR: 'self' used before 'super.init' call</span></span><br><span class="line">        timer = .scheduledTimer(withTimeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>!.value += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 2 - try to initialize super first</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()  <span class="comment">// ERROR: Property 'self.timer' not initialized at super.init call</span></span><br><span class="line">        timer = .scheduledTimer(withTimeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>!.value += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使属性既可选又可变（在 super.init 期间初始化为 nil，然后在之后更改它）之外，还有什么办法可以解决这个问题吗？</p><p>我有点明白为什么编译器不能接受这种情况，但是必须使属性可选且可变，这很烦人，而一旦类完全初始化，它实际上既不应该为零，也不应该变。</p><p><strong>回答</strong></p><p>需要在函数内有一个本地变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> futureSelf: <span class="type">Sub</span>? = <span class="literal">nil</span></span><br><span class="line">    timer = .scheduledTimer(withTimeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; [<span class="keyword">weak</span> futureSelf] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            futureSelf?.value += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    futureSelf = <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，编译器无法知道采用闭包捕获 self 的对象是否不会立即被调用，并且它试图避免使用半初始化的 self 实例调用闭包。</p><p>6) 讨论<a href="https://forums.swift.org/t/should-deinit-be-called-after-explicit-consume-of-reference-type/66920" title="显式使用引用类型后是否应该调用 deinit？" target="_blank" rel="noopener">显式使用引用类型后是否应该调用 deinit？</a></p><p>我想通过使用 <code>_ = Consumer</code> 对象显式结束演员/类的生命周期，以避免引入具有单独作用域的另一级嵌套。 但是，在显式消费之后不会调用该对象的 deinit。 相反，它是在作用域末尾调用的。 这是预期行为还是编译器错误？ 对于不可复制的结构，它可以按预期工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"deinit object"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Noncopyable</span>: ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"deinit noncopyable"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDeinitAfterConsume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> object = <span class="type">Object</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"before consume"</span>)</span><br><span class="line">        <span class="number">_</span> = consume object</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"after consume"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> noncopyable = <span class="type">Noncopyable</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"before consume"</span>)</span><br><span class="line">        <span class="number">_</span> = consume noncopyable</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"after consume"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before consume</span><br><span class="line">after consume</span><br><span class="line"><span class="keyword">deinit</span> object</span><br><span class="line"></span><br><span class="line">before consume</span><br><span class="line"><span class="keyword">deinit</span> noncopyable</span><br><span class="line">after consume</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>这是可以理解的。 一般来说，每当对象丢失最后一个引用时，类析构器就会运行，而不考虑变量范围。</p><p>在某种程度上不鼓励在类去初始化中依赖共享可变状态，并且强烈不鼓励依赖与常规代码中的副作用相关的顺序。 即使没有优化，它通常也会很棘手并且容易出错。</p><p>对对象生命周期的显式控制是 Swift 中依赖类取消初始化顺序的官方方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">withExtendedLifetime</span>(object) &#123;</span><br><span class="line">    <span class="comment">// Modify shared mutable state without accessing object.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于局部变量（包括参数），编译器（5.7 后）遵循一些保守的生命周期规则，以便大多数“看起来正常”的编程模式无需显式生命周期管理即可工作。 事实上，如果我们按照字面意思理解这个示例，则 deinit 将不会发生，并且我们永远不会看到以下输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> object</span><br><span class="line">before consume</span><br><span class="line">after consume</span><br></pre></td></tr></table></figure><p>额外的安全规则是：</p><p>如果不安全指针或弱引用可能依赖于局部变量的生命周期，则编译器会自动扩展该变量持有的任何引用。</p><p>如果常规代码在 Swift 外部调用（包括所有 I/O）或跨任务同步（调用异步函数），则类析构器将不会跨这些边界重新排序。 这也意味着程序员可以通过添加同步代码来控制对象的生命周期，而无需 withExtendedLifetime。 在此示例中，调用 “print” 被视为同步点，从而阻止优化。</p><p>这里有更详细的描述：<a href="https://gist.github.com/atrick/cc03c4d07fb0a7bee92c223ae5e5695b#lexical-variable-scope-can-affect-object-lifetime" target="_blank" rel="noopener">https://gist.github.com/atrick/cc03c4d07fb0a7bee92c223ae5e5695b#lexical-variable-scope-can-affect-object-lifetime</a><br>在这方面，消耗参数与 “let”、“var” 和非 “消耗” 参数不同，因为它们的生命周期可以在隐式消耗时提前结束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(<span class="number">_</span> object: consuming Object)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(object: consuming Object)</span></span> &#123;</span><br><span class="line">    bar(object)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"after consume"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总是得到结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> object</span><br><span class="line">after consume</span><br></pre></td></tr></table></figure><p>这为那些关心 ARC 开销和 CoW 行为的人提供了理想的编程模型。 很快，我希望所有局部变量都具有“消耗”的效果。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/08/01/mastering-storekit2" title="掌握 StoreKit2" target="_blank" rel="noopener">掌握 StoreKit2</a></p><p><strong>摘要：</strong> 本文介绍了 Swift 中的 StoreKit2，这是一个用于构建应用内购买和订阅的框架。文章从配置项目和创建 StoreKit 配置文件开始，介绍了如何使用 Store 类型处理应用内购买逻辑。通过示例代码和说明，文章展示了如何使用 Store 类型来获取和显示应用内购买产品列表，并启动购买流程。还介绍了产品类型和其 purchase 函数，在成功购买时处理交易和验证过程。文章还涉及了处理挂起状态和监视交易更新的方法。此外，提到了 StoreKit2 提供的 currentEntitlements 属性，用于获取活动订阅和已购买产品列表。最后，文章给出了一个基本的 App 结构示例，其中包含了 Store 对象，并在应用程序启动时获取活动交易。 </p><p><a href="https://juejin.cn/post/7251501966592917563" title=" iOS 防 dump 可行性调研报告" target="_blank" rel="noopener"> iOS 防 dump 可行性调研报告</a></p><p><strong>摘要：</strong>  文章介绍了如何防止 iOS App 被 dump ，包括代码混淆、加密、完整性检查等多层防御策略，以及服务器端验证、动态加载、API 安全性和多因素认证等方案。此外，监控与告警、定期安全审计和安全培训等后置方案也可以提高 App 的安全性。最后，还介绍了禁止越狱设备的实施方案，以及 DeviceCheck 和 App Attest API 等新技术方案。</p><p><a href="https://juejin.cn/post/7268119060055031865" title=" WWDC23 10105 - 打造响应更快的相机体验" target="_blank" rel="noopener"> WWDC23 10105 - 打造响应更快的相机体验</a></p><p><strong>摘要：</strong> 文章介绍了 iOS17 提供了一些新的特性，通过延迟图片处理、快门零延迟、响应捕获等新特性，以及状态监听等措施，能大幅提高相机响应速度，创造更流畅的拍摄体验。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>日本核污水排海，你还会吃海鲜吗？</strong></p><ol><li>会</li><li>不会</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十六期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;一米阳光下阴雨绵绵，一米阳光上晴空万里，这就是生活。&lt;strong&gt;Swift社区&lt;/strong&gt;伴你一起，走过风雨，沐浴暖阳！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通&lt;/p&gt;
&lt;p&gt;提案：对 AsyncStream 的 Backpressure 支持&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议全局变量的严格并发&lt;/p&gt;
&lt;p&gt;推荐博文：WWDC23 10105 - 打造响应更快的相机体验&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;日本核污水排海，你还会吃海鲜吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十五期/</id>
    <published>2024-03-06T07:56:33.000Z</published>
    <updated>2024-03-06T08:02:31.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十五期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>是站在生命之巅，嘲笑死神的无能？还是跪在生活边缘，寻求生存的可能？<strong>Swift社区</strong>始于渺小，行至辽阔！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：五天市值蒸发 2000 亿美元，苹果公司怎么了？</p><p>提案：具有编码验证的 <code>String Initializers</code></p><p>Swift 论坛：Swift 分布式追踪</p><p>推荐博文：iOS ReplayKit 与 屏幕录制</p><p><strong>话题讨论：</strong> </p><p>苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/d83bb1a9-5218-4d1c-892c-bc767e2cfe00.jpg" alt=""></p><p>从投票结果可以看出来，购买决策不再仅仅只受价格影响，用户更注重手机性能、价值、国产支持等多个方面。你怎么看～</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="五天市值蒸发-2000-亿美元，苹果公司怎么了？"><a href="#五天市值蒸发-2000-亿美元，苹果公司怎么了？" class="headerlink" title="五天市值蒸发 2000 亿美元，苹果公司怎么了？"></a>五天市值蒸发 2000 亿美元，苹果公司怎么了？</h3><p>不久前的 6 月份，苹果公司刚成为首家市值超过 3 万亿美元的企业，但其最新一季的财报却引发了投资者对其手机与其他设备需求不振的担忧。</p><p>8 月 4 日，苹果公司公布了三季度财报。财报显示，苹果第三财季营收 817.97 亿美元，不及上一财年同期的 829.59 亿美元，较上一财季的 948.36 亿美元大幅下滑。在看到新一季财报数据后，投资者惊讶地发现，这家巨无霸上市公司的营业收入已经连续 3 个财季下滑，且苹果在第四季展望中预测当季表现也不大会有差别。</p><p>公司股价接连下跌</p><p>苹果公司三季报发布日恰在其新产品 iPhone15 系列新机上市前，但市场预期苹果手机这一新机型受追捧程度不如以往。在悲观情绪影响下，苹果公司股价在 8 月 4 日财报公布日重挫 4.8% ，创下今年以来最大单日跌幅，市值一天之内蒸发逾 1600 亿美元。而后，苹果股价并未能止住跌势，截至本周一（8 月 7 日），苹果的股价已经遭遇“五连跌”，股价暴跌近 10% ，总市值蒸发超过 2000 亿美元，约合人民币 1.44万 亿元。</p><p>美国银行的分析师在一份业绩报告中表示，苹果正面临美国智能手机市场疲软的大环境。此外，估值过高可能也是苹果此次下跌的又一重要原因。对于苹果销售额的“三连降”，第一手机界研究院院长孙燕飙表示，消费电子市场持续低迷削弱了对智能手机的需求，叠加创新力不足难以拉动新机销量，苹果手机的销售收入连续下滑。如果苹果在第四财季的销售额继续同比下降，这将是该公司 20 年来销售额同比下降持续时间最长的一次。（来源：金融时报）</p><h3 id="在你的-App-中帮助顾客解决账单问题"><a href="#在你的-App-中帮助顾客解决账单问题" class="headerlink" title="在你的 App 中帮助顾客解决账单问题"></a>在你的 App 中帮助顾客解决账单问题</h3><p>正如我们在 4 月份宣布的那样，很快，你的顾客就能直接在你的 App 中解决付款问题，以便更轻松地继续订阅你的内容、服务和高级功能。</p><p>自 2023 年 8 月 14 日起，如果自动续期订阅因账单问题而无法续订，你的 App 中会显示一个系统提供的表单，提示顾客更新其 Apple ID 的付款方式。你可以在沙盒中先测试一下此表单，还可以使用 StoreKit 中的 messages (英文) 和 display (英文) 来推迟或禁止显示此表单。这项功能在 iOS 16.4 和 iPadOS 16.4 或更高版本中提供，无需采取任何操作即可采用。</p><h3 id="需要声明原因的-API-列表现已推出"><a href="#需要声明原因的-API-列表现已推出" class="headerlink" title="需要声明原因的 API 列表现已推出"></a>需要声明原因的 API 列表现已推出</h3><p>Apple 致力于保护我们平台上的用户隐私。我们知道，有一小部分 API 可能会被滥用来通过信息指纹收集用户设备的相关数据，这是我们的 Developer Program 许可协议禁止的一种做法。为了防止滥用这些 API，我们在 WWDC23 (英文) 上宣布了开发者需要在 App 的隐私清单中声明使用这些 API 的原因。这将有助于确保 App 仅将这些 API 用于预期用途。在这个流程中，你需要选择一个或多个能够准确反映你的 App 如何使用相应 API 的批准原因，并且你的 App 只能出于你选择的原因使用相应 API。</p><p>从 2023 年秋季开始，如果你上传到 App Store Connect 的新 App 或 App 更新使用了需要声明原因的 API (包括来自第三方 SDK 的内容)，而你没有在 App 的隐私清单中提供批准的原因，那么你会收到通知。从 2024 年春季开始，若要将新 App 或 App 更新上传到 App Store Connect，你需要在 App 的隐私清单中注明批准的原因，以准确反映你的 App 如何使用相应 API。</p><p>如果目前批准原因的涵盖范围内并未包含某个需要声明原因的 API 的用例，且你确信这个用例可让你的 App 用户直接受益，请告诉我们。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0403-swiftpm-mixed-language-targets.md" title="SE-0403" target="_blank" rel="noopener">SE-0403</a> <strong>软件包管理器混合语言目标支持</strong> 提案通过审查。该提案已在 <strong>三十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0405-string-validating-initializers.md" title="SE-0405" target="_blank" rel="noopener">SE-0405</a> <strong>具有编码验证的 String Initializers</strong> 提案正在审查。</p><p>我们建议添加新的 <code>String</code> 可失败 <code>Initializer</code>s，用于验证编码输入，并在输入包含任何无效元素时返回 <code>nil</code>。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/swift-string-comparison-doesnt-consider-ligatures-equivalent-to-their-components/66665" title="Swift 字符串比较不将连字等同于其组件" target="_blank" rel="noopener">Swift 字符串比较不将连字等同于其组件</a></p><p><strong>内容大概</strong></p><p>我刚刚发现 Swift 字符串将 “office” 和 “oﬃce” 视为不相等，这让我感到惊讶，因为它将 “caña” 和 “caña” 视为相等（即，都是组合和分解形式）。对于一般用户来说，这些情况是等价的 - 它们只是以不同的方式表示相同的字形（至少在某些字体中是如此）。</p><p>我进行了一些调查，似乎这是因为 Swift 承诺在 Unicode 术语中使用 “规范” 比较，而不是 “兼容” 比较。文档提到了这一点，但没有解释其含义。</p><p>我进一步查找并发现了有关 Unicode 中连字的一些争议和历史，这可能会为此提供一些启示（例如，目前 Unicode 关于连字的观点似乎是不应该用于字距调整，例如 “ﬃ”，但它仍然包含一些”不恰当” 的连字 - 再次，如 “ﬃ” - 这些连字是在这种心态转变之前添加的）。</p><p><code>NSString</code> 也类似，除非你在使用 <code>compare(_:options:)</code> 时选择了 <code>caseInsensitive</code> 选项，这时它会将连字视为其分解形式。这很奇怪，因为这与字符大小写无关。</p><p>我猜这篇文章主要是向其他人提供信息和警告。但我很好奇为什么 Swift 选择执行 “规范” 比较，而不是 “兼容” 比较？此外，似乎在 Swift 标准库中没有办法执行 “兼容” 比较 - 必须导入 Foundation 才能获取字符串重叠部分，以便访问前面提到的 <code>NSString</code> 方法。</p><p><strong>回答</strong></p><p>兼容性分解是 Unicode 在需要与早期编码兼容（作为超集）的情况下所迫不得已的妥协。如果这些字符直接提议给 Unicode，它们将永远不会被编码。通常情况下，即使您在使用它们，也可能是在做错误的事情，因为它们所编码的内容（例如连字）不是文本的属性，而是显示格式的属性。</p><p>在 Unicode 的观点中，它们本身就不应该出现在原始字符串中。然而，将它们折叠到规范形式会丢失有关格式的信息，因此不能安全地应用于实际使用了它们的传统文本。（以“ff”为例，不是每一对“f”都要在显示中连接；那些跨越复合词两半的“f”应该保持分开。不能通过简单查看上下文来恢复这种区别，需要手动进行或通过字典查询来完成。）这与类似“ñ”的规范分解根本不同，后者在规范化过程中不会丢失信息。</p><p>如果想知道两个字符串是否在兼容性方面是等价的，则可以使用 Foundation 的 <code>decomposedStringWithCompatibilityMapping</code> 方法。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-swift-distributed-tracing/66679" title="Swift 分布式追踪" target="_blank" rel="noopener">Swift 分布式追踪</a></p><p><strong>动机</strong></p><p>虽然 <a href="https://github.com/apple/swift-log" title="Logging" target="_blank" rel="noopener">Logging</a> 和 <a href="https://github.com/apple/swift-metrics" title="Metrics" target="_blank" rel="noopener">Metrics</a> 可以用于仪器化应用程序的特定部分，但 <a href="https://github.com/apple/swift-distributed-tracing" title="Distributed Tracing" target="_blank" rel="noopener">Distributed Tracing</a> 提供了对整个分布式系统的整体视图。与这两者一起，分布式跟踪将完成“可观察性的三大支柱”。</p><p>与 Logging 和 Metrics 一样，如果在库和框架中直接使用一个共同的 API 来实现分布式跟踪，社区将从中受益最多。最终用户应该能够自由选择合适的后端实现，而无需更改他们正在使用的库或框架。</p><p><strong>建议的解决方案</strong></p><p>Swift 分布式跟踪围绕着创建跨度（span），这些跨度共同形成一种树状结构。跟踪可以由在单个服务中记录的跨度组成，也可以跨多个服务传播。Swift 分布式跟踪使用基于任务本地的 <a href="https://github.com/apple/swift-service-context" title="Swift Service Context" target="_blank" rel="noopener">Swift Service Context</a> 来实现透明的传播，无需手动传递上下文。</p><p>我们提出的解决方案是一个针对三个“角色”的库：</p><ul><li>终端用户</li><li>库和框架作者</li><li>跟踪器后端实现</li></ul><p><strong>用户端</strong></p><p>最终用户是从分布式跟踪中受益的人。他们选择适合自己需求的跟踪后端，使用具有内置的 Swift 分布式跟踪支持的库，并在自己的代码中进行手动仪器化。</p><p><strong>库和框架作者</strong></p><p>诸如 HTTP 服务器/客户端、数据库库等库/框架最了解如何仪器化其库的内部。他们使用 Swift 分布式跟踪 API 实现通用的跟踪支持，而无需考虑特定的跟踪后端。</p><p>例子:</p><ul><li><a href="https://github.com/hummingbird-project/hummingbird/releases/tag/1.6.0" title="Hummingbird" target="_blank" rel="noopener">Hummingbird</a></li><li><a href="https://github.com/soto-project/soto-core/pull/575" title="Soto" target="_blank" rel="noopener">Soto</a></li></ul><p><strong>跟踪后端实现</strong></p><p>最后一个难题是跟踪器后端实现。它们为导出跟踪 span 提供特定于供应商的支持。</p><p>例子</p><p><a href="https://github.com/slashmo/swift-otel" title="Swift OTel" target="_blank" rel="noopener">Swift OTel</a> 公开了一个导出到 <a href="https://opentelemetry.io/docs/collector" title="OpenTelemetry Collector" target="_blank" rel="noopener">OpenTelemetry Collector</a> 的跟踪器。这已经允许该跟踪库的采用者导出到与 OpenTelemetry 兼容的流行后端，例如 Zipkin、Jaeger、Honeycomb 等。</p><p><strong>到期理由</strong></p><p>我们提议这个软件包处于“孵化”成熟度级别。 我们相信这个包是服务器生态系统的重要构建块，就像许多服务器和客户端库采用 <a href="https://github.com/apple/swift-log" title="swift-log" target="_blank" rel="noopener">swift-log</a> 和 <a href="https://github.com/apple/swift-metrics" title="swift-metrics" target="_blank" rel="noopener">swift-metrics</a> 一样。</p><p>该项目已经成熟超过3年，有多个活跃的维护人员，并且在生产环境中满足了采用要求。</p><p>3) 讨论<a href="https://forums.swift.org/t/attributedstring-index-fetching-causes-internal-unwrap-of-nil-value/66677" title="AttributedString 索引获取导致 nil 值的内部解包" target="_blank" rel="noopener">AttributedString 索引获取导致 nil 值的内部解包</a></p><p><strong>问题描述</strong></p><p>我有一个富文本字符串，其中一个子字符串正在被替换，但是会引发 fatalError：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="type">AttributedString</span>(<span class="string">"café"</span>)</span><br><span class="line"><span class="keyword">let</span> replaceIndex = string.index(beforeCharacter: string.endIndex)</span><br><span class="line"><span class="keyword">let</span> range = replaceIndex..&lt;string.endIndex</span><br><span class="line">string.replaceSubrange(range, with: <span class="type">AttributedString</span>(<span class="string">"e"</span>))</span><br><span class="line"><span class="keyword">let</span> next = string.index(afterCharacter: replaceIndex)</span><br><span class="line"><span class="comment">//                ^---- Unexpectedly found nil while unwrapping an Optional value</span></span><br><span class="line"><span class="built_in">assert</span>(next == string.endIndex)</span><br></pre></td></tr></table></figure><p>这令人惊讶，因为我认为在更改之前，索引会保持稳定。更奇怪的是，改变如何创建范围不会导致失败。以下代码可以正常工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="type">AttributedString</span>(<span class="string">"café"</span>)</span><br><span class="line"><span class="keyword">let</span> range = range(of: <span class="string">"é"</span>)!</span><br><span class="line">string.replaceSubrange(range, with: <span class="type">AttributedString</span>(<span class="string">"e"</span>))</span><br><span class="line"><span class="keyword">let</span> next = string.index(afterCharacter: replaceIndex)</span><br><span class="line"><span class="built_in">assert</span>(next == string.endIndex)</span><br></pre></td></tr></table></figure><p>使用 ASCII 字符而不是重音符号 ‘é’ 不会导致两种范围技术中的任何一种失败。我仔细分析了开源实现，试图揭示出现 nil 可选值的源头，但我看不到任何问题，我认为这与当前发布的代码不同。</p><p>对于我哪里的逻辑出了问题，有什么建议吗？</p><p>我使用的是 macOS 13.4.1 和 Xcode 15b5。</p><p><strong>回答</strong></p><p>明确一点，<code>RangeReplaceableCollection</code> 的变异操作可能会使现有索引失效，因为这些索引可能包含对于变异集合不再有效的信息（例如，在字符串的情况下，计算的字节偏移不再有效）。从 <code>RangeReplaceableCollection.replaceSubrange(_:with:)</code> 文档中可以看出：</p><blockquote><p>调用此方法可能会使任何现有索引在与此集合一起使用时失效。</p></blockquote><p>并且，这个方法几乎是 <code>RangeReplaceableCollection</code> 上所有其他操作的基础，所以人们应该假设（除非为特定类型另有说明）任何可能改变索引相关信息的变异操作都会使现有索引失效。</p><p>4) 提议<a href="https://forums.swift.org/t/pitch-access-level-on-import-statements/66657" title="导入语句的访问级别" target="_blank" rel="noopener">导入语句的访问级别</a></p><p>这是一个关于在 Swift 中更好地控制依赖和导入的提案。通过这个特性，可以将导入标记为公共的（当前的常规导入方式），对于模块的实现细节，可以标记为内部，对于源文件的实现细节，可以标记为私有或文件私有。</p><p>另外，更新后的包访问级别允许将依赖标记为仅对同一包中的模块可见。这会像源文件中的常规访问级别一样进行强制执行。将作为内部导入的声明只能从内部声明或更低的访问级别中引用，而在公共或包声明中使用则会报错。</p><p>下面是一个典型的用例，其中依赖项是我们不希望在模块 API 中暴露给客户端的实现细节，以及预期的诊断信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">import</span> DatabaseAdapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">internalFunc</span><span class="params">()</span></span> -&gt; <span class="type">DatabaseAdapter</span>.<span class="type">Entry</span> &#123; ... &#125; <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">publicFunc</span><span class="params">(entry: DatabaseAdapter.Entry)</span></span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// error: function cannot be declared public because its parameter uses an internal type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">useInBody</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">DatabaseAdapter</span>.foo() <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">useInInlinableBody</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">DatabaseAdapter</span>.foo()</span><br><span class="line">    <span class="comment">// error: global function 'foo()' is internal and cannot be referenced from an '@inlinable' function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该提案还定义了一组条件，其中可以从客户端隐藏依赖项。这提供了一种强大的方法来完全隐藏实现细节，并可以加快客户端的构建时间。</p><p>这个提案旨在提供一个正式且更清晰的替代方案，来取代 <code>@_implementationOnly</code>。与此相反，此版本提供了熟悉的诊断信息，更多级别的控制，以及与非弹性模块和 <code>@testable</code> 客户端更好的兼容性。</p><p>根据社区对建议的 Swift 6 行为的反应，我们可以将其纳入该提案。</p><p>5) 讨论<a href="https://forums.swift.org/t/actors-that-serialise-file-access/66652" title="序列化文件访问的 Actor" target="_blank" rel="noopener">序列化文件访问的 Actor</a></p><p><strong>问题描述</strong></p><p>我想知道使用 Actor 是否是保护资源免受并发访问的好选择，例如一个文件目录。在过去，我曾使用 dispatch queues 实现这种情况。使用 Actor 作为阻塞文件访问 API 的通道点的优缺点是什么？</p><p><strong>回答</strong></p><blockquote><p>仅仅是在文件系统中进行典型的CRUD操作</p></blockquote><p>在这里，Actor并不能帮助你。即使在 Actor 可重入性的考虑之外，从 Actor 外部调用的 Actor 方法的执行顺序也无法保证。</p><p>CRUD 操作已经是线程安全的（如果它们不是，那将是一个相当令人失望的文件系统）。由于 Actor 不以执行方法的调用顺序“串行化”任何内容，因此不需要 Actor。</p><p>可能需要的是一个 FIFO 队列，这就是（串行的）DispatchQueue 解决方案为此提供的好处。</p><p>现在，如果谈论的是将一系列操作有效地“原子化”（例如，在枚举目录时不允许同时对其进行变异），那么需要保护的是一些可变状态，Actor 可以保护它。在我看来，这是比 CRUD 更高层次的抽象。在这方面，我认为 <code>@tera</code> 的问题在这里比想象的更相关。</p><p>6) 讨论<a href="https://forums.swift.org/t/l-shaped-enums/66661" title="L-shaped 枚举" target="_blank" rel="noopener">L-shaped 枚举</a></p><p><strong>问题描述</strong></p><p>用于缺乏更好的术语，我有很多“L-shaped”枚举，它们具有一些不同的有效载荷类型和一些共同的有效载荷类型。</p><p>以下是一个示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Request</span>:<span class="title">Sendable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">get</span>    (<span class="type">Get</span>, <span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;)</span><br><span class="line">        <span class="keyword">case</span> post   (<span class="type">Post</span>, <span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;)</span><br><span class="line">        <span class="keyword">case</span> delete (<span class="type">Delete</span>, <span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span>.<span class="title">Request</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Get</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Post</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Delete</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种布局存在问题：</p><p>很难访问共同的字段（<code>EventLoopPromise&lt;ServerResponse&gt;</code>），除非在枚举上进行 switch 操作。</p><p>很难在实际的变体有效载荷上进行 switch，因为您必须使用 _ 忽略共同字段。</p><p>这里有一个明显的重构方法，即将变体有效载荷提升到另一个嵌套类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Request</span>:<span class="title">Sendable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> operation:<span class="type">Operation</span></span><br><span class="line">        <span class="keyword">let</span> promise:<span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span>.<span class="title">Request</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Operation</span>:<span class="title">Sendable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">get</span>    (<span class="type">Get</span>)</span><br><span class="line">        <span class="keyword">case</span> post   (<span class="type">Post</span>)</span><br><span class="line">        <span class="keyword">case</span> delete (<span class="type">Delete</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span>.<span class="title">Request</span>.<span class="title">Operation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Get</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Post</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Delete</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这感觉像是过多的嵌套和（过多？）的类型结构，与我尝试建模的复杂性成正比。而且 <code>ServerDelegate.Request.Operation.Get</code>、<code>ServerDelegate.Request.Operation.Post</code> 等枚举本身可能还有更多的嵌套结构。</p><p>我们有哪些替代方案呢？”</p><p><strong>回答</strong></p><p>命名空间中的点是嵌套的结果，这与这里的类型结构并不是真正的基本关系。提供便利的 API 来处理一些 <code>.init</code> 繁琐的情况似乎也是合理的，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(url: URL, params: [String: String], mintPromise: <span class="params">()</span></span></span> -&gt; <span class="type">EventLoopPromise</span>) -&gt; <span class="type">Self</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7217692600647254071/" title="iOS ReplayKit 与 屏幕录制" target="_blank" rel="noopener">iOS ReplayKit 与 屏幕录制</a></p><p><strong>摘要：</strong> 这篇文章主要介绍了使用 Apple 的 ReplayKit 框架来实现屏幕录制功能，包括应用内录制和系统级录制。 ReplayKit 从 iOS 9中第一次提供，已经发展并增强了许多特性。文章对创建和接入 ReplayKit  Extension ，系统级录制流程，以及在 LOOK 直播中的实践例子等进行了详细介绍。然而，屏幕录制开发面临着一些挑战，如内存限制、开发和调试困难、内存控制等。文章强调在开发过程中要小心应对这些问题，保持内存使用远离 50MB 的限制阈值，以及充分利用日志来解决问题，使能够优雅地完成屏幕录制功能。 </p><p><a href="https://juejin.cn/post/7264503433965518911/" title="TheRouter-iOS 轻量化路由中间件" target="_blank" rel="noopener">TheRouter-iOS 轻量化路由中间件</a></p><p><strong>摘要：</strong>  TheRouter 是一款由货拉拉打造的轻量级路由中间件，旨在支持 Android 和 iOS 平台。该中间件在 iOS 端吸取了其他语言的特性，增加了注解功能，强化了路由在 iOS 端的使用体验。 TheRouter 摒弃了传统 iOS 的 target-action 或 protocol 理念，对齐了更广泛的后台或 Android 应用。主要功能包括依赖注入、硬编码消除、动态化能力和页面导航跳转能力。文章详细解释了 TheRouter 的实现原理，如注解式依赖注入，路径硬编码处理等，并提供了详细的使用介绍和示例。</p><p><a href="https://juejin.cn/post/7116301510887079967/" title="iOS App Store 上架被拒 case" target="_blank" rel="noopener">iOS App Store 上架被拒 case</a></p><p><strong>摘要：</strong> 这篇文章主要记录了 App Store 上架过程中遇到的一些被拒绝的案例，以及对应的原因分析和解决策略。案例涵盖了从功能完整性、信息需要、隐私确认，到软件需求和上传被拒等不同阶段的问题。文章还详细阐述了各种问题的产生原因，如 APP 功能不全、集成未使用的库、隐私信息填写不全等，并提出相应的解决方案。通过这些案例的分享，开发者可以理解和学习如何避免类似的错误，更顺利地完成 App Store 的上架过程。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>报道称曾红极一时的少儿编程培训，如今现爆雷隐患。你认为儿童是否有必要提早接触编程课？</strong></p><ol><li>有必要：编程课可以激发儿童创造力，培养解决问题的能力。</li><li>没必要：缺乏基础和成熟度，编程需要数学和逻辑思维能力，导致理解困难和挫败感。</li><li>因人而异：有些儿童适合提早接触，有天赋和热情，发挥潜力，其他儿童可以在稍后阶段考虑。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十五期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;是站在生命之巅，嘲笑死神的无能？还是跪在生活边缘，寻求生存的可能？&lt;strong&gt;Swift社区&lt;/strong&gt;始于渺小，行至辽阔！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：五天市值蒸发 2000 亿美元，苹果公司怎么了？&lt;/p&gt;
&lt;p&gt;提案：具有编码验证的 &lt;code&gt;String Initializers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swift 论坛：Swift 分布式追踪&lt;/p&gt;
&lt;p&gt;推荐博文：iOS ReplayKit 与 屏幕录制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十四期/</id>
    <published>2024-03-06T07:56:27.000Z</published>
    <updated>2024-03-06T08:01:44.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十四期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>恰似烈日灼身，清风缕缕慰我清静。恰似无边心海，<strong>Swift社区</strong>渡我心安！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄</p><p>提案：允许在非泛型上下文中嵌套协议</p><p>Swift 论坛：提议 DocC 中的数学排版</p><p>推荐博文：Swift HTTP Types 的介绍</p><p><strong>话题讨论：</strong> </p><p>苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/9206a50e-e85e-4b70-bcff-5396ed536173.jpg" alt=""></p><p>这只是一个简单的投票结果，虽然不能完全反映实际的社会情况，但是也能帮助大家了解目前的生活状态（仅作参考）。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="iPhone-Pro-要提价！新款-iPhone-或会使用-USB-C-充电器，边框更薄"><a href="#iPhone-Pro-要提价！新款-iPhone-或会使用-USB-C-充电器，边框更薄" class="headerlink" title="iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄"></a>iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄</h3><p>据彭博社当地时间 7 月 24 日报道，苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格。</p><p>苹果公司通常在 9 月份发布新款 iPhone 。自 2019 年以来，苹果公司一直在销售高端的 iPhone Pro ，其起售价在美国为 999 美元，而屏幕更大的 Max 型号至少为 1099 美元。据报道，苹果公司最新的高端型号可能会涨价，这将通过提高新 iPhone 的平均售价来增加苹果公司的总收入。</p><p><img src="https://pics0.baidu.com/feed/34fae6cd7b899e51482ccff515245e3fca950dc4.jpeg@f_auto?token=8eb543197d27f0d69f5479a7a2299a2b" alt="图片来源：苹果官网"></p><p>在疫情期间，苹果公司没有提高美国新款 iPhone 的价格，尽管该公司面临零部件短缺，并表示通货膨胀导致了一些服务（如运输和零部件）的成本上升。</p><p>然而，苹果公司经常根据汇率波动调整其在全球各地的产品价格，包括去年推出的 iPhone 14 设备。</p><p>苹果公司没有回应置评请求。</p><p>新款 iPhone 可能会使用 USB-C 充电器，而不是专有的 Lightning 充电器，这是去年欧洲通过新规定后的结果。据供应链分析师郭明錤称，新款 Pro 型号可能会采用钛合金外壳和更薄的边框。</p><p>价格上涨也可能有助于苹果公司利用智能手机行业近期的趋势。总体而言，智能手机出货量下降并已持续一年，但消费者仍然对最好和最贵的设备有需求，分析师们说。</p><p>“尽管全球智能手机需求复苏低于预期，但看起来高端市场（因此也是苹果）受到的影响较小。”德意志银行分析师何思迪（Sidney Ho）周一在一份报告中写道。</p><p>另据科创板日报 7 月 24 日援引外媒报道，苹果供应链消息称，2023 年 iPhone 15 零部件备货力道不及 2022 年同期，略估初步备货量仅约 8300 万 ~ 8500 万支水准，同比下降逾 8%。2022 年同期 iPhone 备货预估量约 9000 万支以上，甚至“还有喊到近 1 亿支”。</p><p>之前市场认为，手机市场已开始出现回温，但大立光董事长林恩平认为，这只是中低阶手机市场销售的略为走升，至于高阶市场的销售，客户端看法仍然相对保守，主要问题在于“卖不好”。</p><p>美国银行分析师 Wamsi Mohan 在报告中指出，iPhone 15 设备可能会推迟“几周”，部分机型或将推迟到 10 月上市，但 The Information 认为苹果仍将如期在 9 月份上市 iPhone 15 的 Pro 系列。(来源：每日经济新闻)</p><h3 id="与-App-Store-专家会面交流"><a href="#与-App-Store-专家会面交流" class="headerlink" title="与 App Store 专家会面交流"></a>与 App Store 专家会面交流</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/7ED4820B-E3B1-4F08-A0FE-1708671981CC/2048.jpeg" alt=""></p><p>加入我们，参与 8 月 1 日至 8 月 24 日的在线讲座，了解最新的 App Store 功能并获取问题的解答。我们将在多个时区以多种语言进行实时演讲和答疑。</p><p>探索 App Store 定价机制升级，包括增强的全球定价机制、用于按店面管理定价的工具，以及额外的价格点。<br>你将学习如何通过 App 分析来衡量用户获取情况，以及如何使用 App Store 的各项功能来发展你的订阅业务。<br>探索产品页优化如何助你测试产品页的不同元素，以找出哪些元素最能引起用户的共鸣。<br>了解自定产品页如何助你创建额外的产品页版本，以突出显示特定功能或内容。<br>你还能了解怎样通过 Game Center 来提高曝光度和参与度，以及 App 内活动的配置操作。</p><h3 id="让你的-App-和游戏在-visionOS-模拟器外更进一步"><a href="#让你的-App-和游戏在-visionOS-模拟器外更进一步" class="headerlink" title="让你的 App 和游戏在 visionOS 模拟器外更进一步"></a>让你的 App 和游戏在 visionOS 模拟器外更进一步</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/4CC97B65-CD76-433A-8139-18D6DD7BB227/2048.jpeg" alt=""></p><p><strong>Apple Vision Pro 兼容性评估</strong></p><p>我们可协助你确保 visionOS、iPadOS 和 iOS App 在 Vision Pro 上正常运行。而且，我们会先根据新发布的兼容性核对清单调整你的 App，然后再要求直接在 Vision Pro 上对你的 App 进行评估。</p><p><strong>Apple Vision Pro 开发者实验室</strong></p><p>体验在 Vision Pro 上运行的 visionOS、iPadOS 和 iOS App。你将能够在 Apple 的支持下测试并优化你的 App，为无边的空间画布做好准备。我们分别在库比蒂诺、伦敦、慕尼黑、上海、新加坡和东京设立了实验室。</p><p><strong>Apple Vision Pro 开发者套件</strong></p><p>如果你有任何 visionOS App 的好创意是需要在 Vision Pro 真机上构建和测试的，欢迎申请 Vision Pro 开发者套件。通过持续直接访问 Vision Pro，你将能够快速构建、测试和优化 App，在 visionOS 上提供出色的空间体验。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" title="SE-0400" target="_blank" rel="noopener">SE-0400</a> <strong>Init 访问器</strong> 提案通过审查。该提案已在 <strong>三十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md" title="SE-0401" target="_blank" rel="noopener">SE-0401</a> <strong>移除由属性包装器引起的 Actor 隔离推断</strong> 提案通过审查。该提案已在 <strong>三十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0402-extension-macros.md" title="SE-0402" target="_blank" rel="noopener">SE-0402</a> <strong>将 conformance 宏作为 extension 宏</strong> 提案通过审查。该提案已在 <strong>三十三期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0403-swiftpm-mixed-language-targets.md" title="SE-0403" target="_blank" rel="noopener">SE-0403</a> <strong>软件包管理器混合语言目标支持</strong> 提案正在审查。</p><p>改提案旨在为包含 Swift 和 C 等基于语言的混合源代码的目标添加软件包管理器支持。目前，一个目标的源代码可以是 Swift 或 C 等基于语言（根据SE-0038），但不能同时存在两者。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0404-nested-protocols.md" title="SE-0404" target="_blank" rel="noopener">SE-0404</a> <strong>允许在非泛型上下文中嵌套协议</strong> 提案正在审查。</p><p>允许在非泛型的结构体、类、枚举和 actors 中嵌套协议。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-mathematical-typesetting-in-docc/66418" title="DocC 中的数学排版" target="_blank" rel="noopener">DocC 中的数学排版</a></p><p>提出了一个新的 DocC 指令，@Math：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The sample variance of the collection.</span></span><br><span class="line"><span class="comment">/// - Returns: The sample variance:</span></span><br><span class="line"><span class="comment">/// @Math("sample-variance.xml", description: "Sum, from i = 1 to n, of the squared norm of x_i minus mu. Everything divided by n minus 1.")</span></span><br><span class="line"><span class="comment">/// where 𝑛 is the collection's `count` and ‖𝑥ᵢ - 𝜇‖ is the Euclidean distance from each element 𝑥ᵢ to the sample mean 𝜇.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sampleVariance</span> …</span></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/17787/40fb523c-b052-4582-90e1-abd730fa72fb.png" alt=""></p><p><strong>动机</strong></p><p>文档页面通常需要包含数学表达式。例如，Apple 的 Accelerate 1 文档页面（使用 DocC 制作）通过方程式和矩阵来丰富文档的内容，以帮助阐明文档的文本内容。</p><p>虽然已经可以将数学表达式添加到 DocC 文档中，但所有现有的方法都还不够完善。</p><ul><li><p>对于只包含单行的表达式，使用 Unicode 数学符号通常就足够了，比如 <code>‖𝑥ᵢ - 𝜇‖²</code>。但是对于包含多行的表达式，使用 Unicode 数学符号往往不够美观或不易阅读。例如，对于上面所示的 TL;DR 表达式，能做到的最好效果是 <code>¹⁄₍ₙ₋₁₎ ∑ᵢ₌₁ⁿ ‖𝑥ᵢ - 𝜇‖²</code>。而且，很多时候，多行表达式在 Unicode 数学符号中根本无法表示。例如，Unicode 中没有上标希腊字母。矩阵也是无法表示的。</p></li><li><p>可以将排版好的数学表达式（例如 <code>LaTeX</code> 的 .tex 文件或 MathML 的 .xml 文件）编译为图像（比如 .png 或 .svg 格式）。这需要保持 2 - 3 个文件同步：浅色模式下的图像、深色模式下的图像，以及可选的（但最好有的）源文件。这就是 Accelerate 文档所采用的方法（不包含深色模式支持）。</p></li><li><p>也可以使用链接中提到的第六种方法，这是我个人比较喜欢的方式，但它也有自己的缺点（在链接的帖子中有详细介绍）。</p></li></ul><p>因此，为 DocC 提供对数学排版的一流支持将是一个受欢迎的补充。有许多不同的方法可以实现这一点，所以我在此发布帖子是为了让我们讨论潜在的解决方案。我将包含我个人的首选方案，以及一些替代方法。</p><p><strong>建议的解决方案</strong></p><p>保持简单：采用 MathML 编写，输出 MathML。DocC 输出的是网页；我认为我们应该充分利用这一事实，并在可能的情况下坚持使用 Web 标准。与 LaTeX 相比，MathML 的语法更加繁琐，但这个解决方案具有以下优势：</p><ul><li>不添加任何依赖，比如 MathJax 或 KaTeX。</li><li>避免了在运行时将 LaTeX 编译为 SVG（或将 LaTeX 编译为 MathML，或将 MathML 编译为 SVG）的性能问题。对于前两种情况（LaTeX 转 SVG 和 LaTeX 转 MathML），MathJax 是臭名昭著的，因为它可能导致屏幕上有许多方程式时的滞后。</li><li>无需额外工作即可适应明暗模式，因为 MathML 元素使用当前的字体颜色。可以试一下：检查 DocC 网页，添加一个带有一些 MathML 的 <code>&lt;math&gt;</code> 标签，然后在明暗模式之间切换。</li><li>是最容易实现和维护的。在验证源 MathML 有效性后，DocC 只需将其未经修改地粘贴到网页中。</li></ul><p>另外，无论输入是 MathML 还是 LaTeX，只要输出是 MathML（而不是 SVG 等其他格式），都将具有很好的可访问性，因为用户可以通过屏幕阅读器浏览 <math> 方程式。这比仅提供 alt 文本要好，因为在 DocC 支持数学排版之前，这是我们能做的最好的方式。 （话虽如此，MathJax 对于屏幕阅读器的支持也非常出色。）</math></p><p>作为未来的方向，我们可以考虑支持 LaTeX 作为源语言。如果我们这样做，我认为我们应该将 .tex 文件编译为 MathML（而不是 SVG、PNG 等）以保持一致性和最佳可访问性。另外，我们应该在编译文档时将源 LaTeX 编译为 MathML（即不通过 MathJax 或 KaTeX 在运行时进行编译），以获得更轻的文档网页并避免性能问题。</p><p>2) 讨论<a href="https://forums.swift.org/t/cannot-find-type-bar-in-scope-in-extension/66394" title="在扩展范围内找不到类型 Bar" target="_blank" rel="noopener">在扩展范围内找不到类型 Bar</a></p><p>给定以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面这个看似无害的扩展中，会产生错误：Cannot find type ‘Bar’ in scope</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123; <span class="comment">// Error: Cannot find type 'Bar' in scope</span></span><br><span class="line">        <span class="type">Bar</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，使用 typealias 可以解决这个问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Bar</span> = <span class="type">Foo</span>.<span class="type">Bar</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123; <span class="comment">// Okay</span></span><br><span class="line">        <span class="type">Bar</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不出来。有谁能解释这个错误的原因吗？</p><p>这两者不是等价的吗？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123;</span><br><span class="line">            <span class="type">Bar</span> ()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123;</span><br><span class="line">        <span class="type">Bar</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答：</strong></p><p>值得注意的是，在扩展中，令人惊讶的是，Self 解析为 Bar：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> </span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Self</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 讨论<a href="https://forums.swift.org/t/dealing-with-non-deterministic-task-execution-order/66411" title="处理非确定性任务执行顺序" target="_blank" rel="noopener">处理非确定性任务执行顺序</a></p><p>首先，想说明这个问题的范围超出了 TCA 本身，但我很好奇 TCA 是否能提供解决方案。</p><p>假设我们希望在 Main Actor 之外向数据库写入数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">Database</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> value: Int)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"insert <span class="subst">\(value)</span>"</span>) &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">(<span class="number">_</span> value: Int)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"delete <span class="subst">\(value)</span>"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们有一个 Reducer，例如，从 UI 接收输入。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppReducer</span>: <span class="title">ReducerProtocol</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span>: <span class="title">Equatable</span> </span>&#123; … &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> insert(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> delete(<span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @<span class="type">Dependency</span>(\.database) <span class="keyword">var</span> database</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">ReducerProtocol</span>&lt;<span class="type">State</span>, <span class="type">Action</span>&gt; &#123;</span><br><span class="line">    <span class="type">Reduce</span> &#123; state, action <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">switch</span> action &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">let</span> .insert(value):</span><br><span class="line">        <span class="keyword">return</span> .run &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">          await database.insert(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">let</span> .delete(value):</span><br><span class="line">        <span class="keyword">return</span> .run &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">          await database.delete(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Reducer 按照特定的顺序接收操作，由于 Actor 的重入性，数据库可能不会按照相应的顺序被调用。例如，如果 Reducer 接收以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viewStore.send(.insert(<span class="number">0</span>))</span><br><span class="line">viewStore.send(.delete(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>由于 Swift Concurrency 中的每个挂起点都涉及非确定性的执行顺序，数据库可能会以错误的顺序执行，打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete 0</span><br><span class="line">insert 0</span><br></pre></td></tr></table></figure><p>在 GCD 世界中，会在串行队列上执行数据库写入操作，但是使用 Swift Concurrency 似乎没有很好的方法来模拟这种行为。因为每个挂起点都涉及非确定性的执行顺序。想知道是如何处理这个问题的。是否有根本不同的方式来思考 Swift Concurrency 中的设计模式？在其他情况下也遇到过这个问题，例如按照拍摄顺序显示照片。它适用于任何存在输入流进入异步进程并产生与输入相同顺序的输出的情况。</p><p><strong>回答：</strong></p><p>TCA 测试存储在序列化到主执行器时将表现出确定性（这是当前版本的配置选项，在即将发布的 1.0 版本中将成为默认设置）。</p><p>对于应用程序代码，如果需要在继续之前完全处理一个操作，可以使用 await：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">await viewStore.send(.insert(<span class="number">0</span>)).finish()</span><br><span class="line">viewStore.send(.delete(<span class="number">0</span>))  <span class="comment">// 在上面的操作完成之前不会执行</span></span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/i-just-want-to-write-extensions-that-i-can-make-available-wherever-i-want/66407" title="我只想编写能在任何地方使用的扩展" target="_blank" rel="noopener">我只想编写能在任何地方使用的扩展</a></p><p><strong>提问：</strong></p><p>为 String 和 Int 等类型编写和使用扩展很有趣，但是当这样做时，拉取请求没有获得批准，因为它们不符合 SOLID 原则。希望可以在协议内编写扩展，这样就可以在继承协议的任何地方使用扩展。</p><p><strong>回答：</strong></p><p>在 Swift 中，扩展遵循与任何其他类型声明相同的访问控制规则，因此，如果发现编写的扩展范围太广，可能希望利用一些工具来帮助解决这个问题。</p><p>例如，可以通过将扩展放在一个模块中，并且不将其设为 <code>public</code> 来限定其作用域，这样只有该模块中的类型才能看到并调用在该扩展中定义的方法。</p><p>或者，如果团队关心的是这些扩展是否合适，因为添加了在所有 String/Int/ 或其他类型上都不合理使用的功能，因此不应该广泛访问，那么更好的解决方案可能是引入一个新的特定于领域的类型，它包含一个 String/Int/ 或其他类型，并在其上提供特定于领域的接口。（例如，URL 类型可以被实现成包含一个 String，并提供相应工具的方式，而不是在 String 本身上提供 URL 类型的扩展）。”</p><p>5) 讨论<a href="https://forums.swift.org/t/enum-tuple-case-composing-decomposing-disparity/66406/1" title="Enum Tuple case 组合/分解差异" target="_blank" rel="noopener">Enum Tuple case 组合/分解差异</a></p><p>在这个例子中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Tuple</span> = (first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TupleEnum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> tuple(<span class="type">Tuple</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(value: TupleEnum)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> value &#123;</span><br><span class="line">    <span class="comment">// case let .tuple(t: Tuple): break // 很明显</span></span><br><span class="line">    <span class="comment">// case let .tuple((first, second)): break // 很明显</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .tuple(first, second): <span class="keyword">break</span> <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TupleEnum</span>.tuple(first: <span class="number">0</span>, second: <span class="number">0</span>) <span class="comment">// 🛑 枚举 case 'tuple' 需要一个类型为 'Tuple' (也就是 '(first: Int, second: Int)') 的单一参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用两个单独的变量匹配一个接受元组的枚举 case，但不能反过来做：用两个单独的变量构造该 case。</p><p>同样在这个例子中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Tuple</span> = (first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PairEnum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> pair(first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(e: PairEnum)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="comment">// case let .pair(first, second): break // 很明显</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .pair(v: <span class="type">Tuple</span>): <span class="keyword">break</span> <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tuple = <span class="type">Tuple</span>(first: <span class="number">0</span>, second: <span class="number">0</span>)</span><br><span class="line">    <span class="type">PairEnum</span>.pair(tuple) <span class="comment">// 🛑 枚举 case 'two' 需要2个单独的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用元组匹配接受两个单独变量的枚举 case，但不能反过来：用元组构造该 case。</p><p>是否可以以某种方式修复这个问题，使组合和分解行为保持一致？</p><p><strong>回答：</strong></p><p>更有趣的是，通过传递到泛型上下文，可以这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PairEnum</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> pair(first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;T, U&gt;<span class="params">(<span class="number">_</span> f: <span class="params">(T)</span></span></span>-&gt;<span class="type">U</span>, <span class="number">_</span> x: <span class="type">T</span>) -&gt; <span class="type">U</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tuple = (first: <span class="number">0</span>, second: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> result = apply(<span class="type">PairEnum</span>.pair, tuple)    <span class="comment">// 这是有效的！</span></span><br></pre></td></tr></table></figure><p>…只是不能直接这样做，因为存在 SE-0029。</p><p>6) 讨论<a href="https://forums.swift.org/t/why-does-casting-type-metadata-to-anyobject-later-result-in-destroy-value-being-called-on-the-anyobject/66371" title="为什么将类型元数据转换为 AnyObject 后，最后会调用 destroy_value 以销毁 AnyObject？" target="_blank" rel="noopener">为什么将类型元数据转换为 AnyObject 后，最后会调用 destroy_value 以销毁 AnyObject？</a></p><blockquote><p>此帖子可能看起来有点抽象和学术，但它源自一个真实的问题！</p></blockquote><p>给定以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="number">_</span> = <span class="type">A</span>.<span class="keyword">self</span> <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器为函数 b 生成以下原始 SIL 代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">0</span> = metatype $@thick <span class="type">A</span>.<span class="type">Type</span>                    <span class="comment">// user: %1</span></span><br><span class="line">%<span class="number">1</span> = thick_to_objc_metatype %<span class="number">0</span> : $@thick <span class="type">A</span>.<span class="type">Type</span> to $<span class="meta">@objc</span>_metatype <span class="type">A</span>.<span class="type">Type</span> <span class="comment">// user: %2</span></span><br><span class="line">%<span class="number">2</span> = objc_metatype_to_object %<span class="number">1</span> : $<span class="meta">@objc</span>_metatype <span class="type">A</span>.<span class="type">Type</span> to $<span class="type">AnyObject</span> <span class="comment">// user: %3</span></span><br><span class="line">destroy_value %<span class="number">2</span> : $<span class="type">AnyObject</span>                   <span class="comment">// id: %3</span></span><br><span class="line">%<span class="number">4</span> = tuple ()                                   <span class="comment">// user: %5</span></span><br><span class="line"><span class="keyword">return</span> %<span class="number">4</span> : $()                                 <span class="comment">// id: %5</span></span><br></pre></td></tr></table></figure><p>为什么在函数的末尾有一个 <code>destroy_value</code>？据我所见，没有平衡的“retain”存在吗？</p><p><strong>回答：</strong></p><ol><li><code>AnyObject</code> 值默认始终被视为已保留，因此编译器必须释放它。</li><li>当将一个类转换为 <code>AnyObject</code> 时，编译器可以选择保留它，但它选择不这样做，因为它知道类是永久存在的，因此可以通过不执行此操作来节省代码大小和运行时间。</li></ol><p>这两个局部推理的结果导致了遇到的问题。如果释放操作与创建 <code>AnyObject</code> 值的地方足够远（例如，可能将一个类分配给全局变量，然后稍后将其他内容分配给它），对（1）进行更智能的处理是不可能的。因此，唯一100％正确的选择是在（2）方面更加保守，从而为这种罕见的使用情况提供好处，但同时为其他所有人带来不必要的操作成本。</p><p>7) 讨论<a href="https://forums.swift.org/t/why-this-pattern/66392" title="为什么会有这种设计模式？" target="_blank" rel="noopener">为什么会有这种设计模式？</a></p><p>这与一般编程以及 Swift 本身都有关。</p><p>从 UIKit 中，我们得到了以下函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> touches: Set&lt;UITouch&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    with event: UIEvent?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>如果没有事件对象，这个函数几乎没有意义。文档并没有提到会收到空事件。那么为什么事件是一个可选类型呢？</p><p><strong>回答：</strong></p><p>我不认为 UIKit 会用空事件调用 <code>touchesBegan()</code>，但这是一个需要重写方法并手动转发事件的 API，如果您没有处理事件，则需要手动转发，但该转发可能无法正确转发事件。不幸的是，最初允许转发空事件，而在事后将其更改为非可选类型是困难的。</p><p>如果同样的 API 是在今天使用 Swift 设计的，我怀疑事件参数将不会是可选的。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.avanderlee.com/swift/backdeployed-function-back-deployment/" title=" @backDeployed 用于将函数的可用性扩展到旧版本的操作系统" target="_blank" rel="noopener"> @backDeployed 用于将函数的可用性扩展到旧版本的操作系统</a></p><p><strong>摘要：</strong> 文章主要介绍了 @backDeployed 属性以及如何将函数的可用性扩展到旧的操作系统版本。 @backDeployed 属性是 Swift 5.8 首次实现的一项功能，并且在较低的最小部署目标和框架对比下，允许将新的声明提供给应用程序。文章详细解释了 @backDeployed 如何工作，并通过一个假设的 “Temperature” 类型的例子进行了演示。 @backDeployed 属性允许将函数回溯部署并使其对运行在旧版操作系统的应用程序可用。文章还指出，功能回溯部署主要对 SDK 开发者有用，同时也解释了为什么苹果不能将所有新的API回溯部署到旧的 OS 版本。使用 @backDeployed 属性进行函数回溯部署对于 SDK 开发者来说是一个很好的工具，能够使其 API 支持更有老旧的操作系统版本。虽然这不能解决所有新 API 的回溯部署问题，但它已经允许你使用一些新的、独立的 Swift API 。 </p><p><a href="https://www.swift.org/blog/introducing-swift-http-types/" title="Swift HTTP Types 的介绍" target="_blank" rel="noopener">Swift HTTP Types 的介绍</a></p><p><strong>摘要：</strong>  这篇 Swift 官方博客介绍了一个名为 “Swift HTTP Types” 的新的开源软件包。该软件包旨在为 Swift 中的客户端/服务器 HTTP 操作提供共享的通用类型。<br>文章指出，网络化应用中的网络技术对于许多用例来说在 Swift 中是无处不在的，包括客户端、服务器、中介和其他网络参与者。在苹果平台上，系统的 HTTP 实现通过 Foundation 框架中的 URLSession API 进行暴露。而对于 Swift 服务器项目，推荐使用 SwiftNIO 实现 HTTP。<br>为了在 Swift 中提供最佳的 HTTP 使用体验，共享的通用类型在许多项目中至关重要。 Swift HTTP Types 提供了一种表示 HTTP 消息核心构建块的通用表现形式。它包括 HTTPRequest 和 HTTPResponse ，分别代表客户端和服务器使用的 HTTP 消息。通过在多个项目中采用这些类型，可以在不同框架之间共享更多的代码，并消除在使用多个框架时的类型转换成本。</p><p><a href="https://juejin.cn/post/7260523399252475961?searchId=202307281123557A68223DBAE2C4960FFC/" title="Qunar 客户端 iOS 实时活动接入实践" target="_blank" rel="noopener">Qunar 客户端 iOS 实时活动接入实践</a></p><p><strong>摘要：</strong> 这篇文章介绍了去哪儿（Qunar）客户端如何实时接入了苹果在 iOS16 上推出的实时活动 (Live Activities) 功能。该功能允许应用在用户锁屏界面上展示实时信息，与常规推送相比，实时活动可以在一定时间段内持续展示，并于合适的时机自行消失，为用户提供更优秘体验。<br>通过实时活动功能，去哪儿的用户可以在出行全周期内，通过锁屏或灵动岛看到最新实时的出行信息。根据 Qunar 的数据，该功能自上线以来影响力显著，其中50%的用户已经与此功能互动，超过80%的用户因此而享受到更便捷的出行信息展示。目前，实时活动主要覆盖了航班和火车的出行场景，未来还可能延伸至船票、汽车票、景点门票等业务线场景，为 Qunar 的产品生态带来更大的贡献。<br>作者还详细介绍了实时活动的原理和机制，包括如何在主 APP 端启动一个实时活动实例，如何利用推送服务进行数据更新，如何关闭或更新实时活动等，并分享了在接入过程中遇到的问题及解决思路，希望帮助读者更好地理解和接入实时活动功能。。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？</strong></p><ol><li>必须买，因为贵不是它的缺点，也不是我的缺点。</li><li>超过一万元的话，那我现在的 iphone 还是可以将就用的。</li><li>我有钱但不代表我傻，手里的钱买两斤排骨它不香吗？</li><li>不买，当它超过一万快的时候，我的爱国情怀已悄然攀升。</li><li>别说一万块钱啦，就是降价到五千，我也不买。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十四期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;恰似烈日灼身，清风缕缕慰我清静。恰似无边心海，&lt;strong&gt;Swift社区&lt;/strong&gt;渡我心安！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄&lt;/p&gt;
&lt;p&gt;提案：允许在非泛型上下文中嵌套协议&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议 DocC 中的数学排版&lt;/p&gt;
&lt;p&gt;推荐博文：Swift HTTP Types 的介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十三期/</id>
    <published>2024-03-06T07:56:00.000Z</published>
    <updated>2024-03-06T08:01:11.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十四期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>看那碧水蓝天，波澜又壮阔。浅读<strong>Swift社区</strong>，充实而豁然。期许光亮，皆在其中！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：App 内购买项目和订阅即将实行价格与税率调整</p><p>提案：将 conformance 宏作为 extension 宏</p><p>Swift 论坛：讨论 <code>\</code> 和 <code>$</code> 的意义</p><p>推荐博文：轻量化的 iOS 动画框架实现</p><p><strong>话题讨论：</strong> </p><p>最新薪酬排行出炉，广州平均月薪 10883 元，北京平均月薪 13438 元，你的月薪处于什么水平？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/6efb3a39-c887-439f-a0a6-909472e4961b.jpg" alt=""></p><p>这个结果表明大多数人对 vision pro 在推动虚拟现实技术发展方面持乐观态度。Vision pro 具备强大的图像处理和感知能力，可以为虚拟现实应用提供更加逼真、沉浸式的体验。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="App-内购买项目和订阅即将实行价格与税率调整"><a href="#App-内购买项目和订阅即将实行价格与税率调整" class="headerlink" title="App 内购买项目和订阅即将实行价格与税率调整"></a>App 内购买项目和订阅即将实行价格与税率调整</h3><p>App Store 的交易和支付机制旨在帮助你在覆盖全球的 175 个国家和地区的店面中，以 44 种货币为你的产品和服务便捷地进行定价与销售。当税务法规或外汇汇率变化时，App Store 中某些地区的价格有时会随之更新，且你的收入亦将调整。这些调整将根据金融数据机构提供的公开汇率信息进行，以此确保 App 和 App 内购买项目的定价在所有店面中保持平衡。</p><p>从 7 月 25 日起，App 和 App 购买项目 (不包括自动续期订阅) 在埃及、尼日利亚、坦桑尼亚和土耳其店面中的定价将会进行调整。这些调整还包含了以下税率变更：</p><p>埃及：收取 14% 的增值税 (VAT)<br>坦桑尼亚：收取 18% 的增值税和 2% 的数字服务税<br>土耳其：增值税率从 18% 上调至 20%<br>这些调整对定价的影响<br>如果你选择了埃及、尼日利亚、坦桑尼亚或土耳其作为 App 或 App 内购买项目 (不包括自动续期订阅) 的基准店面，则对应店面中的价格不会发生变化。其他店面中的价格将会进行更新，以便与你选择的基准价格保持持平。<br>如果你为 App 或 App 内购买项目 (不包括自动续期订阅) 选择的基准店面不是埃及、尼日利亚、坦桑尼亚或土耳其，则埃及、尼日利亚、坦桑尼亚和土耳其店面中的价格将会上调。<br>如果你的 App 内购买项目是自动续期订阅，或者如果你手动管理各个店面的价格，而不是使用自动均衡价格，那么你的价格不会发生变化。<br>App Store Connect 中“我的 App”的“价格与销售范围”部分现已更新，以显示这些即将进行的价格调整。一如既往，你可以随时更改你的 App、App 内购买项目和自动续期订阅的价格。</p><p>这些调整对收益和税务管理的影响<br>你从 App 和 App 内购买项目 (包括自动续期订阅) 销售中获得的收益将会发生变化，以反映新的税率和更新后的价格。《付费 App 协议》的附录 B 已更新，表明 Apple 在埃及和坦桑尼亚征收和汇付适用税款。</p><h3 id="为家庭提供安全的-App-体验"><a href="#为家庭提供安全的-App-体验" class="headerlink" title="为家庭提供安全的 App 体验"></a>为家庭提供安全的 App 体验</h3><p>App Store 的创建目的是为用户提供一个安全且值得信赖的 App 下载平台，并为开发者提供绝佳的商机。由于孩子们会使用我们的产品和服务，来探索数字世界并与家人和朋友进行交流，因此对许多家庭而言，Apple 平台和你构建的 App 变得非常重要。针对面向儿童的 App，以及那些具有用户生成内容和互动的 App，我们设立了极高的标准。为了继续为家庭打造安全的体验，谨在此提醒你，我们提供了各种工具和资源，并制定了相关要求，以帮助你保障用户在 App 中的安全。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>将 conformance 宏作为 extension 宏</strong> 提案正在审查。</p><p>该提案将 <code>conformance</code> 宏角色推广为 <code>extension</code> 宏角色，除了协议和 where 子句外，还可以向扩展中添加成员列表。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/are-these-typos/66118" title="这些是错别字吗？" target="_blank" rel="noopener">这些是错别字吗？</a></p><p>提问：</p><p>在观看 SwifUIi 视频时，看到两处看起来像是拼写错误的东西。想知道为什么它们的表达如此含糊：</p><p>反斜杠有什么用？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">List</span> (graphics, children: \.children) &#123; graphic <span class="keyword">in</span></span><br><span class="line">        <span class="type">GraphicRow</span> (graphic)</span><br><span class="line">    &#125;</span><br><span class="line">    .listStyle(<span class="type">SidebarListStyle</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>美元符号有什么用？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">DocumentGroup</span> (newDocument: <span class="type">SketchDocument</span>()) &#123; file <span class="keyword">in</span></span><br><span class="line">        <span class="type">DocumentView</span>(file.$document)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>这些不是拼写错误。它们是用于访问特定语言功能的符号，这些功能会生成与命名属性相关的内容，而不是正常访问该属性。</p><p>Swift 在前缀运算符位置中使用 \ 来创建“关键路径”，该对象通常表示（在本例中）<code>Graphic.children</code> 属性，而不是特定 <code>Graphic</code> 的 <code>Children</code>属性；该对象可以应用于 Graphic 的任何实例以访问其 Children 属性。</p><p>在其他语言中，\ 字符在字符串文字中很常见，它开始一个“转义序列”，但它很少用作运算符，并且使用它的语言之间几乎没有一致性。</p><p>这里与“转义”的想法有某种模糊的联系，因为在这两种情况下，你都在逐步提升到更抽象的含义水平，但在大多数情况下，它被选择是因为它是一个未使用的符号，通常是 易于打字并且看起来不错。 该功能的演变提案实际上讨论了几种不同的语法，<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0161-key-paths.md#spelling" title="并解释了为什么选择反斜杠" target="_blank" rel="noopener">并解释了为什么选择反斜杠</a>。</p><p>$ 前缀意味着您正在访问相关属性的属性包装器提供的特殊功能。在这里，该属性是 <code>FileDocumentConfiguration.document</code>，<a href="https://developer.apple.com/documentation/swiftui/filedocumentconfiguration/document" target="_blank" rel="noopener">根据文档</a>有一个 <code>@Binding</code> 属性包装器。 这意味着 $document 将公开一个到文档的 Binding - 一个可用于访问和修改该文档属性的对象，而无需关心它实际存储的位置。</p><p>我们将此 $ 变量称为“投影值”而不是“绑定值”或其他任何名称，因为 $ 语法是通用语言功能，因此如果您使用 @Binding 以外的其他内容，$ 属性可能不会创建绑定；可能被赋予一些其他功能。</p><p>选择这两种语法并不是因为它们会立即熟悉，而是因为我们确定没有一种语法可以立即熟悉，最好选择开发人员需要学习但一旦学习后会发现易于使用的语法。</p><p>2) 讨论<a href="https://forums.swift.org/t/nslock-lock-plus-await-plus-nslock-unlock-leads-to-main-thread-freeze/66113" title="NSLock.Lock 加 Await 加 NSLock.Unlock 导致主线程冻结" target="_blank" rel="noopener">NSLock.Lock 加 Await 加 NSLock.Unlock 导致主线程冻结</a></p><p>提问：</p><p>以下代码模拟了当外部库的作者引入锁时的情况，这可能包含等待调用。 </p><p>有什么办法可以防止这种情况</p><p>noasync 注释不是解决方案，因为：</p><p>1）如果函数包装在另一个没有 noasync 注释的函数中，它不起作用；<br>2）第三方库的作者可能会忘记添加这样的注释。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">thirdPartyLibLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"- do sum work and lock"</span>)</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     I also tried to replace it with:</span></span><br><span class="line"><span class="comment">         await withCheckedContinuation(&#123; c in</span></span><br><span class="line"><span class="comment">             lock.lock()</span></span><br><span class="line"><span class="comment">             c.resume()</span></span><br><span class="line"><span class="comment">         &#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">thirdPartyLibUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"- do sum work and unlock"</span>)</span><br><span class="line">    lock.unlock()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     I also tried to replace it with:</span></span><br><span class="line"><span class="comment">         await withCheckedContinuation(&#123; c in</span></span><br><span class="line"><span class="comment">             lock.unlock()</span></span><br><span class="line"><span class="comment">             c.resume()</span></span><br><span class="line"><span class="comment">         &#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Console:</span></span><br><span class="line"><span class="comment">     - start 4</span></span><br><span class="line"><span class="comment">     - do sum work and lock</span></span><br><span class="line"><span class="comment">     - start 1</span></span><br><span class="line"><span class="comment">     - do sum work and lock</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     And that's all. We have suspended main thread.</span></span><br><span class="line"><span class="comment">     Numbers 4 and 1 could differ between app launches, it's ok.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">1000</span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- start <span class="subst">\(i)</span>"</span>)</span><br><span class="line"></span><br><span class="line">            thirdPartyLibLock()</span><br><span class="line">            <span class="keyword">try</span> await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line">            thirdPartyLibUnlock()</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- end <span class="subst">\(i)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Won't be executed.</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">3</span>, execute: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"- ping"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>由于多种原因，锁定+解锁 API 对在设计上是不安全的，这就是其中之一。 更好的设计是使用一个函数来获取锁，调用回调，然后在回调返回后释放锁。</p><p>（理想情况下，该函数还可以提供对受锁保护的资源的回调访问，否则将无法访问。）只需使整个过程同步，就可以非常巧妙地表达在锁定和解锁之间不挂起的要求。</p><p>3) 讨论<a href="https://forums.swift.org/t/desired-swift-language-features-that-can-advance-the-state-of-c-interoperability-support/66144" title="所需的 Swift 语言功能可以提升 C++ 互操作性支持的状态" target="_blank" rel="noopener">所需的 Swift 语言功能可以提升 C++ 互操作性支持的状态</a></p><p>内容：</p><p>Swift 5.9 可以在 Swift 中导入和使用多种 C++ 类型。 但是，并非所有类型类别都受支持。这篇文章列出了一组所需的 Swift 语言功能，这些功能使我们能够支持 Swift 中的大多数 C++ 类型：</p><p>对不可复制类型的泛型支持。 虽然 Swift 5.9 添加了对不可复制结构和枚举的支持，但这些类型仍然不允许用作泛型类型参数。 </p><p>这是阻止我们在 Swift 中完全完成对仅移动 C++ 类型的支持的一个关键问题，因为我们需要形成像 UnsafePointer<moveonlycxxtype> 这样没有语言限制的类型。</moveonlycxxtype></p><p>添加到上面的一点，像 UnsafePointer 和 UnsafeMutablePointer 这样的类型应该提供对借用和可变借用不可复制指针对象的支持。</p><p>不可移动/不可逃避的 Swift 类型类别。 不可转义和不可复制的 Swift 类型将允许我们在 Swift 中导入和建模不可复制和不可移动的 C++ 类型。</p><p>此外，以下语言功能将有助于改善 Swift 中对 C++ 类型执行的一些常见操作的人体工程学：</p><p>能够在 Swift 序列上执行借用 for 循环，这确实需要经过 IteratorProtocol，但可以使用索引迭代。 这将使我们能够自动在 std::map 等非随机访问集合上使用 for 循环。</p><p>回答：</p><p>这些听起来与我们计划完善不可复制类型支持的项目一致，这很好。 在此列表中包含内部导入以及支持导入 C 和 C++ 类型而不间接公开其 ABI 是否也有意义，以便允许包在内部使用 C++ 互操作而不要求依赖项了解它？</p><p>4) 讨论将协议添加到同名模块<br>提问：</p><p>我有一个名为 HTML 的模块，其中包含同名的类型 HTML。 它的树看起来像这样：</p><ul><li>HTML（模块）</li><li>HTML（结构）</li><li>HTML.属性（枚举）</li><li>HTML.ContainerElement（枚举）</li><li>HTML.VoidElement（枚举）</li></ul><p>到目前为止，一切都很好。 不可能限定对该模块中的声明的引用，因为它是同名的，但这没关系，因为 HTML 类型本身在功能上是命名空间限定符。</p><p>现在想向这个模块添加一个协议，称之为 <code>HTMLOutputStreamable</code>。但是不能向未命名为 HTML 的 HTML 模块添加顶级类型，因为该模块是同名的，并且无法使用 <code>HTML.HTMLOutputStreamable</code> 来限定对此协议的引用。</p><p><strong>该如何解决这个问题？</strong></p><p>回答：</p><p>我发现的唯一方法就是使用不同的名称。</p><p>从这个角度来看，Swift 仍然缺少完整的命名空间功能。 可以是模块级命名空间，但更完整和可靠。 我更喜欢像 C++ 那样的命名空间，或者像 Rust 那样的显式模块定义，但这似乎不是 Swift 进化愿景的一部分。</p><p>5) 讨论<a href="https" title="嵌套函数和 @ViewBuilder：奇怪的编译器错误">嵌套函数和 <code>@ViewBuilder</code>：奇怪的编译器错误</a></p><p>以下代码给出了一个奇怪的编译器错误，该错误似乎不相关：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">world</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">            <span class="string">"world"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello, <span class="subst">\(world()</span>)!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误信息是：</p><p>包含声明的闭包不能与结果生成器 “ViewBuilder” 一起使用</p><p>有趣的是，如果我在 world() 中添加 return （即 return “world”），编译器会在其他地方显示错误并添加警告，两者也不是很相关。 这看起来更像是一个编译器错误。</p><p>有什么想法吗？</p><p>回答：</p><p>从历史上看，结果构建器对其内部运行的语法有一些限制。 其中许多限制在 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0373-vars-without-limits-in-result-builders.md" target="_blank" rel="noopener">SE-0373</a>：解除结果构建器中变量的所有限制中被删除，但如果仍然存在一些限制，我不会感到惊讶。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7252586606091419708/" title="轻量化的 iOS 动画框架实现" target="_blank" rel="noopener">轻量化的 iOS 动画框架实现</a></p><p><strong>摘要：</strong> 在这篇博客中，介绍了日常开发中对视图进行动画处理的常见问题，并提供了一种解决方案。文章首先展示了普通的动画代码，并指出了其回调函数回溯的问题。接着介绍了一些流行的动画库，如 Spring ， Hero 和 TweenKit ，但它们都存在一些限制。为了解决这些问题，引入了一种简洁、易于使用和维护的动画执行方式。该方案基于 Animator 和 Animation 的封装实现，其中 Animator 定义了动画执行器的基本协议，并封装了几种不同类型的动画执行器。 Animation 定义了动画执行的参数，并为不同的 Animato r制定了不同的协议。此外，文章还介绍了类型擦除的概念，以解决参数类型不一致的问题。具体实现方面，通过扩展UIView添加了串行和并行动画的方法。最后，总结了该方案的优点和可能的改进点。 </p><p><a href="https://www.polpiella.dev/load-custom-fonts-with-no-code-using-swift-package-plugins/" title="使用 Swift Package 插件将自定义字体加载到您的应用程序中" target="_blank" rel="noopener">使用 Swift Package 插件将自定义字体加载到您的应用程序中</a></p><p><strong>摘要：</strong>  本文介绍了如何使用 Swift Package 插件将自定义字体加载到应用程序中。通过创建一个 Swift Package 来包含共享的字体文件和字体加载代码，可以加快新应用的发布速度，减少代码重复，并提供一个统一更新字体文件的地方。结合 Swift Package 的可重用性和 Swift Package 插件的强大功能，甚至可以在构建时从字体文件自动生成所有必要的代码。本文使用 SwiftGen 来演示如何实现这一点。首先创建一个名为 “Fonts” 的 Swift Package ，并在其中添加自定义字体资源。然后添加 SwiftGen 插件来生成加载字体所需的代码。最后，可以使用生成的代码来在 SwiftUI 和 UIKit 中使用自定义字体。</p><p><a href="https://swiftwithmajid.com/2023/07/04/mastering-swift-foundation-formatter-api-custom-format-styles/" title="掌握 Swift Foundation Formatter API 。自定义格式样式" target="_blank" rel="noopener">掌握 Swift Foundation Formatter API 。自定义格式样式</a></p><p><strong>摘要：</strong> 本篇博客介绍了如何使用 Swift Foundation Formatter API 中的自定义格式样式。作者分享了自己在每个项目中都使用该 API 并构建自定义格式化逻辑的经验。博客中详细讲解了 FormatStyle 协议以及如何创建符合该协议的自定义格式样式。通过示例，展示了如何创建短数字格式样式和粗体数字格式样式，并说明了如何在自定义类型中重用这些格式样式。最后，作者还提供了一种封装格式化逻辑的方法。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>最新薪酬排行出炉，广州平均月薪 10883 元，北京平均月薪 13438 元，你的月薪处于什么水平？</strong></p><ol><li>巨富</li><li>豪</li><li>小富</li><li>小康</li><li>穷</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十四期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;看那碧水蓝天，波澜又壮阔。浅读&lt;strong&gt;Swift社区&lt;/strong&gt;，充实而豁然。期许光亮，皆在其中！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：App 内购买项目和订阅即将实行价格与税率调整&lt;/p&gt;
&lt;p&gt;提案：将 conformance 宏作为 extension 宏&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 &lt;code&gt;\&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 的意义&lt;/p&gt;
&lt;p&gt;推荐博文：轻量化的 iOS 动画框架实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;最新薪酬排行出炉，广州平均月薪 10883 元，北京平均月薪 13438 元，你的月薪处于什么水平？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十二期/</id>
    <published>2023-07-04T07:20:25.000Z</published>
    <updated>2023-07-04T07:32:29.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十三期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>骚年，努力去成为你期待已久的自己吧，就像<strong>Swift社区</strong>一样，时刻心怀梦想，不断向前！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果已提供新的设计资源</p><p>提案：本期提案没有最新内容</p><p>Swift 论坛：讨论 Non-Reentrant Actors</p><p>推荐博文：AngularGradient 在 swiftUI 中的使用</p><p><strong>话题讨论：</strong> </p><p>你认为 vision pro 是否会加速虚拟现实技术的发展？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/976e8f1f-d753-438d-8117-a58b5a020286.jpeg" alt=""></p><p>根据投票结果，小编认为企业应根据自身情况和员工需求，平衡薪资保密与透明的利弊，制定适合的薪资政策。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="现已提供新的设计资源"><a href="#现已提供新的设计资源" class="headerlink" title="现已提供新的设计资源"></a>现已提供新的设计资源</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/7DD13ED0-F50B-4568-813A-2C89D0D8DB25/2048.jpeg" alt=""></p><p>为方便开发者在 Apple 平台上构建 App，我们现在提供了全新及更新后的设计资源，让你可以更便捷、更准确地设计 App。</p><p>visionOS 设计资料库以及适用于 Figma 和 Sketch 的模板 (英文)。</p><p>适用于 Figma 和 Sketch 的 iOS 17 和 iPadOS 17 设计套件 (英文)。</p><p>适用于 Figma 和 Sketch 的 macOS Sonoma 设计套件 (英文)。</p><p>适用于 Sketch 的 watchOS 10 设计套件 (英文)。</p><p>SF Symbols 5 Beta 版，包含 700 多个新符号 (英文)。</p><p>更新后的《人机界面指南》(英文)，现提供简体中文和日文版本。</p><p>SF 脚本扩展，现已支持亚美尼亚语、格鲁吉亚语和希伯来语 (英文页面)。</p><h3 id="visionOS-SDK-现已发布"><a href="#visionOS-SDK-现已发布" class="headerlink" title="visionOS SDK 现已发布"></a>visionOS SDK 现已发布</h3><p>Apple Vision Pro 提供了一幅无边的画布，你现在就可以开始为这幅画布打造前沿的空间计算 App。下载 Xcode 15 Beta 版 2，其中包含 visionOS SDK 和 Reality Composer Pro — 这是一种新的工具，可让你轻松地预览和准备适用于 visionOS 的 3D 内容。将 visionOS 目标添加到你的现有项目中或构建一个全新的 App，然后在 Xcode 预览中迭代你的 App。你可以在全新的 visionOS 模拟器中与你的 App 互动，探索各种房间布局和光线条件，并创建测试和可视化效果。此外，我们还提供了新的文档和示例代码，帮助你完成整个开发过程。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>本期提案没有最新内容，期待下期更新～～</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/request-for-feedback-partial-consumption-of-fields-of-noncopyable-types/65884" title="使用部分不可复制类型的字段" target="_blank" rel="noopener">使用部分不可复制类型的字段</a></p><p><strong>介绍</strong></p><p>当前给定一个类似于 var 的构造（例如：var、inout），Swift 不允许部使用耗该类型的存储字段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> : ~<span class="title">Copyable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> : ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> first: <span class="type">E</span></span><br><span class="line">    <span class="keyword">var</span> second: <span class="type">Klass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="number">_</span> = s.e <span class="comment">// Error! Cannot partially consume s</span></span><br></pre></td></tr></table></figure><p><strong>不可复制类型的部分使用</strong></p><p>在设计空间中考虑以下几个不同的轴：</p><ol><li>关于带有 deinit 的类型</li><li>启用 Library Evolution 时</li><li>当 Library Evolution 被禁用时</li><li>无论哪种情况，是否应该只允许方法中的部分消耗。</li></ol><p>具有 Deinits 的类型的部分消耗</p><p>禁止使用 deinits 部分消耗不可复制类型，因为当字段被部分消耗，允许该类型被销毁</p><p>例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> : ~<span class="title">Copyable</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> : ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> first: <span class="type">E</span></span><br><span class="line">   <span class="keyword">var</span> second: <span class="type">E</span></span><br><span class="line">   <span class="keyword">deinit</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="number">_</span> = s.first <span class="comment">// s.first is destroyed here</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// s.second is destroyed here</span></span><br></pre></td></tr></table></figure><p>由于这里的 s 已被部分消耗，因此永远不会将其全部销毁，这意味着永远不会调用它自己的 deinit，这意味着不能允许发生。 </p><p><strong>请注意</strong>，即使不允许这样做，仍然允许使用方法的作者使用丢弃运算符来关闭值的 deinit，然后部分解构该值。</p><p>2) 提问<a href="https://forums.swift.org/t/can-a-group-of-weak-references-conform-to-collection/65899" title="一组弱引用可以符合Collection吗？" target="_blank" rel="noopener">一组弱引用可以符合Collection吗？</a></p><p>问题陈述：</p><p>有一个收集弱引用的类型，可以对其进行迭代并追加。 </p><p>希望它符合 RangeReplaceableCollection，但是不能做任何比 Sequence 更具体的事情。</p><p>该类型本身是一个经典的指针长度容量三元组，其中指针指向弱引用缓冲区。 一旦长度==容量，在尝试重新分配之前，会扫描缓冲区以查找可以丢弃的 nils。 仅当无法删除足够的 nil 来为新元素腾出空间时，才会执行重新分配。</p><p>使其符合 Collection 的问题是下标(<code>_:</code>)。 如果索引类型只是缓冲区中的索引，则其他线程可能会导致弱引用从下面删除，因此索引可能会变得无效，而不会对集合进行明显的更改。</p><p>可以想到两种方法来解决这个问题，但都不能令人满意。</p><p>第一个是使索引类型也持有对该对象的强引用。 但是担心当用户没有意识到他们通过索引持有强大的参考时，可能会产生问题。</p><p>第二个是使元素类型为T？ 而不是 T。这是一种误导，因为迭代器会跳过 nils，但会使下标可实现。</p><p>第三个选项是在不实际遵守协议的情况下实现许多（但不是全部）收集操作。 担心这是我必须做的，除非能证明其他两种行为之一是合理的。 </p><p>有没有一种方法可以在不改变类型语义的情况下实现协议？</p><p>回答：</p><p>不是集合似乎是所提供的数据结构的固有属性，而不是实现限制。 如果序列中的第 n 个项目可以从 x 更改为 y，因为 x（或序列中较早的某个其他对象）已被收集，则序列没有稳定的索引。</p><p>3) 提问<a href="https://forums.swift.org/t/no-such-module-uikit-in-swift-macro/65885" title="swift Macro 中没有这样的模块“UIKit”" target="_blank" rel="noopener">swift Macro 中没有这样的模块“UIKit”</a></p><p>在 swift Macro 中导入 UIKit 时，报错 No such module ‘UIKit’ 。</p><p>宏包有以下平台</p><p>平台：[.macOS(.v10_15)、.iOS(.v13)、.tvOS(.v13)、.watchOS(.v6)、.macCatalyst(.v13)]</p><p>回答：</p><p>在构建过程中，宏在编码的计算机（可能是 Mac/Windows/Linux）上运行。 它不在 iOS 上运行，因此无法访问 UIKit。</p><p>为什么在宏中需要 UIKit（而不是在声明宏的包中）？</p><p>可以尝试创建一个可以导入 UIKit 的“Mac Catalyst”宏，但即使有可能，也可能没有用</p><p>4) 提议<a href="https://forums.swift.org/t/pitch-low-level-linkage-control-attributes-used-and-section/65877" title="低级联动控制属性：@used 和@section" target="_blank" rel="noopener">低级联动控制属性：@used 和@section</a></p><p><strong>动机</strong></p><p>动机有两个目标：</p><p>提供低级构建块来构建更多高级 API，例如 “链接器集”（见下文）或自定义每种类型元数据，如 SE-0385 中所述（swift-evolution/proposals/0385-custom-reflection-metadata.md，位于 main·apple/swift-evolution·GitHub 2）。</p><p>尽管这个推介/提案实际上并没有尝试添加或设计高级 API，只是提供了一条单独解锁设计的路径。</p><p>为系统编程用例提供低级机制（这些用例是针对具体系统的定制案例），并构建一个通常可重用的高级 API 是没有意义的（项目作者可以自由地构建这样一个高级 API，例如项目的内部机制）。</p><p>“链接器集”机制是 Swift 已经在使用的一种方法：几乎任何类型的编译器发出的元数据都被放入二进制文件中专门命名的部分中，并给出固定布局的记录。 </p><p>然后，想要查找某些信息时（例如，在二进制文件中查找协议一致性），要求加载器（Darwin 上的 dyld）为我们提供每个加载的该部分的起始/结束地址。 图像，然后可以迭代这些部分中的所有记录。 </p><p>还可以从进程外部提取一些元数据，或者从二进制文件本身中挖掘它。使用现有的反射库来完成此操作，例如 <code>swift-inspect</code> 和 <code>swift-reflection-dump</code>。</p><p>在 Swift 语言中添加功能来表达该机制的第一部分：将固定布局记录放入专门命名的部分。</p><p><strong>提议</strong></p><p>其中一些已经在功能标志下实现为 main 中的下划线属性（ <code>@_section</code>、<code>@_used</code>），通过 <a href="https://github.com/apple/swift/pull/65901" target="_blank" rel="noopener">https://github.com/apple/swift/pull/65901</a> 实现。 总之：</p><p>@used 属性，通过 llvm.used 将全局变量或顶级函数标记为“不要死区”，大致相当于 C/C++ 中的 <strong>attribute</strong>((used)) 。</p><p>@section(“…”) 属性，将全局变量或顶级函数放入具有该名称的节中，大致相当于 C/C++ 中的 <strong>attribute</strong>((section(“…”))) 。</p><p>这些注释只能应用于保证最终“静态初始化”（而不是通过 init_once 运行时调用延迟初始化）的全局变量，因为否则注释没有任何意义。</p><p>这就提出了一个有趣的问题：当用于初始化全局时，哪些表达式可以保证“静态初始化”？ 建议从一组非常基本的表达式开始，并在将来对其进行改进。</p><p>强制优化管道已经使整数文字、元组和简单算术表达式进行“静态初始化”，如果存在任何具有 <code>@section</code> 属性的全局变量，可以在 SIL 管道末尾明确拒绝编译 这不是静态初始化的。 </p><p>然后，作为后续改进，应该考虑允许 POD 结构类型也在强制优化管道中处理，并允许与 <code>@section</code> 一起使用。</p><p>虽然超出了本次推介的范围，但以下是“链接器集”API 的运行时端的草图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// in Module1</span></span><br><span class="line">@used @section(<span class="string">"__DATA,mysection"</span>) <span class="keyword">private</span> <span class="keyword">let</span> my_entry: <span class="type">Int</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// in Module2</span></span><br><span class="line">@used @section(<span class="string">"__DATA,mysection"</span>) <span class="keyword">private</span> <span class="keyword">let</span> my_entry: <span class="type">Int</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> <span class="type">SwiftRuntime</span>.section(<span class="string">"__DATA,mysection"</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; <span class="comment">// this uses the loader's APIs to locate and iterate over the section</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，将其包装到基于宏的解决方案中可能是有意义的，这样就根本不会公开低级属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">LinkerSet</span>(name: <span class="string">"myLinkerSet"</span>) <span class="keyword">private</span> <span class="keyword">let</span> myEntry: <span class="type">Int</span> = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> <span class="type">SwiftRuntime</span>.linkerSet(<span class="string">"myLinkerSet"</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，在想要将元数据附加到类型的情况下（由 SE-0385 推动）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Registered</span>(name: <span class="string">"My Favorite Type"</span>) <span class="comment">// this creates a hidden global in a named section</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> regType <span class="keyword">in</span> allRegisteredTypes &#123; <span class="comment">// queries over the entries in the section</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5) 提问<a href="https://forums.swift.org/t/enable-preprocessor-flags-during-build/65892" title="在构建期间启用预处理器标志" target="_blank" rel="noopener">在构建期间启用预处理器标志</a></p><p>有一个 C++ 头文件，仅在设置了预处理器标志时才公开一个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIX_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Some_Class</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UNIX_ENABLED</span></span></span><br></pre></td></tr></table></figure><p>当调用 swift 编译器时：</p><p>swiftc MyApp.swift -cxx-互操作性模式=默认-Xcc -std=c++17 -I cxx -c -parse-as-library</p><p>并尝试在 MyApp.swift 中使用 Some_Class ，但显然找不到该类。 尝试使用 -D UNIX_ENABLED 但这没有帮助。</p><p>有什么想法可以进行此编译吗？</p><p>回答：</p><p>可以尝试将 -Xcc -D -Xcc UNIX_ENABLED 传递给 swiftc 以确保它将 -D 转发给 clang</p><p>6) 讨论<a href="https://forums.swift.org/t/non-reentrant-actors/65888" title="Non-Reentrant Actors" target="_blank" rel="noopener">Non-Reentrant Actors</a></p><p>每当编写涉及 Actor 的代码时，发现自己想要对 Actor 进行有意义的工作，但最终会在此过程中引入难以捕获的错误。 以这个简单的例子为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">HeavyLifting</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cachedResult: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doHeavyLifting</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedResult &#123; <span class="keyword">return</span> cachedResult &#125;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">try</span> await <span class="comment">// load some resource and process it.</span></span><br><span class="line">        cachedResult = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发人员可能会认为这是确保只执行一次“繁重工作”并缓存结果的完全足够的方法。然而，更精明的审阅者可能会注意到，虽然这不会导致灾难性的失败，实际上也不会保护繁重的工作不被多次完成，因为对此方法的多个并发请求虽然不是“ 一旦达到每个负载的暂停点，每个负载就会开始繁重的工作负载。</p><p>更具冒险精神的开发人员的工具带中确实有一个工具可以解决这个问题 - 非结构化任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">HeavyLifting</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heavyLiftingTask: <span class="type">Task</span>&lt;<span class="type">String</span>, <span class="type">Error</span>&gt;?</span><br><span class="line">    <span class="keyword">var</span> heavyLiftingResult: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> heavyLiftingTask &#123; <span class="keyword">return</span> <span class="keyword">try</span> await heavyLiftingTask.value &#125;</span><br><span class="line">            <span class="keyword">let</span> task = <span class="type">Task</span> &#123; <span class="keyword">try</span> await <span class="comment">// load some resource and process it. &#125;</span></span><br><span class="line">            heavyLiftingTask = task</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> await task.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在引入了不完整样板的微妙平衡，更不用说缺乏对取消传播的适当支持，所有这些都是以防止死锁的名义，而实际上并没有阻止富有冒险精神的开发人员编写可能会导致死锁的代码。</p><p>代码中到处都是这样的样板文件，最终肯定会弄错，当一天结束时，希望并假设在错误的等待最终潜入之前所做的事情，是为了 Actor 的方法在进行过程中不可调用，而 Actor 的其余部分则继续其业务。</p><p>已经使用过 Actor 一段时间，重新审视不可重入性，因为它是比较有用的工具。可以看到单独的方法或函数是希望以某种能力强制执行串行访问的东西，但是也可以看到将其应用于对整个参与者的所有访问的好处。</p><p>回答：</p><p>在未来方向（有任务链重入的奖励积分，但没有任务链重入绝对非常有用）将如那里所描述的那样非常棒。不希望应用于整个 Actor。</p><p>会有助于避免现在很容易变得脆弱的模式来解决缺乏此功能的问题。</p><p>可选的参与者“发送”对 Void 返回函数的支持一起将释放参与者的很大一部分潜力。</p><p>7) 讨论<a href="https://forums.swift.org/t/accessing-source-code-after-macro-expansion/65881" title="宏扩展后访问源代码" target="_blank" rel="noopener">宏扩展后访问源代码</a></p><p>当构建一个使用 SwiftSyntax 遍历 Swift 源代码的工具时，是否有一种直接的方法来遍历宏扩展后的源代码？</p><p>这是否需要通过尝试扩展每个源文件来手动完成？</p><p>正在构建的工具中，复制源文件并对其进行操作，但这是直接来自文件系统和预扩展的。 具体来说，该工具会遍历有效的 .swift 文件并捕获符合给定协议的所有类型。使用宏来添加对该协议的一致性，但是构建插件无法仅通过阅读非扩展源代码来了解最终的一致性。 使用 <code>Target.directory</code> 来确定给定目标的源文件所在的位置，但是是否有更好的方法来访问扩展源所在的构建目录？</p><p>回答：</p><p>如果对宏扩展的工作原理感到好奇，可以在<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/#Macro-Expansion" target="_blank" rel="noopener">这个文档</a>中阅读。</p><p>Swift 中的宏扩展基于语法的内存表示，这意味着无法在不手动执行扩展的情况下直接从源文件中检索扩展的代码。</p><p>可能会考虑尝试使用此方法扩展所有宏：<a href="https://github.com/apple/swift-syntax/blob/b556ac7c099539ed058f6fcfd978d66cb133176e/Sources/SwiftSyntaxMacros/MacroSystem.swift#L576" target="_blank" rel="noopener">SyntaxProtocol.expand(macros:in:)</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swdevnotes.com/swift/2023/angulargradient-in-swiftui/" title="AngularGradient 在swiftUI中的使用" target="_blank" rel="noopener">AngularGradient 在swiftUI中的使用</a></p><p><strong>摘要：</strong> 本篇文章讲解了如何在 swiftUI 中使用  AngularGradient，用于从一种颜色过渡到另一种颜色，可选地通过围绕指定中心点的放射状图案中的一系列颜色。本文探讨了设置不同中心点以及指定渐变的起始角度和结束角度范围的效果。 AngularGradient 可用于在 SwiftUI 视图中创建引人注目的视觉效果，尤其是在圆形或弧形中使用时。</p><p><a href="https://juejin.cn/post/7095940115532349454/" title=" 字节跳动 DanceCC 工具链系列之Swift 调试性能的优化方案" target="_blank" rel="noopener">字节跳动 DanceCC 工具链系列之Swift 调试性能的优化方案</a></p><p><strong>摘要：</strong>  本篇文章讲解了大型 Swift 项目如何通过开关，以及自定义 LLDB ，优化 Swift 开发同学的调试速度，提高整体的研发效能。其中讲解了 LLDB 的部分工作流程，以及针对性优化的技术细节，以及实际效果。</p><p><a href="https://juejin.cn/post/7244809939839434808/" title="Swift 的可选值优化" target="_blank" rel="noopener">Swift 的可选值优化</a></p><p><strong>摘要：</strong> 在 Swift 中，nil 的语义与 Objective-C 中的 nil 不同，它代表没有值的概念。为了表示没有值，Swift 引入了 nil 关键字，但在内存中的表示方式与 Objective-C 不同。文章通过代码展示了 nil 在内存中的真正表示，发现可选的 Int? 类型比普通的 Int 类型多占一个字节，用来表示是否有值。然而，Swift 编译器已经进行了优化，例如 Bool? 类型只占用一个字节，用2来表示 nil 。 String 类型也可以在内存中用0表示没有值。对于 Class 类型和 Enum 类型，空指针或越界值可以表示没有值，也没有内存浪费。总之， Swift 编译器会尽可能地优化可选值的内存占用，但仍建议在某些情况下尽量少使用可选值，特别是在结构体中连续多个可选的 Int 的情况下，可以使用非可选值并用0初始化它们。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>你认为vision pro是否会加速虚拟现实技术的发展？</strong></p><ol><li>会</li><li>不会</li><li>AI发展才是王道</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十三期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;骚年，努力去成为你期待已久的自己吧，就像&lt;strong&gt;Swift社区&lt;/strong&gt;一样，时刻心怀梦想，不断向前！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果已提供新的设计资源&lt;/p&gt;
&lt;p&gt;提案：本期提案没有最新内容&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Non-Reentrant Actors&lt;/p&gt;
&lt;p&gt;推荐博文：AngularGradient 在 swiftUI 中的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为 vision pro 是否会加速虚拟现实技术的发展？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十一期/</id>
    <published>2023-07-04T07:20:20.000Z</published>
    <updated>2023-07-04T07:31:54.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十二期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>若目标远大，就要有大动作。若追求卓越，便须有大改变。<strong>Swift社区</strong>已整装待发，你要不要一起呢？👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：Apple Vision Pro 和 visionOS 撼世登场</p><p>提案：移除由属性包装器引起的 Actor 隔离推断</p><p>Swift 论坛：为什么只能将结构附加到数组一次</p><p>推荐博文：Swift OpenAPI Generator 的介绍</p><p><strong>话题讨论：</strong> </p><p>你认为企业实行薪资保密有哪些利弊</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/273d30d8-22a4-4ef9-9e4b-b6a692f6aac3.png" alt=""></p><p>上期话题投票结果表明，在 2023 年工作更难找的情况下，大家面临着更大的工作压力，裁员消息的传出也增加了担忧。大量的媒体报道可能强调了经济衰退的迹象，这也会加强大家对经济危机的看法。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="注册-WWDC23-实验室和活动"><a href="#注册-WWDC23-实验室和活动" class="headerlink" title="注册 WWDC23 实验室和活动"></a>注册 WWDC23 实验室和活动</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/1AC9D4F4-43B5-4913-B149-B0486FFE64FE/2048.jpeg" alt=""></p><p>通过在线实验室和活动这种绝佳方式，你可以在一整周内与 Apple 工程师、设计师和专家进行交流沟通。</p><p>一对一实验室<br>从开发的基础知识到复杂概念，你都可以在这里获得个性化指导。了解如何运用全新 Apple 技术、探索 UI 设计原则、优化产品在 App Store 上的形象，以及更多主题。</p><p>活动<br>每日都有许多精彩的活动在 Slack 中展开。</p><p>在 Q&amp;A 中就工程和设计主题提问。<br>在大家一起观看讲座视频期间加入或关注实时对话，并与演讲者进行 Q&amp;A。<br>在社区暖场活动中了解其他开发者和 Apple 团队。<br>体验最新的框架，尝试各种设计理念，并在学习区分享你的创作。<br>在 6 月 6 日，与业内的佼佼者比试一下专业知识问答。<br>实验室和活动对 Apple Developer Program 和 Apple Developer Enterprise Program 的所有成员，以及 2023 Swift Student Challenge 参赛者开放。</p><h3 id="Apple-Vision-Pro-和-visionOS-撼世登场"><a href="#Apple-Vision-Pro-和-visionOS-撼世登场" class="headerlink" title="Apple Vision Pro 和 visionOS 撼世登场"></a>Apple Vision Pro 和 visionOS 撼世登场</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/213FE0A2-813D-404D-B093-D766AC8D7AF3/2048.jpeg" alt=""></p><p>Apple Vision Pro 是一款革命性的空间计算设备，可实现数字化内容与真实世界的无缝融合，让用户在沉浸于当下的同时还能与他人沟通交流。在 Apple Vision Pro 中，各种 App 将突破传统显示器的束缚限制，拥有一幅无边的画布。此外，Apple Vision Pro 还推出了一个全三维用户界面，而控制这个界面，仅需要用户的眼睛、双手和语音 — 最自然、最直观的输入工具。Apple Vision Pro 搭载了全球首个空间操作系统 visionOS，让用户能够以一种绝妙的方式与数字化内容互动，如同它们真的存在于现实世界之中。Apple Vision Pro 采用了突破性设计：在显示方面，采用超高分辨率显示屏系统，两块显示屏的总像素为 2,300 万；在性能方面，采用独特的双芯片设计并搭载定制的 Apple 芯片，确保每一刻的体验都真实无比，让人沉浸当下。</p><p>探索丰富实用的资源，助你通过一种全新而又熟悉的方式将空间计算方面的创意变为现实，打造出能够重新定义沟通、效率和娱乐的 App。</p><h3 id="App-Store-中新增的隐私功能"><a href="#App-Store-中新增的隐私功能" class="headerlink" title="App Store 中新增的隐私功能"></a>App Store 中新增的隐私功能</h3><p>在 Apple，我们将隐私视作每个人的基本权利。因此，我们构建了许多功能来帮助用户了解开发者在隐私以及数据收集和共享方面的做法，让用户能够自主掌控他们的数据。通过 App 跟踪透明度 (ATT)，用户可以选择 App 是否有权跟踪用户在其他公司的 App 和网站内的活动，以便投放广告或者与数据代理商共享。借助隐私标签和 App 隐私报告，用户可以查看 App 收集哪些数据以及如何使用这些数据。</p><p>许多 App 会利用第三方软件开发工具包 (SDK)，这些工具包可以提供出色的功能，但可能会对 App 处理用户数据的方式产生影响。为了让开发者可以更轻松地打造出色的 App，同时告知用户数据使用情况并尊重他们在这方面做出的选择，我们推出了两项新功能。</p><p>首先，为了帮助开发者了解第三方 SDK 如何使用数据，我们推出了新的隐私清单。隐私清单是一份文件，会以单一标准格式概述 App 中第三方代码的隐私做法。当开发者准备分发他们的 App 时，Xcode 会将开发者使用的所有第三方 SDK 中的隐私清单合并为一个简单易用的报告。这个报告内容全面，总结了 App 中的所有第三方 SDK，使开发者能够更轻松地创建更准确的隐私标签。</p><p>此外，为了向用户提供额外的隐私保护，如果 App 引用的 API 可能会被用于指纹识别（在 App Store 中被禁止的一种做法），现在需要选择合理的原因来解释为什么使用此 API 并在隐私清单中声明已使用此 App。在这个过程中，App 必须准确描述其对于这些 API 的使用情况，并且只能出于隐私清单中所述的原因而使用这些 API。</p><p>第二，我们希望帮助开发者改善软件供应链的完整性。使用第三方 SDK 时，开发者可能很难知道他们下载的代码是不是由期望的开发者编写的。为了解决这个问题，我们推出了适用于 SDK 的签名功能，这样一来，当开发者在 App 中采用新版本的第三方 SDK 时，Xcode 将验证它是否由同一开发者签名。这个功能将对开发者和用户都十分有帮助。</p><p>我们将在今年晚些时候发布更多信息，包括：</p><p>影响隐私的 SDK 列表 (对用户隐私产生重大影响的第三方 SDK)<br>“需要指明原因”的 API 列表，使用它们时必须给出合理的原因<br>开发者反馈表，用于就调用涉及的 API 提出新的原因<br>其他文档，详细介绍签名和隐私清单、他们的优势以及何时需要使用它们</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" title="SE-0400" target="_blank" rel="noopener">SE-0400</a> <strong>Init 访问器</strong> 提案正在审查。</p><p>该提案的目的是，Init 访问器将属性包装器的离线初始化特性泛化，使得类型中的任何计算属性都可以选择参与确定性初始化分析，并且可以替代使用自定义初始化代码对一组存储属性进行初始化。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md" title="SE-0401" target="_blank" rel="noopener">SE-0401</a> <strong>移除由属性包装器引起的 Actor 隔离推断</strong> 提案正在审查。</p><p>SE-0316：全局 Actors 引入了像 <code>@MainActor</code> 这样的注释，将类型、函数或属性隔离到特定的全局 Actor。还引入了各种规则，用于推断全局 Actor 隔离。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UIUpdating</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">  @<span class="type">MainActor</span> <span class="keyword">var</span> wrappedValue: <span class="type">Wrapped</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CounterView</span> </span>&#123; <span class="comment">// infers @MainActor from use of @UIUpdating</span></span><br><span class="line">  @<span class="type">UIUpdating</span> <span class="keyword">var</span> intValue: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该提案主张在使用 Swift 6 语言模式编译时移除此推断规则。根据上面的示例，<code>CounterView</code> 在 Swift 6 中将不再推断 <code>@MainActor</code> 隔离。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="SE-0400: Init Accessors" target="_blank" rel="noopener">SE-0400: Init Accessors</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" target="_blank" rel="noopener">SE-0400</a>：Init Accessors 314 的审查从现在开始，一直持续到 2023 年 6 月 26 日。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-improve-the-proposal-template-for-better-feature-experimentation/65604" title="改进提案模板以获得更好的功能实践" target="_blank" rel="noopener">改进提案模板以获得更好的功能实践</a></p><p><strong>介绍</strong></p><p>强制性工具链和示例项目以及 Experiment It 部分将允许开发人员在提案审查期间更轻松地进行实验并参与讨论。</p><p><strong>动机</strong></p><p>试验正在审查的功能这是评估提案的重要方式，即使是写得很好和详细的提案也可以从让开发人员试验它中受益。 提案模板可以改进，使任何人在审查期间更容易试用提议的功能。</p><p><strong>建议的解决方案</strong></p><p>将以下标题字段添加到提案模板：工具链和示例项目以及新的 Experiment It 部分。</p><p><strong>工具链</strong></p><p>该字段应指向一个链接，从中可以下载一个 swift 工具链，其中该功能是在实验性标志下实现的。</p><p>目前大多数提案只提到主分支中有一个功能可用，尽管大多数时候该功能都在 Swift.org 上可用的开发快照中 - 下载 Swift 对于新手来说了解这一点并不是那么微不足道，有时还有一个提案审查期 甚至在没有工作快照的情况下启动。</p><p>该链接应该从第一天起就可用，并在审核期间尽可能更新。</p><p>一种可能性是在网站下载页面上添加一个额外的部分，其中包含专用于正在审查的提案的工具链，这可以允许工具链可用，即使由于某种原因它不能出现在主快照中也是如此。</p><p>3) 提问<a href="https://forums.swift.org/t/why-can-i-only-append-a-struct-to-an-array-once/65601" title="为什么只能将结构附加到数组一次？" target="_blank" rel="noopener">为什么只能将结构附加到数组一次？</a></p><p>我的应用程序的目标是提醒用户与他们亲近的人互动。 因此，我的应用程序主要使用两个结构体，称为 Relation（代表一个人）和 Interaction（代表与人的一次交互）。</p><p>我构建了一个名为 “NewInteractionSheet” 的工作表，其目标是向关系的交互数组之一添加一个新的交互。</p><p>在添加交互时，此工作表非常有效。 但是，由于某种原因，它只能工作一次。 为什么要这样做？ 这就是我想要弄清楚的。</p><p>这是 “NewInteractionSheet.swift” 代码的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PhotosUI</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewInteractionSheet</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> isPresentingNewInteractionView: <span class="type">Bool</span></span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> relations: [<span class="type">Relation</span>]</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> newInteraction = <span class="type">Interaction</span>.emptyInteraction</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> relation: <span class="type">Relation</span> = <span class="type">Relation</span>.emptyRelation</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPresentingLocationPicker: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">Form</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">Section</span>(<span class="string">"You interacted with..."</span>) &#123;</span><br><span class="line">                    <span class="type">RelationPicker</span>(relations: $relations, relation: $relation)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">Section</span>(<span class="string">"Interaction details"</span>) &#123;</span><br><span class="line">                    <span class="type">InteractionDatePicker</span>(dateToSet: $newInteraction.date)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">TypePicker</span>(typeToSet: $newInteraction.type)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">DurationPicker</span>(shouldShow: newInteraction.type.hasDuration,</span><br><span class="line">                                   hoursToSet: $newInteraction.durationHours,</span><br><span class="line">                                   minutesToSet: $newInteraction.durationMinutes)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">SummaryTextField</span>(summaryToSet: $newInteraction.summary)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">LocationPicker</span>(shouldShow: newInteraction.type.hasLocation,</span><br><span class="line">                                   coordinatesToSet: $newInteraction.location.coordinates,</span><br><span class="line">                                   locationNameToSet: $newInteraction.location.name,</span><br><span class="line">                                   isPresentingLocationPicker: $isPresentingLocationPicker)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">InteractionPhotosPicker</span>(images: $newInteraction.pictures)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toolbar &#123;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .cancellationAction) &#123;</span><br><span class="line">                    <span class="type">Button</span>(<span class="string">"Dismiss"</span>) &#123;</span><br><span class="line">                        isPresentingNewInteractionView = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .confirmationAction) &#123;</span><br><span class="line">                    <span class="type">Button</span>(<span class="string">"Add"</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> index = relations.firstIndex(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.id == relation.id &#125;) &#123;</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">"\nBefore appending to relations"</span>)</span><br><span class="line">                            <span class="built_in">print</span>(relations[index])</span><br><span class="line">                            <span class="built_in">print</span>(newInteraction)</span><br><span class="line">                            relations[index].interactions.append(newInteraction)</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">"\nAfter having appended to relations"</span>)</span><br><span class="line">                            <span class="built_in">print</span>(relations[index])</span><br><span class="line">                            <span class="built_in">print</span>(newInteraction)</span><br><span class="line">                        &#125;</span><br><span class="line">                        isPresentingNewInteractionView = <span class="literal">false</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//AJOUTER LA PLANIFICATION D'UNE NOTIFICATION</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">"New interaction"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如在代码中看到的，我包含了三个“打印”指令来帮助我调试它。 当我尝试添加两个交互时，以下是控制台中打印的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Before</span> appending to relations</span><br><span class="line"><span class="type">Relation</span>(id: <span class="type">EA18AAD4</span>-<span class="type">E576</span>-49A9-90BF-<span class="type">CC58C5000ECE</span>, firstName: <span class="string">"Johanna"</span>, lastName: <span class="string">"Duby"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1814400.0</span>, birthday: <span class="type">Optional</span>(<span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">40</span> +<span class="number">0000</span>), notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.blue, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">After</span> having appended to relations</span><br><span class="line"><span class="type">Relation</span>(id: <span class="type">EA18AAD4</span>-<span class="type">E576</span>-49A9-90BF-<span class="type">CC58C5000ECE</span>, firstName: <span class="string">"Johanna"</span>, lastName: <span class="string">"Duby"</span>, photo: <span class="literal">nil</span>, interactions: [<span class="type">Relations</span>.<span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])], contactFrequency: <span class="number">1814400.0</span>, birthday: <span class="type">Optional</span>(<span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">40</span> +<span class="number">0000</span>), notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.blue, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"><span class="type">Before</span> appending to relations</span><br><span class="line"><span class="type">Relation</span>(id: 8D3D2012-<span class="type">D8A2</span>-<span class="number">4092</span>-<span class="type">B1A9</span>-<span class="type">D476F7E05B9A</span>, firstName: <span class="string">"Nastassja"</span>, lastName: <span class="string">"Ferrari"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1209600.0</span>, birthday: <span class="literal">nil</span>, notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.green, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 5C4EE2E1-7D2D-4E32-<span class="type">BC00</span>-<span class="type">FCA781EC8C20</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">49</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">After</span> having appended to relations</span><br><span class="line"><span class="type">Relation</span>(id: 8D3D2012-<span class="type">D8A2</span>-<span class="number">4092</span>-<span class="type">B1A9</span>-<span class="type">D476F7E05B9A</span>, firstName: <span class="string">"Nastassja"</span>, lastName: <span class="string">"Ferrari"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1209600.0</span>, birthday: <span class="literal">nil</span>, notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.green, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 5C4EE2E1-7D2D-4E32-<span class="type">BC00</span>-<span class="type">FCA781EC8C20</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">49</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br></pre></td></tr></table></figure><p>4) 提问<a href="https://forums.swift.org/t/are-nested-recursive-macros-supported-in-swift-5-9/65569" title="Swift 5.9 是否支持嵌套/递归宏？" target="_blank" rel="noopener">Swift 5.9 是否支持嵌套/递归宏？</a></p><p>5) 提问<a href="https://forums.swift.org/t/how-to-reference-an-article-in-a-different-module/65581" title="如何引用不同模块中的文章？" target="_blank" rel="noopener">如何引用不同模块中的文章？</a></p><p>查看 DocC 代码链接的语法，似乎我们有办法引用同一模块中的文章：</p><doc:gettingstarted><p>但是我们不能使用前导斜杠语法来指定模块相对路径，因为它已经被 tutorials 命名空间占用：</p><p><a href="doc:/tutorials/SlothCreator" target="_blank" rel="noopener">doc:/tutorials/SlothCreator</a></p><p>如何引用来自不同模块的文章？</p><p>回答：</p><p>库存 DocC 尚不支持外部 - 或者更具体地说，尚未提供公共解决方案。 早期的 DocC 代码中有一些关于允许某些过程的外部引用解析器的位，@ronnqvist 一直在研究更新的解决方案（“分层解析器”）——但我只关注了一些 PR（最近的一个 提取了很多旧代码：通过 d-ronnqvist 添加成功解析的外部引用到参考索引, <a href="https://github.com/apple/swift-docc/pull/582" target="_blank" rel="noopener">Pull Request #582</a>）</p><p>6) 提问<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="Macros包会嵌入到App中吗？" target="_blank" rel="noopener">Macros包会嵌入到App中吗？</a></p><p>例如，当我使用 #stringify Swift 宏在我的应用程序中生成代码时，它会在编译期间用新代码替换我的一些源代码。 那么这个宏包会随我的应用程序一起提供吗？ 或者它只是在编译期间发生</p><p>回答：替换发生在编译时。 宏目标不应链接到应用该目标中包含的宏的代码。</p><p>7) 提问<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="哪个 Apple Networking Api 用于 UDP 多播和单播？" target="_blank" rel="noopener">哪个 Apple Networking Api 用于 UDP 多播和单播？</a></p><p>一般而言，iOS 开发和网络的新手。 开发一个游戏节目类型的应用程序，其中“主机”设备需要多播到“参赛者”设备。 参赛者设备也需要能够响应。 实际上传递的信息很少，但速度很重要，因此使用 UDP。 </p><p>我一直在研究苹果设备的一些常用网络 api：network.framework、CocoaAsyncSocket、Multipeer-Connectivity、BSD 套接字等。总的来说，我倾向于只使用高级 network.framework 但缺乏 示例和资源使决策变得困难。 任何意见，将不胜感激。</p><p>回答：<a href="https://developer.apple.com/documentation/technotes/tn3151-choosing-the-right-networking-api" target="_blank" rel="noopener">TN3151: Choosing the right networking API</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/introducing-swift-openapi-generator/" title=" Swift OpenAPI Generator 的介绍" target="_blank" rel="noopener">Swift OpenAPI Generator 的介绍</a></p><p><strong>摘要：</strong> Swift OpenAPI Generator是一个 SwiftPM 插件，它可以生成客户端代码或服务器端代码，以便处理 HTTP 调用。 OpenAPI 是一种用于记录HTTP服务的规范，可以使用YAML或JSON编写，并可被工具读取，以帮助自动化工作流程，例如生成必要的代码以发送和接收HTTP请求。Swift OpenAPI Generator 可以帮助我们通过 OpenAPI 文档描述HTTP请求和响应的结构，包括 HTTP 方法、 URL 路径和查询参数、HTTP状态码和内容类型，使用 JSON Schema 描述响应体的结构，使得我们能够在开发应用程序时生成网络代码，而不需要手动编写和维护网络代码，专注于核心业务逻辑。要使用 Swift OpenAPI Generator 插件，需要添加 SwiftPM 依赖项以及运行时库和传输实现，然后使用生成的API客户端或服务器端存根。 Swift OpenAPI Generator 支持大多数常用特性，但仍有一些特性需要实现，项目跟踪进展情况可以使用 GitHub issues </p><p><a href="https://www.avanderlee.com/swift/macros/" title=" Swift 宏：使用新的表达方式扩展 Swift" target="_blank" rel="noopener"> Swift 宏：使用新的表达方式扩展 Swift</a></p><p><strong>摘要：</strong>  Swift 宏是在 Swift 5.9发布的一项新功能，它允许你通过自定义编译时检查和生成新的代码，在编译时将它们写入到你的文件中，从而消除冗余的样板代码。本文讲解了宏的工作原理、如何编写自定义宏以及如何进行测试，以验证一个允许在编译时验证 URL 并在 URL 有效时返回解包值的宏的例子。本文还讨论了宏的不同角色，包括独立和附加宏，并解释了为什么你可能考虑在代码中使用宏。</p><p><a href="https://www.avanderlee.com/swift/share-swift-code-swift-on-server-vapor/" title="在 Swift 服务器端 Vapor 和客户端应用之间共享 Swift 代码" target="_blank" rel="noopener">在 Swift 服务器端 Vapor 和客户端应用之间共享 Swift 代码</a></p><p><strong>摘要：</strong> 这篇博客讨论了在客户端应用和后端服务器之间共享 Swift 代码的好处以及如何通过 Swift 包和 Vapor 实现这一目标。通过共享模型和端点定义，您可以确保两个侧面都使用相同的层，避免出现意料之外的请求失败。博客提供了定义软件包结构、暴露模型、共享端点定义和在后端软件包中配置端点的代码示例。此外，它提供了一个通用方法，用于请求端点并在客户端应用中使用它们。作者还提到了优化适用于所有支持的 HTTP 方法的代码的重要性。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>薪酬保密作为人力资源管理中一项颇具争议的举措，近年来学界对其研究越来越多。有人提出，实行薪酬保密，能让企业根据员工绩效的高低提供差异较大的薪酬，提升薪酬激励作用，同时也能避免因为收入差距产生内部冲突。也有人提出公开的薪酬制度能使内部沟通更为有效，减少误传，增强信任感，作为一种制度，薪酬的等级体系、岗位差距以及操作程序还应以公开为准则。<strong>你认为企业实行薪资保密有哪些利弊？</strong></p><p>1.保护员工个人隐私。</p><p>2.避免员工之间的比较和嫉妒心理，减少内部矛盾。</p><p>3.难以查看薪资公正性，更少的保密性意味着更多的平等。</p><p>4.易产生员工对公司不信任，让员工产生长期处于被剥削的感觉。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p></doc:gettingstarted>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十二期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;若目标远大，就要有大动作。若追求卓越，便须有大改变。&lt;strong&gt;Swift社区&lt;/strong&gt;已整装待发，你要不要一起呢？👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：Apple Vision Pro 和 visionOS 撼世登场&lt;/p&gt;
&lt;p&gt;提案：移除由属性包装器引起的 Actor 隔离推断&lt;/p&gt;
&lt;p&gt;Swift 论坛：为什么只能将结构附加到数组一次&lt;/p&gt;
&lt;p&gt;推荐博文：Swift OpenAPI Generator 的介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为企业实行薪资保密有哪些利弊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十期/</id>
    <published>2023-07-04T07:20:16.000Z</published>
    <updated>2023-07-04T07:31:19.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十一期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>求人不如求己，你多一样本领，就少一点啊乞求；<strong>Swift社区</strong>让你多一样技能，少一些嘲讽！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：码出新宇宙，WWDC23 就在眼前</p><p>提案：有 4 个提案通过，本期没有产生新的提案</p><p>Swift 论坛：PermutableCollection 协议</p><p>推荐博文：SwiftUI 中 LinearGradient的用法</p><p><strong>话题讨论：</strong> </p><p>有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/6f2a4159-0a47-4f33-b6d2-5f7516d78f89.png" alt=""></p><p>上期话题讨论结果表明，<strong>社交隔阂</strong>和<strong>个人选择标准的提高</strong>是导致男女群体互不干涉的主要原因，而<strong>社会观念的变化</strong>也起到了一定的影响。这些因素共同作用导致了男群体和女群体相互独立地寻找伴侣的现象。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="App、App-内购买项目和订阅即将实行税率调整"><a href="#App、App-内购买项目和订阅即将实行税率调整" class="headerlink" title="App、App 内购买项目和订阅即将实行税率调整"></a>App、App 内购买项目和订阅即将实行税率调整</h3><p>App Store 的交易和支付机制旨在帮助你在覆盖全球的 175 个国家和地区的商店中，以 44 种货币为你的产品和服务便捷地进行定价与销售。Apple 会为开发者管理其中 70 多个国家和地区的税收，而且你还能够为 App 和 App 内购买项目分配税务类别。我们会根据税务法规的变化，定期更新你在某些地区的收益。</p><p>从 5 月 31 日起，你从 App 和 App 内购买项目 (包括自动续期订阅) 销售中获得的收益将进行调整，以反映以下税率调整。请注意，相关内容的价格将保持不变。</p><p>加纳：增值税率从 12.5% 上调至 15%。<br>立陶宛：对于符合条件的电子书和有声书，增值税率从 21% 下调至 9%。<br>摩尔多瓦：对于符合条件的电子书和期刊，增值税率从 20% 下调至 0%。<br>西班牙：收取 3% 的数字服务税。<br>由于巴西税务法规的变化，在巴西开展的所有 App Store 销售现由 Apple 代扣税款。我们会按月代扣代缴应向相应税务机关缴纳的税款。自 2023 年 6 月开始，你可以在 5 月份的收入中查看从你的收益中扣除的税款金额。巴西境内的开发者不会受到这一变化的影响。</p><p>以上调整生效后，App Store Connect 中“我的 App”的“价格与销售范围”部分会随即更新。一如既往，你可以随时更改你的 App 和 App 内购买项目的价格 (包括自动续期订阅)。现在，你可以从 900 个价格点中选择，为任何店面更改定价。</p><h3 id="码出新宇宙"><a href="#码出新宇宙" class="headerlink" title="码出新宇宙"></a>码出新宇宙</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/B6D2ADBF-1563-457E-82CE-374A654AA6B0/2048.jpeg" alt=""></p><p>WWDC23 就在眼前。太平洋夏令时间 6 月 5 日上午 10 点，Apple 主题演讲将在 apple.com 和 Apple Developer App 线上提供，为本次大会拉开序幕。你还可以通过同播共享，邀请朋友一起观看。</p><p>现在，符合条件的开发者可以开始报名参加活动了。相关活动包括 Q&amp;A、“会见演讲者”以及社区暖场活动等线上聊天室活动，旨在促进你与开发者社区和 Apple 专家的沟通和交流。</p><h3 id="Apple-公证服务更新"><a href="#Apple-公证服务更新" class="headerlink" title="Apple 公证服务更新"></a>Apple 公证服务更新</h3><p>正如去年在 WWDC (简体中文字幕) 上宣布的那样，如果你目前使用 altool 命令行工具或者 Xcode 13 或更早版本通过 Apple 公证服务对 Mac 软件进行公证，则需要改为使用 notarytool 命令行工具，或者升级到 Xcode 14 或更高版本。自 2023 年 11 月 1 日起，Apple 公证服务将不再接受从 altool 或者 Xcode 13 或更早版本上传的内容。已经过公证的现有软件可以继续正常工作。</p><p>Apple 公证服务是一个自动化系统，它会扫描 Mac 软件中有没有恶意内容，检查有没有代码签名问题，并快速返回结果。对软件进行公证可向用户保证，Apple 已检查且未发现软件中包含恶意软件。</p><p>为改进 Apple 平台的安全性和隐私保护，用于验证 App 和关联 App 内购买项目销售的 App Store 收据签名媒介证书将更新为使用 SHA-256 加密算法。此更新将分多个阶段完成，新的 App 和 App 更新可能会受影响，具体取决于它们验证收据的方式。</p><h3 id="Apple-设计大奖入围名单公布"><a href="#Apple-设计大奖入围名单公布" class="headerlink" title="Apple 设计大奖入围名单公布"></a>Apple 设计大奖入围名单公布</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/020C144B-0FE5-49A1-ADB2-7B01072574C7/2048.jpeg" alt=""></p><p>Apple 设计大奖旨在表彰在多元包容、乐趣横生、出色互动、社会影响、视觉图像，以及创新思维等类别中表现出色的 App 和游戏。马上一睹今年的入围作品，我们将在太平洋夏令时间 6 月 5 日下午 6:30 揭晓获奖者，敬请关注。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0399-tuple-of-value-pack-expansion.md" title="SE-0399" target="_blank" rel="noopener">SE-0399</a> <strong>value 包展开的元组</strong> 提案通过审查。该提案已在 <strong>二十九期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0397-freestanding-declaration-macros.md" title="SE-0397" target="_blank" rel="noopener">SE-0397</a> <strong>独立声明 Macros</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0392-custom-actor-executors.md" title="SE-0392" target="_blank" rel="noopener">SE-0392</a> <strong>自定义 Actor 执行器</strong> 提案通过审查。该提案已在 <strong>二十五期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md" title="SE-0390" target="_blank" rel="noopener">SE-0390</a> <strong>引入 @noncopyable </strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://translate.google.com/?sl=en&amp;tl=zh-CN&amp;text=Migrating%20from%20Realm%20Database%20Tips%3F&amp;op=translate" title="从 Realm 数据库迁移提示？" target="_blank" rel="noopener">从 Realm 数据库迁移提示？</a></p><p><strong>提问</strong></p><p>目前正在寻求迁移到更轻量级的解决方案（realm 目前对我的用例来说太过分了）并且想迁移到 grdb，但不必将 realm 作为依赖项持续一年或更长时间……</p><p><strong>回答</strong></p><p>在没有 Realm 库的情况下，您是否能够读取 Realm 数据库文件的内容？ 否则，您必须将 Realm 作为依赖项保留，直到您的用户迁移完毕。</p><p>您可以通过发布能够要求用户升级的应用程序版本来缩短时间跨度。 这将允许您使用 “Realm-only”、“Realm-to-GRDB” 和最终的 “GRDB-only” 版本进行过渡。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-allow-protocols-to-be-nested-in-non-generic-contexts/65285" title="允许 protocol 嵌套在非通用上下文中" target="_blank" rel="noopener">允许 protocol 嵌套在非通用上下文中</a></p><p><strong>介绍</strong></p><p>允许协议嵌套在非通用 struct/class/enum/actors 和函数中。</p><p><strong>动机</strong></p><p>将标称类型嵌套在其他标称类型中允许开发人员表达内部类型的自然范围——例如，String.UTF8View 是嵌套在 struct String 中的 struct UTF8View，它的名称清楚地传达了它作为 UTF-8 代码接口的用途 - 字符串值的单位。</p><p>但是，嵌套目前仅限于在其他 struct/class/enum/actors 中的 struct/class/enum/actors； 协议根本不能嵌套，因此必须始终是模块中的顶级类型。 这很不幸，我们应该放宽此限制，以便开发人员可以表达自然作用于某些外部类型的协议。</p><p><strong>建议的解决方案</strong></p><p>我们将允许在非泛型 struct/class/enum/actors 中以及在不属于泛型上下文的函数中嵌套协议。</p><p>例如，TableView.Delegate 自然是与表视图相关的委托协议。 开发人员应该这样声明它——嵌套在他们的 TableView 类中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableView</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">Delegate</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span>: TableView, didSelectRowAtIndex: Int)</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegateConformer</span>: <span class="title">TableView</span>.<span class="title">Delegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span>: TableView, didSelectRowAtIndex: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前，开发人员采用复合名称（例如 TableViewDelegate）来表达可以通过嵌套表达的相同自然范围。</p><p>作为一个额外的好处，在 TableView 的上下文中，可以使用更短的名称来引用嵌套协议委托（与所有其他嵌套类型一样）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">Delegate</span>?</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">Delegate</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议也可以嵌套在非泛型函数和闭包中。 不可否认，这在某种程度上是有限的实用性，因为对此类协议的所有一致性也必须在同一功能内。 但是，也没有理由人为地限制开发人员在函数中创建的模型的复杂性。 一些代码库（值得注意的是，Swift 编译器本身）使用带有嵌套类型的大型闭包，并且它们受益于使用协议的抽象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">protocol</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     associatedtype <span class="type">ResultType</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">ResultType</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">SomeConformance</span>: <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AnotherConformance</span>: <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">impl</span>&lt;T: Abstraction&gt;<span class="params">(<span class="number">_</span> input: T)</span></span> -&gt; <span class="type">T</span>.<span class="type">ResultType</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">let</span> <span class="number">_</span>: <span class="type">Int</span> = impl(<span class="type">SomeConformance</span>())</span><br><span class="line">   <span class="keyword">let</span> <span class="number">_</span>: <span class="type">String</span> = impl(<span class="type">AnotherConformance</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 提议<a href="https://forums.swift.org/t/permutablecollection-protocol/65314" title="PermutableCollection 协议" target="_blank" rel="noopener">PermutableCollection 协议</a></p><p><strong>简介</strong></p><p>该提案旨在添加一个 PermutableCollection 协议，该协议将位于集合协议层次结构中的 Collection 和 MutableCollection 之间。</p><p><strong>动机</strong></p><p>在某些情况下，人们希望能够移动和排序元素，同时不允许（或限制）元素的突变。 鉴于大量不太重要的收集协议，这是一个值得注意的遗漏。 创建自定义集合类型时，PermutableCollection 协议在任何强制元素唯一性和/或身份的有序集合中都是首选。 用例将包括即将推出的 OrderedDictionary 和 OrderedSet。 对于不可变和可变集合，它还可以提供对 Swift 使用的底层（并且可能是高度优化的）排序算法的统一访问。</p><p><strong>设计</strong></p><p>协议设计简单，只需一个 swapAt 要求</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A collection that supports sorting.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PermutableCollection</span>&lt;<span class="title">Element</span>&gt; : <span class="title">Collection</span> <span class="title">where</span> <span class="title">Self</span>.<span class="title">SubSequence</span> : <span class="title">PermutableCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  mutable <span class="function"><span class="keyword">func</span> <span class="title">swapAt</span><span class="params">(<span class="number">_</span> i: Index, <span class="number">_</span> j: Index)</span></span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 swapAt 函数，通过扩展添加额外的排序函数实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PermutableCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(fromOffsets source: IndexSet, toOffset destination: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// move algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(by belongsInSecondPartition: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">    <span class="comment">// partition algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">()</span></span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">RandomAccessCollection</span>, <span class="type">Self</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// partition algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... more permutation operations that mimic those available for MutableCollection</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/vapor-and-query-caching/65278" title="Vapor和query缓存？" target="_blank" rel="noopener"> Vapor 和 query 缓存？</a></p><p>5) 讨论<a href="https://forums.swift.org/t/in-swift-system-how-does-one-read-a-files-contents-to-a-string/65294" title="在 Swift 系统中，如何将文件内容读取为字符串？" target="_blank" rel="noopener">在 Swift 系统中，如何将文件内容读取为字符串？</a></p><p><strong>提问</strong></p><p>我有一个文件的 FileDescriptor：</p><p>let fd = try FileDescriptor.open(&lt;#filepath#&gt;, .readOnly) 我可以使用 fd.read(into:) 将文件内容加载到 UnsafeMutableRawBufferPointer，但这是将文件内容加载到字符串中的正确第一步吗？ 如果是这样，</p><p>在将它传递给 fd.read(into:) 之前，</p><ol><li>我需要使用 .allocate(byteCount:alignment:) 分配 UnsafeMutableRawBufferPointer。 正确的 byteCount 取决于文件的大小。那么如何使用 Swift System 获取文件的大小呢？</li><li>如何从 UnsafeMutableRawBufferPointer 获取字符串？</li></ol><p><strong>回答</strong></p><p>可以参考这个Git库：<a href="https://github.com/tayloraswift/swift-unidoc/blob/master/Sources/System/FileDescriptor.swift" target="_blank" rel="noopener">https://github.com/tayloraswift/swift-unidoc/blob/master/Sources/System/FileDescriptor.swift</a></p><p>6) 讨论<a href="https://forums.swift.org/t/why-can-t-i-forward-enum-cases-with-dynamicmemberlookup/65290" title="为什么我不能使用 @dynamicMemberLookup 转发 enum cases？" target="_blank" rel="noopener">为什么我不能使用 @dynamicMemberLookup 转发 enum cases？</a></p><p>7) 讨论<a href="https://forums.swift.org/t/how-to-do-performance-testing-properly-in-swift-foundation/65282" title="如何在 swift-foundation 中正确地进行性能测试？" target="_blank" rel="noopener">如何在 swift-foundation 中正确地进行性能测试？</a></p><p><strong>提问</strong></p><p>我想对比一下swift-foundation 和 Xcode 自带的 JSONDecoder 解码的速度。</p><p>我在一个新项目中使用单元测试和 measureBlock 以及在 swift-foundation 中使用 JSONEncoderTests 对其进行了测试。</p><p>swift-foundation 中的 JSONDecoder 看起来太慢了，我认为这是因为 swift-foundation 还没有作为一个库被引入。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7238802590661476412/" title="iOS crash 报告分析系列 - 看懂 crash 报告的内容" target="_blank" rel="noopener">iOS crash 报告分析系列 - 看懂 crash 报告的内容</a></p><p><strong>摘要：</strong> 本篇文章主要介绍了iOS崩溃报告的解读方法，从报告的 Header、Exception information、Diagnostic messages、Backtraces、Thread state 和 Binary images 六个部分详细讲解了各字段含义，并提供示例代码帮助读者更好地理解。同时也引导读者去深入学习符号化的相关知识来获得更多信息。通过阅读本文，开发者可轻松看懂代码中产生的崩溃报告，并进行问题定位和处理。</p><p><a href="https://swdevnotes.com/swift/2023/lineargradient-in-swiftui/" title="SwiftUI 中 LinearGradient的用法" target="_blank" rel="noopener">SwiftUI 中 LinearGradient的用法</a></p><p><strong>摘要：</strong> 这篇博文探讨了在 SwiftUI 中使用 LinearGradient 为对象创建渐变颜色效果。它展示了如何定义颜色数组、使用标准和自定义起点和终点，以及设置坐标以改进铅笔对象上的颜色笔尖。本文还包括用于创建具有各种起点终点组合的不同线性渐变的示例代码。文章以示例结束，展示了如何使用这些技术来自定义一支蓝色铅笔或整套铅笔的外观。</p><p><a href="https://swiftwithmajid.com/2023/05/23/dynamic-member-lookup-in-swift/" title="Swift 中的动态成员查找" target="_blank" rel="noopener">Swift 中的动态成员查找</a></p><p><strong>摘要：</strong> 本文介绍了 Swift 语言中的动态成员查找（Dynamic Member Lookup）特性。通过在类型上使用 @dynamicMemberLookup 属性，我们可以重载该类型的 subscript 方法来更方便地访问其数据。但是，这也意味着缺乏编译时安全性。为了解决这个问题，本文提到了使用 KeyPath 作为参数的 subscript 方法来实现编译时安全检查。最后，作者建议我们可以谨慎地使用 <code>@dynamicMemberLookup</code> 特性来改进 API 设计。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？</strong></p><p>1.是的。确实已经经济危机了，今年工作很难找，同事比以前更卷啦，各种裁员消息不断。</p><p>2.经济危机不可能。五一淄博接待游客超过了100万人次，人挤人的旅游景象依然常在。</p><p>3.经济危机应该是相对的。对于大多数上班族来说，2023年很难，奉劝大家且行且珍惜。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十一期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;求人不如求己，你多一样本领，就少一点啊乞求；&lt;strong&gt;Swift社区&lt;/strong&gt;让你多一样技能，少一些嘲讽！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：码出新宇宙，WWDC23 就在眼前&lt;/p&gt;
&lt;p&gt;提案：有 4 个提案通过，本期没有产生新的提案&lt;/p&gt;
&lt;p&gt;Swift 论坛：PermutableCollection 协议&lt;/p&gt;
&lt;p&gt;推荐博文：SwiftUI 中 LinearGradient的用法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十九期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十九期/</id>
    <published>2023-07-04T07:20:09.000Z</published>
    <updated>2023-07-04T07:30:45.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>最无情的永远不是环境，而是缺乏勇气的内心。<strong>Swift社区</strong>与你一起，赤胆平乱世，长枪定江山！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：担心泄密！外媒：苹果公司限制员工使用ChatGPT</p><p>提案：value 包展开的元组</p><p>Swift 论坛：讨论 Xcode 忽略 Package.resolved 文件</p><p>推荐博文：万字长文详解如何使用 Swift 提高代码质量</p><p><strong>话题讨论：</strong> </p><p>一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/c465cfe7-1b3a-49d3-820c-e7b06fd7738b.png" alt=""></p><p>上期话题讨论结果表明对于 AI 是否会取代软件工程师的问题，大家的观点存在分歧，而实际的结果可能<strong>取决于 AI 技术的发展和与人类工程师的协作方式的演变</strong>。让我们拭目以待。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="担心泄密！外媒：苹果公司限制员工使用ChatGPT"><a href="#担心泄密！外媒：苹果公司限制员工使用ChatGPT" class="headerlink" title="担心泄密！外媒：苹果公司限制员工使用ChatGPT"></a>担心泄密！外媒：苹果公司限制员工使用ChatGPT</h3><p>中新经纬 5 月 19 日电 据华尔街日报中文网 19 日报道，其获悉的一份文件以及知情人士的消息显示，苹果公司已经限制使用 ChatGPT 和其他外部 AI 工具。</p><p>根据这份文件，苹果公司担心员工使用这类程序可能会泄露机密数据。该文件还称，苹果公司还告诉员工，不要使用微软所有的 GitHub 的产品 Copilot。Copilot 可以自动编写软件代码。</p><p>ChatGPT 是 AI 研究公司 OpenAI 开发的一款人工智能聊天机器人。该产品于 2022 年 11 月发布，可以进行从历史到哲学等话题的对话，并对计算机程序代码提供修改建议。</p><p>值得注意的是，在 ChatGPT 爆火的背后，也出现过商业泄密的重大事故。</p><p>今年 4 月，据多家媒体报道，三星电子引入聊天机器人 ChatGPT 不到 20 天，便曝出机密资料外泄，如半导体设备测量数据、产品良率等内容。为杜绝类似事故再发生，三星制定相关保护措施，该公司向员工表示，“若采取信息保护紧急措施后仍发生类似事故，公司内部网络可能会切断 ChatGPT 连接”。</p><p>此外，已经有国家监管机构注意到了数据安全风险。</p><p>当地时间 3 月 31 日，意大利个人数据保护局宣布，即日起禁止使用聊天机器人 ChatGPT ，限制其开发公司 OpenAI 处理意大利用户信息，并开始立案调查。意大利个人数据保护局认为，3 月 20 日 ChatGPT 平台出现了用户对话数据和付款服务支付信息丢失情况，而该平台没有就收集处理用户信息进行告知，且缺乏大量收集和存储个人信息的法律依据。(中新经纬APP)</p><h3 id="苹果公司大幅削减其MR头显销售预期，不足百万台"><a href="#苹果公司大幅削减其MR头显销售预期，不足百万台" class="headerlink" title="苹果公司大幅削减其MR头显销售预期，不足百万台"></a>苹果公司大幅削减其MR头显销售预期，不足百万台</h3><p>品玩 5 月 19 日讯，据界面新闻消息，苹果公司已将其期待已久的混合现实（MR）头显的销售预期下调约三分之二。报道指出，苹果最初希望每年销售约 300 万台，但现在已将销售预期削减至约 100 万台，随后又下调至 90 万台。该公司将于 6 月 5 日举行全球开发者大会，预计将在会上展示该产品。该设备的售价预计会高达 3000 美元左右，是 Meta Platforms 最昂贵的 Quest Pro 头显售价的三倍。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0396-never-codable.md" title="SE-0396" target="_blank" rel="noopener">SE-0396</a> <strong>Never 遵守 Codable</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>允许泛型类型对包进行抽象声明</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>value 包展开的元组</strong> 提案正在审查。</p><p>之前的 SE-0393 引入了 Value 和 Type 参数包。该提案允许引用一个包含在重复模式中的 value 包的元组值。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/swiftui-charts-very-large-data-sets-and-chart-overlay/65054" title="SwiftUI 图表、超大数据集和图表叠加" target="_blank" rel="noopener">SwiftUI 图表、超大数据集和图表叠加</a></p><p>2) 讨论<a href="https://forums.swift.org/t/sendable-warning-with-thread-safe-property-wrapper/65053" title="带有线程安全属性包装器的可发送警告" target="_blank" rel="noopener">带有线程安全属性包装器的可发送警告</a></p><p>当使用有针对性的严格并发进行构建时，我收到一条警告，我想知道除了使我的类型“未经检查的可发送”之外，我是否可以做任何事情。</p><p>考虑一些线程安全的属性包装器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper <span class="class"><span class="keyword">struct</span> <span class="title">ThreadSafe</span>&lt;<span class="title">Value</span>: <span class="title">Sendable</span>&gt;: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock: <span class="type">Lock</span>&lt;<span class="type">Value</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; lock.withLock &#123; $<span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; lock.withLock &#123; $<span class="number">0</span> = newValue &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(lock: .<span class="keyword">init</span>(initialState: wrappedValue))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(lock: <span class="type">Lock</span>&lt;<span class="type">Value</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.lock = lock</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并考虑使用它来强制执行线程安全和可发送性的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeSendable</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">    @<span class="type">ThreadSafe</span></span><br><span class="line">    <span class="keyword">var</span> someBool: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使我的课程是线程安全的，我仍然收到此警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stored</span> property '_someBool' of '<span class="type">Sendable'</span>-conforming <span class="class"><span class="keyword">class</span> '<span class="title">SomeSendable</span>' <span class="title">is</span> <span class="title">mutable</span></span></span><br></pre></td></tr></table></figure><p>编译器诊断似乎没有检查属性包装器的可发送性。</p><p>有没有办法在不使我的类型“未选中”的情况下平息此警告？</p><p><strong>回答</strong></p><p>问题是任何带有 var 的类总是不可发送的，并且属性包装器不允许 let。</p><p>但对我来说，真正的问题是 SomeSendable 使用起来真的不是那么安全，特别是 <code>@ThreadSafe</code> 是不安全的。 它使得以易受竞争影响的方式使用可变状态变得太容易了。 由于数据被锁定，您肯定不会遇到运行时崩溃，但您很容易得到不正确的结果。</p><p>例如，像旋转 1,000 个任务来切换布尔值这样简单的事情在最后总是会产生一个真值，但有时你会得到假，有时你会得到真：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = <span class="type">SomeSendable</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">1000</span> &#123;</span><br><span class="line">  <span class="type">Task</span> &#123; object.toggle() &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(object.someBool)</span><br></pre></td></tr></table></figure><p>这是一个相当大的问题，它正在发生，因为 <code>@ThreadSafe</code> 允许直接写入底层值。 所以像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.someBool = !object.someBool</span><br></pre></td></tr></table></figure><p>…隐藏竞争条件。</p><p>实际上，您可能应该直接在类中保留 Lock 值，而不是使用 <code>@ThreadSafe</code> 属性包装器，然后仅通过它的 withValue 进行变异。 当然，如果可变数据的安全是最重要的问题，那么您真的应该使用 actor。</p><p>3) 讨论<a href="https://forums.swift.org/t/using-snippets-in-documentation-comments-not-possible/65046" title="无法在文档注释中使用片段？" target="_blank" rel="noopener">无法在文档注释中使用片段？</a></p><p>我阅读 SE-0356 的方式应该可以在 Swift 包的 Snippets 文件夹中创建一个片段文件，然后通过@Snippet 在我的文档评论中引用它。</p><p>但这似乎并不像我预期的那样工作（使用 Xcode 14.3 / Swift 5.8）：</p><p><code>@Snippet</code> 给我警告：“符号源文档不支持指令”<br>显示我记录的类型的快速帮助不包括片段。</p><p>使用菜单“产品”&gt;“构建文档”生成没有代码片段的文档。</p><p><strong>回答</strong></p><p>片段在 Swift 5.7 中实现，并可通过 <code>swift-docc-plugin</code> 与 SwiftPM 一起使用，但正如其他人指出的那样，没有与基于 Xcode 的文档工作流集成，因为它使用不同的构建系统。 我会更新提案。</p><p>4) 讨论<a href="https://forums.swift.org/t/xcode-ignoring-package-resolved-file/65031" title="Xcode 忽略 Package.resolved 文件" target="_blank" rel="noopener"> Xcode 忽略 Package.resolved 文件</a></p><p>我不确定这是 SPM 问题还是 Xcode 问题，但将 SPM 与 Xcode 一起使用时最令人沮丧的经历之一是它经常忽略我的 repo 中的 <code>Package.resolved</code> 文件，通常是在切换分支或不同机器之间时。</p><p><code>Package.resolved</code> 文件应该是我的依赖项的真实来源，它永远不应该被忽略——如果有问题，包解析失败，但永远不要改变我的依赖项。</p><p>似乎发生的情况是，Xcode 更愿意使用其源缓存中恰好满足包版本要求的库版本，而不是解析文件中的库版本。 例如，我有一个版本要求为“2.2.0 up to next minor”的库。 </p><p>Package.resolved 文件中有 2.2.3，所以这是我希望始终使用的版本，除非我进行一些会引入冲突的更改。 当我在另一台机器上打开同一个项目时，出于某种原因它坚持要更改为 2.2.2，大概这是它缓存中的版本。 为什么？ 如果可以忽略已解析文件的意义何在？</p><p><strong>回答</strong></p><p>我可能遗漏了一些细节，但在更新到 Xcode 14.3 并在我们的 CI 中面对这个问题时，我们意识到我们从未使用 <code>-onlyUsePackageVersionsFromResolvedFile</code> 标志调用 xcodebuild。 现在我们这样做了，而且 CI 似乎尊重我们的 Package.resolved 文件。</p><p>对于我们来说，这个问题只存在于 Xcode 的 GUI 中。 （与此同时，我同样感到困惑，为什么需要 <code>-onlyUsePackageVersionsFromResolvedFile</code> 而不是 CLI 和 GUI 的默认模式！）</p><p>5) 讨论<a href="https://forums.swift.org/t/without-objective-c-or-swift-how-can-a-display-name-be-retrieved-from-cgdirectdisplayid-in-c-or-c/65034" title="如果没有 Objective-C 或 Swift，如何在 C 或 C++ 中从 CGDirectDisplayID 检索显示名称？" target="_blank" rel="noopener">如果没有 Objective-C 或 Swift，如何在 C 或 C++ 中从 CGDirectDisplayID 检索显示名称？</a></p><p>我试图在纯 C++（或 C）中从 <code>CGDirectDisplayID</code> 获取显示名称</p><p>我可以在 Objective-C++ 中做到这一点，类似于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;CoreGraphics/CoreGraphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;IOKit/graphics/IOGraphicsLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> getDisplayNameForDispID(<span class="built_in">CGDirectDisplayID</span> dispID,</span><br><span class="line">                             std::string&amp; strOutName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> bRes = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    strOutName.clear();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *screens = [<span class="built_in">NSScreen</span> screens];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSScreen</span> *screen <span class="keyword">in</span> screens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span>* screenDictionary = [screen deviceDescription];</span><br><span class="line">        <span class="keyword">if</span>(screenDictionary)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span>* screenID = [screenDictionary objectForKey:<span class="string">@"NSScreenNumber"</span>];</span><br><span class="line">            <span class="keyword">if</span>(screenID)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CGDirectDisplayID</span> aID = [screenID unsignedIntValue];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(aID == dispID)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Got it</span></span><br><span class="line">                    <span class="built_in">NSString</span>* pName = [screen localizedName];</span><br><span class="line">                    </span><br><span class="line">                    strOutName.assign([pName UTF8String], [pName lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line"></span><br><span class="line">                    bRes = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我不想仅仅为了完成这一项任务而将这个缓慢的 Objective-C 代码添加到我的项目中。 在低级 C 中，必须有一种方法可以做到这一点。</p><p>我知道有一个完整的主题专门讨论它。 由于 <code>CGDisplayIOServicePort</code> 已弃用并且仅返回 0 并且任何后续调用都会执行操作，因此请注意，没有任何解决方法为 macOS Ventura 提供工作。</p><p><strong>回答</strong></p><p>如果您坚持不直接使用任何 Objective C 代码，您仍然可以使用 Objective C 运行时 API 从 C 调用 Objective C API，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class nsScreen = objc_lookUpClass(<span class="string">"NSScreen"</span>);</span><br><span class="line">objc_object *screens = objc_msgSend(nsScreen, sel_getUid(<span class="string">"screens"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Desugaring "fast enumeration" is particularly knarly.</span></span><br><span class="line"><span class="comment">// for (NSScreen *screen in screens)</span></span><br><span class="line">objc_object *enumerator = objc_msgSend(screens, sel_getUid(<span class="string">"objectEnumerator"</span>));</span><br><span class="line">objc_object *screen;</span><br><span class="line"><span class="keyword">while</span> ((screen = objc_msgSend(enumerator, sel_getUid(<span class="string">"nextObject"</span>)) != <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>你会发现它比 Objective C 代码（实际上只是这类函数调用的语法糖）要“迟钝”得多，因为你需要一直转换所有内容。</p><p>我也完全忘记了手动添加内存管理。 你需要保留/释放一大堆东西。 真是一团糟。 如果你可以管理它，我强烈建议将其编译为 Objective C。</p><p>6) 讨论<a href="https://forums.swift.org/t/does-task-cancellation-propagate-to-urlsessiontasks/65041" title="任务取消是否传播到 URLSession 任务？" target="_blank" rel="noopener">任务取消是否传播到 URLSession 任务？</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="type">Task</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> (data, response) = <span class="keyword">try</span> await <span class="type">URLSession</span>.shared.data(from: <span class="type">URL</span>(string: <span class="string">"https://some-image-url.com"</span>)!)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我执行 <code>task.cancel()</code>，URLSession 是否也会自动取消 <code>URLSessionTask？</code> 假设 URLSessionTask 也被取消似乎很粗心，但我找不到关于此事的任何文档。 但是，如果 URLSessionTask 没有自动取消，那么我不得不使用基于闭包的 <code>URLSession.dataTask(with:,completionHandler:)</code> 来获取对 URLSessionTask 的引用，然后还调用 <code>dataTask.cancel()</code> 在 <code>task.cancel()</code> 之上，这有点奇怪。</p><p><strong>回答</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task will start"</span>)</span><br><span class="line">            <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://postman-echo.com/delay/10"</span>)!</span><br><span class="line">            <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: <span class="number">60.0</span>)</span><br><span class="line">            <span class="keyword">let</span> (data, response) = <span class="keyword">try</span> await <span class="type">URLSession</span>.shared.data(<span class="keyword">for</span>: request)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task did complete, response: <span class="subst">\(response)</span>, data: <span class="subst">\(data)</span>"</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task did error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: will cancel task"</span>)</span><br><span class="line">        t.cancel()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: did cancel task"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: waiting"</span>)</span><br><span class="line">    <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">60</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await main()</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">52</span> +<span class="number">0000</span>: task will start</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: will cancel task</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: did cancel task</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: waiting</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: task did error</span><br></pre></td></tr></table></figure><p>7) 讨论<a href="https://forums.swift.org/t/evolving-the-swift-workgroups/65052" title="发展 Swift 工作组" target="_blank" rel="noopener">发展 Swift 工作组</a></p><p>今天，Swift 核心团队宣布对 Swift 的结构、工作和周围的人进行前瞻性的改变。 这些更改包括新的组、名称、组织以及作为每个组的一流概念的包含。</p><p>链接：<a href="https://www.swift.org/blog/evolving-swift-project-workgroups/" target="_blank" rel="noopener">https://www.swift.org/blog/evolving-swift-project-workgroups/</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7231359714055077946/" title="万字长文详解如何使用 Swift 提高代码质量 | 京东云技术团队" target="_blank" rel="noopener">万字长文详解如何使用 Swift 提高代码质量 | 京东云技术团队</a></p><p><strong>摘要：</strong> 文章介绍了如何使用 Swift 提高代码质量。 Swift 的三个重要特性：富有表现力、安全性和快速。通过使用这些特性，可以提高代码质量并减少 Crash 的发生率。同时，本文还分享了一些实践技巧来提高使用 Swift 编写代码的效率和可读性，如利用编译检查、减少使用 Any/AnyObject 、不推荐大量使用 Dictionary 数据结构等。最后，从性能优化的角度，谈到了使用源代码打包，减少方法动态派发，使用 Slice 共享内存优化性能等来提高代码质量。</p><p><a href="https://swiftwithmajid.com/2023/05/03/the-power-of-overlays-in-swiftui/" title="swiftUI 中视图叠加的强大能力" target="_blank" rel="noopener">swiftUI 中视图叠加的强大能力</a></p><p><strong>摘要：</strong> 本博客文章讨论了 SwiftUI 中两个有趣的叠加使用案例。第一个案例涉及使用叠加来保持视图的结构标识，这对于防止性能问题和状态丢失至关重要。第二个用例是通过叠加视图修饰符构建自定义导航转换，使开发人员能够创建流畅的动画而不依赖 NavigationView 或 NavigationStack。提供示例以说明这些概念，并提供其他资源供进一步学习。总体而言，本文展示了 SwiftUI 中叠加功能的强大之处以及它们如何增强应用程序开发中用户体验。</p><p><a href="https://swiftwithmajid.com/2023/05/10/file-importing-and-exporting-in-swiftui/" title="SwiftUI 中的文件导入和导出" target="_blank" rel="noopener">SwiftUI 中的文件导入和导出</a></p><p><strong>摘要：</strong> 本篇博客讨论了如何使用 fileImporter 和 fileExporter 视图修饰符在 SwiftU I视图中导入和导出文件。文章包括两种操作的代码示例，以及一个额外部分介绍如何使用 fileMover 视图修改器进行文件移动。此外，还介绍了 TextDocument 类型，它符合 FileDocument 协议并允许从文件读取纯文本字符串，并将字符串数据导出到文件。总体而言，这篇文章强调了使用这些简单的视图修饰符可以轻松实现 SwiftUI 应用程序中的文件管理体验。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？</strong></p><p>1、社交隔阂：社交圈子的分隔和交流机会的减少<br>2、忙碌生活：现代社会的快节奏和高压力导致个人时间和精力有限<br>3、数字化社交：社交媒体和在线交友平台的兴起导致<br>4、个人选择标准的提高：个人对伴侣的要求变得更加苛刻，导致匹配的难度增加<br>5、社会观念的变化：个人对恋爱和婚姻的态度发生了变化，导致对寻找恋爱对象的需求减少</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;最无情的永远不是环境，而是缺乏勇气的内心。&lt;strong&gt;Swift社区&lt;/strong&gt;与你一起，赤胆平乱世，长枪定江山！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：担心泄密！外媒：苹果公司限制员工使用ChatGPT&lt;/p&gt;
&lt;p&gt;提案：value 包展开的元组&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Xcode 忽略 Package.resolved 文件&lt;/p&gt;
&lt;p&gt;推荐博文：万字长文详解如何使用 Swift 提高代码质量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
