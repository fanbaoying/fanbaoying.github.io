<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FBY展菲个人博客</title>
  
  <subtitle>『公众号：网罗开发』</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2018-04-06T07:29:35.000Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>FBY展菲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AVFoundation | 封装一个好用的视频播放器</title>
    <link href="https://fanbaoying.github.io/AVFoundation-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://fanbaoying.github.io/AVFoundation-封装一个好用的视频播放器/</id>
    <published>2018-04-06T07:25:43.000Z</published>
    <updated>2018-04-06T07:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="video.png"></p><p>上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。</p><a id="more"></a><ul><li><p>CoreAudio : 处理所有音频事件.是由多个框架整合在一起的总称,为音频和MIDI内容的录制,播放和处理提供相应接口.设置可以针对音频信号进行完全控制,并通过Audio Units来构建一些复杂的音频处理.有兴趣的可以单独了解一下这个框架。</p></li><li><p>CoreMedia: 是AVFoundation所用到低层级媒体管道的一部分.提供音频样本和视频帧处理所需的低层级数据类型和接口。</p></li><li><p>CoreAnimation: 动画相关框架, 封装了支持OpenGL和OpenGL ES功能的ObjC各种类. AVFoundation可以利用CoreAnimation让开发者能够在视频的编辑和播放过程中添加动画和图片效果。</p></li></ul><p>下面我就和大家详细的分享一下，如何使用AVFoundation来实现一个好用的视频播放器。如果好用或者对你有所帮助，不要忘了关注点个赞呦！！！</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>视频控制界面实现</p></li><li><p>用于视频显示的View创建</p></li><li><p>视频数据下载器FBYVideoDownload创建</p></li><li><p>播放、暂停、横竖屏操作方法实现</p></li><li><p>监听播放进度</p></li><li><p>控制存储缓冲范围</p></li><li><p>拖动滑块，控制快进快退</p></li><li><p>定义临时文件路径</p></li><li><p>定义缓存文件夹路径</p></li><li><p>发起视频路径网路请求方法</p></li><li><p>播放结束设置</p></li><li><p>前后视频播放控制</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-视频控制界面实现"><a href="#1-视频控制界面实现" class="headerlink" title="1. 视频控制界面实现"></a>1. 视频控制界面实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (FBYVideoPlayerView *)videoPlayControl&#123;</span><br><span class="line">    if (!_videoPlayControl) &#123;</span><br><span class="line">        _videoPlayControl = [[FBYVideoPlayerView alloc] initWithFrame:self.backgroundView.bounds];</span><br><span class="line">        [self.backgroundView addSubview:_videoPlayControl];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return _videoPlayControl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-用于视频显示的View创建"><a href="#2-用于视频显示的View创建" class="headerlink" title="2. 用于视频显示的View创建"></a>2. 用于视频显示的View创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)videoShowView&#123;</span><br><span class="line">    if (!_videoShowView) &#123;</span><br><span class="line">        _videoShowView = [[UIView alloc] init];</span><br><span class="line">        _videoShowView.layer.masksToBounds = YES;</span><br><span class="line">        [self.backgroundView addSubview:_videoShowView];</span><br><span class="line">    &#125;</span><br><span class="line">    return _videoShowView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-视频数据下载器FBYVideoDownload创建"><a href="#3-视频数据下载器FBYVideoDownload创建" class="headerlink" title="3. 视频数据下载器FBYVideoDownload创建"></a>3. 视频数据下载器FBYVideoDownload创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, weak) id &lt;FBYVideoDownloadDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">//定义初始化方法 传入videoUrl参数（NSString）</span><br><span class="line">- (instancetype)initWithURL:(NSString *)videoUrl withDelegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">//开始下载</span><br><span class="line">- (void)start;</span><br><span class="line">//暂停</span><br><span class="line">- (void)suspend;</span><br><span class="line">//关闭</span><br><span class="line">- (void)cancel;</span><br></pre></td></tr></table></figure><h4 id="4-播放、暂停、横竖屏操作方法实现"><a href="#4-播放、暂停、横竖屏操作方法实现" class="headerlink" title="4. 播放、暂停、横竖屏操作方法实现"></a>4. 播放、暂停、横竖屏操作方法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//全屏</span><br><span class="line">[_videoPlayControl setFullScreenButtonClick_block:^&#123;</span><br><span class="line">    if (weakSelf.delegate &amp;&amp; [weakSelf.delegate respondsToSelector:@selector(videoPlayerDidFullScreenButtonClick)]) &#123;</span><br><span class="line">        [weakSelf.delegate videoPlayerDidFullScreenButtonClick];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">//播放/暂停</span><br><span class="line">[_videoPlayControl setPlayButtonClick_block:^(BOOL play) &#123;</span><br><span class="line">    if (play) &#123;</span><br><span class="line">        [weakSelf.player play];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [weakSelf.player pause];</span><br><span class="line">    &#125;</span><br><span class="line">    weakSelf.playButtonState = !weakSelf.playButtonState;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="5-监听播放进度"><a href="#5-监听播放进度" class="headerlink" title="5. 监听播放进度"></a>5. 监听播放进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.timeObserve = [self.player addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) &#123;</span><br><span class="line">        CGFloat current = CMTimeGetSeconds(time);</span><br><span class="line">        CGFloat total = CMTimeGetSeconds(weakSelf.currentPlayerItem.duration);</span><br><span class="line">        CGFloat progress = current / total;</span><br><span class="line"></span><br><span class="line">        weakSelf.videoPlayControl.currentTime = current;</span><br><span class="line">        weakSelf.videoPlayControl.playValue = progress;</span><br><span class="line"></span><br><span class="line">        if (weakSelf.isCanToGetLocalTime) &#123;</span><br><span class="line">            weakSelf.localTime = [weakSelf getLocalTime];</span><br><span class="line">        &#125;</span><br><span class="line">        NSInteger timeNow = [weakSelf getLocalTime];</span><br><span class="line">        if (timeNow - weakSelf.localTime &gt; 1.5) &#123;</span><br><span class="line">            [weakSelf.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">            weakSelf.isCanToGetLocalTime = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h4 id="6-监听播放器的状态"><a href="#6-监听播放器的状态" class="headerlink" title="6. 监听播放器的状态"></a>6. 监听播放器的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="7-监听当前的缓冲进度"><a href="#7-监听当前的缓冲进度" class="headerlink" title="7. 监听当前的缓冲进度"></a>7. 监听当前的缓冲进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;loadedTimeRanges&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="8-监听到当前没有缓冲数据"><a href="#8-监听到当前没有缓冲数据" class="headerlink" title="8. 监听到当前没有缓冲数据"></a>8. 监听到当前没有缓冲数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;playbackBufferEmpty&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="9-控制存储缓冲范围"><a href="#9-控制存储缓冲范围" class="headerlink" title="9. 控制存储缓冲范围"></a>9. 控制存储缓冲范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)playForActivity&#123;</span><br><span class="line">    if (self.playButtonState) &#123;</span><br><span class="line">        [self.player play];</span><br><span class="line">    &#125;</span><br><span class="line">    self.isBufferEmpty = NO;</span><br><span class="line">    self.isPlaying = YES;</span><br><span class="line">    [self.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-拖动滑块，控制快进快退"><a href="#10-拖动滑块，控制快进快退" class="headerlink" title="10. 拖动滑块，控制快进快退"></a>10. 拖动滑块，控制快进快退</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//拖动滑块</span><br><span class="line">[_videoPlayControl setSliderTouchEnd_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">//快进快退</span><br><span class="line">[_videoPlayControl setFastFastForwardAndRewind_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure><h4 id="11-定义临时文件路径"><a href="#11-定义临时文件路径" class="headerlink" title="11. 定义临时文件路径"></a>11. 定义临时文件路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoTempPath = [NSString tempFilePathWithFileName:videoName];</span><br></pre></td></tr></table></figure><h4 id="12-定义缓存文件夹路径"><a href="#12-定义缓存文件夹路径" class="headerlink" title="12. 定义缓存文件夹路径"></a>12. 定义缓存文件夹路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoCachePath = [NSString cacheFilePathWithName:videoName];</span><br></pre></td></tr></table></figure><h4 id="13-发起视频路径网路请求方法"><a href="#13-发起视频路径网路请求方法" class="headerlink" title="13. 发起视频路径网路请求方法"></a>13. 发起视频路径网路请求方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendHttpRequst</span><br><span class="line">&#123;</span><br><span class="line">    [_fileHandle seekToEndOfFile];</span><br><span class="line">    NSURL *url = [NSURL URLWithString:_videoUrl];</span><br><span class="line">    NSMutableURLRequest *requeset = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    //指定头信息  当前已下载的进度</span><br><span class="line">    [requeset setValue:[NSString stringWithFormat:@&quot;bytes=%ld-&quot;, _curruentLength] forHTTPHeaderField:@&quot;Range&quot;];</span><br><span class="line"></span><br><span class="line">    //创建请求</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self.session dataTaskWithRequest:requeset];</span><br><span class="line">    self.dataTask = dataTask;</span><br><span class="line"></span><br><span class="line">    //发起请求</span><br><span class="line">    [self.dataTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-播放结束设置"><a href="#14-播放结束设置" class="headerlink" title="14. 播放结束设置"></a>14. 播放结束设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)playerItemDidPlayToEnd:(NSNotification *)notification&#123;</span><br><span class="line">    //重新开始播放</span><br><span class="line">    __weak typeof(self) weak_self = self;</span><br><span class="line">    [self.player seekToTime:CMTimeMake(0, 1) completionHandler:^(BOOL finished) &#123;</span><br><span class="line">        __strong typeof(weak_self) strong_self = weak_self;</span><br><span class="line">        if (!strong_self) return;</span><br><span class="line">        [strong_self.player play];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-前后视频播放控制"><a href="#15-前后视频播放控制" class="headerlink" title="15. 前后视频播放控制"></a>15. 前后视频播放控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//进入后台</span><br><span class="line">- (void)appDidEnterBackground&#123;</span><br><span class="line">    if (self.stopWhenAppDidEnterBackground) &#123;</span><br><span class="line">        [self pauseVideo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//进入前台</span><br><span class="line">- (void)appDidEnterForeground&#123;</span><br><span class="line">    [self playVideo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYVideoData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"><a href="#2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理" class="headerlink" title="2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"></a>2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYVideoPlayer.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;FBYVideoPlayerDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic ,strong) FBYVideoPlayer *videoPlayer;</span><br><span class="line">@property (nonatomic ,strong) UIView *videoPlayBGView;</span><br><span class="line">@property (nonatomic ,copy)   NSString*videoUrl;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-初始化创建基层view"><a href="#3-初始化创建基层view" class="headerlink" title="3. 初始化创建基层view"></a>3. 初始化创建基层view</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayBGView = [[UIView alloc] initWithFrame:CGRectMake(0, 90, SCREEN_WIDTH, SCREEN_WIDTH * 0.6)];</span><br><span class="line">self.videoPlayBGView.backgroundColor = [UIColor blackColor];</span><br><span class="line">    [self.view addSubview:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="4-初始化调用视频播放方法"><a href="#4-初始化调用视频播放方法" class="headerlink" title="4. 初始化调用视频播放方法"></a>4. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="5-初始化调用视频播放方法"><a href="#5-初始化调用视频播放方法" class="headerlink" title="5. 初始化调用视频播放方法"></a>5. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYVideoPlayer-iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;video.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>人脸识别 -- 活体检测(张嘴摇头识别)</title>
    <link href="https://fanbaoying.github.io/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%B4%BB%E4%BD%93%E6%A3%80%E6%B5%8B-%E5%BC%A0%E5%98%B4%E6%91%87%E5%A4%B4%E8%AF%86%E5%88%AB/"/>
    <id>https://fanbaoying.github.io/人脸识别-活体检测-张嘴摇头识别/</id>
    <published>2018-03-19T01:14:22.000Z</published>
    <updated>2018-03-19T01:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。</p><p>大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。</p><p>在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>点击识别按钮，调用相机</p></li><li><p>CameraRules类，检测相机权限</p></li><li><p>初始化页面，创建摄像页面，创建张嘴数据和摇头数据</p></li><li><p>开启识别，脸部框识别</p></li><li><p>脸部部位识别，脸部识别判断是否检测到人脸</p></li><li><p>检测到人脸之后，判断位置</p></li><li><p>位置判断合适，判断是否张嘴</p></li><li><p>张嘴判断完毕，验证是否摇头</p></li><li><p>摇头判断完毕，3秒倒计时拍照</p></li><li><p>拍照完毕，选择重拍或者上传图片</p></li><li><p>选择重拍重复5-9步骤，选择上传将图片数据回调</p></li><li><p>数据clean</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-点击识别按钮，调用相机"><a href="#1-点击识别按钮，调用相机" class="headerlink" title="1. 点击识别按钮，调用相机"></a>1. 点击识别按钮，调用相机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if([CameraRules isCapturePermissionGranted])&#123;</span><br><span class="line">        [self setDeviceAuthorized:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSString* info=@&quot;没有相机权限&quot;;</span><br><span class="line">            [self showAlert:info];</span><br><span class="line">            [self setDeviceAuthorized:NO];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-CameraRules类，检测相机权限"><a href="#2-CameraRules类，检测相机权限" class="headerlink" title="2. CameraRules类，检测相机权限"></a>2. CameraRules类，检测相机权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//检测相机权限</span><br><span class="line">+(BOOL)isCapturePermissionGranted&#123;</span><br><span class="line">    if([AVCaptureDevice respondsToSelector:@selector(authorizationStatusForMediaType:)])&#123;</span><br><span class="line">        AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];</span><br><span class="line">        if(authStatus ==AVAuthorizationStatusRestricted || authStatus ==AVAuthorizationStatusDenied)&#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(authStatus==AVAuthorizationStatusNotDetermined)&#123;</span><br><span class="line">            dispatch_semaphore_t sema = dispatch_semaphore_create(0);</span><br><span class="line">            __block BOOL isGranted=YES;</span><br><span class="line">            [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) &#123;</span><br><span class="line">                isGranted=granted;</span><br><span class="line">                dispatch_semaphore_signal(sema);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">            return isGranted;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据"><a href="#3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据" class="headerlink" title="3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据"></a>3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建摄像页面，创建张嘴数据和摇头数据</span><br><span class="line">[self faceUI];</span><br><span class="line">[self faceCamera];</span><br><span class="line">[self faceNumber];</span><br></pre></td></tr></table></figure><h4 id="4-开启识别，脸部框识别"><a href="#4-开启识别，脸部框识别" class="headerlink" title="4. 开启识别，脸部框识别"></a>4. 开启识别，脸部框识别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float cx = (left+right)/2;</span><br><span class="line">float cy = (top + bottom)/2;</span><br><span class="line">float w = right - left;</span><br><span class="line">float h = bottom - top;</span><br><span class="line">float ncx = cy ;</span><br><span class="line">float ncy = cx ;</span><br><span class="line"></span><br><span class="line">CGRect rectFace = CGRectMake(ncx-w/2 ,ncy-w/2 , w, h);</span><br><span class="line"></span><br><span class="line">if(!isFrontCamera)&#123;</span><br><span class="line">    rectFace=rSwap(rectFace);</span><br><span class="line">    rectFace=rRotate90(rectFace, faceImg.height, faceImg.width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL isNotLocation = [self identifyYourFaceLeft:left right:right top:top bottom:bottom];</span><br><span class="line"></span><br><span class="line">if (isNotLocation==YES) &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-脸部部位识别，脸部识别判断是否检测到人脸"><a href="#5-脸部部位识别，脸部识别判断是否检测到人脸" class="headerlink" title="5. 脸部部位识别，脸部识别判断是否检测到人脸"></a>5. 脸部部位识别，脸部识别判断是否检测到人脸</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for(id key in keys)&#123;</span><br><span class="line">    id attr=[landmarkDic objectForKey:key];</span><br><span class="line">    if(attr &amp;&amp; [attr isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line"></span><br><span class="line">        if(!isFrontCamera)&#123;</span><br><span class="line">            p=pSwap(p);</span><br><span class="line">            p=pRotate90(p, faceImg.height, faceImg.width);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isCrossBorder == YES) &#123;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        p=pScale(p, widthScaleBy, heightScaleBy);</span><br><span class="line"></span><br><span class="line">        [arrStrPoints addObject:NSStringFromCGPoint(p)];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-检测到人脸之后，判断位置动作提醒"><a href="#6-检测到人脸之后，判断位置动作提醒" class="headerlink" title="6. 检测到人脸之后，判断位置动作提醒"></a>6. 检测到人脸之后，判断位置动作提醒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if (right - left &lt; 230 || bottom - top &lt; 250) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太远了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else if (right - left &gt; 320 || bottom - top &gt; 320) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太近了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    if (isJudgeMouth != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复张嘴动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line"></span><br><span class="line">        if (left &lt; 100 || top &lt; 100 || right &gt; 460 || bottom &gt; 400) &#123;</span><br><span class="line">            isCrossBorder = YES;</span><br><span class="line">            isJudgeMouth = NO;</span><br><span class="line">            self.textLabel.text = @&quot;调整下位置先&quot;;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (isJudgeMouth == YES &amp;&amp; isShakeHead != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复摇头动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;shakeHead&quot; count:4];</span><br><span class="line">        number = 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        takePhotoNumber += 1;</span><br><span class="line">        if (takePhotoNumber == 2) &#123;</span><br><span class="line">            [self timeBegin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isCrossBorder = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-位置判断合适，判断是否张嘴"><a href="#7-位置判断合适，判断是否张嘴" class="headerlink" title="7. 位置判断合适，判断是否张嘴"></a>7. 位置判断合适，判断是否张嘴</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (rightX &amp;&amp; leftX &amp;&amp; upperY &amp;&amp; lowerY &amp;&amp; isJudgeMouth != YES) &#123;</span><br><span class="line"></span><br><span class="line">    number ++;</span><br><span class="line">    if (number == 1 || number == 300 || number == 600 || number ==900) &#123;</span><br><span class="line">        mouthWidthF = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">        mouthHeightF = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">        NSLog(@&quot;%d,%d&quot;,mouthWidthF,mouthHeightF);</span><br><span class="line">    &#125;else if (number &gt; 1200) &#123;</span><br><span class="line">        [self delateNumber];</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mouthWidth = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">    mouthHeight = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">    NSLog(@&quot;%d,%d&quot;,mouthWidth,mouthHeight);</span><br><span class="line">    NSLog(@&quot;张嘴前：width=%d，height=%d&quot;,mouthWidthF - mouthWidth,mouthHeight - mouthHeightF);</span><br><span class="line">    if (mouthWidth &amp;&amp; mouthWidthF) &#123;</span><br><span class="line"></span><br><span class="line">        if (mouthHeight - mouthHeightF &gt;= 20 &amp;&amp; mouthWidthF - mouthWidth &gt;= 15) &#123;</span><br><span class="line">            isJudgeMouth = YES;</span><br><span class="line">            imgView.animationImages = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-张嘴判断完毕，验证是否摇头"><a href="#8-张嘴判断完毕，验证是否摇头" class="headerlink" title="8. 张嘴判断完毕，验证是否摇头"></a>8. 张嘴判断完毕，验证是否摇头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if ([key isEqualToString:@&quot;mouth_middle&quot;] &amp;&amp; isJudgeMouth == YES) &#123;</span><br><span class="line"></span><br><span class="line">        if (bigNumber == 0 ) &#123;</span><br><span class="line">            firstNumber = p.x;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &gt; bigNumber) &#123;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &lt; smallNumber) &#123;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bigNumber - smallNumber &gt; 60) &#123;</span><br><span class="line">            isShakeHead = YES;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="9-摇头判断完毕，3秒倒计时拍照"><a href="#9-摇头判断完毕，3秒倒计时拍照" class="headerlink" title="9. 摇头判断完毕，3秒倒计时拍照"></a>9. 摇头判断完毕，3秒倒计时拍照</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(timeCount &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        self.textLabel.text = [NSString  stringWithFormat:@&quot;%ld s后拍照&quot;,(long)timeCount];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        [theTimer invalidate];</span><br><span class="line">        theTimer=nil;</span><br><span class="line"></span><br><span class="line">        [self didClickTakePhoto];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="10-拍照完毕，选择重拍或者上传图片"><a href="#10-拍照完毕，选择重拍或者上传图片" class="headerlink" title="10. 拍照完毕，选择重拍或者上传图片"></a>10. 拍照完毕，选择重拍或者上传图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickPhotoAgain</span><br><span class="line">&#123;</span><br><span class="line">    [self delateNumber];</span><br><span class="line"></span><br><span class="line">    [self.previewLayer.session startRunning];</span><br><span class="line">    self.textLabel.text = @&quot;请调整位置&quot;;</span><br><span class="line"></span><br><span class="line">    [backView removeFromSuperview];</span><br><span class="line"></span><br><span class="line">    isJudgeMouth = NO;</span><br><span class="line">    isShakeHead = NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-选择重拍重复5-9步骤，选择上传将图片数据回调"><a href="#11-选择重拍重复5-9步骤，选择上传将图片数据回调" class="headerlink" title="11. 选择重拍重复5-9步骤，选择上传将图片数据回调"></a>11. 选择重拍重复5-9步骤，选择上传将图片数据回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickUpPhoto</span><br><span class="line">&#123;</span><br><span class="line">    //上传照片成功</span><br><span class="line">    [self.faceDelegate sendFaceImage:imageView.image];</span><br><span class="line">    [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-数据clean"><a href="#12-数据clean" class="headerlink" title="12. 数据clean"></a>12. 数据clean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)delateNumber</span><br><span class="line">&#123;</span><br><span class="line">    number = 0;</span><br><span class="line">    takePhotoNumber = 0;</span><br><span class="line"></span><br><span class="line">    mouthWidthF = 0;</span><br><span class="line">    mouthHeightF = 0;</span><br><span class="line">    mouthWidth = 0;</span><br><span class="line">    mouthHeight = 0;</span><br><span class="line"></span><br><span class="line">    smallNumber = 0;</span><br><span class="line">    bigNumber = 0;</span><br><span class="line">    firstNumber = 0;</span><br><span class="line"></span><br><span class="line">    imgView.animationImages = nil;</span><br><span class="line">    imgView.image = [UIImage imageNamed:@&quot;shakeHead0&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：讯飞SDK下载及配置"><a href="#四：讯飞SDK下载及配置" class="headerlink" title="四：讯飞SDK下载及配置"></a>四：讯飞SDK下载及配置</h2><h4 id="1-SDK下载"><a href="#1-SDK下载" class="headerlink" title="1. SDK下载"></a>1. SDK下载</h4><p>因为项目中使用到讯飞人脸识别SDK，需要去<a href="http://console.xfyun.cn/app/edit?appId=NWFhNjI3OTM%3D&amp;appName=RkJZRmFjZVJlY29nbml0aW9uX2lPUw%3D%3D" target="_blank" rel="noopener">讯飞开放平台</a>创建应用，下载SDK。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b10687203a879c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><h4 id="2-添加系统库"><a href="#2-添加系统库" class="headerlink" title="2. 添加系统库"></a>2. 添加系统库</h4><p>将开发工具包中lib目录下的iflyMSC.framework添加到工程中。同时请将Demo中依赖的其他库也添加到工程中。 按下图示例添加 SDK 所需要的 iOS系统库：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-93809e5d166a1633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="88.png"></p><h4 id="3-设置Bitcode"><a href="#3-设置Bitcode" class="headerlink" title="3. 设置Bitcode"></a>3. 设置Bitcode</h4><p>在Targets - Build Settings 中搜索Bitcode 即可，找到相应选项，设置为NO，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-3414999985ccd080.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="333.jpg"></p><h4 id="4-用户隐私权限配置"><a href="#4-用户隐私权限配置" class="headerlink" title="4. 用户隐私权限配置"></a>4. 用户隐私权限配置</h4><p>在Info.plist 中增加下图设置：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-19d0d89539d05cbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="444.png"></p><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYFaceData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYFaceRecognitionViewController"><a href="#2-在项目中引入FBYFaceRecognitionViewController" class="headerlink" title="2. 在项目中引入FBYFaceRecognitionViewController"></a>2. 在项目中引入FBYFaceRecognitionViewController</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYFaceRecognitionViewController.h&quot;</span><br></pre></td></tr></table></figure><h4 id="3-在项目识别按钮的点击事件中添加代码"><a href="#3-在项目识别按钮的点击事件中添加代码" class="headerlink" title="3. 在项目识别按钮的点击事件中添加代码"></a>3. 在项目识别按钮的点击事件中添加代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)pushToFaceStreamDetectorVC</span><br><span class="line">&#123;</span><br><span class="line">    FBYFaceRecognitionViewController *faceVC = [[FBYFaceRecognitionViewController alloc]init];</span><br><span class="line">    faceVC.faceDelegate = self;</span><br><span class="line">    [self.navigationController pushViewController:faceVC animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-图片回调函数"><a href="#4-图片回调函数" class="headerlink" title="4. 图片回调函数"></a>4. 图片回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)sendFaceImage:(UIImage *)faceImage</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;图片上传成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendFaceImageError &#123;</span><br><span class="line">    NSLog(@&quot;图片上传失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYFaceRecognitionDemo_iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。&lt;/p&gt;
&lt;p&gt;大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。&lt;/p&gt;
&lt;p&gt;在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 识别集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%AF%86%E5%88%AB%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 实现点击图片放大</title>
    <link href="https://fanbaoying.github.io/iOS-%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7/"/>
    <id>https://fanbaoying.github.io/iOS-实现点击图片放大/</id>
    <published>2018-03-06T02:02:13.000Z</published>
    <updated>2018-03-06T02:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>给UIImageView添加手势</p></li><li><p>封装一个继承NSObject的FBYImageZoom类</p></li><li><p>写一个函数用来接收出入的UIImageView</p></li><li><p>根据传入的UIImageView重新绘制在Window中</p></li><li><p>添加放大后背景视图的颜色和透明度</p></li><li><p>使用动画放大展示ImageView</p></li><li><p>添加恢复ImageView原始尺寸的tap点击事件</p></li><li><p>完成之后将背景视图删掉</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-给UIImageView添加手势"><a href="#1-给UIImageView添加手势" class="headerlink" title="1. 给UIImageView添加手势"></a>1. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.myImageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 150, SCREEN_WIDTH-100, SCREEN_WIDTH-100)];</span><br><span class="line">self.myImageView.image = [UIImage imageNamed:@&quot;bankcard&quot;];</span><br><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br><span class="line">[_myImageView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line">[_myImageView setUserInteractionEnabled:YES];</span><br><span class="line">[self.view addSubview:_myImageView];</span><br></pre></td></tr></table></figure><h4 id="2-封装一个继承NSObject的FBYImageZoom类"><a href="#2-封装一个继承NSObject的FBYImageZoom类" class="headerlink" title="2. 封装一个继承NSObject的FBYImageZoom类"></a>2. 封装一个继承NSObject的FBYImageZoom类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYImageZoom : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-写一个函数用来接收出入的UIImageView"><a href="#3-写一个函数用来接收出入的UIImageView" class="headerlink" title="3. 写一个函数用来接收出入的UIImageView"></a>3. 写一个函数用来接收出入的UIImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @param contentImageview 图片所在的imageView</span><br><span class="line"> */</span><br><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview;</span><br></pre></td></tr></table></figure><h4 id="4-根据传入的UIImageView重新绘制在Window中"><a href="#4-根据传入的UIImageView重新绘制在Window中" class="headerlink" title="4. 根据传入的UIImageView重新绘制在Window中"></a>4. 根据传入的UIImageView重新绘制在Window中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview&#123;</span><br><span class="line"></span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    [self scanBigImageWithImage:contentImageview.image frame:[contentImageview convertRect:contentImageview.bounds toView:window]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-添加放大后背景视图的颜色和透明度"><a href="#5-添加放大后背景视图的颜色和透明度" class="headerlink" title="5. 添加放大后背景视图的颜色和透明度"></a>5. 添加放大后背景视图的颜色和透明度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当前视图</span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    //背景</span><br><span class="line">    UIView *backgroundView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">    [backgroundView setBackgroundColor:[UIColor colorWithRed:107/255.0 green:107/255.0 blue:99/255.0 alpha:0.6]];</span><br></pre></td></tr></table></figure><h4 id="6-使用动画放大展示ImageView"><a href="#6-使用动画放大展示ImageView" class="headerlink" title="6. 使用动画放大展示ImageView"></a>6. 使用动画放大展示ImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//动画放大所展示的ImageView</span><br><span class="line">[UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">    CGFloat y,width,height;</span><br><span class="line">    y = ([UIScreen mainScreen].bounds.size.height - image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width) * 0.5;</span><br><span class="line">    //宽度为屏幕宽度</span><br><span class="line">    width = [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">    //高度 根据图片宽高比设置</span><br><span class="line">    height = image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width;</span><br><span class="line">    [imageView setFrame:CGRectMake(0, y, width, height)];</span><br><span class="line">    //重要！ 将视图显示出来</span><br><span class="line">    [backgroundView setAlpha:1];</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="7-添加恢复ImageView原始尺寸的tap点击事件"><a href="#7-添加恢复ImageView原始尺寸的tap点击事件" class="headerlink" title="7. 添加恢复ImageView原始尺寸的tap点击事件"></a>7. 添加恢复ImageView原始尺寸的tap点击事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件同样是类方法 -&gt; 作用是再次点击回到初始大小</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hideImageView:)];</span><br><span class="line">[backgroundView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  恢复imageView原始尺寸</span><br><span class="line"> */</span><br><span class="line">+(void)hideImageView:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    UIView *backgroundView = tap.view;</span><br><span class="line">    //原始imageview</span><br><span class="line">    UIImageView *imageView = [tap.view viewWithTag:1024];</span><br><span class="line">    //恢复</span><br><span class="line">    [UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">        [imageView setFrame:oldframe];</span><br><span class="line">        [backgroundView setAlpha:0];</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        [backgroundView removeFromSuperview];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-完成之后将背景视图删掉"><a href="#8-完成之后将背景视图删掉" class="headerlink" title="8. 完成之后将背景视图删掉"></a>8. 完成之后将背景视图删掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//完成后操作-&gt;将背景视图删掉</span><br><span class="line">[backgroundView removeFromSuperview];</span><br></pre></td></tr></table></figure><h2 id="四：项目实际使用"><a href="#四：项目实际使用" class="headerlink" title="四：项目实际使用"></a>四：项目实际使用</h2><h4 id="1-引入封装类FBYImageZoom"><a href="#1-引入封装类FBYImageZoom" class="headerlink" title="1. 引入封装类FBYImageZoom"></a>1. 引入封装类FBYImageZoom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYImageZoom.h&quot;</span><br></pre></td></tr></table></figure><h4 id="2-给UIImageView添加手势"><a href="#2-给UIImageView添加手势" class="headerlink" title="2. 给UIImageView添加手势"></a>2. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br></pre></td></tr></table></figure><h4 id="3-调用封装类函数"><a href="#3-调用封装类函数" class="headerlink" title="3. 调用封装类函数"></a>3. 调用封装类函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//浏览大图点击事件</span><br><span class="line">-(void)scanBigImageClick:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    NSLog(@&quot;点击图片&quot;);</span><br><span class="line">    UIImageView *clickedImageView = (UIImageView *)tap.view;</span><br><span class="line">    [FBYImageZoom ImageZoomWithImageView:clickedImageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里点击图片放大到全屏就完成了</p><h2 id="五：项目展示"><a href="#五：项目展示" class="headerlink" title="五：项目展示"></a>五：项目展示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161f900f7b9f73d6?w=300&amp;h=500&amp;f=gif&amp;s=1992499" alt=""></p><h4 id="六-本篇文章demo源码："><a href="#六-本篇文章demo源码：" class="headerlink" title="六. 本篇文章demo源码："></a>六. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYImageZoom-iOS" target="_blank" rel="noopener">github demo</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIDatePicker | 时间选择器</title>
    <link href="https://fanbaoying.github.io/iOS-UIDatePicker%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85/"/>
    <id>https://fanbaoying.github.io/iOS-UIDatePicker的使用详情/</id>
    <published>2018-02-09T07:25:17.000Z</published>
    <updated>2018-02-11T01:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：UIDatePicker的介绍"><a href="#一：UIDatePicker的介绍" class="headerlink" title="一：UIDatePicker的介绍"></a>一：UIDatePicker的介绍</h2><p>UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。<br>日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。<br>你也可以对其进行定制，令其使用任何范围的日期。</p><p>UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。<br>iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。<br>使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。<br>UIDatePicker给出了倒计时模式，但是并没有实现相关事件。<br>如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。</p><a id="more"></a><h2 id="二：UIDatePicker的使用"><a href="#二：UIDatePicker的使用" class="headerlink" title="二：UIDatePicker的使用"></a>二：UIDatePicker的使用</h2><h2 id="2-1-创建并添加一个UIDatePicker对象"><a href="#2-1-创建并添加一个UIDatePicker对象" class="headerlink" title="2.1 创建并添加一个UIDatePicker对象"></a>2.1 创建并添加一个UIDatePicker对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  DatePicker</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">//创建对象</span><br><span class="line">@property (nonatomic, strong) UIDatePicker *datePicker;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="2-2-配置UIDatePicker对象"><a href="#2-2-配置UIDatePicker对象" class="headerlink" title="2.2 配置UIDatePicker对象"></a>2.2 配置UIDatePicker对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupDateKeyPan &#123;</span><br><span class="line"></span><br><span class="line">    UIDatePicker *datePicker = [[UIDatePicker alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置地区: zh-中国</span><br><span class="line">    datePicker.locale = [NSLocale localeWithLocaleIdentifier:@&quot;zh&quot;];</span><br><span class="line"></span><br><span class="line">    //设置日期模式(Displays month, day, and year depending on the locale setting)</span><br><span class="line">    datePicker.datePickerMode = UIDatePickerModeCountDownTimer;</span><br><span class="line">    // 设置当前显示时间</span><br><span class="line">    [datePicker setDate:[NSDate date] animated:YES];</span><br><span class="line">    // 设置显示最大时间（此处为当前时间）</span><br><span class="line">    [datePicker setMaximumDate:[NSDate date]];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line"></span><br><span class="line">    //监听DataPicker的滚动</span><br><span class="line">    [datePicker addTarget:self action:@selector(dateChange:) forControlEvents:UIControlEventValueChanged];</span><br><span class="line"></span><br><span class="line">    self.datePicker = datePicker;</span><br><span class="line"></span><br><span class="line">    //设置时间输入框的键盘框样式为时间选择器</span><br><span class="line">    self.timeTextField.inputView = datePicker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-禁止用户输入文字"><a href="#2-3-禁止用户输入文字" class="headerlink" title="2.3 禁止用户输入文字"></a>2.3 禁止用户输入文字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//禁止用户输入文字</span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">  return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-显示文本"><a href="#2-4-显示文本" class="headerlink" title="2.4 显示文本"></a>2.4 显示文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)dateChange:(UIDatePicker *)datePicker &#123;</span><br><span class="line"></span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line">    formatter.dateFormat = @&quot;yyyy年 MM月 dd日&quot;;</span><br><span class="line">    NSString *dateStr = [formatter  stringFromDate:datePicker.date];</span><br><span class="line"></span><br><span class="line">    self.timeTextField.text = dateStr;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="三：选择模式"><a href="#三：选择模式" class="headerlink" title="三：选择模式"></a>三：选择模式</h2><p>日期/时间选取器持4种不同模式的选择方式。<br>通过设置 datePickerMode 属性，可以定义选择模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.datePickerMode = UIDatePickerModeTime;</span><br></pre></td></tr></table></figure></p><p>支持的模式：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a1d8372b?w=600&amp;h=214&amp;f=png&amp;s=93770" alt="支持模式"></p><p>四种时间模式样式截图如下：</p><h4 id="3-1-UIDatePickerModeTime"><a href="#3-1-UIDatePickerModeTime" class="headerlink" title="3.1 UIDatePickerModeTime"></a>3.1 UIDatePickerModeTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a01a3438?w=600&amp;h=1065&amp;f=jpeg&amp;s=20585" alt="UIDatePickerModeTime"><br>在这种模式下，显示时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-2-UIDatePickerModeDate"><a href="#3-2-UIDatePickerModeDate" class="headerlink" title="3.2 UIDatePickerModeDate"></a>3.2 UIDatePickerModeDate</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a20f7db1?w=600&amp;h=1065&amp;f=jpeg&amp;s=28097" alt="UIDatePickerModeDate"></p><p>在这种模式下，显示年、月、日。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-3-UIDatePickerModeDateAndTime"><a href="#3-3-UIDatePickerModeDateAndTime" class="headerlink" title="3.3 UIDatePickerModeDateAndTime"></a>3.3 UIDatePickerModeDateAndTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa39d537561?w=600&amp;h=1065&amp;f=jpeg&amp;s=28835" alt="UIDatePickerModeDateAndTime"></p><p>在这种模式下，显示日期的月、日、星期，时间的时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-4-UIDatePickerModeCountDownTimer"><a href="#3-4-UIDatePickerModeCountDownTimer" class="headerlink" title="3.4 UIDatePickerModeCountDownTimer"></a>3.4 UIDatePickerModeCountDownTimer</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a24ca874?w=600&amp;h=1065&amp;f=jpeg&amp;s=21341" alt="UIDatePickerModeCountDownTimer"></p><p>在这种模式下，显示时、分。应用程序必须实现一个计数器（NSTimer对象），让倒计时中的时间不断减少。</p><h2 id="四：日期范围"><a href="#四：日期范围" class="headerlink" title="四：日期范围"></a>四：日期范围</h2><p>你可以通过设置mininumDate 和 maxinumDate 属性，来指定使用的日期范围。如果用户试图滚动到超出这一范围的日期，表盘会回滚到最近的有效日期。两个方法都需要NSDate 对象作参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDate* minDate = [[NSDate alloc]initWithString:@&quot;1900-01-01 00:00:00 -0500&quot;];    </span><br><span class="line">NSDate* maxDate = [[NSDate alloc]initWithString:@&quot;2099-01-01 00:00:00 -0500&quot;];    </span><br><span class="line"></span><br><span class="line">datePicker.minimumDate = minDate;    </span><br><span class="line">datePicker.maximumDate = maxDate;</span><br></pre></td></tr></table></figure></p><p>如果两个日期范围属性中任何一个未被设置，则默认行为将会允许用户选择过去或未来的任意日期。这在某些情况下很有用处，比如，当选择生日时，可以是过去的任意日期，但终止与当前日期。如果你希望设置默认显示的日期，可以使用date属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.date = minDate;</span><br></pre></td></tr></table></figure><p>此外，你还可以用 setDate 方法。如果选择了使用动画，则表盘会滚动到你指定的日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[datePicker setDate:maxDate animated:YES];</span><br></pre></td></tr></table></figure><h4 id="4-本篇文章demo源码："><a href="#4-本篇文章demo源码：" class="headerlink" title="4. 本篇文章demo源码："></a>4. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">UIDatePicker–DEMO</a></p><hr><p>欢迎关注我的公众号：网罗开发</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/29/1613fe638def80c9?w=300&amp;h=300&amp;f=jpeg&amp;s=21616" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;a href=&quot;#一：UIDatePicker的介绍&quot; class=&quot;headerlink&quot; title=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;/a&gt;一：UIDatePicker的介绍&lt;/h2&gt;&lt;p&gt;UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。&lt;br&gt;日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。&lt;br&gt;你也可以对其进行定制，令其使用任何范围的日期。&lt;/p&gt;
&lt;p&gt;UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。&lt;br&gt;iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。&lt;br&gt;使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。&lt;br&gt;UIDatePicker给出了倒计时模式，但是并没有实现相关事件。&lt;br&gt;如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 文集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS发红包页面</title>
    <link href="https://fanbaoying.github.io/iOS%E5%8F%91%E7%BA%A2%E5%8C%85%E9%A1%B5%E9%9D%A2/"/>
    <id>https://fanbaoying.github.io/iOS发红包页面/</id>
    <published>2018-02-07T09:38:47.000Z</published>
    <updated>2018-02-07T09:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS APP发红包页面制作，可直接参考源码，节约开发时间。<br><a href="https://github.com/fanbaoying/GiveRedEnvelopes" target="_blank" rel="noopener">点击获取GitHub 源码</a></p><p>来源：来自 qq:668562416 “西安 - 梦龙雪糕” 的贡献</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2829694-0086035242f8609e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="22.png"></p><p>其他干货信息：</p><ul><li><a href="https://github.com/fanbaoying/MsgPlaySound" target="_blank" rel="noopener">获取系统震动和声音</a>(来自”西安 - 梦龙雪糕” 的贡献)</li><li><a href="https://github.com/fanbaoying/AFN-YYCache" target="_blank" rel="noopener">AFN-YYCache二次封装网络请求</a>(来自”MrGoodbye”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYFMDBDemo" target="_blank" rel="noopener">FMDB | 实现数据的增删改查</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYDataDisplay-iOS" target="_blank" rel="noopener">iOS折线图统计图</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYIDCardRecognition-Android" target="_blank" rel="noopener">Android 银行卡身份证识别demo</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYBankCardRecognition-iOS" target="_blank" rel="noopener">iOS 银行卡识别demo</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYIDCardRecognition-iOS" target="_blank" rel="noopener">iOS 身份证识别demo</a>(来自”FBY展菲”的贡献)</li></ul><p>更多干货信息请到：GitHub: <a href="https://github.com/fanbaoying" target="_blank" rel="noopener">https://github.com/fanbaoying</a> 下载</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS APP发红包页面制作，可直接参考源码，节约开发时间。&lt;br&gt;&lt;a href=&quot;https://github.com/fanbaoying/GiveRedEnvelopes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击获取GitHub 源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：来自 qq:668562416 “西安 - 梦龙雪糕” 的贡献&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 贡献集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%B4%A1%E7%8C%AE%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Apple Pay开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-Apple-Pay%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-Apple-Pay开发流程/</id>
    <published>2018-02-06T08:00:31.000Z</published>
    <updated>2018-02-06T08:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下Apple_pay，其他支付也写了对应教程，并且给出了连接。</p><a id="more"></a><h2 id="二：支付流程介绍"><a href="#二：支付流程介绍" class="headerlink" title="二：支付流程介绍"></a>二：支付流程介绍</h2><h2 id="2-1-Apple-Pay-页面演示"><a href="#2-1-Apple-Pay-页面演示" class="headerlink" title="2.1 Apple Pay 页面演示"></a>2.1 Apple Pay 页面演示</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3bdb0c80?w=1240&amp;h=871&amp;f=png&amp;s=238050" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3f1fee30?w=1240&amp;h=974&amp;f=png&amp;s=216268" alt="Apple Pay 页面演示"></p><ol><li>买家在手机应用中购买商品或服务，在订单页面中展示 Apple Pay 按钮</li><li>通过银联控件，掉起 Apple Pay 支付页面</li><li>用户通过支付页面验证 Touch ID，输入银行卡密码 是否需要输入银行卡密码取决于交易限额和银行支持情况</li><li>支付成功，商户应用内展示成功页面<br>(1)支付成功页面应参照 UI 示例，展示“银联”标识，“云闪付”标识。<br>(2)银联 SDK 控件支持折扣功能。在折扣活动期间，商户应用内应参照实例 UI 进行原金 额、折扣金额的展示</li></ol><h3 id="2-2-Apple-Pay-支付的实现方式"><a href="#2-2-Apple-Pay-支付的实现方式" class="headerlink" title="2.2 Apple Pay 支付的实现方式"></a>2.2 Apple Pay 支付的实现方式</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3bcc2b63?w=1240&amp;h=774&amp;f=png&amp;s=76672" alt="Apple Pay 支付的实现方式"></p><p>1-2. 商户生成订单，通过商户 SERVER 端将订单信息发送给银联支付网关;<br>3-4. 银联支付网关记录订单信息，返回用来标识订单的 TN 号，经由商户 SERVER 返回至给 商户 APP;<br>5.商户 APP 调用银联 SDK，将 TN 号传递给银联 SDK<br>6.银联 SDK 向 Apple 公司的 PASSKIT FRAMEWORK 发起支付请求;<br>7.接口返回加密的支付 Token 信息;<br>8-9.银联 SDK 将支付 Token 传递给银联支付网关，完成交易认证;<br>10-12.银联将支付结果返回给商户 APP，商户 SERVER，商户 APP 负责提示用户交易结果。</p><h2 id="三：工程配置"><a href="#三：工程配置" class="headerlink" title="三：工程配置"></a>三：工程配置</h2><p>bundleID设置</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3be01987?w=1069&amp;h=245&amp;f=png&amp;s=55370" alt="bundleID设置"></p><p>Capability中启用Apple Pay权限，并选择merchantID，<a href="https://juejin.im/post/5a31e031f265da430a50971e" target="_blank" rel="noopener">merchantID申请流程</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db41f7cd8f?w=873&amp;h=476&amp;f=png&amp;s=47034" alt="启用Apple Pay权限"></p><p>之后项目会多一个Applepay的配置文件ApplePayYasin.entitlements</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3e704842?w=1136&amp;h=204&amp;f=png&amp;s=49705" alt="项目文件"></p><h2 id="四：下载Apple-Pay-SDK"><a href="#四：下载Apple-Pay-SDK" class="headerlink" title="四：下载Apple Pay SDK"></a>四：下载Apple Pay SDK</h2><p><a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">Apple Pay SDK</a></p><p>下载之后，找到.h文件和库文件，使用UPPaymentControl需要将paymentcontrol/inc目录下UPAPayPlugin.h、UPAPayPluginDelegate.h文件和paymentcontrol/libs目录下的libUPAPayPlugin.a文件添加到商户应用的工程中</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db909531af?w=1238&amp;h=376&amp;f=png&amp;s=79656" alt="SDK路径"></p><h2 id="五：调用支付接口"><a href="#五：调用支付接口" class="headerlink" title="五：调用支付接口"></a>五：调用支付接口</h2><p>在调用银联支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UPAPayPlugin.h&quot;</span><br><span class="line"></span><br><span class="line">// TODO 商户需要换用自己的mertchantID</span><br><span class="line">#define kAppleMerchantID        @&quot;merchant.com.AgreePay.ApplePayAgree&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//当获得的tn不为空时，调用支付接口</span><br><span class="line">if (tn != nil &amp;&amp; tn.length &gt; 0) &#123;</span><br><span class="line">        [UPAPayPlugin startPay:tn</span><br><span class="line">        mode:@&quot;01&quot;</span><br><span class="line">        viewController:ViewController</span><br><span class="line">        delegate:self andAPMechantID:kAppleMerchantID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法需要的几个参数文档上都写的有，tn是交易流水号，服务器端传回来的，客户端只有凭借这个参数才能调用支付控件 进行支付的。只需要调用一个方法就行啦！！！</p><h2 id="六：支付结果回调"><a href="#六：支付结果回调" class="headerlink" title="六：支付结果回调"></a>六：支付结果回调</h2><p>就在调起支付的ViewController 中写入下面代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -</span><br><span class="line">#pragma mark 响应控件返回的支付结果</span><br><span class="line">#pragma mark -</span><br><span class="line">- (void)UPAPayPluginResult:(UPPayResult *)result</span><br><span class="line">&#123;</span><br><span class="line">    if(result.paymentResultStatus == UPPaymentResultStatusSuccess) &#123;</span><br><span class="line">        NSString *otherInfo = result.otherInfo?result.otherInfo:@&quot;&quot;;</span><br><span class="line">        NSString *successInfo = [NSString stringWithFormat:@&quot;支付成功\n%@&quot;,otherInfo];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%@&quot;,successInfo);</span><br><span class="line"></span><br><span class="line">    &#125;else if(result.paymentResultStatus == UPPaymentResultStatusCancel)&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;支付取消&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;else if (result.paymentResultStatus == UPPaymentResultStatusFailure) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *errorInfo = [NSString stringWithFormat:@&quot;%@&quot;,result.errorDescription];</span><br><span class="line">        NSLog(@&quot;支付失败%@&quot;,errorInfo);</span><br><span class="line">    &#125;else if (result.paymentResultStatus == UPPaymentResultStatusUnknownCancel)  &#123;</span><br><span class="line"></span><br><span class="line">        //TODO UPPAymentResultStatusUnknowCancel表示发起支付以后用户取消，导致支付状态不确认，需要查询商户后台确认真实的支付结果</span><br><span class="line">//        NSString *errorInfo = [NSString stringWithFormat:@&quot;支付过程中用户取消了，请查询后台确认订单&quot;];</span><br><span class="line">//        [self showAlertMessage:errorInfo];</span><br><span class="line">        NSLog(@&quot;支付过程中用户取消了，请查询后台确认订单&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db620e1851?w=744&amp;h=1368&amp;f=png&amp;s=163923" alt="支付调起截图"></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下Apple_pay，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 最新版本支付宝支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-最新版本支付宝支付开发流程/</id>
    <published>2018-02-06T07:58:32.000Z</published>
    <updated>2018-02-06T08:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>最近支付宝，微信，银联支付类sdk均做了更新，其中支付宝sdk变化比较大，由原来需要导入六个文件：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li><li>Order.h和Order.m</li><li>Until文件夹</li><li>openssl文件夹</li><li>libcrypto.a和libssl.a</li></ul><p>在新版之后只需要导入两个文件就可以解决了，文件如下：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li></ul><p>下面我在旧版文章的基础上，为大家详细介绍最新版本支付宝支付开发流程。</p><a id="more"></a><p>因为工作的需要，我先后总结了iOS支付相关的近五类支付开发文章，分别是支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，做这些总结第一是方便以后的查阅，第二也为大家提供方便， 以免在用到的地方重复踩坑。</p><blockquote><p>注意开始填坑！！！</p></blockquote><h2 id="二：交互流程"><a href="#二：交互流程" class="headerlink" title="二：交互流程"></a>二：交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是<a href="https://doc.open.alipay.com/doc2/detail?spm=0.0.0.0.w6njr9&amp;treeId=59&amp;articleId=103658&amp;docType=1" target="_blank" rel="noopener">交互流程</a>这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090db631c91f4e?w=848&amp;h=456&amp;f=png&amp;s=79224" alt="功能流程图"></p><p>流程说明：</p><ul><li>第4步：调用支付接口</li><li>第5步：支付请求</li><li>第8步：接口返回支付结果</li><li>第12步：异步发送支付通知</li></ul><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090dbeccf4cb9c?w=885&amp;h=469&amp;f=png&amp;s=93602" alt="数据交互图"></p><p>数据交互说明：</p><ol><li>构造订单数据并签名</li><li>发送请求数据</li><li>手机支付宝支付开发包对请求数据进行处理</li><li>返回处理的结果数据</li><li>商户对获取的返回结果数据进行处理</li></ol><h2 id="三：下载支付宝SDK"><a href="#三：下载支付宝SDK" class="headerlink" title="三：下载支付宝SDK"></a>三：下载支付宝SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了<a href="https://docs.open.alipay.com/54/104509" target="_blank" rel="noopener">最新的sdk地址</a>（注意的是下载出来的SDK包里面并没有传说中的开发文档，需要其他地方找或者看网页上的）。</p><p>公钥、私钥、PID、sellerID、key这些东西的用途和获取方式在文档上都有详细的说明，这里不再赘述，一定要把概念分清楚再去做，不然一会就乱了。如果遇到问题的话咱们可以再一起探讨。</p><h2 id="四：-导入库集成SDK"><a href="#四：-导入库集成SDK" class="headerlink" title="四： 导入库集成SDK"></a>四： 导入库集成SDK</h2><h3 id="4-1-导入文件和关键库"><a href="#4-1-导入文件和关键库" class="headerlink" title="4.1 导入文件和关键库"></a>4.1 导入文件和关键库</h3><p>官方demo文件</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090ea4e1572b1f?w=778&amp;h=370&amp;f=png&amp;s=46381" alt=""></p><p>把iOS包中的压缩文件中以下文件拷贝到项目文件夹下，并导入到项目工程中：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li></ul><p>在Build Phases选项卡的Link Binary With Libraries中，增加以下依赖：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f21ff23afc13?w=800&amp;h=387&amp;f=png&amp;s=161849" alt="配置截图"><br>其中，需要注意的是：</p><ul><li>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；</li><li>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib（如下图）。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f21ff158304a?w=800&amp;h=63&amp;f=png&amp;s=15152" alt=""></p><p>此时，假如你启动工程，很大几率上你会发现报error的情况。<br>报错#include <openssl opensslconf.h=""> not find<br>这是一个神奇的大坑，我Google了好久，也不得其解，然后经网友提醒之后想起来#import “”和#import &lt;&gt;的区别。</openssl></p><blockquote><p>解决方法：Targets -&gt; Build Settings 下的 Header Search Paths。添加如下目录 “$(SRCROOT)/项目名称/文件的绝对地址”<br>如图：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2200ab48e0b?w=910&amp;h=519&amp;f=png&amp;s=274742" alt="3.png"></p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>在需要调用AlipaySDK的文件中，增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在支付宝的接入文档中，是将生成一个订单这步放在客户端来做了，但这个最好是 放在服务器端来做。<br>后台生成订单然后拼接，签名，然后服务器端直接给客户端传一个加密签名过的参数就可以了，这样比较安全。<br>所有的订单信息，商户信息等都掌握在自己的手中，这样的话APP端就不怕被拦截数据，并且调用起来也就特别简单了，只需要调用支付的接口。<br>如果只需要发送订单和处理支付返回结果，只需要添加AlipaySDK.bundle和AlipaySDK.framework这两个就行了，下载的SDK中很容易发现。<br>快捷支付方法是这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)payOrder:(NSString *)orderStr fromScheme:(NSString *)schemeStr callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>在支付的按钮中，使用支付宝这个类，再调用这个方法就行啦！如下如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[AlipaySDK defaultService] payOrder:credential fromScheme:fromScheme callback:^(NSDictionary* resultDic) &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,resultDic);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h3 id="4-4-配置支付宝客户端返回url处理方法"><a href="#4-4-配置支付宝客户端返回url处理方法" class="headerlink" title="4.4 配置支付宝客户端返回url处理方法"></a>4.4 配置支付宝客户端返回url处理方法</h3><p>如示例AliSDKDemo\APAppDelegate.m文件中，增加引用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure></p><p>在@implementation  AppDelegate中以下代码中的NSLog改为实际业务处理代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line"></span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-项目配置"><a href="#4-5-项目配置" class="headerlink" title="4.5 项目配置"></a>4.5 项目配置</h3><p>最后，不要忘了还要写一个URL Scheme，在Targets -&gt; Info 下最后一个即可找到，<br>点击“Info”选项卡，在“URL Types”选项中，点击“+”。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f220218b212e?w=1044&amp;h=348&amp;f=jpeg&amp;s=30900" alt="项目配置"></p><p>到这里支付宝支付就基本完成了，如果小伙伴们在集成过程中遇到什么问题，可以留言给我或者添加qq，在线帮你解决。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;最近支付宝，微信，银联支付类sdk均做了更新，其中支付宝sdk变化比较大，由原来需要导入六个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AlipaySDK.framework&lt;/li&gt;
&lt;li&gt;AlipaySDK.bundle&lt;/li&gt;
&lt;li&gt;Order.h和Order.m&lt;/li&gt;
&lt;li&gt;Until文件夹&lt;/li&gt;
&lt;li&gt;openssl文件夹&lt;/li&gt;
&lt;li&gt;libcrypto.a和libssl.a&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在新版之后只需要导入两个文件就可以解决了，文件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AlipaySDK.framework&lt;/li&gt;
&lt;li&gt;AlipaySDK.bundle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我在旧版文章的基础上，为大家详细介绍最新版本支付宝支付开发流程。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 微信支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-微信支付开发流程/</id>
    <published>2018-02-06T07:53:12.000Z</published>
    <updated>2018-02-06T08:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1" target="_blank" rel="noopener">微信支付开发文档</a>里面有详细的字段和说明。<br>微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）</p><a id="more"></a><h2 id="二：业务流程"><a href="#二：业务流程" class="headerlink" title="二：业务流程"></a>二：业务流程</h2><p>以下是交互时序图，统一下单API、支付结果通知API和查询订单API等都涉及签名过程，调用都必须在商户服务器端完成。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27888c19afc?w=894&amp;h=1042&amp;f=png&amp;s=35313" alt="交互时序图"></p><p>商户系统和微信支付系统主要交互说明：</p><ul><li><ol><li>用户在商户APP中选择商品，提交订单，选择微信支付。</li></ol></li><li><ol><li>商户后台收到用户支付单，调用微信支付统一下单接口。</li></ol></li><li><ol><li>统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为appid，partnerid，prepayid，noncestr，timestamp，package。</li></ol></li><li><ol><li>商户APP调起微信支付。</li></ol></li><li><ol><li>商户后台接收支付通知。</li></ol></li><li><ol><li>商户后台查询支付结果。</li></ol></li></ul><h2 id="三：下载微信SDK"><a href="#三：下载微信SDK" class="headerlink" title="三：下载微信SDK"></a>三：下载微信SDK</h2><p>如果集成了友盟分享里的微信，那就不用下载,也不用配置环境，因为配置友盟分享的时候已经把微信支付的环境都配置好了（包括框架，schema跳转，白名单）如果没有集成过友盟分享那么请到<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">微信开放平台下载SDK</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f278a718dc7b?w=800&amp;h=278&amp;f=png&amp;s=44629" alt="下载微信SDK"></p><blockquote><p> 建议把iOS头文件和支付示例都下载下来</p></blockquote><h2 id="四：导入库集成SDK"><a href="#四：导入库集成SDK" class="headerlink" title="四：导入库集成SDK"></a>四：导入库集成SDK</h2><h3 id="4-1-导入SDK库"><a href="#4-1-导入SDK库" class="headerlink" title="4.1 导入SDK库"></a>4.1 导入SDK库</h3><p>导入上面那个iOS头文件和库下载下载出来的SDK包的就行，然后需要链接上依赖库，在Target —&gt; BuildPhases —&gt; Link Binary With Libraries— 点击+号 -&gt; 搜索你需要的系统库。</p><ul><li>SystemConfiguration.framework</li><li>libz.tbd</li><li>libsqlite3.0.tbd</li><li>CoreTelephony.framework</li><li>QuartzCore.framework</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2788cdb89fc?w=800&amp;h=606&amp;f=png&amp;s=84310" alt="导入SDK库"></p><h3 id="4-2-设置URL-Scheme"><a href="#4-2-设置URL-Scheme" class="headerlink" title="4.2 设置URL Scheme"></a>4.2 设置URL Scheme</h3><p>商户在微信开放平台申请开发APP应用后，微信开放平台会生成APP的唯一标识APPID，在<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="noopener">APP端开发步骤</a>里面说得很清楚了，需要填在URL Schemes这个地方。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27889fad2d9?w=800&amp;h=443&amp;f=png&amp;s=89206" alt="URL Scheme"></p><h3 id="4-2-在Appdelegate中注册APPID"><a href="#4-2-在Appdelegate中注册APPID" class="headerlink" title="4.2 在Appdelegate中注册APPID"></a>4.2 在Appdelegate中注册APPID</h3><p>首先要在Appdelegate中引用头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//微信支付</span><br><span class="line">#import &quot;WXApi.h&quot;</span><br></pre></td></tr></table></figure></p><p>然后注册APPID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">//    向微信终端注册ID</span><br><span class="line"></span><br><span class="line">    [WXApi registerApp:@&quot;wxd930ea5d5a258f4f&quot;];</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在支付成功之后，支付结果返回，需要获取url，也需要在Appdelegate中完成，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line"></span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if ([url.host isEqualToString:@&quot;pay&quot;]) &#123;</span><br><span class="line">        // 处理微信的支付结果</span><br><span class="line">        [WXApi handleOpenURL:url delegate:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if ([url.host isEqualToString:@&quot;pay&quot;]) &#123;</span><br><span class="line">        // 处理微信的支付结果</span><br><span class="line">        [WXApi handleOpenURL:url delegate:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>微信SDK自带的方法，处理从微信客户端完成操作后返回程序之后的回调方法,显示支付结果的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(void) onResp:(BaseResp*)resp</span><br><span class="line">&#123;</span><br><span class="line">    //启动微信支付的response</span><br><span class="line">    NSString *payResoult = [NSString stringWithFormat:@&quot;errcode:%d&quot;, resp.errCode];</span><br><span class="line">    if([resp isKindOfClass:[PayResp class]])&#123;</span><br><span class="line">        //支付返回结果，实际支付结果需要去微信服务器端查询</span><br><span class="line">        switch (resp.errCode) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                payResoult = @&quot;支付结果：成功！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case -1:</span><br><span class="line">                payResoult = @&quot;支付结果：失败！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case -2:</span><br><span class="line">                payResoult = @&quot;用户已经退出支付！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                payResoult = [NSString stringWithFormat:@&quot;支付结果：失败！retcode = %d, retstr = %@&quot;, resp.errCode,resp.errStr];</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在调用微信支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;WXApi.h&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中，需要上传的参数包括：appid、partid（商户号）、prepayid（预支付订单ID）、noncestr（参与签名的随机字符串）、timestamp（参与签名的时间戳）、sign（签名字符串）这六个。<br>在点击支付的控制器中使用核心代码来调起微信客户端支付,这些个参数都是后台传给你的。 加上了注释，应该很好理解的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 微信支付方法</span><br><span class="line">- (void)WechatPay&#123;</span><br><span class="line"></span><br><span class="line">    //需要创建这个支付对象</span><br><span class="line">    PayReq *req   = [[PayReq alloc] init];</span><br><span class="line">    //由用户微信号和AppID组成的唯一标识，用于校验微信用户</span><br><span class="line">    req.openID = appid;</span><br><span class="line">    // 商家id，在注册的时候给的</span><br><span class="line">    req.partnerId = partnerid;</span><br><span class="line">    // 预支付订单这个是后台跟微信服务器交互后，微信服务器传给你们服务器的，你们服务器再传给你</span><br><span class="line">    req.prepayId  = prepayid;</span><br><span class="line">    // 根据财付通文档填写的数据和签名</span><br><span class="line">    req.package  = package;</span><br><span class="line">    // 随机编码，为了防止重复的，在后台生成</span><br><span class="line">    req.nonceStr  = noncestr;</span><br><span class="line">    // 这个是时间戳，也是在后台生成的，为了验证支付的</span><br><span class="line">    NSString * stamp = timestamp;</span><br><span class="line">    req.timeStamp = stamp.intValue;</span><br><span class="line">    // 这个签名也是后台做的</span><br><span class="line">    req.sign = sign;</span><br><span class="line">    //发送请求到微信，等待微信返回onResp</span><br><span class="line">    [WXApi sendReq:req];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-判断手机是否安装微信客户端"><a href="#4-4-判断手机是否安装微信客户端" class="headerlink" title="4.4 判断手机是否安装微信客户端"></a>4.4 判断手机是否安装微信客户端</h3><p>在需要微信支付的地方调用封装的类方法之后会跳转到微信app,如果没有安装则没有任何反应。这里需要注意，因为没有安装微信，必须要提供webview的方式登录微信来支付，否则苹果公司会拒绝应用上架。但是微信又不自带webview的方式，（支付宝是自带的）所以要判断用户有没有安装微信，如果没有安装微信就不显示微信支付这个按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 判断手机有没有微信</span><br><span class="line">    if ([WXApi isWXAppInstalled]) &#123;</span><br><span class="line">        wechatButton.hidden = NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        wechatButton.hidden = YES;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里微信支付就基本完成了，如果小伙伴们在集成过程中遇到什么问题，可以留言给我或者添加qq，在线帮你解决。</p><h2 id="后续：常见问题解决"><a href="#后续：常见问题解决" class="headerlink" title="后续：常见问题解决"></a>后续：常见问题解决</h2><ol><li>如果支付完成后，一直留在微信，那就检查下URLType中的Scheme设置问题。</li><li>能够打开微信客户端，但是打开后只有中间一个白色的 “确定按钮”，点击后会回到客户端上，如果是这样，那应该是prepayid 参数的问题，过期了，或者不是真实的id。</li><li>微信支付的单位是分</li><li>工程-&gt;build setttings -&gt; 搜索other linker flags 添加-Objc -all_load ，运行工程可能会崩溃，原因是程序没有找到sdk库。</li><li><p>白名单：不配置白名单也可以调起支付，如果调不起支付，查看是否是白名单的问题。<br>打开工程里的info.plist文件 添加LSApplicationQueriesSchemes数组并添加wechat 和 weixin字符串。<br>或者info.plist右键-&gt;source code打开添加下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;&lt;string&gt;wechat&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;weixin &lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></li><li><p>中文名的工程会报这个错误，英文名则不会，这是因为缺少UIKit库 在WXApiObject.h里导入库#import <uikit uikit.h="">。</uikit></p></li></ol><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信支付开发文档&lt;/a&gt;里面有详细的字段和说明。&lt;br&gt;微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 银联支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E9%93%B6%E8%81%94%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-银联支付开发流程/</id>
    <published>2018-02-06T07:42:06.000Z</published>
    <updated>2018-02-06T08:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付</a>，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44a1979e7?w=800&amp;h=493&amp;f=png&amp;s=144804" alt="银联手机控件SDK"></p><h2 id="二：支付流程介绍"><a href="#二：支付流程介绍" class="headerlink" title="二：支付流程介绍"></a>二：支付流程介绍</h2><p>通过支付控件进行交易的流程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44cf785ab?w=800&amp;h=604&amp;f=png&amp;s=80017" alt="业务流程图"><br>流程图说明：<br>　　(1)用户在客户端中点击购买商品，客户端发起订单生成请求到商户后台;<br>　　(2)商户后台收到订单生成请求后，按照《手机控件支付产品接口规范》组织并推送订单信息至银联后台;<br>　　(3)银联后台接收订单信息并检查通过后，生成对应交易流水号(即TN)，并回复至商户后台(应答要素：交易流水号等);<br>　　(4)商户后台接收到交易流水号(TN)，将交易流水号返回至客户端;<br>　　(5)客户端通过交易流水号(TN)调用支付控件;<br>　　(6)用户在支付控件中输入相关支付信息后，由支付控件向银联后台发起支付请求;<br>　　(7)支付成功后，银联后台将支付结果通知给商户后台;<br>　　(8)银联后台同时也将支付结果通知支付控件;<br>　　(9)支付控件显示支付结果并将支付结果返回至客户端;<br>　　此处备注：我们是通过后台获取订单，我们可以根据商品id等信息通过后台接口获取订单信息，对订单支付流程的签名加密过程后台完成。</p><h2 id="三：下载银联SDK"><a href="#三：下载银联SDK" class="headerlink" title="三：下载银联SDK"></a>三：下载银联SDK</h2><p><a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付SDK</a></p><p>下载之后，找到.h文件和库文件，使用UPPaymentControl需要将paymentcontrol/inc目录下UPPaymentControl.h文件和paymentcontrol/libs目录下的libPaymentControl.a文件添加到商户应用的工程中</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b4488acca3?w=800&amp;h=165&amp;f=png&amp;s=56174" alt="SDK路径"></p><h2 id="四：工程配置"><a href="#四：工程配置" class="headerlink" title="四：工程配置"></a>四：工程配置</h2><h3 id="4-1-导入SDK库"><a href="#4-1-导入SDK库" class="headerlink" title="4.1 导入SDK库"></a>4.1 导入SDK库</h3><p>导入上面那个iOS头文件和库下载下载出来的SDK包的就行，然后需要链接上依赖库，在Target —&gt; BuildPhases —&gt; Link Binary With Libraries— 点击+号 -&gt; 搜索你需要的系统库。</p><ul><li>CFNetwork.framework</li><li>SystemConfiguration.framework</li><li>libz</li><li>libPaymentControl.a</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2788cdb89fc?w=800&amp;h=606&amp;f=png&amp;s=84310" alt="导入SDK库"></p><h3 id="4-2-设置URL-Scheme"><a href="#4-2-设置URL-Scheme" class="headerlink" title="4.2 设置URL Scheme"></a>4.2 设置URL Scheme</h3><p>在工程info.plist设置中添加一个URL Types回调协议(在UPPayDemo工程中使用“UPPayDemo”作为协议)，用于在支付完成后返回商户客户端。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27889fad2d9?w=800&amp;h=443&amp;f=png&amp;s=89206" alt="URL Scheme"></p><h3 id="4-3-http请求设置"><a href="#4-3-http请求设置" class="headerlink" title="4.3 http请求设置"></a>4.3 http请求设置</h3><p>进行http请求时，需要在工程对应的plist文件中添加NSAppTransportSecurity Dictionary 并同时设置里面NSAllowsArbitraryLoads 属性值为 YES</p><h3 id="4-4-添加协议白名单"><a href="#4-4-添加协议白名单" class="headerlink" title="4.4 添加协议白名单"></a>4.4 添加协议白名单</h3><p>需要在工程对应的plist文件中，添加LSApplicationQueriesSchemes Array并加入uppaysdk、uppaywallet、uppayx1、uppayx2、uppayx3五个item，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44a6be849?w=1038&amp;h=556&amp;f=png&amp;s=83234" alt="添加白名单"></p><h3 id="4-5-调用支付接口"><a href="#4-5-调用支付接口" class="headerlink" title="4.5 调用支付接口"></a>4.5 调用支付接口</h3><p>在调用银联支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UPPaymentControl.h&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//当获得的tn不为空时，调用支付接口</span><br><span class="line">if (tn != nil &amp;&amp; tn.length &gt; 0) &#123;</span><br><span class="line">        [[UPPaymentControl defaultControl]startPay:tn</span><br><span class="line">        fromScheme:@&quot;URL Scheme&quot;</span><br><span class="line">        mode:tnModel</span><br><span class="line">        viewController:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法需要的几个参数文档上都写的有，tn是交易流水号，服务器端传回来的，客户端只有凭借这个参数才能调用支付控件 进行支付的。只需要调用一个方法就行啦！！！</p><h3 id="4-6-支付结果回调"><a href="#4-6-支付结果回调" class="headerlink" title="4.6 支付结果回调"></a>4.6 支付结果回调</h3><p>在支付成功之后，支付结果返回，需要获取url，需要在Appdelegate中完成<br>在Appdelegate里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UPPaymentControl.h&quot;</span><br></pre></td></tr></table></figure><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;uppayresult&quot;])&#123;</span><br><span class="line">        //银联支付结果</span><br><span class="line">        [[UPPaymentControl defaultControl] handlePaymentResult:url completeBlock:^(NSString *code, NSDictionary *data) &#123;</span><br><span class="line">            //结果code为成功时，先校验签名，校验成功后做后续处理</span><br><span class="line">            if([code isEqualToString:@&quot;success&quot;]) &#123;</span><br><span class="line">                //交易成功</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;fail&quot;]) &#123;</span><br><span class="line">                //交易失败</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;cancel&quot;]) &#123;</span><br><span class="line">                //交易取消</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;uppayresult&quot;])&#123;</span><br><span class="line">        //银联支付结果</span><br><span class="line">        [[UPPaymentControl defaultControl] handlePaymentResult:url completeBlock:^(NSString *code, NSDictionary *data) &#123;</span><br><span class="line">            //结果code为成功时，先校验签名，校验成功后做后续处理</span><br><span class="line">            if([code isEqualToString:@&quot;success&quot;]) &#123;</span><br><span class="line">                //交易成功</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;fail&quot;]) &#123;</span><br><span class="line">                //交易失败</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;cancel&quot;]) &#123;</span><br><span class="line">                //交易取消</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-7-常见问题解决"><a href="#4-7-常见问题解决" class="headerlink" title="4.7 常见问题解决"></a>4.7 常见问题解决</h3><p>1.由于支付控件使用到了C、C++和OC混编的情况，将涉及到引用UPPaymentControl.h的源文件的后缀名都改为.mm;</p><p>2.由于在UPPayDemo工程中添加了自定义的库文件libPaymentControl.a，当编译Demo工程时，应该检查工程设置Search Paths里的Framework Search Paths、Header Search Paths、Library Search Paths的路径设置，看设置路径是否正确，另外还要注意里边是否多余一些不确定的路径。</p><p>3.控件界面无限加载，请参考控件使用指南iOS “添加SDK包“里“添加-ObjC宏”，特别注意大小写不要弄混。(此步骤操作有问题时也可修改为 -force_load+空格+控件路径，如：-force_load (PROJECT_DIR)/ libPaymentControl.a)。</p><p>4.控件闪退异常’NSInvalidArgumentException’, reason: ‘-[__NSCFConstantString newSizeWithFont:详略]’<br>　　出现以上问题是由于添加-ObjC宏的地方没有配置正确，如果配-ObjC实在解决不了的话，可尝试去掉-ObjC，改为-force_load+空格+控件路径，如：-force_load $(PROJECT_DIR)/ libPaymentControl.a。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://open.unionpay.com/ajweb/help/file/techFile?productId=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;银联手机控件支付&lt;/a&gt;，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android 银联控件支付开发流程</title>
    <link href="https://fanbaoying.github.io/Android-%E9%93%B6%E8%81%94%E6%8E%A7%E4%BB%B6%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/Android-银联控件支付开发流程/</id>
    <published>2018-02-06T07:36:54.000Z</published>
    <updated>2018-02-06T07:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付</a>，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d687fbdf7?w=800&amp;h=472&amp;f=png&amp;s=140075" alt="银联手机控件SDK"></p><h2 id="二：支付流程介绍"><a href="#二：支付流程介绍" class="headerlink" title="二：支付流程介绍"></a>二：支付流程介绍</h2><p>通过支付控件进行交易的流程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44cf785ab?w=800&amp;h=604&amp;f=png&amp;s=80017" alt="业务流程图"><br>流程图说明：<br>　　(1)用户在客户端中点击购买商品，客户端发起订单生成请求到商户后台;<br>　　(2)商户后台收到订单生成请求后，按照《手机控件支付产品接口规范》组织并推送订单信息至银联后台;<br>　　(3)银联后台接收订单信息并检查通过后，生成对应交易流水号(即TN)，并回复至商户后台(应答要素：交易流水号等);<br>　　(4)商户后台接收到交易流水号(TN)，将交易流水号返回至客户端;<br>　　(5)客户端通过交易流水号(TN)调用支付控件;<br>　　(6)用户在支付控件中输入相关支付信息后，由支付控件向银联后台发起支付请求;<br>　　(7)支付成功后，银联后台将支付结果通知给商户后台;<br>　　(8)银联后台同时也将支付结果通知支付控件;<br>　　(9)支付控件显示支付结果并将支付结果返回至客户端;<br>　　此处备注：我们是通过后台获取订单，我们可以根据商品id等信息通过后台接口获取订单信息，对订单支付流程的签名加密过程后台完成。</p><h2 id="三：下载银联SDK"><a href="#三：下载银联SDK" class="headerlink" title="三：下载银联SDK"></a>三：下载银联SDK</h2><p><a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付SDK</a></p><p>下载之后，找到两个jar包，将UPPayAssistEx.jar和UPPayPluginExPro.jar添加到商户应用的工程中</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6f4b263a?w=800&amp;h=270&amp;f=png&amp;s=73837" alt="SDK路径"></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6574a83b?w=796&amp;h=556&amp;f=png&amp;s=204593" alt="SDK路径"></p><h2 id="四：导入开发SDK"><a href="#四：导入开发SDK" class="headerlink" title="四：导入开发SDK"></a>四：导入开发SDK</h2><p>导入sdk流程同支付宝导入流程一样，这里就借用支付宝导入流程进行介绍。</p><h3 id="4-1-如果项目开发使用的Eclipse软件，导入步骤如下："><a href="#4-1-如果项目开发使用的Eclipse软件，导入步骤如下：" class="headerlink" title="4.1 如果项目开发使用的Eclipse软件，导入步骤如下："></a>4.1 如果项目开发使用的Eclipse软件，导入步骤如下：</h3><p>1.将alipaySDK-20150602.jar包放入商户应用工程的libs目录下，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bd81ee8?w=392&amp;h=68&amp;f=png&amp;s=10285" alt="201.png"></p><p>2.进入商户应用工程的Java Build Path，将libs目录下的alipaySDK-20150602.jar导入，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bfaafda?w=1078&amp;h=436&amp;f=png&amp;s=243108" alt="202.png"></p><p>3.选中Order and Export，勾选alipaySDK-20150602.jar，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f824fb2?w=1078&amp;h=486&amp;f=png&amp;s=283277" alt="203.png"></p><blockquote><p>将上图的支付宝sdk更换成银联控件支付的两个jar包即可</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6a4e8c58?w=796&amp;h=556&amp;f=png&amp;s=204593" alt="103.png"></p><h3 id="4-2-如果项目开发使用的Android-Studio软件，导入步骤如下："><a href="#4-2-如果项目开发使用的Android-Studio软件，导入步骤如下：" class="headerlink" title="4.2 如果项目开发使用的Android Studio软件，导入步骤如下："></a>4.2 如果项目开发使用的Android Studio软件，导入步骤如下：</h3><p>1.将银联SDK拷贝到项目libs文件夹下，如果没有libs文件夹，就新建一个。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6c66e215?w=642&amp;h=222&amp;f=png&amp;s=26199" alt="105.png"></p><p>2.如果sdk使用过程中，提示找不到文件。<br>进行如下操作，选中sdk文件，右击选择Reveal in Finder</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f59e85f?w=982&amp;h=1266&amp;f=png&amp;s=249602" alt="302.png"></p><h2 id="除了导入jar包之外，还要导入资源包和依赖包，如下图："><a href="#除了导入jar包之外，还要导入资源包和依赖包，如下图：" class="headerlink" title="除了导入jar包之外，还要导入资源包和依赖包，如下图："></a>除了导入jar包之外，还要导入资源包和依赖包，如下图：</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6815f35c?w=496&amp;h=596&amp;f=png&amp;s=98530" alt="106.png"></p><h2 id="五：修改AndroidManifest-xml配置"><a href="#五：修改AndroidManifest-xml配置" class="headerlink" title="五：修改AndroidManifest.xml配置"></a>五：修改AndroidManifest.xml配置</h2><p>1.在商户应用工程的AndroidManifest.xml文件里面添加声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-library</span><br><span class="line">    android:name=&quot;org.simalliance.openmobileapi&quot;</span><br><span class="line">    android:required=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.unionpay.uppay.PayActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden&quot;</span><br><span class="line">    android:excludeFromRecents=&quot;true&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:screenOrientation=&quot;portrait&quot;</span><br><span class="line">    android:windowSoftInputMode=&quot;adjustResize&quot; /&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.unionpay.UPPayWapActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden&quot;</span><br><span class="line">    android:screenOrientation=&quot;portrait&quot;</span><br><span class="line">    android:windowSoftInputMode=&quot;adjustResize&quot; /&gt;</span><br></pre></td></tr></table></figure><p>和权限声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.nfc.hce&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;org.simalliance.openmobileapi.SMARTCARD&quot; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，银联支付的前期配置已经完成，下面需要完成支付代码编写。</p></blockquote><h2 id="六：支付接口调用"><a href="#六：支付接口调用" class="headerlink" title="六：支付接口调用"></a>六：支付接口调用</h2><ol><li>在点击支付按钮的点击事件中，我提供的是从后端获取订单信息。</li><li>需要在新线程中调用支付接口。代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//    支付按钮</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        //起一个线程</span><br><span class="line">        Runnable payRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String data = null;</span><br><span class="line">                PayBean payBean = new PayBean();</span><br><span class="line">                payBean.setOrderTime(&quot;&quot;);</span><br><span class="line">                String json = new Gson().toJson(payBean);</span><br><span class="line">                //json为获取后端结果时需要提供给后端订单信息，例如：时间、金额、订单属性等</span><br><span class="line">                Log.i(&quot;charge request&quot;, json);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //data为后端返回数据，其中包括订单字符串</span><br><span class="line">                    data = postJson(CHARGE_URL, json);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // Json解析data</span><br><span class="line">                ChargeBean charge = new Gson().fromJson(data, ChargeBean.class);</span><br><span class="line">                String tn = (String)charge.getResult().getCredential();</span><br><span class="line">                //在mHandler中处理微信调起支付和返回结果回调</span><br><span class="line">                Message msg = new Message();</span><br><span class="line">                msg.what = SDK_PAY_UPPAY;</span><br><span class="line">                msg.obj = charge;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 必须异步调用</span><br><span class="line">        Thread payThread = new Thread(payRunnable);</span><br><span class="line">        payThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>在mHandler中处理调起支付</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (msg.what == SDK_PAY_UPPAY)&#123;</span><br><span class="line">                String tn = (String) msg.obj;</span><br><span class="line">                Log.i(&quot;charge&quot;, tn);</span><br><span class="line">                int ret = UPPayAssistEx.startPay (ThirdActivity.this, null, null, tn, &quot;01&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ol><li>支付结果回调</li></ol><p>支付完成后，获取支付控件支付结果，并添加相应处理逻辑，只需实现调用Activity中的onActivityResult()方法即可，支付成功时会返回商户客户端支付结果和签名信息。</p><p>控件返回的结果信息仅作为参考，商户订单是否成功支付应该以商户后台主动到全渠道查询的结果或者收到全渠道支付结果通知为准。<br>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">        /*************************************************</span><br><span class="line">         * 步骤3：处理银联手机支付控件返回的支付结果</span><br><span class="line">         ************************************************/</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String msg = &quot;&quot;;</span><br><span class="line">        /*</span><br><span class="line">         * 支付控件返回字符串:success、fail、cancel 分别代表支付成功，支付失败，支付取消</span><br><span class="line">         */</span><br><span class="line">        String str = data.getExtras().getString(&quot;pay_result&quot;);</span><br><span class="line">        if (str.equalsIgnoreCase(&quot;success&quot;)) &#123;</span><br><span class="line">            // 支付成功后，extra中如果存在result_data，取出校验</span><br><span class="line">            // result_data结构见c）result_data参数说明</span><br><span class="line">            if (data.hasExtra(&quot;result_data&quot;)) &#123;</span><br><span class="line">                msg = &quot;支付成功！&quot;;</span><br><span class="line">            &#125; else if (str.equalsIgnoreCase(&quot;fail&quot;)) &#123;</span><br><span class="line">                msg = &quot;支付失败！&quot;;</span><br><span class="line">            &#125; else if (str.equalsIgnoreCase(&quot;cancel&quot;)) &#123;</span><br><span class="line">                msg = &quot;用户取消了支付&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AlertDialog.Builder builder = new AlertDialog.Builder(this);</span><br><span class="line">            builder.setTitle(&quot;支付结果通知&quot;);</span><br><span class="line">            builder.setMessage(msg);</span><br><span class="line">            builder.setInverseBackgroundForced(true);</span><br><span class="line">            builder.setNegativeButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                    dialog.dismiss();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.create().show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下三种为常用结果判断</p><blockquote><p>success为支付成功<br>fail为支付失败<br>cancel为取消支付</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://open.unionpay.com/ajweb/help/file/techFile?productId=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;银联手机控件支付&lt;/a&gt;，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。&lt;/p&gt;
    
    </summary>
    
      <category term="Android 支付集" scheme="https://fanbaoying.github.io/categories/Android-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 微信支付开发流程</title>
    <link href="https://fanbaoying.github.io/Android-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/Android-微信支付开发流程/</id>
    <published>2018-02-06T07:35:22.000Z</published>
    <updated>2018-02-06T07:47:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1" target="_blank" rel="noopener">微信支付开发文档</a>里面有详细的字段和说明。<br>微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）</p><a id="more"></a><h2 id="二：业务流程"><a href="#二：业务流程" class="headerlink" title="二：业务流程"></a>二：业务流程</h2><p>以下是交互时序图，统一下单API、支付结果通知API和查询订单API等都涉及签名过程，调用都必须在商户服务器端完成。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27888c19afc?w=894&amp;h=1042&amp;f=png&amp;s=35313" alt="交互时序图"></p><p>商户系统和微信支付系统主要交互说明：</p><ul><li><ol><li>用户在商户APP中选择商品，提交订单，选择微信支付。</li></ol></li><li><ol><li>商户后台收到用户支付单，调用微信支付统一下单接口。</li></ol></li><li><ol><li>统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为appid，partnerid，prepayid，noncestr，timestamp，package。</li></ol></li><li><ol><li>商户APP调起微信支付。</li></ol></li><li><ol><li>商户后台接收支付通知。</li></ol></li><li><ol><li>商户后台查询支付结果。</li></ol></li></ul><h2 id="三：下载微信SDK"><a href="#三：下载微信SDK" class="headerlink" title="三：下载微信SDK"></a>三：下载微信SDK</h2><p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">微信开放平台下载SDK</a><br>建议把Android头文件和支付示例都下载下来</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f32563772c4?w=800&amp;h=265&amp;f=png&amp;s=35629" alt="下载微信SDK"></p><h2 id="四：后台设置"><a href="#四：后台设置" class="headerlink" title="四：后台设置"></a>四：后台设置</h2><p>商户在微信开放平台申请开发应用后，微信开放平台会生成APP的唯一标识APPID。由于需要保证支付安全，需要在开放平台绑定商户应用包名和应用签名，设置好后才能正常发起支付。设置界面在【开放平台】中的栏目【管理中心 / 修改应用 / 修改开发信息】里面。如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f325b14d820?w=764&amp;h=722&amp;f=png&amp;s=18177" alt="102.png"></p><p>应用包名：是在APP项目配置文件AndroidManifest.xml中声明的package值，例如DEMO中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package=&quot;net.sourceforge.simcpux&quot;</span><br></pre></td></tr></table></figure></p><p>应用签名：根据项目的应用包名和编译使用的keystore，可由签名工具生成一个32位的md5串，在调试的手机上安装签名工具后，运行可生成应用签名串，如下图所示，绿色串即应用签名。</p><p>签名工具下载地址</p><p><a href="https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk" target="_blank" rel="noopener">https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk</a></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f3255fa05d8?w=538&amp;h=295&amp;f=png&amp;s=93202" alt="103.png"></p><blockquote><p>net.sourceforge.simcpux 是项目包名</p></blockquote><h2 id="五：导入开发SDK"><a href="#五：导入开发SDK" class="headerlink" title="五：导入开发SDK"></a>五：导入开发SDK</h2><p>导入sdk流程同支付宝导入流程一样，这里就借用支付宝导入流程进行介绍。</p><h3 id="5-1-如果项目开发使用的Eclipse软件，导入步骤如下："><a href="#5-1-如果项目开发使用的Eclipse软件，导入步骤如下：" class="headerlink" title="5.1 如果项目开发使用的Eclipse软件，导入步骤如下："></a>5.1 如果项目开发使用的Eclipse软件，导入步骤如下：</h3><p>1.将alipaySDK-20150602.jar包放入商户应用工程的libs目录下，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bd81ee8?w=392&amp;h=68&amp;f=png&amp;s=10285" alt="201.png"></p><p>2.进入商户应用工程的Java Build Path，将libs目录下的alipaySDK-20150602.jar导入，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bfaafda?w=1078&amp;h=436&amp;f=png&amp;s=243108" alt="202.png"></p><p>3.选中Order and Export，勾选alipaySDK-20150602.jar，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f824fb2?w=1078&amp;h=486&amp;f=png&amp;s=283277" alt="203.png"></p><blockquote><p>将上图的支付宝sdk更换成微信sdk即可</p></blockquote><h3 id="5-2-如果项目开发使用的Android-Studio软件，导入步骤如下："><a href="#5-2-如果项目开发使用的Android-Studio软件，导入步骤如下：" class="headerlink" title="5.2 如果项目开发使用的Android Studio软件，导入步骤如下："></a>5.2 如果项目开发使用的Android Studio软件，导入步骤如下：</h3><p>1.将微信SDK拷贝到项目libs文件夹下，如果没有libs文件夹，就新建一个。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f325c159f90?w=628&amp;h=198&amp;f=png&amp;s=24859" alt="301.png"></p><p>2.如果sdk使用过程中，提示找不到文件。<br>进行如下操作，选中sdk文件，右击选择Reveal in Finder</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f59e85f?w=982&amp;h=1266&amp;f=png&amp;s=249602" alt="302.png"></p><h2 id="六：修改AndroidManifest-xml配置"><a href="#六：修改AndroidManifest-xml配置" class="headerlink" title="六：修改AndroidManifest.xml配置"></a>六：修改AndroidManifest.xml配置</h2><p>1.在商户应用工程的AndroidManifest.xml文件里面添加声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信--&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">     android:name=&quot;.wxapi.WXPayEntryActivity&quot;</span><br><span class="line">     android:exported=&quot;true&quot;</span><br><span class="line">     android:launchMode=&quot;singleTop&quot;&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>和权限声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，微信支付的前期配置已经完成，下面需要完成支付代码编写。</p></blockquote><h2 id="七：支付接口调用"><a href="#七：支付接口调用" class="headerlink" title="七：支付接口调用"></a>七：支付接口调用</h2><ol><li>在点击支付按钮的点击事件中，我提供的是从后端获取订单信息。</li><li>需要在新线程中调用支付接口。代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//    微信按钮</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        //起一个线程</span><br><span class="line">        Runnable payRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String data = null;</span><br><span class="line">                PayBean payBean = new PayBean();</span><br><span class="line">                payBean.setOrderTime(&quot;&quot;);</span><br><span class="line">                String json = new Gson().toJson(payBean);</span><br><span class="line">                //json为获取后端结果时需要提供给后端订单信息，例如：时间、金额、订单属性等</span><br><span class="line">                Log.i(&quot;charge request&quot;, json);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //data为后端返回数据，其中包括订单字符串</span><br><span class="line">                    data = postJson(CHARGE_URL, json);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // Json解析data</span><br><span class="line">                ChargeWXBean charge = new Gson().fromJson(data.replace(&quot;package&quot;, &quot;packages&quot;), ChargeWXBean.class);</span><br><span class="line">                //在mHandler中处理微信调起支付和返回结果回调</span><br><span class="line">                Message msg = new Message();</span><br><span class="line">                msg.what = SDK_PAY_WECHAT;</span><br><span class="line">                msg.obj = charge;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 必须异步调用</span><br><span class="line">        Thread payThread = new Thread(payRunnable);</span><br><span class="line">        payThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>在mHandler中处理调起支付</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (msg.what == SDK_PAY_WECHAT) &#123;</span><br><span class="line"></span><br><span class="line">                ChargeWXBean charge =  (ChargeWXBean) msg.obj;</span><br><span class="line">                String packsges = charge.getResult().getCredential().getPackages();</span><br><span class="line">                String appid = charge.getResult().getCredential().getAppid();</span><br><span class="line">                String partenerid = charge.getResult().getCredential().getPartnerid();</span><br><span class="line">                String prepayid = charge.getResult().getCredential().getPrepayid();</span><br><span class="line">                String noncestr = charge.getResult().getCredential().getNoncestr();</span><br><span class="line">                String timestamp = charge.getResult().getCredential().getTimestamp();</span><br><span class="line">                String sign = charge.getResult().getCredential().getSign();</span><br><span class="line">//              商户APP工程中引入微信JAR包，调用API前，需要先向微信注册您的APPID，代码如下：</span><br><span class="line">                final IWXAPI msgApi = WXAPIFactory.createWXAPI(ThirdActivity.this, null);</span><br><span class="line">               // 将该app注册到微信   </span><br><span class="line">                msgApi.registerApp(appid);</span><br><span class="line"></span><br><span class="line">                PayReq req = new PayReq();</span><br><span class="line">                req.appId = appid;</span><br><span class="line">                req.partnerId = partenerid;</span><br><span class="line">                req.prepayId = prepayid;</span><br><span class="line">                req.nonceStr = noncestr;</span><br><span class="line">                req.timeStamp = timestamp;</span><br><span class="line">                req.packageValue = packsges;</span><br><span class="line">                req.sign = sign;</span><br><span class="line">                msgApi.sendReq(req);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ol><li>支付结果回调</li></ol><p>参照微信SDK Sample，在net.sourceforge.simcpux.wxapi包路径中实现WXPayEntryActivity类(包名或类名不一致会造成无法回调)，在WXPayEntryActivity类中实现onResp函数，支付完成后，微信APP会返回到商户APP并回调onResp函数，开发者需要在该函数中接收通知，判断返回错误码，如果支付成功则去后台查询支付结果再展示用户实际支付结果。注意一定不能以客户端返回作为用户支付的结果，应以服务器端的接收的支付通知或查询API返回的结果为准。(net.sourceforge.simcpux为你的项目包名)代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResp(BaseResp resp) &#123;</span><br><span class="line">    Log.d(TAG,&quot;onPayFinish,errCode=&quot;+resp.errCode);</span><br><span class="line"></span><br><span class="line">    // 判断resultStatus 为“0”则代表支付成功，具体状态码代表含义可参考接口文档</span><br><span class="line">    if (resp.errCode.equals(&quot;0&quot;)) &#123;</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;else if (resp.errCode.equals(&quot;-1&quot;))&#123;</span><br><span class="line"></span><br><span class="line">        // -1为支付失败，包括用户主动取消支付，或者系统返回的错误</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;else if (resp.errCode.equals(&quot;-2&quot;))&#123;</span><br><span class="line"></span><br><span class="line">        // -2为取消支付，或者系统返回的错误</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;取消支付&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 其他为系统返回的错误</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;支付错误&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下三种为常用结果判断</p><blockquote><p>0为支付成功<br>-1为支付失败<br>-2为取消支付</p></blockquote><h2 id="调起支付页面截图"><a href="#调起支付页面截图" class="headerlink" title="调起支付页面截图"></a>调起支付页面截图</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f3256a7f969?w=800&amp;h=696&amp;f=png&amp;s=77705" alt="002.png"></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信支付开发文档&lt;/a&gt;里面有详细的字段和说明。&lt;br&gt;微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）&lt;/p&gt;
    
    </summary>
    
      <category term="Android 支付集" scheme="https://fanbaoying.github.io/categories/Android-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>iOS 静态库详解与开发</title>
    <link href="https://fanbaoying.github.io/iOS-%E9%9D%99%E6%80%81%E5%BA%93%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    <id>https://fanbaoying.github.io/iOS-静态库详解与开发/</id>
    <published>2018-02-01T04:02:34.000Z</published>
    <updated>2018-02-01T05:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><h4 id="1-什么是库？"><a href="#1-什么是库？" class="headerlink" title="1. 什么是库？"></a>1. 什么是库？</h4><p>库是共享程序代码的方式，一般分为静态库和动态库。</p><p>静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。</p><p>动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2829694-2ca66d6c17532fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="库.png"></p><h4 id="2-两种形式中-framework的区别"><a href="#2-两种形式中-framework的区别" class="headerlink" title="2. 两种形式中.framework的区别"></a>2. 两种形式中.framework的区别</h4><p>如上图所示，静态库的形式包含.a和.framework两种形式，动态库的形式包含.dylib和.framework。<br>静态库和动态库都有.framework，但是各有所指，系统的.framework是动态库，我们自己建立的.framework是静态库。</p><h4 id="3-静态库中-a与-framework的区别"><a href="#3-静态库中-a与-framework的区别" class="headerlink" title="3. 静态库中.a与.framework的区别"></a>3. 静态库中.a与.framework的区别</h4><p>.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。<br>.a文件不能直接使用，至少还有.h文件配合，.framework文件可以直接使用，因为本身包含了h文件和其他文件</p><h4 id="4-静态库的优点"><a href="#4-静态库的优点" class="headerlink" title="4. 静态库的优点"></a>4. 静态库的优点</h4><ul><li>实现程序的模块化，将固定的业务模块化成静态库。</li><li>方便共享代码，即可以和别人分享你的代码库，但别人又看不到你代码的实现。</li><li>开发第三方sdk的需要，例如两个公司之间业务交流，不可能把源代码都发送给另一个公司，这时候将私密内容打包成静态库，别人只能调用接口，而不能知道其中实现的细节。</li></ul><p>公司项目需要开发出一套同时支持微信支付、支付宝支付、银联支付的sdk，既要满足本公司项目需求，还需要提供给友方公司使用。</p><p>同时集成三家第三方的支付sdk，其中有大量的配置冲突需要解决。这篇文章通过demo和大家介绍一下如何开发自己的静态库.a文件，分享给大家，同时对工作进行总结。</p><h2 id="二：静态库实现"><a href="#二：静态库实现" class="headerlink" title="二：静态库实现"></a>二：静态库实现</h2><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">静态库生成demo</a><br><a href="https://github.com/fanbaoying/FBYURLSDKDemo" target="_blank" rel="noopener">静态库使用demo</a></p><h4 id="1-新建一个静态库工程"><a href="#1-新建一个静态库工程" class="headerlink" title="1. 新建一个静态库工程"></a>1. 新建一个静态库工程</h4><p>打开Xcode，点击File\New\Project，选择iOS\Framework &amp; Library\Cocoa Touch Static Library新建一个静态库工程。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-5c10466b1eb83783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><p>将工程命名为FBYSDKDemo，然后将工程保存到一个空目录下。<br>静态库工程由头文件FBYSDKDemo.h和实现文件FBYSDKDemo.m组成，这些文件将被编译为库本身，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-c890566ea7b83b00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"></p><p>在开发中，为了让开发的静态库使用起来更方便，只需要让使用者导入一个头文件，便可以访问你所提供的接口，并且通过接口进行数据回调。</p><h2 id="2-导入头文件"><a href="#2-导入头文件" class="headerlink" title="2. 导入头文件"></a>2. 导入头文件</h2><p>导入UIKit的头文件，这是创建一个库所需要的。当你在创建不同的组成类时，你将会为它们添加到这个文件中，确保它们能够被库的使用者获取到。</p><p>打开FBYSDKDemo.h，引入头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure></p><p>点击Build Phases，展开Link Binary with Libraries这一部分，点击+添加一个新的framework，找到UIKit.framework，点击add添加进来。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-73af75316bd9c807.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="33.png"></p><p>如果不结合头文件，静态库是没有用的，静态库编译一组文件，在这些文件中类和方法都以二进制数据的形式存在。<br>在静态库中类分为两类，一类是公开的public，一类是私有的只能内部访问使用。</p><p>接下来，需要在build栏中添加新的phase，来包含所有头文件。<br>在Xcode的Build Phases界面，选择Editor\Add Build Phase\Add Headers Build Phase。</p><p>注意：如果发现按上面找到的菜单项是不可点击的，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-ec4c0abb01fd6703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="44.png"></p><p>点击下方Build Phases界面的白色区域来获取Xcode的应用焦点，然后重新试一下</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-1aa858ffe3ebcd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="55.png"></p><p>把FBYSDKDemo.h从项目中拖到Copy Headers下的Public部分。<br>这里是要保证用户可以使用库中公开的类或者接口。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-5bcdf62ad6da934f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="66.png"></p><p>Copy Headers下的Public部分中所添加的类均是对外公开的。<br>这里有三个分组，Public公开的，Private下的头文件是可以被用户看到的，Project下的文件是私有的，这里建议尽量将文件放在Public和Project下。</p><h2 id="3-添加配置"><a href="#3-添加配置" class="headerlink" title="3. 添加配置"></a>3. 添加配置</h2><p>添加配置主要是在Build Settings下操作，点击项目名，然后选择FBYSDKDemo静态库目标，选择Build Setting栏，然后搜索public header，双击Public Headers Folder Path，在弹出视图中键入如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include/$(PROJECT_NAME)</span><br></pre></td></tr></table></figure></p><p>截图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-69c53a921d485524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="77.png"></p><p>因为你创建好的静态文件供他人使用，最好禁掉无效代码和debug符号，让用户自己选择对自己的项目有利的部分使用。<br>在搜索框中分别搜索Dead Code Stripping、Strip Debug Symbol During Copy、Strip Style配置如下：</p><ul><li>Dead Code Stripping设置为NO</li><li>Strip Debug Symbol During Copy 全部设置为NO</li><li>Strip Style设置为Non-Global Symbols</li></ul><p>到目前为止，项目的构建已经完成，选择目标为Generic iOS Device，按下command + B进行编译，工程导航栏中Product目录下libRWUIControls.a文件将从红色变为黑色，表明现在该文件已经存在了。右键单击libRWUIControls.a，选择Show in Finder，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-fc1fa643726aba34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="83.png"></p><p>上图就可以看到对外公开的FBYSDKDemo.h类，其他实现类均以二进制的形式在libFBYSDKDemo.a中。</p><h4 id="4-功能实现"><a href="#4-功能实现" class="headerlink" title="4. 功能实现"></a>4. 功能实现</h4><p>这里以实现静态库的开发为主，功能部分实现一个简单的功能demo来举例。</p><p>在头文件FBYSDKDemo.h中实现如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">typedef void (^FBYSDKCompletion)(NSString *result);</span><br><span class="line"></span><br><span class="line">@interface FBYSDKDemo : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param urltype       网页类型信息 urltype可为iOS、Android</span><br><span class="line"> *  @param completion    根据urltype获取到相应网页url结果回调</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">- (void)urlType:(NSString *)urltype withCompletion:(FBYSDKCompletion)completion;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其中urltype为网页类型信息 urltype可为iOS、Android，根据urltype获取到相应网页url结果回调completion。</p><p>在实现文件FBYSDKDemo.m中代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYSDKDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@interface FBYSDKDemo ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FBYSDKDemo</span><br><span class="line"></span><br><span class="line">- (void)urlType:(NSString *)urltype withCompletion:(FBYSDKCompletion)completion&#123;</span><br><span class="line"></span><br><span class="line">    if ([urltype isEqualToString:[NSString stringWithFormat:@&quot;iOS&quot;]]) &#123;</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            completion(@&quot;https://juejin.im/post/5a41c04c6fb9a044fc44fd23&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else if ([urltype isEqualToString:[NSString stringWithFormat:@&quot;Android&quot;]]) &#123;</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            completion(@&quot;https://juejin.im/post/5a31e6adf265da430c11d41f&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>选择目标为Generic iOS Device，按下command + B进行编译。</p><h4 id="5-合并静态库"><a href="#5-合并静态库" class="headerlink" title="5. 合并静态库"></a>5. 合并静态库</h4><p>选择目标为Generic iOS Device，编译运行后，右键单击libRWUIControls.a，选择Show in Finder显示的libFBYSDKDemo.a可在真机，如果在虚拟机中运行会报错。</p><p>所以还要选择目标为虚拟机(例如iPhone 7)，然后编译运行,右键单击libRWUIControls.a，选择Show in Finder显示的libFBYSDKDemo.a可在虚拟机中运行，如果在真机中运行会报错。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-a3e708bee87e2ab4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="85.png"></p><p>合并方法：打开终端，输入 lipo -create 真机库.a的路径 模拟器库.a的路径 －output 合成库的名字(可以复制模库.a的路径，修改名字).a；回车就可以在模拟库的文件夹中看到新合成的.a文件了，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-f248aa80f8e0d51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="87.png"></p><p>合成后静态库文件截图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-ac84b824650886ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="86.png"></p><p>libFBYSDKDemo_all.a文件即为静态库文件，一个通用的静态库.a就做好了。</p><h2 id="三：静态库使用"><a href="#三：静态库使用" class="headerlink" title="三：静态库使用"></a>三：静态库使用</h2><h4 id="1-导入静态库"><a href="#1-导入静态库" class="headerlink" title="1. 导入静态库"></a>1. 导入静态库</h4><p>导入静态库和.h头文件，注意下图选项：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-4f6e12c405f4cca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="89.png"></p><h4 id="2-调用函数"><a href="#2-调用函数" class="headerlink" title="2. 调用函数"></a>2. 调用函数</h4><p>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)blogsBtn:(UIButton *)sender &#123;</span><br><span class="line"></span><br><span class="line">    if (sender.tag == 6000) &#123;</span><br><span class="line"></span><br><span class="line">        [FBYSDKDemo urlType:@&quot;iOS&quot; withCompletion:^(NSString *result) &#123;</span><br><span class="line"></span><br><span class="line">            [self contentURL:result];</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if (sender.tag == 6001) &#123;</span><br><span class="line"></span><br><span class="line">        [FBYSDKDemo urlType:@&quot;Android&quot; withCompletion:^(NSString *result) &#123;</span><br><span class="line"></span><br><span class="line">            [self contentURL:result];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>result就是通过sdk回调获取到的结果。</p><h4 id="3-DEMO截图如下"><a href="#3-DEMO截图如下" class="headerlink" title="3. DEMO截图如下"></a>3. DEMO截图如下</h4><p><img src="http://upload-images.jianshu.io/upload_images/2829694-9a2fd73f4f291b21.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DEMO截图"></p><p>本篇文章demo源码：</p><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">静态库生成demo</a><br><a href="https://github.com/fanbaoying/FBYURLSDKDemo" target="_blank" rel="noopener">静态库使用demo</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;h4 id=&quot;1-什么是库？&quot;&gt;&lt;a href=&quot;#1-什么是库？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是库？&quot;&gt;&lt;/a&gt;1. 什么是库？&lt;/h4&gt;&lt;p&gt;库是共享程序代码的方式，一般分为静态库和动态库。&lt;/p&gt;
&lt;p&gt;静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。&lt;/p&gt;
&lt;p&gt;动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WKUIDelegate协议 - 手机网站支付转Native支付</title>
    <link href="https://fanbaoying.github.io/WKUIDelegate%E5%8D%8F%E8%AE%AE-%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E8%BD%ACNative%E6%94%AF%E4%BB%98/"/>
    <id>https://fanbaoying.github.io/WKUIDelegate协议-手机网站支付转Native支付/</id>
    <published>2018-01-31T06:16:07.000Z</published>
    <updated>2018-01-31T06:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>为了节约开发成本，很多Native-H5混合App采用手机网站支付的方式去实现支付模块。但手机网站支付的网络依赖比较严重，也通常需要经过更多的验证，这种种原因导致手机网站支付的成功率比Native支付低，对商户的利益造成影响。</p><a id="more"></a><p>官方文档使用的是UIWebViewDelegate协议</p><h2 id="二：新旧版本区别"><a href="#二：新旧版本区别" class="headerlink" title="二：新旧版本区别"></a>二：新旧版本区别</h2><h4 id="1-旧版本"><a href="#1-旧版本" class="headerlink" title="1. 旧版本"></a>1. 旧版本</h4><p>获取到的url order info，从h5链接中获取订单串接口函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString*)fetchOrderInfoFromH5PayUrl:(NSString*)urlStr;</span><br><span class="line">- (void)payUrlOrder:(NSString *)orderStr</span><br><span class="line">         fromScheme:(NSString *)schemeStr</span><br><span class="line">           callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>上面两个函数自版本15.4.0起已废弃。</p><h4 id="2-新版本"><a href="#2-新版本" class="headerlink" title="2. 新版本"></a>2. 新版本</h4><p>新版本推荐使用下面方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  从h5链接中获取订单串并支付接口（自版本15.4.0起，推荐使用该接口）</span><br><span class="line"> *</span><br><span class="line"> *  @param urlStr     拦截的 url string</span><br><span class="line"> *</span><br><span class="line"> *  @return YES为成功获取订单信息并发起支付流程；NO为无法获取订单信息，输入url是普通url</span><br><span class="line"> */</span><br><span class="line">- (BOOL)payInterceptorWithUrl:(NSString *)urlStr</span><br><span class="line">                   fromScheme:(NSString *)schemeStr</span><br><span class="line">                     callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>旧版本在官方推荐的UIWebViewDelegate协议中使用，暂时没有遇到问题。</p><p>如果在WKUIDelegate协议中使用fetchOrderInfoFromH5PayUrl函数，获得的获取到的url order info为空，无法调起支付。</p><p>下面我就给大家介绍一下使用WKUIDelegate协议怎么解决手机网站支付转Native支付。</p><h2 id="三：SDK导入流程"><a href="#三：SDK导入流程" class="headerlink" title="三：SDK导入流程"></a>三：SDK导入流程</h2><h4 id="1-下载sdk"><a href="#1-下载sdk" class="headerlink" title="1.下载sdk"></a>1.<a href="https://docs.open.alipay.com/54/104509" target="_blank" rel="noopener">下载sdk</a></h4><p>把iOS包中的压缩文件中以下文件拷贝到项目文件夹下，并导入到项目工程中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AlipaySDK.bundle</span><br><span class="line">AlipaySDK.framework</span><br></pre></td></tr></table></figure></p><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2.添加依赖"></a>2.添加依赖</h4><p>在Build Phases选项卡的Link Binary With Libraries中，增加以下依赖：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f45ce7a16e86?w=1112&amp;h=538&amp;f=png&amp;s=143033" alt="h5alipay.png"></p><p>注意：</p><p>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd。</p><p>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib。</p><h2 id="四：使用说明："><a href="#四：使用说明：" class="headerlink" title="四：使用说明："></a>四：使用说明：</h2><h4 id="1-头文件引用"><a href="#1-头文件引用" class="headerlink" title="1.头文件引用"></a>1.头文件引用</h4><p>在需要调用AlipaySDK的文件中，增加头文件引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br><span class="line"></span><br><span class="line">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line">@interface ViewController ()&lt;WKNavigationDelegate,WKUIDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) WKWebView *webView;</span><br><span class="line">//进度条</span><br><span class="line">@property (weak, nonatomic) CALayer *progresslayer;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>//初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)stopRunning&#123;</span><br><span class="line"></span><br><span class="line">    WKWebView *webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 64, SCREEN_WIDTH, SCREEN_HEIGHT-64)];</span><br><span class="line"></span><br><span class="line">    [self.view addSubview:webView];</span><br><span class="line">    self.webView = webView;</span><br><span class="line"></span><br><span class="line">    webView.navigationDelegate = self;</span><br><span class="line">    webView.UIDelegate = self;</span><br><span class="line"></span><br><span class="line">    //添加属性监听</span><br><span class="line">    [webView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line"></span><br><span class="line">    //进度条</span><br><span class="line">    UIView *progress = [[UIView alloc]initWithFrame:CGRectMake(0, 64, CGRectGetWidth(self.view.frame), 3)];</span><br><span class="line">    progress.backgroundColor = [UIColor clearColor];</span><br><span class="line">    [self.view addSubview:progress];</span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    layer.frame = CGRectMake(0, 0, 0, 3);</span><br><span class="line">    layer.backgroundColor = [UIColor blueColor].CGColor;</span><br><span class="line">    [progress.layer addSublayer:layer];</span><br><span class="line">    self.progresslayer = layer;</span><br><span class="line">    [webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:_customLabel.text]]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-调用接口"><a href="#2-调用接口" class="headerlink" title="2.调用接口"></a>2.调用接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[AlipaySDK defaultService]fetchOrderInfoFromH5PayUrl:url]</span><br></pre></td></tr></table></figure><h4 id="3-实现WKUIDelegate协议，拦截H5的URL"><a href="#3-实现WKUIDelegate协议，拦截H5的URL" class="headerlink" title="3.实现WKUIDelegate协议，拦截H5的URL"></a>3.实现WKUIDelegate协议，拦截H5的URL</h4><p>如果返回的resultCode为9000，接入方可以提示用户支付成功；</p><p>返回结果不是9000的情况，无需做任何处理。如果returnUrl不为空，建议接入方跳转到该returnUrl。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction*)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);//允许跳转</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,navigationAction.request.URL.absoluteString);</span><br><span class="line"></span><br><span class="line">    if ([navigationAction.request.URL.absoluteString hasPrefix:@&quot;alipay://alipayclient/&quot;]) &#123;</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line"></span><br><span class="line">        if ([[UIApplication sharedApplication] canOpenURL:navigationAction.request.URL]) &#123;</span><br><span class="line">            [[UIApplication sharedApplication] openURL:navigationAction.request.URL options:@&#123;UIApplicationOpenURLOptionUniversalLinksOnly: @NO&#125; completionHandler:^(BOOL success) &#123;</span><br><span class="line"></span><br><span class="line">                __weak APWebViewController* wself = self;</span><br><span class="line">                BOOL isIntercepted = [[AlipaySDK defaultService] payInterceptorWithUrl:[navigationAction.request.URL absoluteString] fromScheme:@&quot;alisdkdemo&quot; callback:^(NSDictionary *result) &#123;</span><br><span class="line">                    // 处理支付结果</span><br><span class="line">                    NSLog(@&quot;%@&quot;, result);</span><br><span class="line">                    // isProcessUrlPay 代表 支付宝已经处理该URL</span><br><span class="line">                    if ([result[@&quot;isProcessUrlPay&quot;] boolValue]) &#123;</span><br><span class="line">                        // returnUrl 代表 第三方App需要跳转的成功页URL</span><br><span class="line">                        NSString* urlStr = result[@&quot;returnUrl&quot;];</span><br><span class="line">                        [wself loadWithUrlStr:urlStr];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;];</span><br><span class="line"></span><br><span class="line">                if (isIntercepted) &#123;</span><br><span class="line"></span><br><span class="line">                    NSLog(@&quot;URL非支付宝支付URL&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-支付结果回调处理"><a href="#4-支付结果回调处理" class="headerlink" title="4.支付结果回调处理"></a>4.支付结果回调处理</h4><p>支付宝客户端返回url处理方法，在AppDelegate.m文件中，增加头文件引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure></p><p>在@implementation AppDelegate中增加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //如果极简开发包不可用，会跳转支付宝钱包进行支付，需要将支付宝钱包的支付结果回传给开发包</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    //【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;platformapi&quot;])&#123;//支付宝钱包快登授权返回authCode</span><br><span class="line"></span><br><span class="line">        [[AlipaySDK defaultService] processAuthResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            //【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;为了节约开发成本，很多Native-H5混合App采用手机网站支付的方式去实现支付模块。但手机网站支付的网络依赖比较严重，也通常需要经过更多的验证，这种种原因导致手机网站支付的成功率比Native支付低，对商户的利益造成影响。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android 使用广播系统解决app开机自启动问题</title>
    <link href="https://fanbaoying.github.io/Android-%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3app%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://fanbaoying.github.io/Android-使用广播系统解决app开机自启动问题/</id>
    <published>2018-01-31T04:01:37.000Z</published>
    <updated>2018-01-31T06:20:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanbaoying/PowerBoot" target="_blank" rel="noopener">Demo地址</a>  如果有所帮助记得关注，点Star<br>总结一下使用ACTION_BOOT_COMPLETED的广播，解决app开机自启动的问题<br>1.首先在你的工程上建一个广播接受的类，继承BroadcastReceiver：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package guide.example.com.guidedemo;</span><br><span class="line"></span><br><span class="line">import android.content.BroadcastReceiver;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by fby on 2017/6/26.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class BootReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    static final String action_boot =&quot;android.intent.action.BOOT_COMPLETED&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive (Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        Log.i(&quot;charge start&quot;, &quot;启动完成&quot;);</span><br><span class="line"></span><br><span class="line">        if (intent.getAction().equals(action_boot))&#123;</span><br><span class="line"></span><br><span class="line">            Intent mBootIntent = new Intent(context, MainActivity.class);</span><br><span class="line">            // 下面这句话必须加上才能开机自动运行app的界面</span><br><span class="line">            mBootIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            context.startActivity(mBootIntent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后要在AndroidManifest.xml中加入权限和配置相关信息：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>3.在application标签中，配置以下相关信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//BootReceiver是上面建的广播类</span><br><span class="line">        &lt;receiver android:name=&quot;.BootReceiver&quot;&gt;  </span><br><span class="line">            &lt;intent-filter&gt;  </span><br><span class="line">                &lt;!--注册开机广播地址--&gt;  </span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&gt;            </span><br><span class="line">                &lt;/action&gt;  </span><br><span class="line"></span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;  </span><br><span class="line">            &lt;/intent-filter&gt;  </span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><p>补充说明：<br>1.查看系统中是否安装了类似360管家的软件，为了加快开机速度，默认是关闭掉开机广播的，只需要在设置中打开即可。<br>2.如果监听不到广播，可以尝试同时监听广播和sd卡。<br>3.同时监听广播和sd卡，在application标签中，配置以下相关信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.broadcastReceiver.BootCompletedReceiver&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;data android:scheme=&quot;package&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanbaoying/PowerBoot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo地址&lt;/a&gt;  如果有所帮助记得关注，点Star&lt;br&gt;总结一下使用ACTION_BOOT_COMPLETED的广播，解决app开机自启动的问题&lt;br&gt;1.首先在你的工程上建一个广播接受的类，继承BroadcastReceiver：&lt;/p&gt;
    
    </summary>
    
      <category term="Android文集" scheme="https://fanbaoying.github.io/categories/Android%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>码出一个高颜值原生折线图</title>
    <link href="https://fanbaoying.github.io/%E7%A0%81%E5%87%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E9%A2%9C%E5%80%BC%E5%8E%9F%E7%94%9F%E6%8A%98%E7%BA%BF%E5%9B%BE/"/>
    <id>https://fanbaoying.github.io/码出一个高颜值原生折线图/</id>
    <published>2018-01-31T02:34:30.000Z</published>
    <updated>2018-01-31T06:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>在项目中遇到数据展示需求时，往往会通过，以列表的形式展示出数据或者以表格的形式展示。但是并不能直观的观察数据的变化，如果通过图表的形式来展示，就可以更快捷的获取到数据变化情况。</p><p>图表展示的方式大致分为折线图、柱状图、饼状图等等，那么如何码出一个高颜值原生折线图呢？<a href="https://github.com/fanbaoying/FBYDataDisplay-iOS" target="_blank" rel="noopener">demo源码</a>已经放在GitHub上，下面来介绍一下如何使用。</p><a id="more"></a><h2 id="二：项目展示"><a href="#二：项目展示" class="headerlink" title="二：项目展示"></a>二：项目展示</h2><p>运行后的展示截图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-412e7b8951ec0bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="三：-实现思路分析"><a href="#三：-实现思路分析" class="headerlink" title="三： 实现思路分析"></a>三： 实现思路分析</h2><p>实现折线图的核心代码是下面四个类：</p><ul><li>FBYLineGraphBaseView</li><li>FBYLineGraphContentView</li><li>FBYLineGraphColorView</li><li>FBYLineGraphView<br>下面针对这四个类实现做一个详细的流程分析。</li></ul><h4 id="1-折线图基础框架实现-FBYLineGraphBaseView类"><a href="#1-折线图基础框架实现-FBYLineGraphBaseView类" class="headerlink" title="1. 折线图基础框架实现(FBYLineGraphBaseView类)"></a>1. 折线图基础框架实现(FBYLineGraphBaseView类)</h4><p>折线图基础框架包括Y轴刻度标签、X轴刻度标签、与x轴平行的网格线的间距、网格线的起始点、x 轴长度、y 轴长度，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYLineGraphBaseView : UIView</span><br><span class="line"></span><br><span class="line">//Y轴刻度标签</span><br><span class="line">@property (nonatomic, strong) NSArray *yMarkTitles;</span><br><span class="line"></span><br><span class="line">//X轴刻度标签</span><br><span class="line">@property (nonatomic, strong) NSArray *xMarkTitles;</span><br><span class="line"></span><br><span class="line">// 与x轴平行的网格线的间距</span><br><span class="line">@property (nonatomic, assign) CGFloat xScaleMarkLEN;</span><br><span class="line"></span><br><span class="line">//网格线的起始点</span><br><span class="line">@property (nonatomic, assign) CGPoint startPoint;</span><br><span class="line"></span><br><span class="line">//x 轴长度</span><br><span class="line">@property (nonatomic, assign) CGFloat yAxis_L;</span><br><span class="line"></span><br><span class="line">//y 轴长度</span><br><span class="line">@property (nonatomic, assign) CGFloat xAxis_L;</span><br><span class="line"></span><br><span class="line">//绘图</span><br><span class="line">- (void)mapping;</span><br><span class="line"></span><br><span class="line">//更新做标注数据</span><br><span class="line">- (void)reloadDatas;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="2-折线图数据内容显示-FBYLineGraphContentView类"><a href="#2-折线图数据内容显示-FBYLineGraphContentView类" class="headerlink" title="2. 折线图数据内容显示(FBYLineGraphContentView类)"></a>2. 折线图数据内容显示(FBYLineGraphContentView类)</h4><p>折线图数据内容显示是继承FBYLineGraphBaseView类进行实现，其中主要包括，X轴最大值、数据内容来实现，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;FBYLineGraphBaseView.h&quot;</span><br><span class="line">@interface FBYLineGraphContentView : FBYLineGraphBaseView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSArray *valueArray;</span><br><span class="line">@property (nonatomic, assign) CGFloat maxValue;</span><br><span class="line"></span><br><span class="line">//绘图</span><br><span class="line">- (void)mapping;</span><br><span class="line"></span><br><span class="line">//更新折线图数据</span><br><span class="line">- (void)reloadDatas;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-折线图颜色控制类-FBYLineGraphColorView类"><a href="#3-折线图颜色控制类-FBYLineGraphColorView类" class="headerlink" title="3. 折线图颜色控制类(FBYLineGraphColorView类)"></a>3. 折线图颜色控制类(FBYLineGraphColorView类)</h4><p>折线图颜色控制类主要控制选中远点边框宽度和整体布局颜色，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYLineGraphColorView : UIView</span><br><span class="line"></span><br><span class="line">//颜色设置</span><br><span class="line">@property (nonatomic, assign) CGFloat borderWidth;</span><br><span class="line">@property (nonatomic, assign) UIColor *borderColor;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCenter:(CGPoint)center radius:(CGFloat)radius;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-折线图核心代码类-FBYLineGraphView类"><a href="#3-折线图核心代码类-FBYLineGraphView类" class="headerlink" title="3. 折线图核心代码类(FBYLineGraphView类)"></a>3. 折线图核心代码类(FBYLineGraphView类)</h4><p>折线图核心代码类主要给引用类提供配置接口和数据接口，其中包括表名、Y轴刻度标签title、Y轴最大值、X轴刻度标签的长度（单位长度）、设置折线图显示的数据和对应X坐标轴刻度标签，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYLineGraphView : UIView</span><br><span class="line"></span><br><span class="line">//表名</span><br><span class="line">@property (nonatomic, strong) NSString *title;</span><br><span class="line"></span><br><span class="line">//Y轴刻度标签title</span><br><span class="line">@property (nonatomic, strong) NSArray *yMarkTitles;</span><br><span class="line"></span><br><span class="line">//Y轴最大值</span><br><span class="line">@property (nonatomic, assign) CGFloat maxValue;</span><br><span class="line"></span><br><span class="line">//X轴刻度标签的长度（单位长度）</span><br><span class="line">@property (nonatomic, assign) CGFloat xScaleMarkLEN;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  设置折线图显示的数据和对应X坐标轴刻度标签</span><br><span class="line"> *</span><br><span class="line"> *  @param xMarkTitlesAndValues 折线图显示的数据和X坐标轴刻度标签</span><br><span class="line"> *  @param titleKey             标签（如:9月1日）</span><br><span class="line"> *  @param valueKey             数据 (如:80)</span><br><span class="line"> */</span><br><span class="line">- (void)setXMarkTitlesAndValues:(NSArray *)xMarkTitlesAndValues titleKey:(NSString *)titleKey valueKey:(NSString *)valueKey;</span><br><span class="line"></span><br><span class="line">- (void)mapping;</span><br><span class="line">- (void)reloadDatas;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="四：如何在项目中使用"><a href="#四：如何在项目中使用" class="headerlink" title="四：如何在项目中使用"></a>四：如何在项目中使用</h2><h4 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h4><p>在demo中找到FBYLineGraph文件夹，将文件夹拖入自己的项目中。DEMO截图</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-ac73ffe325cbacb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B0375CE3-F420-4E36-842F-6491EA0047F9.png"></p><h4 id="2-代码引用"><a href="#2-代码引用" class="headerlink" title="2. 代码引用"></a>2. 代码引用</h4><p>2.1 首先在项目中需要使用的页面引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYLineGraphView.h&quot;</span><br></pre></td></tr></table></figure><p>2.2 初始化折线图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FBYLineGraphView *LineGraphView = [[FBYLineGraphView alloc] initWithFrame:CGRectMake(10, 100, SCREEN_WIDTH - 20, 220)];</span><br></pre></td></tr></table></figure><p>2.3 设置折线图属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LineGraphView.title = @&quot;折线统计图&quot;; // 折线图名称</span><br><span class="line">LineGraphView.maxValue = 100;   // 最大值</span><br><span class="line">LineGraphView.xScaleMarkLEN = 60; // 每格的宽度如果不设置，系统默认平均分配</span><br></pre></td></tr></table></figure><p>2.4 给折线图添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LineGraphView.yMarkTitles = @[@&quot;0&quot;,@&quot;20&quot;,@&quot;40&quot;,@&quot;60&quot;,@&quot;80&quot;,@&quot;100&quot;]; // Y轴刻度标签</span><br><span class="line"></span><br><span class="line">[LineGraphView setXMarkTitlesAndValues:@[@&#123;@&quot;item&quot;:@&quot;1月1日&quot;,@&quot;count&quot;:@10&#125;,@&#123;@&quot;item&quot;:@&quot;1月2日&quot;,@&quot;count&quot;:@80&#125;,@&#123;@&quot;item&quot;:@&quot;1月3日&quot;,@&quot;count&quot;:@68&#125;,@&#123;@&quot;item&quot;:@&quot;1月4日&quot;,@&quot;count&quot;:@100&#125;,@&#123;@&quot;item&quot;:@&quot;1月5日&quot;,@&quot;count&quot;:@60&#125;,@&#123;@&quot;item&quot;:@&quot;1月6日&quot;,@&quot;count&quot;:@56&#125;,@&#123;@&quot;item&quot;:@&quot;1月7日&quot;,@&quot;count&quot;:@11&#125;] titleKey:@&quot;item&quot; valueKey:@&quot;count&quot;]; // X轴刻度标签及相应的值</span><br></pre></td></tr></table></figure><p>可以根据自己项目获取的数据进行修改，不过数据格式不要改动。</p><p>2.5 设置完数据和属性，绘制展示折线图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//设置完数据等属性后绘图折线图</span><br><span class="line">[LineGraphView mapping];</span><br><span class="line">[self.view addSubview:LineGraphView];</span><br></pre></td></tr></table></figure><p>设置完上面的，一个高颜值原生折线统计图就可以使用了。<br>如果好用就请点赞关注，会不定期更新更多干货。更多源码可以去GitHub下载。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;在项目中遇到数据展示需求时，往往会通过，以列表的形式展示出数据或者以表格的形式展示。但是并不能直观的观察数据的变化，如果通过图表的形式来展示，就可以更快捷的获取到数据变化情况。&lt;/p&gt;
&lt;p&gt;图表展示的方式大致分为折线图、柱状图、饼状图等等，那么如何码出一个高颜值原生折线图呢？&lt;a href=&quot;https://github.com/fanbaoying/FBYDataDisplay-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo源码&lt;/a&gt;已经放在GitHub上，下面来介绍一下如何使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>FMDB | 实现数据的增删改查</title>
    <link href="https://fanbaoying.github.io/FMDB-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>https://fanbaoying.github.io/FMDB-实现数据的增删改查/</id>
    <published>2018-01-30T06:50:04.000Z</published>
    <updated>2018-01-31T06:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>是一个轻量级的数据库，用于将网络资源存储在本地。<br>项目中使用 ARC 还是 MRC，对使用 FMDB 都没有任何影响，FMDB 会在编译项目时自动匹配。<br>FMDB 将 SQLite API 进行了很友好的封装，使用起来非常方便。</p><p>下面是对FMDB的使用总结，分享给大家，另外附一份<a href="https://github.com/fanbaoying/FBYFMDBDemo" target="_blank" rel="noopener">demo</a>供大家参考。</p><a id="more"></a><h2 id="二：FMDB优点"><a href="#二：FMDB优点" class="headerlink" title="二：FMDB优点"></a>二：FMDB优点</h2><ul><li><p>1.使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</p></li><li><p>2.对比苹果自带的Core Data框架，更加轻量级和灵活</p></li><li><p>3.提供了多线程安全的数据库操作方法，有效地防止数据混乱</p></li></ul><h2 id="三：将FMDB第三方库引入到项目"><a href="#三：将FMDB第三方库引入到项目" class="headerlink" title="三：将FMDB第三方库引入到项目"></a>三：将FMDB第三方库引入到项目</h2><p>下载<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>库文件，demo中是直接导入项目中，可直接下载demo引用库文件，也可以使用CocoaPods导入。</p><blockquote><p>注意：需要 libsqlite3.dylib 依赖（具体流程 Project-&gt;TARGETS-&gt;Build Phases-&gt;Link Binary With Libraries,然后点击＋号引用该动态库）</p></blockquote><h2 id="四：FMDB主要的核心类"><a href="#四：FMDB主要的核心类" class="headerlink" title="四：FMDB主要的核心类"></a>四：FMDB主要的核心类</h2><h4 id="4-1-FMDatabase"><a href="#4-1-FMDatabase" class="headerlink" title="4.1 FMDatabase"></a>4.1 FMDatabase</h4><p>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1.获得数据库文件的路径</span><br><span class="line">NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line">self.dbPath = fileName;</span><br><span class="line">//2.获得数据库</span><br><span class="line">FMDatabase *db=[FMDatabase databaseWithPath:self.dbPath];</span><br></pre></td></tr></table></figure><h4 id="4-2-FMResultSet"><a href="#4-2-FMResultSet" class="headerlink" title="4.2 FMResultSet"></a>4.2 FMResultSet</h4><p>使用FMResultSet执行查询后的结果集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.执行查询语句</span><br><span class="line">FMResultSet *resultSet = [self.db executeQuery:@&quot;SELECT * FROM t_userData&quot;];</span><br><span class="line"></span><br><span class="line">// 2.遍历结果</span><br><span class="line">while ([resultSet next]) &#123;</span><br><span class="line"></span><br><span class="line">    NSString *nameStr = [resultSet stringForColumn:@&quot;userName&quot;];</span><br><span class="line">    [self.nameArr addObject:nameStr];</span><br><span class="line"></span><br><span class="line">    NSString *ageStr = [resultSet stringForColumn:@&quot;userAge&quot;];</span><br><span class="line">    [self.ageArr addObject:ageStr];</span><br><span class="line"></span><br><span class="line">    NSString *idStr = [resultSet stringForColumn:@&quot;id&quot;];</span><br><span class="line">    [self.idArr addObject:idStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-FMDatabaseQueue"><a href="#4-3-FMDatabaseQueue" class="headerlink" title="4.3 FMDatabaseQueue"></a>4.3 FMDatabaseQueue</h4><p>FMDatabaseQueue是在多线程下查询和更新数据库用到的类</p><h2 id="五：使用FMDB进行增删改查"><a href="#五：使用FMDB进行增删改查" class="headerlink" title="五：使用FMDB进行增删改查"></a>五：使用FMDB进行增删改查</h2><p>通常对数据库的操作，我们一般称为CURD,即对表进行创建(Create)、更新(Update)、读取(Read)和删除(Delete)操作。</p><h4 id="5-1-数据类型分析"><a href="#5-1-数据类型分析" class="headerlink" title="5.1 数据类型分析"></a>5.1 数据类型分析</h4><p>对数据库中存储的每一个值都有一个类型</p><ul><li>NULL 这个值为空值</li><li>INTEGER 值被标识为整数，依据值的大小可以依次被存储1～8个字节</li><li>REAL 所有值都是浮动的数值</li><li>TEXT 值为文本字符串</li><li>BLOB 值为blob数据</li></ul><h4 id="5-2-FMDB库文件使用"><a href="#5-2-FMDB库文件使用" class="headerlink" title="5.2 FMDB库文件使用"></a>5.2 FMDB库文件使用</h4><p>1.引入头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FMDB.h&quot;</span><br></pre></td></tr></table></figure><p>2.定义属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface viewController ()</span><br><span class="line">@property(nonatomic,strong)FMDatabase *db;</span><br><span class="line"></span><br><span class="line">@property(strong,nonatomic)NSString * dbPath;</span><br><span class="line"></span><br><span class="line">@property(strong,nonatomic)UITextField *nameTxteField;</span><br><span class="line">@property(strong,nonatomic)UITextField *ageTxteField;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>3.获取数据库文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获得数据库文件的路径</span><br><span class="line">NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line">self.dbPath = fileName;</span><br></pre></td></tr></table></figure><p>4.建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//2.获得数据库</span><br><span class="line">FMDatabase *db=[FMDatabase databaseWithPath:self.dbPath];</span><br><span class="line">//3.打开数据库</span><br><span class="line">if ([db open]) &#123;</span><br><span class="line">    //4.创表</span><br><span class="line">    BOOL result=[db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_userData (id integer PRIMARY KEY AUTOINCREMENT, userName text NOT NULL, userAge text NOT NULL);&quot;];</span><br><span class="line">    if (result)&#123;</span><br><span class="line">        NSLog(@&quot;创表成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;创表失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">self.db=db;</span><br><span class="line"></span><br><span class="line">[self insert];</span><br></pre></td></tr></table></figure><h4 id="5-3-新增数据"><a href="#5-3-新增数据" class="headerlink" title="5.3 新增数据"></a>5.3 新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//新增数据</span><br><span class="line">-(void)insert&#123;</span><br><span class="line">    BOOL res = [self.db executeUpdate:@&quot;INSERT INTO t_userData (userName, userAge) VALUES (?, ?);&quot;, _nameTxteField.text, _ageTxteField.text];</span><br><span class="line"></span><br><span class="line">    if (!res) &#123;</span><br><span class="line">        NSLog(@&quot;增加数据失败&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;增加数据成功&quot;);</span><br><span class="line"></span><br><span class="line">        UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;新增数据成功&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">        [self performSelector:@selector(dismiss:) withObject:alert afterDelay:0.5];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-16c71ca322a2b65f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="81.png"></p><h4 id="5-4-删除数据"><a href="#5-4-删除数据" class="headerlink" title="5.4 删除数据"></a>5.4 删除数据</h4><p>删除数据分为删除一条数据和删除整表数据</p><ol><li>删除一条数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 删除一条数据</span><br><span class="line">- (void)deleteData:(NSInteger)userid&#123;</span><br><span class="line">    //1.获得数据库文件的路径</span><br><span class="line">    NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line"></span><br><span class="line">    //2.获得数据库</span><br><span class="line">    FMDatabase *db = [FMDatabase databaseWithPath:fileName];</span><br><span class="line">    if ([db open]) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *str = [NSString stringWithFormat:@&quot;DELETE FROM t_userData WHERE id = %ld&quot;,userid];</span><br><span class="line">        BOOL res = [db executeUpdate:str];</span><br><span class="line">        if (!res) &#123;</span><br><span class="line">            NSLog(@&quot;数据删除失败&quot;);</span><br><span class="line">            [self lookData];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;数据删除成功&quot;);</span><br><span class="line">            [self lookData];</span><br><span class="line">        &#125;</span><br><span class="line">        [db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.删除整表数据</p><p>删除整表数据只需要将删除一条数据的语句更换为如下语句即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;DELETE FROM t_userData&quot;;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-69882fd7bdce9017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="84.png"></p><h4 id="5-5-修改数据"><a href="#5-5-修改数据" class="headerlink" title="5.5 修改数据"></a>5.5 修改数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 更新数据</span><br><span class="line">- (void)updateData &#123;</span><br><span class="line">    //获得数据库文件的路径</span><br><span class="line">    NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line">    self.dbPath = fileName;</span><br><span class="line"></span><br><span class="line">    FMDatabase *db = [FMDatabase databaseWithPath:self.dbPath];</span><br><span class="line">    if ([db open]) &#123;</span><br><span class="line">        NSString *sql = @&quot;UPDATE t_userData SET userName = ? , userAge = ? WHERE id = ?&quot;;</span><br><span class="line">        BOOL res = [db executeUpdate:sql,_nameTxteField.text,_ageTxteField.text,_userId];</span><br><span class="line">        if (!res) &#123;</span><br><span class="line">            NSLog(@&quot;数据修改失败&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;数据修改成功&quot;);</span><br><span class="line"></span><br><span class="line">            UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;数据修改成功&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">            [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">            [self performSelector:@selector(dismiss:) withObject:alert afterDelay:1.0];</span><br><span class="line">        &#125;</span><br><span class="line">        [db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-a7fb5e676e437a20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="82.png"></p><h4 id="5-6-查询数据"><a href="#5-6-查询数据" class="headerlink" title="5.6 查询数据"></a>5.6 查询数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//查询数据</span><br><span class="line">- (void)lookData &#123;</span><br><span class="line"></span><br><span class="line">    //1.获得数据库文件的路径</span><br><span class="line">    NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line"></span><br><span class="line">    //2.获得数据库</span><br><span class="line">    FMDatabase *db=[FMDatabase databaseWithPath:fileName];</span><br><span class="line"></span><br><span class="line">    //3.打开数据库</span><br><span class="line">    if ([db open]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    self.db=db;</span><br><span class="line"></span><br><span class="line">    // 1.执行查询语句</span><br><span class="line">    FMResultSet *resultSet = [self.db executeQuery:@&quot;SELECT * FROM t_userData&quot;];</span><br><span class="line"></span><br><span class="line">    // 2.遍历结果</span><br><span class="line">    while ([resultSet next]) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *nameStr = [resultSet stringForColumn:@&quot;userName&quot;];</span><br><span class="line">        [self.nameArr addObject:nameStr];</span><br><span class="line">        NSString *ageStr = [resultSet stringForColumn:@&quot;userAge&quot;];</span><br><span class="line">        [self.ageArr addObject:ageStr];</span><br><span class="line">        NSString *idStr = [resultSet stringForColumn:@&quot;id&quot;];</span><br><span class="line">        [self.idArr addObject:idStr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.myTableView reloadData];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-7120f1885f2c7aa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="83.png"></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FMDB&lt;/a&gt;是一个轻量级的数据库，用于将网络资源存储在本地。&lt;br&gt;项目中使用 ARC 还是 MRC，对使用 FMDB 都没有任何影响，FMDB 会在编译项目时自动匹配。&lt;br&gt;FMDB 将 SQLite API 进行了很友好的封装，使用起来非常方便。&lt;/p&gt;
&lt;p&gt;下面是对FMDB的使用总结，分享给大家，另外附一份&lt;a href=&quot;https://github.com/fanbaoying/FBYFMDBDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;供大家参考。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android 支付宝支付开发流程</title>
    <link href="https://fanbaoying.github.io/Android-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/Android-支付宝支付开发流程/</id>
    <published>2018-01-26T09:03:46.000Z</published>
    <updated>2018-02-06T07:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下支付宝支付，其他支付也给出了对应的连接。</p><p>在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。<br>其实如果接入的多的话，那些套路都可以绕着走。<br>网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。</p><a id="more"></a><h2 id="二：交互流程"><a href="#二：交互流程" class="headerlink" title="二：交互流程"></a>二：交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是<a href="https://doc.open.alipay.com/doc2/detail?spm=0.0.0.0.w6njr9&amp;treeId=59&amp;articleId=103658&amp;docType=1" target="_blank" rel="noopener">交互流程</a>这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="http://upload-images.jianshu.io/upload_images/2829694-2289d8431d73ccc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="功能流程图"></p><p>1.第4步：调用支付接口：此消息就是本接口所描述的开发包提供的支付对象PayTask，将商户签名后的订单信息传进pay方法唤起支付宝收银台，订单格式具体参见“<a href="https://doc.open.alipay.com/doc2/detail?treeId=59&amp;articleId=103663&amp;docType=1" target="_blank" rel="noopener">请求参数说明</a>”。<br>2.第5步：支付请求：手机支付宝支付开发包将会按照商户客户端提供的请求参数发送支付请求。<br>3.第8步：接口返回支付结果：商户客户端在第4步中调用的支付接口，会返回最终的支付结果（即同步通知），参见“<a href="https://doc.open.alipay.com/doc2/detail?treeId=59&amp;articleId=103665&amp;docType=1" target="_blank" rel="noopener">同步通知参数说明</a>”。<br>4.第12步：异步发送支付通知：手机支付宝支付服务器端发送异步通知消息给商户服务器端（备注：第12步一定发生在第6步之后，但不一定晚于7~11步），参见“<a href="https://doc.open.alipay.com/doc2/detail?treeId=59&amp;articleId=103666&amp;docType=1" target="_blank" rel="noopener">服务器异步通知参数说明</a>”。</p><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="http://upload-images.jianshu.io/upload_images/2829694-d9530794cede63a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据交互图"></p><p>支付宝支付的功能流程相比较微信支付来说简单的很，如上面两张图展示的，我们的App（也就是商户客户端）所做的大概只有三个步骤：</p><blockquote><p>生成订单<br>调用支付宝接口，发送订单<br>返回订单支付结果并处理</p></blockquote><h2 id="三：下载支付宝SDK"><a href="#三：下载支付宝SDK" class="headerlink" title="三：下载支付宝SDK"></a>三：下载支付宝SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了<a href="https://docs.open.alipay.com/54/104509" target="_blank" rel="noopener">最新的sdk地址</a>（注意的是下载出来的SDK包里面并没有传说中的开发文档，需要其他地方找或者看网页上的）。</p><p>想要接入支付宝移动支付功能，必须在<a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218010538" target="_blank" rel="noopener">支付宝商家服务平台</a>进行申请与审核。移动支付功能需要企业或者个体工商户进行申请，审核通过之后方可使用。<br>如何与支付宝签约并审核请参考官方文档：<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.vCcVse&amp;treeId=58&amp;articleId=103541&amp;docType=1" target="_blank" rel="noopener">移动支付-接入指南</a>，里面详细介绍了产品签约与审核流程。并且详细介绍了申请成功之后如何查看或生成必要的一些配置参数。</p><h2 id="四：导入开发SDK"><a href="#四：导入开发SDK" class="headerlink" title="四：导入开发SDK"></a>四：导入开发SDK</h2><h3 id="4-1-如果项目开发使用的Eclipse软件，导入步骤如下："><a href="#4-1-如果项目开发使用的Eclipse软件，导入步骤如下：" class="headerlink" title="4.1 如果项目开发使用的Eclipse软件，导入步骤如下："></a>4.1 如果项目开发使用的Eclipse软件，导入步骤如下：</h3><p>1.将alipaySDK-20150602.jar包放入商户应用工程的libs目录下，如下图。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-476f6522c171e913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="101.png"></p><p>2.进入商户应用工程的Java Build Path，将libs目录下的alipaySDK-20150602.jar导入，如下图。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-ccfa9544fe4b220c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="102.png"></p><p>3.选中Order and Export，勾选alipaySDK-20150602.jar，如下图。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-0c910c91d821c5b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="103.png"></p><h3 id="4-2-如果项目开发使用的Android-Studio软件，导入步骤如下："><a href="#4-2-如果项目开发使用的Android-Studio软件，导入步骤如下：" class="headerlink" title="4.2 如果项目开发使用的Android Studio软件，导入步骤如下："></a>4.2 如果项目开发使用的Android Studio软件，导入步骤如下：</h3><p>1.将支付宝SDK拷贝到项目libs文件夹下，如果没有libs文件夹，就新建一个。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-4988e8029e6d45d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="201.png"></p><p>2.如果sdk使用过程中，提示找不到文件。<br>进行如下操作，选中sdk文件，右击选择Reveal in Finder</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-6fa0ae70ea65bc53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="202.png"></p><h2 id="五：修改AndroidManifest-xml配置"><a href="#五：修改AndroidManifest-xml配置" class="headerlink" title="五：修改AndroidManifest.xml配置"></a>五：修改AndroidManifest.xml配置</h2><p>1.在商户应用工程的AndroidManifest.xml文件里面添加声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">            android:name=&quot;com.alipay.sdk.app.H5PayActivity&quot;</span><br><span class="line">            android:configChanges=&quot;orientation|keyboardHidden|navigation&quot;</span><br><span class="line">            android:exported=&quot;false&quot;</span><br><span class="line">            android:screenOrientation=&quot;behind&quot; &gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">            android:name=&quot;com.alipay.sdk.auth.AuthActivity&quot;</span><br><span class="line">            android:configChanges=&quot;orientation|keyboardHidden|navigation&quot;</span><br><span class="line">            android:exported=&quot;false&quot;</span><br><span class="line">            android:screenOrientation=&quot;behind&quot; &gt;</span><br><span class="line"> &lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>和权限声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="六：添加混淆规则"><a href="#六：添加混淆规则" class="headerlink" title="六：添加混淆规则"></a>六：添加混淆规则</h2><p>在商户应用工程的proguard-project.txt里添加以下相关规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-libraryjars libs/alipaySDK-20150602.jar</span><br><span class="line"></span><br><span class="line">-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;</span><br><span class="line">-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;</span><br><span class="line">-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;</span><br><span class="line">-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;</span><br><span class="line">-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;</span><br><span class="line">-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一行中的alipaySDK-20150602.jar，其中20150602是此版本发布的日期，注意将其修改为你导入的Jar的相应的文件名。</p></blockquote><p>到这里，支付宝支付的前期配置已经完成，下面需要完成支付代码编写。</p><h2 id="七：支付接口调用"><a href="#七：支付接口调用" class="headerlink" title="七：支付接口调用"></a>七：支付接口调用</h2><ol><li>在点击支付按钮的点击事件中，我提供的是从后端获取订单字符串，然后调用支付宝接口，调起支付。</li><li>需要在新线程中调用支付接口。代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//    支付按钮</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        //起一个线程</span><br><span class="line">        Runnable payRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String data = null;</span><br><span class="line">                PayBean payBean = new PayBean();</span><br><span class="line">                payBean.setOrderTime(&quot;&quot;);</span><br><span class="line">                String json = new Gson().toJson(payBean);</span><br><span class="line">                //json为获取后端结果时需要提供给后端订单信息，例如：时间、金额、订单属性等</span><br><span class="line">                Log.i(&quot;charge request&quot;, json);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //data为后端返回数据，其中包括订单字符串</span><br><span class="line">                    data = postJson(CHARGE_URL, json);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // Json解析data</span><br><span class="line">                ChargeBean charge = new Gson().fromJson(data, ChargeBean.class);</span><br><span class="line">                //获取调起支付所需要的字符串credential</span><br><span class="line">                String credential = (String) charge.getResult().getCredential();</span><br><span class="line">                // 调起支付界面</span><br><span class="line">                PayTask alipay = new PayTask(ThirdActivity.this);</span><br><span class="line">                Map&lt;String, String&gt; result = alipay.payV2(credential, true);</span><br><span class="line">                //在mHandler中处理支付宝返回结果</span><br><span class="line">                Message msg = new Message();</span><br><span class="line">                msg.what = SDK_PAY_FLAG;</span><br><span class="line">                msg.obj = result;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 必须异步调用</span><br><span class="line">        Thread payThread = new Thread(payRunnable);</span><br><span class="line">        payThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>在mHandler中处理支付结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (msg.what == SDK_PAY_FLAG) &#123;</span><br><span class="line"></span><br><span class="line">                Toast.makeText(ThirdActivity.this, (String) msg.obj,</span><br><span class="line">                        Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">                PayResult payResult = new PayResult((Map&lt;String, String&gt;) msg.obj);</span><br><span class="line">                /**</span><br><span class="line">                 对于支付结果，请商户依赖服务端的异步通知结果。同步通知结果，仅作为支付结束的通知。</span><br><span class="line">                 */</span><br><span class="line">                String resultInfo = payResult.getResult();// 同步返回需要验证的信息</span><br><span class="line">                String resultStatus = payResult.getResultStatus();</span><br><span class="line">                // 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档</span><br><span class="line">                if (resultStatus.equals(&quot;9000&quot;)) &#123;</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;else if (resultStatus.equals(&quot;4000&quot;))&#123;</span><br><span class="line"></span><br><span class="line">                    // 4000为支付失败，包括用户主动取消支付，或者系统返回的错误</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">                &#125;else if (resultStatus.equals(&quot;6001&quot;))&#123;</span><br><span class="line"></span><br><span class="line">                    // 6001为取消支付，或者系统返回的错误</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;取消支付&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">                &#125;else if (resultStatus.equals(&quot;8000&quot;)) &#123;</span><br><span class="line">                    // &quot;8000&quot;代表支付结果因为支付渠道原因或者系统原因还在等待支付结果确认，最终交易是否成功以服务端异步通知为准（小概率状态）</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;支付结果确认中&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    // 其他为系统返回的错误</span><br><span class="line">                    Toast.makeText(ThirdActivity.this, &quot;支付错误&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>以下四种为常用结果判断</p><blockquote><p>9000为支付成功<br>4000为支付失败<br>6001为取消支付<br>8000为支付结果确认中</p></blockquote><h2 id="调起支付页面截图"><a href="#调起支付页面截图" class="headerlink" title="调起支付页面截图"></a>调起支付页面截图</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43dfc66f3?w=540&amp;h=960&amp;f=jpeg&amp;s=28061" alt="301.jpg"></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下支付宝支付，其他支付也给出了对应的连接。&lt;/p&gt;
&lt;p&gt;在做支付之前，在网上也查寻了资料，大多都说，支付接入坑太多，微信坑最多，银联文档太复杂。&lt;br&gt;其实如果接入的多的话，那些套路都可以绕着走。&lt;br&gt;网上的经验什么的大都是比较老的，比较新的能用到的文章不多（但是好文章还是有的，对我帮助也很大），下面给大家详细介绍一下，帮助大家绕开坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Android 支付集" scheme="https://fanbaoying.github.io/categories/Android-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>快速高效 | iOS身份证识别</title>
    <link href="https://fanbaoying.github.io/%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88-iOS%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB/"/>
    <id>https://fanbaoying.github.io/快速高效-iOS身份证识别/</id>
    <published>2018-01-25T09:40:58.000Z</published>
    <updated>2018-02-06T07:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>快捷支付涉及到方方面面，同时安全问题既是用户所关心的，也是制作者不容忽视的重要部分。<br>比如涉及到支付和金钱的app，商户端app等等，都需要进行实名认证，实名认证可以通过银行卡认证和身份证认证。<br>通常办法是通过上传照片，并且手动输入基本信息进行认证，这种方法不仅操作复杂，而且容易出错。<br>网上很多资源，识别率低，速度慢，用户体验很差。今天我就和大家介绍一下我使用的方法，可以快速、高效的识别中国身份证信息。</p><a id="more"></a><h2 id="二：原理"><a href="#二：原理" class="headerlink" title="二：原理"></a>二：原理</h2><p>经实践发现，只要身份证号码处于摄像头预览图层中时，即不用完全对准身份证也可以读取到身份证号码，但此时截取到的身份证图像并不完整。</p><p>为获取到比较完整的身份证图像，经多次实践发现，当身份证人像大约位于拍摄框中的右上区域时，此时可获取到比较完整的身份证图像。</p><p>因此，在拍摄框中右上区域加了一个人像区域提示框，并将该区域设为扫描人脸的区域，只有该区域扫描到身份证上的人脸时（确保用户的确将身份证人像对准了拍摄框中的人像框），才执行读取身份证信息的操作。</p><h2 id="三：项目展示"><a href="#三：项目展示" class="headerlink" title="三：项目展示"></a>三：项目展示</h2><p>扫描身份证页面<br><img src="http://upload-images.jianshu.io/upload_images/2829694-a7b75f0e38644d03.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扫描身份证页面"></p><p>信息展示页面</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-a58987dfb8a196b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="信息展示页面"></p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-d928d98355e25059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5AB7A14B-0121-4AE8-A6C5-F5A6668287D7.png"></p><h2 id="四：Demo接入流程"><a href="#四：Demo接入流程" class="headerlink" title="四：Demo接入流程"></a>四：Demo接入流程</h2><h4 id="1-首先把demo下载下来"><a href="#1-首先把demo下载下来" class="headerlink" title="1.首先把demo下载下来"></a>1.首先把<a href="https://github.com/fanbaoying/FBYIDCardRecognition-iOS" target="_blank" rel="noopener">demo</a>下载下来</h4><p><img src="http://upload-images.jianshu.io/upload_images/2829694-093ec5c36f491a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo截图"></p><h4 id="2-打开项目将下面的文件拷贝到自己的工程中："><a href="#2-打开项目将下面的文件拷贝到自己的工程中：" class="headerlink" title="2.打开项目将下面的文件拷贝到自己的工程中："></a>2.打开项目将下面的文件拷贝到自己的工程中：</h4><ul><li>libexidcard</li><li>FBYTool</li><li>FBYCategory</li><li>FBYModel</li><li>FBYView</li><li>FBYBase</li></ul><h4 id="3-添加配置"><a href="#3-添加配置" class="headerlink" title="3.添加配置"></a>3.添加配置</h4><p>在你的项目的Info.plist文件中，添加权限描述（Key   Value）<br>Privacy - Camera Usage Description 是否允许访问相机<br>Privacy - Photo Library Usage Description 是否允许访问相册<br>如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2829694-d80f70244fb93afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="plist"></p><h4 id="4-项目设置"><a href="#4-项目设置" class="headerlink" title="4. 项目设置"></a>4. 项目设置</h4><p>根据项目截图设置即可</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-a60f239981f12bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目设置"></p><h4 id="5-项目引用"><a href="#5-项目引用" class="headerlink" title="5. 项目引用"></a>5. 项目引用</h4><p>在项目中需要使用的页面，增加引用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;IDCardCaptureViewController.h&quot;</span><br></pre></td></tr></table></figure></p><p>在点击扫描身份证的点击事件中，跳转页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IDCardCaptureViewController *idcvc = [[IDCardCaptureViewController alloc]init];</span><br><span class="line"></span><br><span class="line">[self.navigationController pushViewController:idcvc animated:YES];</span><br></pre></td></tr></table></figure></p><p>到此项目就接入完成！！！</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;快捷支付涉及到方方面面，同时安全问题既是用户所关心的，也是制作者不容忽视的重要部分。&lt;br&gt;比如涉及到支付和金钱的app，商户端app等等，都需要进行实名认证，实名认证可以通过银行卡认证和身份证认证。&lt;br&gt;通常办法是通过上传照片，并且手动输入基本信息进行认证，这种方法不仅操作复杂，而且容易出错。&lt;br&gt;网上很多资源，识别率低，速度慢，用户体验很差。今天我就和大家介绍一下我使用的方法，可以快速、高效的识别中国身份证信息。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 识别集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%AF%86%E5%88%AB%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Java连接MySQL数据库详细分析</title>
    <link href="https://fanbaoying.github.io/Java%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <id>https://fanbaoying.github.io/Java连接MySQL数据库详细分析/</id>
    <published>2018-01-25T09:35:35.000Z</published>
    <updated>2018-01-31T06:20:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：工具"><a href="#一：工具" class="headerlink" title="一：工具"></a>一：工具</h2><p>eclipse<br>MySQL5.7<br>MySQL连接驱动：mysql-connector-java-5.1.44-bin.jar<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">下载地址</a></p><a id="more"></a><h2 id="二：加载驱动"><a href="#二：加载驱动" class="headerlink" title="二：加载驱动"></a>二：加载驱动</h2><p>2.1 在工程目录中创建lib文件夹，将下载好的JDBC放到该文件夹下，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-9409579868aa2f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="项目文件截图"><br>2.2  右键工程名，选最后一个Properties，在java build path中的Libraries分页中选择Add JARs…，选择刚才添加的JDBC，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-a6f23953ad48761b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="配置截图"></p><p>2.3 数据包准备<br><a href="http://www.jianshu.com/p/07a9826898c0" target="_blank" rel="noopener">安装mysql</a><br>在数据库studb中创建如下数据表t_stu:</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-f88510125881f35e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="表结构"></p><p>2.4 添加数据，表内容如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-6205331e45992d55.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="表内容"></p><p>2.5 连接数据库并读取数据</p><blockquote><p>数据库名称：studb<br>数据包名称：t_stu<br>端口号：3306<br>用户名：root<br>密码：12345</p></blockquote><p>2.6 具体代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package com.agree.sqldemo;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//声明Connection对象</span><br><span class="line">Connection con;</span><br><span class="line">//驱动程序名</span><br><span class="line">String driver = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">//URL指向要访问的数据库名studb</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/studb&quot;;</span><br><span class="line">//MySQL配置时的用户名</span><br><span class="line">String user = &quot;root&quot;;</span><br><span class="line">//MySQL配置时的密码</span><br><span class="line">String password = &quot;12345&quot;;</span><br><span class="line"></span><br><span class="line">//遍历查询结果集</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">//加载驱动程序</span><br><span class="line">Class.forName(driver);</span><br><span class="line">//1.getConnection()方法，连接MySQL数据库！！</span><br><span class="line">con = DriverManager.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">if(!con.isClosed())</span><br><span class="line">System.out.println(&quot;Succeeded connecting to the Database!&quot;);</span><br><span class="line">//2.创建statement类对象，用来执行SQL语句！！</span><br><span class="line">Statement statement = con.createStatement();</span><br><span class="line">//要执行的SQL语句</span><br><span class="line">String sql = &quot;select * from t_stu&quot;;</span><br><span class="line"></span><br><span class="line">//3.ResultSet类，用来存放获取的结果集！！</span><br><span class="line">ResultSet rs = statement.executeQuery(sql);</span><br><span class="line">System.out.println(&quot;-----------------&quot;);</span><br><span class="line">System.out.println(&quot;执行结果如下所示:&quot;);</span><br><span class="line">System.out.println(&quot;-----------------&quot;);</span><br><span class="line">System.out.println(&quot;姓名&quot; + &quot;\t&quot; + &quot;地址&quot;);</span><br><span class="line">System.out.println(&quot;-----------------&quot;);  </span><br><span class="line"></span><br><span class="line">String address = null;</span><br><span class="line"></span><br><span class="line">String name = null;</span><br><span class="line"></span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">//获取sname这列数据</span><br><span class="line">name = rs.getString(&quot;sname&quot;);</span><br><span class="line">//获取address这列数据</span><br><span class="line">address = rs.getString(&quot;address&quot;);</span><br><span class="line">//输出结果</span><br><span class="line">System.out.println(name + &quot;\t&quot; + address);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">rs.close();</span><br><span class="line">con.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;catch(ClassNotFoundException e) &#123;</span><br><span class="line">//数据库驱动类异常处理</span><br><span class="line">System.out.println(&quot;Sorry,can`t find the Driver!&quot;);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;catch(SQLException e) &#123;</span><br><span class="line">//数据库连接失败异常处理</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;catch (Exception e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line">System.out.println(&quot;数据库数据成功获取！！&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.7 运行结果如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/2829694-3cb9446725830fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：工具&quot;&gt;&lt;a href=&quot;#一：工具&quot; class=&quot;headerlink&quot; title=&quot;一：工具&quot;&gt;&lt;/a&gt;一：工具&lt;/h2&gt;&lt;p&gt;eclipse&lt;br&gt;MySQL5.7&lt;br&gt;MySQL连接驱动：mysql-connector-java-5.1.44-bin.jar&lt;a href=&quot;https://dev.mysql.com/downloads/connector/j/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java文集" scheme="https://fanbaoying.github.io/categories/Java%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Java" scheme="https://fanbaoying.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>快速高效 | Android身份证识别</title>
    <link href="https://fanbaoying.github.io/%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88-Android%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB/"/>
    <id>https://fanbaoying.github.io/快速高效-Android身份证识别/</id>
    <published>2018-01-25T09:20:44.000Z</published>
    <updated>2018-02-06T07:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>快捷支付涉及到方方面面，同时安全问题既是用户所关心的，也是制作者不容忽视的重要部分。<br>比如涉及到支付和金钱的app，商户端app等等，都需要进行实名认证，实名认证可以通过银行卡认证和身份证认证。<br>通常办法是通过上传照片，并且手动输入基本信息进行认证，这种方法不仅操作复杂，而且容易出错。<br>网上很多资源，识别率低，速度慢，用户体验很差。今天我就和大家介绍一下我使用的方法，可以快速、高效的识别中国身份证信息。</p><a id="more"></a><h2 id="二：原理"><a href="#二：原理" class="headerlink" title="二：原理"></a>二：原理</h2><p>在拍摄框中右上区域加了一个人像区域提示框，并将该区域设为扫描人脸的区域，只有该区域扫描到身份证上的人脸时（确保用户的确将身份证人像对准了拍摄框中的人像框），才执行读取身份证信息的操作。</p><h2 id="三：项目展示"><a href="#三：项目展示" class="headerlink" title="三：项目展示"></a>三：项目展示</h2><p>扫描身份证面截图</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-20b78f45be90b3de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="头像面扫描"></p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-8cd81ffdb6f4daac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国徽面扫描"></p><p>信息展示页面</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-5dc5685f6c54a9df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="头像页信息"></p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-856239c3727e49d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="国徽页信息"></p><h2 id="四：-使用流程介绍"><a href="#四：-使用流程介绍" class="headerlink" title="四： 使用流程介绍"></a>四： 使用流程介绍</h2><h4 id="4-1-身份验证"><a href="#4-1-身份验证" class="headerlink" title="4.1 身份验证"></a>4.1 身份验证</h4><p>由于使用的是百度云的图像文字识别sdk，首先需要去百度云<a href="https://console.bce.baidu.com/ai/?_=1515636851708&amp;fromai=1#/ai/ocr/app/list" target="_blank" rel="noopener">管理控制台</a>获得API Key / Secret Key。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-d962a45ac612e492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="管理控制台"></p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-97842b3398dd0700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="管理控制台"></p><h4 id="4-2-下载demo"><a href="#4-2-下载demo" class="headerlink" title="4.2 下载demo"></a>4.2 下载demo</h4><p><a href="https://github.com/fanbaoying/FBYIDCardRecognition-Android" target="_blank" rel="noopener">GitHub 源码链接</a></p><ol><li>将下载的demo中libs目录下的ocr-sdk.jar文件拷贝到工程libs目录中，并加入工程依赖</li><li>将libs目录下armeabi，arm64-v8a，armeabi-v7a，x86文件夹按需添加到android studio工程src/main/jniLibs目录中， eclipse用户默认为libs目录。</li><li>在Android studio中以模块方式导入下载包中的identify文件夹,模块方式导入流程如下：<br>首先要在顶层工程目录下的settings.gradle文件中include模块名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:app&apos;,&apos;:identify&apos;</span><br></pre></td></tr></table></figure></li></ol><p>然后直接复制粘贴identify文件导入到项目的文件夹中！！！然后Build&gt;Rebuild Project，重新构建项目。</p><h4 id="4-3-权限配置"><a href="#4-3-权限配置" class="headerlink" title="4.3 权限配置"></a>4.3 权限配置</h4><ol><li><p>在工程AndroidManifest.xml文件中添加如下权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Proguard配置文件中增加, 防止release发布时打包报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-keep class com.baidu.ocr.sdk.**&#123;*;&#125;</span><br><span class="line">-dontwarn com.baidu.ocr.**</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-4-核心函数介绍"><a href="#4-4-核心函数介绍" class="headerlink" title="4.4 核心函数介绍"></a>4.4 核心函数介绍</h4><ol><li><p>初始化函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OCR.getInstance().initAccessTokenWithAkSk(new OnResultListener&lt;AccessToken&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResult(AccessToken result) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(OCRError error) &#123;</span><br><span class="line">                error.printStackTrace();</span><br><span class="line">                Log.d(&quot;onError&quot;, &quot;msg: &quot; + error.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getApplicationContext(), &quot;你注册的appkey&quot;, &quot;你注册的sk&quot;);</span><br></pre></td></tr></table></figure></li><li><p>身份证拍照</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(MainActivity.this, CameraActivity.class);</span><br><span class="line">intent.putExtra(CameraActivity.KEY_OUTPUT_FILE_PATH,</span><br><span class="line">    FileUtil.getSaveFile(getApplication()).getAbsolutePath());</span><br><span class="line">intent.putExtra(CameraActivity.KEY_CONTENT_TYPE, CameraActivity.CONTENT_TYPE_ID_CARD_FRONT);</span><br><span class="line">startActivityForResult(intent, REQUEST_CODE_CAMERA);</span><br></pre></td></tr></table></figure><ol><li><p>图像回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line"></span><br><span class="line">    if (requestCode == REQUEST_CODE_CAMERA &amp;&amp; resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        if (data != null) &#123;</span><br><span class="line">            String contentType = data.getStringExtra(CameraActivity.KEY_CONTENT_TYPE);</span><br><span class="line">            String filePath = FileUtil.getSaveFile(getApplicationContext()).getAbsolutePath();</span><br><span class="line">            if (!TextUtils.isEmpty(contentType)) &#123;</span><br><span class="line">                if (CameraActivity.CONTENT_TYPE_ID_CARD_FRONT.equals(contentType)) &#123;</span><br><span class="line">                    recIDCard(IDCardParams.ID_CARD_SIDE_FRONT, filePath);</span><br><span class="line">                &#125; else if (CameraActivity.CONTENT_TYPE_ID_CARD_BACK.equals(contentType)) &#123;</span><br><span class="line">                    recIDCard(IDCardParams.ID_CARD_SIDE_BACK, filePath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void recIDCard(String idCardSide, String filePath) &#123;</span><br><span class="line">    IDCardParams param = new IDCardParams();</span><br><span class="line">    param.setImageFile(new File(filePath));</span><br><span class="line">    param.setIdCardSide(idCardSide);</span><br><span class="line">    param.setDetectDirection(true);</span><br><span class="line">    OCR.getInstance().recognizeIDCard(param, new OnResultListener&lt;IDCardResult&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onResult(IDCardResult result) &#123;</span><br><span class="line">            if (result != null) &#123;</span><br><span class="line">                Log.d(&quot;onResult&quot;, &quot;result: &quot; + result.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(OCRError error) &#123;</span><br><span class="line">            Log.d(&quot;onError&quot;, &quot;error: &quot; + error.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>到此身份证识别接入就结束了！！！</p><p>相同方式均可实现银行卡识别、驾驶证识别、行驶证识别、车牌识别、营业执照识别等等，如有需要demo可联系我。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;快捷支付涉及到方方面面，同时安全问题既是用户所关心的，也是制作者不容忽视的重要部分。&lt;br&gt;比如涉及到支付和金钱的app，商户端app等等，都需要进行实名认证，实名认证可以通过银行卡认证和身份证认证。&lt;br&gt;通常办法是通过上传照片，并且手动输入基本信息进行认证，这种方法不仅操作复杂，而且容易出错。&lt;br&gt;网上很多资源，识别率低，速度慢，用户体验很差。今天我就和大家介绍一下我使用的方法，可以快速、高效的识别中国身份证信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Android 识别集" scheme="https://fanbaoying.github.io/categories/Android-%E8%AF%86%E5%88%AB%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
