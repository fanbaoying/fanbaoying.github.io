<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2022-09-26T03:49:49.484Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode - 80 删除有序数组中的重复项 II</title>
    <link href="https://fanbaoying.github.io/LeetCode-80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II/"/>
    <id>https://fanbaoying.github.io/LeetCode-80-删除有序数组中的重复项-II/</id>
    <published>2022-09-26T03:46:25.000Z</published>
    <updated>2022-09-26T03:49:49.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 79 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个有序数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <code>原地</code> <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明：</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以 <strong>「引用」</strong> 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 已按升序排列</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedArrayII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">inout</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt; <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">count</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[index] != nums[index - <span class="number">1</span>] || nums[index] != nums[i] &#123;</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：保留一个索引，比较该索引处的元素、索引- 1处的元素以及向前移动的元素。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 79 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 79 单词搜索（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-79-单词搜索（Top-100）/</id>
    <published>2022-09-26T03:46:09.000Z</published>
    <updated>2022-09-26T03:50:15.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 78 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/01dc86a2e8777fa372b18296e334142b.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/07d5e0146bf7c3eeb14504736ed338c0.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><p><img src="https://files.mdnice.com/user/17787/5d692bd2-0e4b-42cc-8bba-474a600acc8f.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board: [[Character]], <span class="number">_</span> word: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> board.<span class="built_in">count</span> &gt; <span class="number">0</span> &amp;&amp; board[<span class="number">0</span>].<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> m = board.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> n = board[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">var</span> visited = <span class="type">Array</span>(<span class="built_in">count</span>: m, repeatedValue: <span class="type">Array</span>(<span class="built_in">count</span>: n, repeatedValue: <span class="literal">false</span>))</span><br><span class="line">        <span class="keyword">var</span> wordContent = [<span class="type">Character</span>](word.characters)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == wordContent[<span class="number">0</span>] &amp;&amp; _dfs(board, wordContent, m, n, i, j, &amp;visited, <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_dfs</span><span class="params">(board: [[Character]], <span class="number">_</span> wordContent: [Character], <span class="number">_</span> m: Int, <span class="number">_</span> n: Int, <span class="number">_</span> i: Int, <span class="number">_</span> j: Int, <span class="keyword">inout</span> <span class="number">_</span> visited: [[Bool]], <span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == wordContent.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">guard</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> !visited[i][j] &amp;&amp; board[i][j] == wordContent[index] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> _dfs(board, wordContent, m, n, i + <span class="number">1</span>, j, &amp;visited, index + <span class="number">1</span>) || _dfs(board, wordContent, m, n, i - <span class="number">1</span>, j, &amp;visited, index + <span class="number">1</span>) || _dfs(board, wordContent, m, n, i, j + <span class="number">1</span>, &amp;visited, index + <span class="number">1</span>) || _dfs(board, wordContent, m, n, i, j - <span class="number">1</span>, &amp;visited, index + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典深度优先搜索，上，下，左，右四个方向。</li><li>时间复杂度： O(mn * 4^(k - 1))， m和n分别代表矩阵的宽和高，k为单词大小</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/word-search/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 78 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 78 子集（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-78-%E5%AD%90%E9%9B%86%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-78-子集（Top-100）/</id>
    <published>2022-09-26T03:45:57.000Z</published>
    <updated>2022-09-26T03:50:40.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 77 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subsets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums: [Int])</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        <span class="keyword">var</span> path = [<span class="type">Int</span>]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted(by: &lt;)</span><br><span class="line">        </span><br><span class="line">        _dfs(&amp;res, &amp;path, nums, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_dfs</span><span class="params">(<span class="keyword">inout</span> res: [[Int]], <span class="keyword">inout</span> <span class="number">_</span> path: [Int], <span class="number">_</span> nums: [Int], <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="comment">// termination case</span></span><br><span class="line">        res.append(path)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> index..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            _dfs(&amp;res, &amp;path, nums, i + <span class="number">1</span>)</span><br><span class="line">            path.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：桶排序。</li><li>时间复杂度： O(n^n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/subsets/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 77 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 77 组合</title>
    <link href="https://fanbaoying.github.io/LeetCode-77-%E7%BB%84%E5%90%88/"/>
    <id>https://fanbaoying.github.io/LeetCode-77-组合/</id>
    <published>2022-09-26T03:45:45.000Z</published>
    <updated>2022-09-26T03:51:03.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 76 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, k = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Combinations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n: Int, <span class="number">_</span> k: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        <span class="keyword">var</span> path = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">let</span> nums = [<span class="type">Int</span>](<span class="number">1</span>...n)</span><br><span class="line">        </span><br><span class="line">        _dfs(nums, &amp;res, &amp;path, <span class="number">0</span>, k)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_dfs</span><span class="params">(nums: [Int], <span class="keyword">inout</span> <span class="number">_</span> res: [[Int]], <span class="keyword">inout</span> <span class="number">_</span> path: [Int], <span class="number">_</span> index: Int, <span class="number">_</span> k: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> path.<span class="built_in">count</span> == k &#123;</span><br><span class="line">            res.append([<span class="type">Int</span>](path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> index..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            _dfs(nums, &amp;res, &amp;path, i + <span class="number">1</span>, k)</span><br><span class="line">            path.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典深度优先搜索，子集的另一个版本。</li><li>时间复杂度： O(n^n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/combinations/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 76 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 76 最小覆盖子串（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-76-最小覆盖子串（Top-100）/</id>
    <published>2022-09-26T03:45:27.000Z</published>
    <updated>2022-09-26T03:51:25.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 75 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &apos;a&apos; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimumWindowSubsequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(<span class="number">_</span> S: String, <span class="number">_</span> T: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> m = <span class="type">T</span>.<span class="built_in">count</span>, n = <span class="type">S</span>.<span class="built_in">count</span>, sChars = <span class="type">Array</span>(<span class="type">S</span>), tChars = <span class="type">Array</span>(<span class="type">T</span>)</span><br><span class="line">        <span class="keyword">var</span> dp = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: n + <span class="number">1</span>), <span class="built_in">count</span>: m + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">var</span> start = <span class="number">0</span>, len = n + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...n &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...n &#123;</span><br><span class="line">                <span class="keyword">if</span> tChars[i - <span class="number">1</span>] == sChars[j - <span class="number">1</span>] &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...n &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[m][i] != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i - dp[m][i] + <span class="number">1</span> &lt; len &#123;</span><br><span class="line">                    len = i - dp[m][i] + <span class="number">1</span></span><br><span class="line">                    start = dp[m][i] - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len == n + <span class="number">1</span> ? <span class="string">""</span> : <span class="type">String</span>(sChars[start..&lt;start + len])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：桶排序。</li><li>时间复杂度： O(mn)</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/minimum-window-substring/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 75 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 75 颜色分类（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-75-颜色分类（Top-100）/</id>
    <published>2022-09-26T03:45:16.000Z</published>
    <updated>2022-09-26T03:51:48.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 74 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库的 sort 函数的情况下解决这个问题。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortColors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sortColors</span><span class="params">(<span class="number">_</span> nums: <span class="keyword">inout</span> [Int])</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> red = <span class="number">0</span>, blue = nums.<span class="built_in">count</span> - <span class="number">1</span>, i = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt;= blue &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;</span><br><span class="line">                _swap(&amp;nums, i, red)</span><br><span class="line">                red += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] == <span class="number">1</span> &#123;</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _swap(&amp;nums, i, blue)</span><br><span class="line">                blue -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">_swap</span>&lt;T&gt;<span class="params">(<span class="number">_</span> nums: <span class="keyword">inout</span> [T], <span class="number">_</span> p: Int, <span class="number">_</span> q: Int)</span></span> &#123;</span><br><span class="line">        (nums[p], nums[q]) = (nums[q], nums[p])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：桶排序。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/sort-colors/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 74 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 74 搜索二维矩阵</title>
    <link href="https://fanbaoying.github.io/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <id>https://fanbaoying.github.io/LeetCode-74-搜索二维矩阵/</id>
    <published>2022-09-26T03:44:53.000Z</published>
    <updated>2022-09-26T03:52:12.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 73 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/06c35690518617675c110e41424111a0.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/b2d0c81496e82f7135f7b27cb45e0ca6.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-10^4 &lt;= matrix[i][j], target &lt;= 10^4</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search2DMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(<span class="number">_</span> matrix: [[Int]], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix.<span class="built_in">count</span> == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> rowNum = searchRow(matrix, target)</span><br><span class="line">        <span class="keyword">return</span> searchCol(matrix[rowNum], target)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">searchRow</span><span class="params">(<span class="number">_</span> matrix: [[Int]], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = matrix.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> + <span class="number">1</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span> + <span class="keyword">left</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &lt; target &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="keyword">right</span>][<span class="number">0</span>] &lt;= target ? <span class="keyword">right</span> : <span class="keyword">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">searchCol</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt;= <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span> + <span class="keyword">left</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：搜索col，然后二分查找row。</li><li>时间复杂度： O(log(m + n))</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/search-a-2d-matrix/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 73 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 73 矩阵置零</title>
    <link href="https://fanbaoying.github.io/LeetCode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>https://fanbaoying.github.io/LeetCode-73-矩阵置零/</id>
    <published>2022-09-26T03:44:10.000Z</published>
    <updated>2022-09-26T03:52:35.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 72 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <code>0</code> ，则将其所在行和列的所有元素都设为 <code>0</code> 。请使用 <strong>原地</strong> 算法。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/75e47e2b4f10b8996e790a45330093a7.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/f82ec2407d00d8f53e61dff637d9c711.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1`</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetMatrixZeroes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(<span class="number">_</span> matrix: <span class="keyword">inout</span> [[Int]])</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rowHasZero = <span class="literal">false</span>, colHasZero = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> m = matrix.<span class="built_in">count</span>, n = matrix[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;m <span class="keyword">where</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            colHasZero = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n <span class="keyword">where</span> matrix[<span class="number">0</span>][i] == <span class="number">0</span> &#123;</span><br><span class="line">            rowHasZero = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..&lt;n &#123;</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..&lt;n &#123;</span><br><span class="line">                <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span> || matrix[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> rowHasZero &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> colHasZero &#123;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用第一行和 col 来跟踪行和 col 是否应该设置为 0，记住它们应该与矩阵的其他部分分开。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/set-matrix-zeroes/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 72 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 72 编辑距离（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-72-编辑距离（Top-100）/</id>
    <published>2022-09-26T03:43:58.000Z</published>
    <updated>2022-09-26T03:49:20.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 71 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (插入 &apos;u&apos;)</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1: String, <span class="number">_</span> word2: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> aChars = [<span class="type">Character</span>](word1.characters)</span><br><span class="line">        <span class="keyword">let</span> bChars = [<span class="type">Character</span>](word2.characters)</span><br><span class="line">        <span class="keyword">let</span> aLen = aChars.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> bLen = bChars.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> dp = <span class="type">Array</span>(<span class="built_in">count</span>: aLen + <span class="number">1</span>, repeatedValue:(<span class="type">Array</span>(<span class="built_in">count</span>: bLen + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...aLen &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>...bLen &#123;</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j] = j</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j] = i</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> aChars[i - <span class="number">1</span>] == bChars[j - <span class="number">1</span>] &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[aLen][bLen]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：2D动态编程，从插入，删除或替换一个字符中找到最小步骤。</li><li>时间复杂度： O(mn)</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/edit-distance/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 71 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 71 简化路径</title>
    <link href="https://fanbaoying.github.io/LeetCode-71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>https://fanbaoying.github.io/LeetCode-71-简化路径/</id>
    <published>2022-09-26T03:43:45.000Z</published>
    <updated>2022-09-26T03:48:57.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 70 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件/目录名称。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><ul><li>始终以斜杠 <code>&#39;/&#39;</code> 开头。</li><li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li><li>最后一个目录名（如果存在）不能 以 <code>&#39;/&#39;</code> 结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li></ul><p>返回简化后得到的 <strong>规范路径</strong> 。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= path.length &lt;= 3000</code></li><li><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</li><li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplifyPath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simplifyPath</span><span class="params">(<span class="number">_</span> path: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> directories = [<span class="type">String</span>]()</span><br><span class="line">        <span class="keyword">let</span> components = path.<span class="built_in">split</span>(separator: <span class="string">"/"</span>)</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> components &#123;</span><br><span class="line">            <span class="keyword">switch</span> component &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">""</span>: <span class="keyword">break</span> <span class="comment">// do nothing</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"."</span>: <span class="keyword">break</span> <span class="comment">// do nothing, pointing to the current directory</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">".."</span>:</span><br><span class="line">                directories.popLast() <span class="comment">// if empty, does nothing</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                directories.append(<span class="type">String</span>(component))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span> + <span class="type">String</span>(directories.joined(separator: <span class="string">"/"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用堆栈，正常 push， ..流行。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/simplify-path/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 70 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 70 爬楼梯（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-70-爬楼梯（Top-100）/</id>
    <published>2022-09-26T03:43:33.000Z</published>
    <updated>2022-09-26T03:48:31.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 69 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> prev = <span class="number">0</span>, post = <span class="number">1</span>, total = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...n &#123;</span><br><span class="line">            total = prev + post</span><br><span class="line">            </span><br><span class="line">            prev = post</span><br><span class="line">            post = total</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：动态编程，<code>dp = dp + dp[i - 2]</code>。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/climbing-stairs/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 69 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 69 x 的平方根</title>
    <link href="https://fanbaoying.github.io/LeetCode-69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>https://fanbaoying.github.io/LeetCode-69-x-的平方根/</id>
    <published>2022-09-26T03:43:18.000Z</published>
    <updated>2022-09-26T03:48:00.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 68 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去</strong> 。</p><p><strong>注意：</strong> 不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= x &lt;= 2^31 - 1</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sqrtx</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = x / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt;= <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span> + <span class="keyword">left</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid * mid == x &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid * mid &lt; x &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：二分查找，应该从 <code>x / 2 + 1</code> 开始，所以它的平方是 <code>x + x ^ 2 / 4 + 1</code>，它肯定大于 <code>x</code>。</li><li>时间复杂度： O(logn)</li><li>空间复杂度： O(1)</li></ul><blockquote><p><strong>注意:</strong> 请使用(右-左)/ 2 +左来获得中间以防整数溢出</p></blockquote><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/sqrtx/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 68 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十三期/</id>
    <published>2022-09-13T02:50:39.000Z</published>
    <updated>2022-09-13T02:51:43.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第四期</strong>，每个模块还在调整磨合期。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>昔孔子登泰山而小天下， 今诸君阅<strong>Swift社区</strong>皆足矣。请君浅读，与君共勉！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone14 Pro 刘海变“灵动岛”</p><p>提案：大量提案审核结果已公布</p><p>Swift 论坛：论坛内容丰富，欢迎参与讨论</p><p>推荐博文：增加 App 排名的 ASO 小技巧</p></blockquote><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="iPhone14-Pro-刘海变“灵动岛”"><a href="#iPhone14-Pro-刘海变“灵动岛”" class="headerlink" title="iPhone14 Pro 刘海变“灵动岛”"></a>iPhone14 Pro 刘海变“灵动岛”</h3><p>iPhone14 Pro 来了，从外观看两个亮点，第一是新配色 #iPhone14Pro 灭霸紫# 好看吗？第二是刘海变成了药丸，不是感叹号，但是带来了 #iPhone14Pro 灵动岛#，和显示动画合为一体。</p><p>本次发布会，iphone14pro 刘海依旧，但刘海减少 30% 变更为“药丸”，并引入灵动岛设计，通过刘海变换多种交互UI。视网膜 XDR2000 尼特峰值，实现息屏显示。使用新的 A16 4nm 芯片，搭载 4800 像素主摄像头，比 iPhone 13 Pro 大了 65%，新增配“灭霸紫”配色。</p><p>9月8日凌晨，苹果秋季发布会推出 iPhone14 系列产品，其中最大亮点为 iPhone14pro 系列新增正面设计“灵动岛”。正面摄像头有一个较小的切口，在不同状态下挖孔形态不同，支持第三方应用。iPhone14 系列售价：iPhone14 5999元起，iPhone14plus 6999元起，iPhone14pro 7999元起，iPhone 14pro max 8999元起。9 月 9 日开始预售，9 月 16 日正式发售。</p><p><img src="https://raw.githubusercontent.com/SwiftCommunityRes/image/main/weekly/iPhone.png" alt=""></p><h3 id="库克：苹果将捐款支持四川地震灾区救援和重建工作"><a href="#库克：苹果将捐款支持四川地震灾区救援和重建工作" class="headerlink" title="库克：苹果将捐款支持四川地震灾区救援和重建工作"></a>库克：苹果将捐款支持四川地震灾区救援和重建工作</h3><p>9 月 7 日消息，苹果 CEO 蒂姆库克的认证微博发布消息称：“我们心系所有受地震影响的四川民众和社区。苹果将捐款支持救援和重建工作。”</p><p><img src="https://raw.githubusercontent.com/SwiftCommunityRes/image/main/weekly/weekly1301.png" alt=""></p><p>此前，小米、宁德时代、阿里巴巴、网易、字节跳动、联想、辛选集团、比亚迪、拼多多、理想汽车等都宣布向四川地震灾区进行捐赠。</p><h3 id="苹果为老款-iPhone-iPad-iPod-发布-iOS-12-5-6-更新，修复严重漏洞"><a href="#苹果为老款-iPhone-iPad-iPod-发布-iOS-12-5-6-更新，修复严重漏洞" class="headerlink" title="苹果为老款 iPhone / iPad / iPod 发布 iOS 12.5.6 更新，修复严重漏洞"></a>苹果为老款 iPhone / iPad / iPod 发布 iOS 12.5.6 更新，修复严重漏洞</h3><p>IT之家 9 月 1 日消息，苹果今日为老款 iPhone 发布了 iOS 12.5.6（内部版本号：16H71）更新，针对无法更新到 iOS 15 的设备进行了安全更新和错误修复。</p><p>这是自 2021 年 9 月以来苹果对 iOS 12 的首次更新，当时苹果修复了一个问题，该问题使恶意制作的 PDF、Web 内容和 App 能够执行代码。最新更新解决了自上次更新以来已在 iOS 15 中修补的漏洞。</p><p>IT之家了解到，苹果会针对无法更新到 iOS 12 之后的旧 iPhone、iPad 和 iPod 提供定期更新。这些更新不会提供任何重大的功能更改或 UI 改进，但会针对旧设备可能容易受到的已知攻击提供保护。</p><p>苹果安全更新网站声明如下：</p><p>一位匿名研究人员提交的 CVE-2022-32893。</p><p>更新适用于：iPhone 5s、iPhone 6、iPhone 6 Plus、iPad Air、iPad mini 2、iPad mini 3 和 iPod touch（第 6 代）</p><p>影响：恶意制作的 Web 内容可能会执行任意代码。有报告称此问题可能已被积极利用。</p><p>描述：已通过改进边界检查解决越界写入问题。(来源： IT之家)</p><p><img src="https://raw.githubusercontent.com/SwiftCommunityRes/image/main/weekly/weekly1302.png" alt=""></p><h3 id="苹果-iOS-16-更新，天气-App-新功能盘点"><a href="#苹果-iOS-16-更新，天气-App-新功能盘点" class="headerlink" title="苹果 iOS 16 更新，天气 App 新功能盘点"></a>苹果 iOS 16 更新，天气 App 新功能盘点</h3><p>IT之家 8 月 31 日消息，苹果在 iOS 16 中对天气应用进行了一些改变，包括新的通知类型，并增加了一些信息，从湿度、温度到能见度全方位为你提供服务。</p><p>此外，新版天气 App 中的许多新功能都融入了苹果此前收购的 Dark Sky 内容。</p><p>天气应用程序的整体设计没有重大更新，但苹果提供了更多信息。长期以来，天气应用一直都有一些小模块，从而向你显示各种信息，包括 10 天内预报、每日气温、空气质量、降水、紫外线指数、日落 / 日出时间、风、湿度、感官温度、能见度和压力等等，现在你可以点击进入这些模块中的任何一个来获取更多信息，还支持快速切换。</p><p>温度部分展示了全天的温度曲线图，包括最高和最低。这应该可以解决 iOS 15 天气应用中存在的一个问题，从而不会再有用户抱怨不清楚气温何时才是每日最低点。此外，这一部分还提供了天气状况的文本概述。在 10 天的天气预报中，你可以点击任何一天查看每日温度范围的图表，还有一个选项可以查看更大的彩色温度地图。</p><p>空气质量这块展示了您所在地区当前空气状况的图表，以及当前状况和主要污染物对健康影响的附加信息。此外，你还可以看到更大的空气质量地图，预计国内同样是由“和风天气”提供信息。</p><p>新的“降水”类似于之前版本的降水信息，显示了风暴将袭击的位置地图，还可以放大显示 12 小时降雨预报，还有一个界面显示了过去 24 小时内的降水总量详情，以及在什么时间下了多少雨、雨夹雪或雪。</p><p>感官温度提供了第二个温度图表，结合温度、湿度，风等一些其他因素，你可以更好地了解周围环境温度变化。</p><p>紫外线指数显示当前的紫外线等级和白天的最高紫外线水平。同时，它还会提供一段介绍，例如建议防晒等级。</p><p>“日落和日出”可以让你知道日出或日落的时间，同时它还包括每月日出和日落的平均值和总日光的读数。</p><p>“风”主要是提供每天的风速摘要，以及全天的风速、风向图表。</p><p>湿度部分显示了全天湿度的图表，分为六个小时的增量。它还提供平均湿度和露点等信息。</p><p>“能见度”可提供全天的能见度范围，并提供每日摘要。</p><p>“压强”显示了当前的压强、全天压强，以及压强是上升还是下降的读数。</p><p>“极端天气警报”和之前一样，会显示重大的暴雨、洪水、飓风、热浪、龙卷风等其他灾害警告，预计国内还是和风天气提供信息。</p><p>“天气锁屏”虽然不是天气应用程序的一部分，但在 iOS 16 中有一个专门的天气锁屏。如果是晴天，你会看到太阳，如果是雨天，你会看到下雨。</p><p>还有许多不同的天气小部件，你可以添加到任何锁屏中，还有一个更大的读数与温度，当前条件，高 / 低随着个别空气质量，紫外线指数，和温度选项。</p><p>“iPad 天气”，随着 iOS 16/ iPadOS 16 更新，终于有了适用于 iPad 的天气应用，相比 iPhone 版本可以更好地适应 iPad 的大显示屏。</p><p>总之，iOS 16 更新了好多新奇的功能哦，小伙伴快去试试吧。(来源： IT之家)</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0370-pointer-family-initialization-improvements.md" title="SE-0370" target="_blank" rel="noopener">SE-0370</a> <strong>改进指针系列初始化和缓冲区</strong> 提案已通过。该提案已在<a href="https://mp.weixin.qq.com/s/IXP8PNT4aoCnyB-V2qMY_Q" target="_blank" rel="noopener">十二期周报</a>正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0365-implicit-self-weak-capture.md" title="SE-0365" target="_blank" rel="noopener">SE-0365</a> <strong>增加对协议 CustomDebugStringConvertible 到 AnyKeyPath 的一致性</strong> 提案已通过。该提案已在<a href="https://mp.weixin.qq.com/s/IXP8PNT4aoCnyB-V2qMY_Q" target="_blank" rel="noopener">十二期周报</a>正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0368-staticbigint.md" title="SE-0368" target="_blank" rel="noopener">SE-0368</a> <strong>StaticBigInt</strong> 提案已通过。该提案已在<a href="https://mp.weixin.qq.com/s/i5a-jhRRdf36KUNRoMX_8w" target="_blank" rel="noopener">十一期周报</a>正在审查的提案模块做了详细介绍。</p><h3 id="拒绝的提案"><a href="#拒绝的提案" class="headerlink" title="拒绝的提案"></a>拒绝的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0371-isolated-synchronous-deinit.md" title="SE-0371" target="_blank" rel="noopener">SE-0371</a> <strong>Isolated synchronous deinit</strong> 被拒绝，重新修订。该提案已在<a href="https://mp.weixin.qq.com/s/IXP8PNT4aoCnyB-V2qMY_Q" target="_blank" rel="noopener">十二期周报</a>正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md" title="SE-0366" target="_blank" rel="noopener">SE-0366</a> <strong>代码上下文新增敏感关键字 move</strong> 被拒绝，重新修订。该提案已在<a href="https://mp.weixin.qq.com/s/i5a-jhRRdf36KUNRoMX_8w" target="_blank" rel="noopener">十一期周报</a>正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0372-document-sorting-as-stable.md" title="SE-0372" target="_blank" rel="noopener">SE-0372</a> <strong>更新稳定排序文档</strong> 提案正在审查。</p><p>Swift 的排序算法在 Swift 5 之前已经更改为稳定排序，但是文档一直没有更新。本提案致力于更新稳定的排序算法文档，方便开发者使用。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论 <a href="https://forums.swift.org/t/automatic-type-conformance/60111" title="Automatic 类型的一致性" target="_blank" rel="noopener">Automatic 类型的一致性</a></p><p>出发点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">cachedImage</span><span class="params">(<span class="keyword">for</span> path: String?)</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">UIImage</span>?, <span class="type">Never</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> path = path <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Just</span>(<span class="literal">nil</span>)</span><br><span class="line">            .eraseToAnyPublisher()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> image = imageCache.object(forKey: <span class="type">NSString</span>(string: path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Just</span>(image)</span><br><span class="line">            .eraseToAnyPublisher()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image(<span class="keyword">for</span>: path)</span><br><span class="line">        .handleEvents(receiveOutput: &#123; [<span class="keyword">weak</span> imageCache] (image) <span class="keyword">in</span></span><br><span class="line">            imageCache?.setObject(image, forKey: <span class="type">NSString</span>(string: path))</span><br><span class="line">        &#125;)</span><br><span class="line">        .eraseToAnyPublisher()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eraseToAnyPublisher()</span><br></pre></td></tr></table></figure><p>被用到了很多次</p><p>把它提出来，写一个 Just 的 extension</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Just</span>: <span class="title">TypeConvertable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> convertable: <span class="type">AnyPublisher</span>&lt;<span class="type">Output</span>, <span class="type">Never</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.eraseToAnyPublisher()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是代码变得简洁了很多</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">cachedImage</span><span class="params">(<span class="keyword">for</span> path: String?)</span></span> -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">UIImage</span>?, <span class="type">Never</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> path = path <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Just</span>(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> image = imageCache.object(forKey: <span class="type">NSString</span>(string: path)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Just</span>(image)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image(<span class="keyword">for</span>: path)</span><br><span class="line">        .handleEvents(receiveOutput: &#123; [<span class="keyword">weak</span> imageCache] (image) <span class="keyword">in</span></span><br><span class="line">             imageCache?.setObject(image, forKey: <span class="type">NSString</span>(string: path))</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把例子变得通用一些</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TypeConvertable</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">ReturnType</span></span><br><span class="line">    <span class="keyword">var</span> convertable: <span class="type">ReturnType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义一个类型转变的时候，编译器应该可以决定对应的类型和相应的转变结果。<br>在这个例子中返回的类型是由给定类型决定的</p><p>2) 讨论 <a href="https://forums.swift.org/t/xcode-14-rc-cannot-specialize-protocol-type/60171" title="Xcode14 RC 不能序列化 protocol 类型" target="_blank" rel="noopener">Xcode14 RC 不能序列化 protocol 类型</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ❌ Cannot specialize protocol type &apos;Collection&apos;</span><br><span class="line">extension Collection&lt;MyType&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// ❌ Cannot specialize protocol type &apos;Sequence&apos;</span><br><span class="line">func foo(_ x: some Sequence&lt;String&gt;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>可能原因 macOS 12 SDK 仍然使用 Swift5.6，而不是 5.7.<br>Swift 5.7 支持：</p><ul><li>自定义 protocol 可以有 associated types。 参考链接：<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0358-primary-associated-types-in-stdlib.md" target="_blank" rel="noopener">https://github.com/apple/swift-evolution/blob/main/proposals/0358-primary-associated-types-in-stdlib.md</a></li><li>在 protocol 里使用 associated type 要注意传入的类型与返回类型</li></ul><p>3) <a href="https://forums.swift.org/t/swift-style-guide/60177/5" title="Swift coding style guide" target="_blank" rel="noopener">Swift coding style guide</a></p><p>一个很好的 swift style 总集文档：<a href="https://google.github.io/swift/#line-wrapping" target="_blank" rel="noopener">https://google.github.io/swift/#line-wrapping</a></p><p>4) 讨论 <a href="https://forums.swift.org/t/c-abstract-class-inheritance-and-c-interop-to-swift-protocols/60170" title="C++ Abstract Class Inheritance and C++-Interop (to Swift Protocols)" target="_blank" rel="noopener">C++ Abstract Class Inheritance and C++-Interop (to Swift Protocols)</a></p><p>5) 提问 <a href="https://forums.swift.org/t/how-to-handle-empty-response-in-responseserializer/60155/1" title="如何处理空的网络返回值" target="_blank" rel="noopener">如何处理空的网络返回值</a></p><p>可以参考 Alamofire 的处理方法.<br>参考链接: <a href="https://github.com/Alamofire/Alamofire/blob/master/Source/ResponseSerialization.swift#L925" target="_blank" rel="noopener">https://github.com/Alamofire/Alamofire/blob/master/Source/ResponseSerialization.swift#L925</a><br>当网络请求返回是空的时候可以判定为请求失败，同时查看返回代码是不是在 200～299 之间</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2022/08/30/lock-screen-widgets-in-swiftui/" title="SwiftUI 锁屏小组件" target="_blank" rel="noopener">SwiftUI 锁屏小组件</a></p><p><strong>摘要：</strong> 随着 iOS 16 的发布，赶快来适配一下 iOS 16 最为重要的更新之一，锁屏小组件吧！</p><p><a href="https://www.polpiella.dev/sourcery-swift-package-command-plugin" title="Sourcery 的 Swift Package 命令行插件" target="_blank" rel="noopener">Sourcery 的 Swift Package 命令行插件</a></p><p><strong>摘要：</strong> 作为 Swift 最流程的代码生成工具，sourcery 能够快速的生成模板代码来帮助开发者节省大量的时间。</p><p><a href="https://mp.weixin.qq.com/s/p_MoRthVdlfhqSyxCkDkow" target="_blank" rel="noopener">项目中第三方库并不是必须的</a></p><p><strong>摘要：</strong> 作者充分的论述了第三方库在提供便利的同时也带来了相当的风险。为是否选择集成第三方库提供了一套有意义的思路。</p><p><a href="https://blog.nielsmouthaan.nl/aso-tips-and-tricks-to-increase-your-apps-ranking" title="增加 App 排名的 ASO 小技巧" target="_blank" rel="noopener">增加 App 排名的 ASO 小技巧</a></p><p><strong>摘要：</strong> 偶尔也可以关注一下技术之外的东西，从另一个方面提升自己的竞争力。</p><p><a href="https://mp.weixin.qq.com/s/R1XLp9hjHDBdYcOI6w8psw" title="云音乐 iOS 端网络图片下载优化实践" target="_blank" rel="noopener">云音乐 iOS 端网络图片下载优化实践</a></p><p><strong>摘要：</strong> 本文介绍了网易云音乐在图片下载的优化下实践。从想法到技术方案，再从 <code>SDWebImage</code> 源码入手，到最后的再次封装实现，都很值得一看。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第四期&lt;/strong&gt;，每个模块还在调整磨合期。各位读者如果有好的提议，欢迎在文末
      
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 16 主要功能和提升</title>
    <link href="https://fanbaoying.github.io/iOS-16-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E5%92%8C%E6%8F%90%E5%8D%87/"/>
    <id>https://fanbaoying.github.io/iOS-16-主要功能和提升/</id>
    <published>2022-09-13T02:45:10.000Z</published>
    <updated>2022-09-15T11:37:06.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="锁定屏幕"><a href="#锁定屏幕" class="headerlink" title="锁定屏幕"></a>锁定屏幕</h3><h4 id="锁定屏幕图库"><a href="#锁定屏幕图库" class="headerlink" title="锁定屏幕图库"></a>锁定屏幕图库</h4><p>从包含众多样式的图库中寻找灵感，定制个性化的锁定屏幕，每款都有自己独特的背景、风格化的日期和时间显示方式，以及便于快速查看的信息。</p><h4 id="切换锁定屏幕"><a href="#切换锁定屏幕" class="headerlink" title="切换锁定屏幕"></a>切换锁定屏幕</h4><p>你可以随时切换锁定屏幕。只需按住锁定屏幕，然后手指轻扫即可。</p><h4 id="编辑锁定屏幕"><a href="#编辑锁定屏幕" class="headerlink" title="编辑锁定屏幕"></a>编辑锁定屏幕</h4><p>轻点锁定屏幕上的各项元素，即可轻松自定其字体、颜色或摆放位置。</p><h4 id="风格化的显示日期和时间"><a href="#风格化的显示日期和时间" class="headerlink" title="风格化的显示日期和时间"></a>风格化的显示日期和时间</h4><p>选择充满表现力的字体样式和颜色，自定锁定屏幕上日期和时间的显示外观。</p><a id="more"></a><h4 id="照片分层效果"><a href="#照片分层效果" class="headerlink" title="照片分层效果"></a>照片分层效果</h4><p>照片主体会动态显示在时间元素前面，令主角在屏幕上呼之欲出。</p><h4 id="建议的照片"><a href="#建议的照片" class="headerlink" title="建议的照片"></a>建议的照片</h4><p>iOS 会智能地为你推荐图库中那些适合放在锁定屏幕上的照片。</p><h4 id="照片随机显示"><a href="#照片随机显示" class="headerlink" title="照片随机显示"></a>照片随机显示</h4><p>在锁定屏幕上展示一组自动随机显示的照片。你可以自己掌控锁定屏幕更新照片的节奏，也可交由 iOS 来决定，让你在一天当中惊喜不断。</p><h4 id="照片样式"><a href="#照片样式" class="headerlink" title="照片样式"></a>照片样式</h4><p>为锁定屏幕上的照片应用样式，自动调整颜色滤镜、色调和字体样式，让画面风格协调统一。</p><h4 id="锁定屏幕上的小组件"><a href="#锁定屏幕上的小组件" class="headerlink" title="锁定屏幕上的小组件"></a>锁定屏幕上的小组件</h4><p>选择一系列小组件显示在锁定屏幕上，以便快速一览天气、时间、日期、电池电量、临近的日程、闹钟、时区和健身记录圆环进度等信息。</p><h4 id="WidgetKit-API"><a href="#WidgetKit-API" class="headerlink" title="WidgetKit API"></a>WidgetKit API</h4><p>轻松浏览来自常用第三方 app 的小组件。小组件以文字、圆形或矩形格式显示在时间附近，便于你了解天气情况或目标完成进度等信息。</p><h4 id="实时活动"><a href="#实时活动" class="headerlink" title="实时活动"></a>实时活动</h4><p>有了实时活动功能，你就可以在锁定屏幕上实时获知各种事情的进展。</p><h4 id="实时活动-API"><a href="#实时活动-API" class="headerlink" title="实时活动 API"></a>实时活动 API</h4><p>跟进骑行活动或订单的进度，相关信息都能一目了然。通过这个新的开发者 API，你便可一览常用第三方 app 的实时活动。</p><h4 id="为专注模式设计的锁定屏幕"><a href="#为专注模式设计的锁定屏幕" class="headerlink" title="为专注模式设计的锁定屏幕"></a>为专注模式设计的锁定屏幕</h4><p>iOS 会根据设定的专注模式选项，建议一系列相关的锁定屏幕。比如，在“工作”专注模式下，推荐信息丰富的锁定屏幕，而使用“个人”专注模式时，则推荐呈现照片的锁定屏幕。</p><h4 id="Apple-精选系列"><a href="#Apple-精选系列" class="headerlink" title="Apple 精选系列"></a>Apple 精选系列</h4><p>Apple 专为 iOS 16 打造了一系列动态、经典和景观类的锁定屏幕，供你随心选择。Apple 精选系列还包含为庆祝某些特定的文化活动而设计的锁定屏幕。</p><h4 id="天文"><a href="#天文" class="headerlink" title="天文"></a>天文</h4><p>一套动态的天文主题锁定屏幕，带你探索地球、月球或太阳系，还会随着实时状态而更新。</p><h4 id="天气"><a href="#天气" class="headerlink" title="天气"></a>天气</h4><p>在锁定屏幕上，一览当天天气状况的实时变化。</p><h4 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h4><p>基于你喜欢的表情符号，创建图案化的锁定屏幕。</p><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>为锁定屏幕选择颜色渐变，颜色组合可按喜好设定。</p><h4 id="“播放中”迎来新设计"><a href="#“播放中”迎来新设计" class="headerlink" title="“播放中”迎来新设计"></a>“播放中”迎来新设计</h4><p>使用实时活动功能时，可将“播放中”的控制界面放大至全屏视图，边听音乐边欣赏专辑封面。</p><h4 id="通知的新面貌"><a href="#通知的新面貌" class="headerlink" title="通知的新面貌"></a>通知的新面貌</h4><p>通知采用粗体文字和图片，视觉呈现直观又醒目。</p><h4 id="通知动画"><a href="#通知动画" class="headerlink" title="通知动画"></a>通知动画</h4><p>通知及通知摘要会从锁定屏幕底部滚动出现，查看起来一目了然。</p><h4 id="锁定屏幕的通知视图"><a href="#锁定屏幕的通知视图" class="headerlink" title="锁定屏幕的通知视图"></a>锁定屏幕的通知视图</h4><p>你可以选择在锁定屏幕上以展开的列表、叠放或数量的视图方式来查看通知。手指轻轻捏合，可更改通知显示时的布局。</p><h3 id="专注模式"><a href="#专注模式" class="headerlink" title="专注模式"></a>专注模式</h3><h4 id="锁定屏幕关联"><a href="#锁定屏幕关联" class="headerlink" title="锁定屏幕关联"></a>锁定屏幕关联</h4><p>将锁定屏幕与专注模式建立关联，可同时转变 iPhone 的屏幕外观和功能。要启用专注模式，只需轻扫切换至相应的锁定屏幕即可。</p><h4 id="锁定屏幕建议"><a href="#锁定屏幕建议" class="headerlink" title="锁定屏幕建议"></a>锁定屏幕建议</h4><p>iOS 会根据设定的专注模式选项，建议一系列相关的锁定屏幕。比如，在“工作”专注模式下，推荐信息丰富的锁定屏幕，而使用“个人”专注模式时，则推荐呈现照片的锁定屏幕。</p><h4 id="主屏幕页面建议"><a href="#主屏幕页面建议" class="headerlink" title="主屏幕页面建议"></a>主屏幕页面建议</h4><p>iOS 会为你提供主屏幕页面建议，推荐显示与你所设定专注模式相关度最高的 app 和小组件。</p><h4 id="专注模式过滤条件"><a href="#专注模式过滤条件" class="headerlink" title="专注模式过滤条件"></a>专注模式过滤条件</h4><p>针对你启用的每个专注模式，在 Apple 的日历、邮件、信息和 Safari 浏览器等 app 中设置不同过滤条件，助你排除外界干扰。比如，你可选择在“工作”专注模式下，Safari 浏览器中可显示哪些标签页组；或者在“个人”专注模式下，隐藏工作日历。</p><h4 id="专注模式过滤条件-API"><a href="#专注模式过滤条件-API" class="headerlink" title="专注模式过滤条件 API"></a>专注模式过滤条件 API</h4><p>有了新的专注模式过滤条件 API，开发者可利用你正在使用某个专注模式的信号，来隐藏让你分心的内容。</p><h4 id="预设启用专注模式"><a href="#预设启用专注模式" class="headerlink" title="预设启用专注模式"></a>预设启用专注模式</h4><p>你可以选择在某个特定时间或地点，或是在使用某个 app 时，自动启用专注模式。</p><h4 id="设置更简单"><a href="#设置更简单" class="headerlink" title="设置更简单"></a>设置更简单</h4><p>在开始使用专注模式时，每个选项都能为你带来个性化设置体验。</p><h4 id="允许和静音列表"><a href="#允许和静音列表" class="headerlink" title="允许和静音列表"></a>允许和静音列表</h4><p>设置专注模式时，你可以通过选择允许或静音，来决定要接收哪些 app 和哪些人的通知。</p><h3 id="今年稍晚推出iCloud-共享图库"><a href="#今年稍晚推出iCloud-共享图库" class="headerlink" title="今年稍晚推出iCloud 共享图库"></a>今年稍晚推出iCloud 共享图库</h3><h4 id="与家人共享照片图库"><a href="#与家人共享照片图库" class="headerlink" title="与家人共享照片图库"></a>与家人共享照片图库</h4><p>你最多可与五人共享独立的 iCloud 图库。</p><h4 id="智能设置规则"><a href="#智能设置规则" class="headerlink" title="智能设置规则"></a>智能设置规则</h4><p>分享你所有以前的照片；或是利用设置工具，按照开始日期或人物选取特定的照片。</p><h4 id="智能共享建议"><a href="#智能共享建议" class="headerlink" title="智能共享建议"></a>智能共享建议</h4><p>手动选取照片，或是使用各种智能功能，顺畅无缝地共享照片。比如借助相机 app 中的切换功能，通过蓝牙近距离感应自动共享，以及从“为你推荐”中获取共享建议。</p><h4 id="携手制作照片集"><a href="#携手制作照片集" class="headerlink" title="携手制作照片集"></a>携手制作照片集</h4><p>每个人都拥有相同的权限，可以随心添加、编辑、收藏、删除照片，或是加上相关说明。</p><h4 id="重温更丰富完整的回忆"><a href="#重温更丰富完整的回忆" class="headerlink" title="重温更丰富完整的回忆"></a>重温更丰富完整的回忆</h4><p>在“回忆”、“精选照片”，或是“照片”小组件中欣赏共享的照片。</p><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><h4 id="编辑信息"><a href="#编辑信息" class="headerlink" title="编辑信息"></a>编辑信息</h4><p>信息发出后的 15 分钟内，你都可以对其进行编辑。接收人可以看到信息的修改记录。</p><h4 id="撤销发送"><a href="#撤销发送" class="headerlink" title="撤销发送"></a>撤销发送</h4><p>你可以在信息发出后的 2 分钟内将其撤回。</p><h4 id="标记为未读"><a href="#标记为未读" class="headerlink" title="标记为未读"></a>标记为未读</h4><p>无法及时回复，想稍后再来处理的信息，你可将其标为未读。</p><h4 id="恢复最近删除的信息"><a href="#恢复最近删除的信息" class="headerlink" title="恢复最近删除的信息"></a>恢复最近删除的信息</h4><p>你可以恢复最近 30 天内删除的信息。</p><h4 id="在“信息”里同播共享"><a href="#在“信息”里同播共享" class="headerlink" title="在“信息”里同播共享"></a>在“信息”里同播共享</h4><p>在信息 app 里与好友一边聊天，一边共享音乐，还能同步更多精彩。</p><h4 id="“与你共享”-API"><a href="#“与你共享”-API" class="headerlink" title="“与你共享” API"></a>“与你共享” API</h4><p>开发者可以在 app 中构建“与你共享”区域。这样一来，当有人给你发送视频或文章时，即使你没法马上查看，下次打开 app 也能轻松找到。</p><h4 id="Android-设备上短信的点回回应"><a href="#Android-设备上短信的点回回应" class="headerlink" title="Android 设备上短信的点回回应"></a>Android 设备上短信的点回回应</h4><p>带上“点回”回应短信，Android 设备上收到后便会出现相应的表情符号。</p><h4 id="双卡信息过滤"><a href="#双卡信息过滤" class="headerlink" title="双卡信息过滤"></a>双卡信息过滤</h4><p>支持逐一按 SIM 卡过滤信息 app 中的对话。</p><h4 id="音频信息播放"><a href="#音频信息播放" class="headerlink" title="音频信息播放"></a>音频信息播放</h4><p>收听音频信息时，你可以快进或倒回。</p><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><h4 id="智能搜索更正"><a href="#智能搜索更正" class="headerlink" title="智能搜索更正"></a>智能搜索更正</h4><p>智能搜索功能可更正搜索词中的错别字并使用同义词，从而优化搜索结果。</p><h4 id="智能搜索建议"><a href="#智能搜索建议" class="headerlink" title="智能搜索建议"></a>智能搜索建议</h4><p>你一开始搜索电子邮件，即可看到更丰富的共享内容视图。</p><h4 id="收件人和附件遗漏提示"><a href="#收件人和附件遗漏提示" class="headerlink" title="收件人和附件遗漏提示"></a>收件人和附件遗漏提示</h4><p>如果你在邮件中遗漏了某些重要内容，如附件或收件人，将会收到相应提示。</p><h4 id="撤销发送-1"><a href="#撤销发送-1" class="headerlink" title="撤销发送"></a>撤销发送</h4><p>在你刚发出的电子邮件送达收件人的收件箱之前，轻松将其撤回。</p><h4 id="定时发送"><a href="#定时发送" class="headerlink" title="定时发送"></a>定时发送</h4><p>将邮件发送安排在恰当的时刻。</p><h4 id="跟进"><a href="#跟进" class="headerlink" title="跟进"></a>跟进</h4><p>将已发出的邮件移至收件箱顶部，以便你快速发送跟进邮件。</p><h4 id="提醒我"><a href="#提醒我" class="headerlink" title="提醒我"></a>提醒我</h4><p>已经打开但尚未回复的邮件，再也不会忘记。选择日期和时间，让邮件到时候在收件箱中再次醒目显现。</p><h4 id="图文链接"><a href="#图文链接" class="headerlink" title="图文链接"></a>图文链接</h4><p>添加图文链接，在邮件里一目了然呈现更多背景信息和详情。</p><h4 id="BIMI-支持"><a href="#BIMI-支持" class="headerlink" title="BIMI 支持"></a>BIMI 支持</h4><p>通过经 BIMI (信息识别的品牌指示) 认证的品牌标志，轻松识别已认证的电子邮件信息。</p><h3 id="Safari-浏览器"><a href="#Safari-浏览器" class="headerlink" title="Safari 浏览器"></a>Safari 浏览器</h3><h4 id="共享标签页组"><a href="#共享标签页组" class="headerlink" title="共享标签页组"></a>共享标签页组</h4><p>与朋友共享一组标签页。每个人都能添加自己的标签页，协作时标签页组如有更新，也能即刻看到。</p><h4 id="标签页组起始页"><a href="#标签页组起始页" class="headerlink" title="标签页组起始页"></a>标签页组起始页</h4><p>标签页组拥有专门的起始页面，你可以自定背景图和个人收藏项。</p><h4 id="标签页组中固定的标签页"><a href="#标签页组中固定的标签页" class="headerlink" title="标签页组中固定的标签页"></a>标签页组中固定的标签页</h4><p>自定你的标签页组，为各个组别设置固定的标签页。</p><h4 id="新的网页扩展-API"><a href="#新的网页扩展-API" class="headerlink" title="新的网页扩展 API"></a>新的网页扩展 API</h4><p>让开发者能够创建更多种类的 Safari 浏览器网页扩展。</p><h4 id="网站推送通知"><a href="#网站推送通知" class="headerlink" title="网站推送通知"></a>网站推送通知</h4><p>可在 iOS 里选择接收网站通知。2023 年推出。</p><h4 id="扩展可同步"><a href="#扩展可同步" class="headerlink" title="扩展可同步"></a>扩展可同步</h4><p>在 Safari 浏览器偏好设置中，查看来自其他设备的可用扩展。扩展在安装后便会同步，你只需启用一次即可。</p><h4 id="网站设置同步"><a href="#网站设置同步" class="headerlink" title="网站设置同步"></a>网站设置同步</h4><p>你针对特定网站所做的设置，如页面缩放和自动阅读器视图，将在各种设备上同步。</p><h4 id="新增语言"><a href="#新增语言" class="headerlink" title="新增语言"></a>新增语言</h4><p>Safari 浏览器网页翻译功能新增阿拉伯语、荷兰语、印尼语、韩语、波兰语、泰语、土耳其语和越南语支持。</p><h4 id="翻译网页图片中的文字"><a href="#翻译网页图片中的文字" class="headerlink" title="翻译网页图片中的文字"></a>翻译网页图片中的文字</h4><p>现支持使用实况文本功能翻译图像中的文字。</p><h4 id="其他的网页技术支持"><a href="#其他的网页技术支持" class="headerlink" title="其他的网页技术支持"></a>其他的网页技术支持</h4><p>让开发者能够更好地掌控网页样式和布局，打造更为引人入胜的内容。</p><h4 id="强密码编辑"><a href="#强密码编辑" class="headerlink" title="强密码编辑"></a>强密码编辑</h4><p>编辑由 Safari 浏览器建议的强密码，以针对特定要求作出调整。</p><h4 id="“设置”中的无线局域网密码"><a href="#“设置”中的无线局域网密码" class="headerlink" title="“设置”中的无线局域网密码"></a>“设置”中的无线局域网密码</h4><p>在“设置”中查看和管理你的无线局域网密码。可引用和共享密码，或删除旧密码。</p><h3 id="通行密钥"><a href="#通行密钥" class="headerlink" title="通行密钥"></a>通行密钥</h3><h4 id="通行密钥-1"><a href="#通行密钥-1" class="headerlink" title="通行密钥"></a>通行密钥</h4><p>通行密钥是更为安全便捷的登录方式，可取代密码。</p><h4 id="防止钓鱼攻击"><a href="#防止钓鱼攻击" class="headerlink" title="防止钓鱼攻击"></a>防止钓鱼攻击</h4><p>通行密钥始终位于你的设备本地，并且仅适用于你在创建时指定的网站，因而几乎不会受到钓鱼攻击。</p><h4 id="避免从网站泄露"><a href="#避免从网站泄露" class="headerlink" title="避免从网站泄露"></a>避免从网站泄露</h4><p>你的私有密钥绝不会保存在网络服务器上，因此不必担心网站泄露影响你的账户安全。</p><h4 id="登录其他设备"><a href="#登录其他设备" class="headerlink" title="登录其他设备"></a>登录其他设备</h4><p>用 iPhone 或 iPad 扫描二维码并通过面容 ID 或触控 ID 进行身份验证，即可利用已保存的通行密钥在其他设备上登录网站或 app，非 Apple 设备也同样适用。</p><h4 id="跨设备同步"><a href="#跨设备同步" class="headerlink" title="跨设备同步"></a>跨设备同步</h4><p>通行密钥采用端到端加密，并通过 iCloud 钥匙串在你的各种 Apple 设备上保持同步。</p><h3 id="实况文本"><a href="#实况文本" class="headerlink" title="实况文本"></a>实况文本</h3><h4 id="视频中的实况文本"><a href="#视频中的实况文本" class="headerlink" title="视频中的实况文本"></a>视频中的实况文本</h4><p>视频暂停画面中的文本可进行充分交互，诸如拷贝、粘贴、查询，或是翻译等功能都可实现。实况文本功能适用于“照片”、快速查看和 Safari 浏览器等 app 或功能。</p><h4 id="快速操作"><a href="#快速操作" class="headerlink" title="快速操作"></a>快速操作</h4><p>对于照片和视频中已检测到的数据，只需轻点一下即可执行多种操作。追踪航班或物流、翻译外语、转换货币等，都不成问题。</p><h4 id="实况文本新增语言支持"><a href="#实况文本新增语言支持" class="headerlink" title="实况文本新增语言支持"></a>实况文本新增语言支持</h4><p>实况文本新增了对日语、韩语和乌克兰语的文本识别功能。</p><h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><h4 id="轻松设置快捷指令"><a href="#轻松设置快捷指令" class="headerlink" title="轻松设置快捷指令"></a>轻松设置快捷指令</h4><p>无需任何设置，Siri 便能运行来自各种 app 的快捷指令。</p><h4 id="自动发送信息"><a href="#自动发送信息" class="headerlink" title="自动发送信息"></a>自动发送信息</h4><p>在发送信息时跳过确认步骤。你可以在“设置”中启用此功能。</p><h4 id="文本中的表情符号"><a href="#文本中的表情符号" class="headerlink" title="文本中的表情符号"></a>文本中的表情符号</h4><p>在发送信息时吩咐 Siri 插入表情符号。</p><h4 id="嘿-Siri，在这里能做些什么？"><a href="#嘿-Siri，在这里能做些什么？" class="headerlink" title="嘿 Siri，在这里能做些什么？"></a>嘿 Siri，在这里能做些什么？</h4><p>通过询问“嘿 Siri，在这里能做些什么”，探索 Siri 在 iOS 和 app 中的功能。你也可查询特定 app 的功能。</p><h4 id="结束通话"><a href="#结束通话" class="headerlink" title="结束通话"></a>结束通话</h4><p>在 Siri 的助力下，你可以完全不用动手就结束通话。只需说声“嘿 Siri，挂电话”(对方也会听到)。可在“设置”中启用此功能。</p><h4 id="扩展的离线支持"><a href="#扩展的离线支持" class="headerlink" title="扩展的离线支持"></a>扩展的离线支持</h4><p>Siri 可以在没有网络连接的情况下，离线处理更多类型的请求，包括家居配件控制 (HomeKit)、广播功能和语音留言。</p><h3 id="听写"><a href="#听写" class="headerlink" title="听写"></a>听写</h3><h4 id="全新的听写体验"><a href="#全新的听写体验" class="headerlink" title="全新的听写体验"></a>全新的听写体验</h4><p>在设备上使用听写功能时，可在语音与触控输入之间流畅切换。无需中断听写模式，照样可以用键盘输入、轻点文本栏、移动光标，或插入快速输入建议。</p><h4 id="自动标点符号"><a href="#自动标点符号" class="headerlink" title="自动标点符号"></a>自动标点符号</h4><p>听写功能可为你的口述自动插入逗号、句号和问号。</p><h4 id="表情符号支持"><a href="#表情符号支持" class="headerlink" title="表情符号支持"></a>表情符号支持</h4><p>在设备上使用听写功能时，可以通过语音插入表情符号。</p><h4 id="信息-App-文本栏中的听写"><a href="#信息-App-文本栏中的听写" class="headerlink" title="信息 App 文本栏中的听写"></a>信息 App 文本栏中的听写</h4><p>听写功能的图标现在会显示在信息 app 的文本输入栏中。</p><h4 id="听写功能弹出窗口"><a href="#听写功能弹出窗口" class="headerlink" title="听写功能弹出窗口"></a>听写功能弹出窗口</h4><p>轻点新的光标弹出窗口，即可轻松停止听写。</p><h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3><h4 id="多途经点路线规划"><a href="#多途经点路线规划" class="headerlink" title="多途经点路线规划"></a>多途经点路线规划</h4><p>在地图 app 中规划驾驶路线时，可添加多个途经点。在 Mac 上规划的有多个途经点的路线，会同步到你的 iPhone 上。</p><h4 id="地图-App-中的交通卡"><a href="#地图-App-中的交通卡" class="headerlink" title="地图 App 中的交通卡"></a>地图 App 中的交通卡</h4><p>不用离开地图 app，即可向钱包 app 添加交通卡，查看余额不足信息，并能向卡内充值。</p><h3 id="Apple-Pay-和钱包"><a href="#Apple-Pay-和钱包" class="headerlink" title="Apple Pay 和钱包"></a>Apple Pay 和钱包</h3><h4 id="钥匙共享"><a href="#钥匙共享" class="headerlink" title="钥匙共享"></a>钥匙共享</h4><p>通过信息、邮件等常用的通迅类 app，与你信任的人安全地共享钱包 app 中的钥匙。</p><h4 id="多次入住的酒店钥匙"><a href="#多次入住的酒店钥匙" class="headerlink" title="多次入住的酒店钥匙"></a>多次入住的酒店钥匙</h4><p>再次预订时，你无需向钱包 app 添加新的酒店房间钥匙。准备入住同一品牌旗下酒店中的任何一家，你都可用同一把钥匙办理入住手续，打开房门。</p><h4 id="从-Safari-浏览器添加钥匙"><a href="#从-Safari-浏览器添加钥匙" class="headerlink" title="从 Safari 浏览器添加钥匙"></a>从 Safari 浏览器添加钥匙</h4><p>现在，不用下载 app，你就可以直接从 Safari 浏览器上通过网站在 iPhone 和 Apple Watch 上添加新的钥匙，方便又安全。</p><h4 id="轻松完成跨设备迁移钥匙"><a href="#轻松完成跨设备迁移钥匙" class="headerlink" title="轻松完成跨设备迁移钥匙"></a>轻松完成跨设备迁移钥匙</h4><p>轻点钱包 app 中的“+”按钮，即可查看你的钥匙列表，然后选择你需要添加至新设备的钥匙即可。</p><h4 id="Apple-Pay-订单跟踪"><a href="#Apple-Pay-订单跟踪" class="headerlink" title="Apple Pay 订单跟踪"></a>Apple Pay 订单跟踪</h4><p>有了 Apple Pay 订单跟踪功能，用户与 Apple Pay 合作商家交易，便可在钱包 app 中接收各种明细票据及订单跟踪信息。</p><h4 id="Apple-Pay-商家令牌"><a href="#Apple-Pay-商家令牌" class="headerlink" title="Apple Pay 商家令牌"></a>Apple Pay 商家令牌</h4><p>商家令牌让你安全地设置，并完成预授权或重复发生的 Apple Pay 支付。</p><h4 id="在一笔-Apple-Pay-交易中向多个商家进行支付"><a href="#在一笔-Apple-Pay-交易中向多个商家进行支付" class="headerlink" title="在一笔 Apple Pay 交易中向多个商家进行支付"></a>在一笔 Apple Pay 交易中向多个商家进行支付</h4><p>现在，你可以在单张 Apple Pay 付款单中指定多个商家的具体支付金额。如此一来，你便可灵活地进行捆绑式购买，如包含航班、租车及酒店的旅行套餐，随后向各个商家发起支付。</p><h4 id="“快速访问”菜单"><a href="#“快速访问”菜单" class="headerlink" title="“快速访问”菜单"></a>“快速访问”菜单</h4><p>通过快速访问功能的菜单 (仅限特定的凭证和卡片)，用户轻点一下就可取用凭证背面的众多功用。</p><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><h4 id="全新的家庭-App"><a href="#全新的家庭-App" class="headerlink" title="全新的家庭 App"></a>全新的家庭 App</h4><p>家庭 app 采用全新设计，令浏览、整理、查看和控制各种配件更加轻松简单。深入基础架构层面的多项优化更新，让你的智能家居表现更出色、更高效、更可靠。</p><h4 id="全屋视图"><a href="#全屋视图" class="headerlink" title="全屋视图"></a>全屋视图</h4><p>在设计一新的“家庭”标签页里，整个家的情况一目了然。各个房间和常用的配件全都整合于 app 的主标签页中，方便你更轻松地调取经常使用的配件。</p><h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><p>以“灯光”、“环境”、“安全”、“扬声器”以及“水”等类别划分，让你能快速调用按房间整理的所有相关配件，同时尽览更详细的状态信息。</p><h4 id="全新摄像头视图"><a href="#全新摄像头视图" class="headerlink" title="全新摄像头视图"></a>全新摄像头视图</h4><p>“家庭”标签页的靠前居中位置最多可展示四个摄像头画面，轻轻滚动便能看到家中其他摄像头的画面。</p><h4 id="板块设计"><a href="#板块设计" class="headerlink" title="板块设计"></a>板块设计</h4><p>配件板块经过重新设计，不同配件的形状和颜色在视觉上更易分辨。只需轻点板块图标，即可从板块直接操控配件。或是轻点配件名称，查看更详细的控制项目。</p><h4 id="今年稍晚推出优化的架构"><a href="#今年稍晚推出优化的架构" class="headerlink" title="今年稍晚推出优化的架构"></a>今年稍晚推出优化的架构</h4><p>基础架构经过了多项优化，使性能表现更快、更可靠，特别是对于那些拥有多款智能配件的家庭来说，改善尤为显著。通过家庭 app，你可更高效地同时在多个设备上与连接的配件进行通讯并控制它们。</p><h4 id="锁定屏幕上的小组件-1"><a href="#锁定屏幕上的小组件-1" class="headerlink" title="锁定屏幕上的小组件"></a>锁定屏幕上的小组件</h4><p>小组件登陆 iPhone 锁定屏幕，让你从锁定屏幕就能查看家居状态，快速取用各种常用配件。</p><h4 id="今年稍晚推出Matter-支持"><a href="#今年稍晚推出Matter-支持" class="headerlink" title="今年稍晚推出Matter 支持"></a>今年稍晚推出Matter 支持</h4><p>Matter 是一项新的智能家居连接标准，可支持多款兼容的配件跨平台顺畅协作。有了 Matter，你可以选择的兼容智能家居配件更多了，并能通过 Apple 设备上的家庭 app 和 Siri 控制它们。</p><h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><h4 id="记录用药情况"><a href="#记录用药情况" class="headerlink" title="记录用药情况"></a>记录用药情况</h4><p>创建用药清单，轻松记录你服用的药物、维生素和营养品。还能添加自定图标，让这些信息更好记。</p><h4 id="用药提醒"><a href="#用药提醒" class="headerlink" title="用药提醒"></a>用药提醒</h4><p>为每种药物创建自定的服用时间和提醒，可以是一日多次、一周一次，或者其他需要的方式。</p><h4 id="用药记录"><a href="#用药记录" class="headerlink" title="用药记录"></a>用药记录</h4><p>你可以借助用药提醒来记录服药时间，也可直接在健康 app 中记录用药情况。交互式的图表信息，有助你了解服药时间，知晓自己是否遵从用药指示。</p><h4 id="“健康共享”邀请"><a href="#“健康共享”邀请" class="headerlink" title="“健康共享”邀请"></a>“健康共享”邀请</h4><p>邀请你关心的人与你安全地共享他们的健康数据。他们收到你的邀请后，可以选择要共享哪些数据。</p><h4 id="经期偏差提示"><a href="#经期偏差提示" class="headerlink" title="经期偏差提示"></a>经期偏差提示</h4><p>如果你的经期记录出现月经稀发、月经不规律、经期延长或持续点滴出血的情况，你将会收到提示。</p><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><h4 id="所有-iPhone-用户都可用的健身-App"><a href="#所有-iPhone-用户都可用的健身-App" class="headerlink" title="所有 iPhone 用户都可用的健身 App"></a>所有 iPhone 用户都可用的健身 App</h4><p>即使你没有 Apple Watch，也能追踪和达成自己的健身目标。iPhone 的运动传感器可记录你的步数和行走距离，并结合第三方 app 的运动数据，估算你在迈向每日活动目标的途中燃烧的卡路里。</p><h3 id="家人共享"><a href="#家人共享" class="headerlink" title="家人共享"></a>家人共享</h3><h4 id="优化的儿童账户设置"><a href="#优化的儿童账户设置" class="headerlink" title="优化的儿童账户设置"></a>优化的儿童账户设置</h4><p>在开始创建儿童账户时，就能设好适当的家长控制，包括既简单易用又适合孩子年龄的媒体限制建议。</p><h4 id="设置孩子的设备"><a href="#设置孩子的设备" class="headerlink" title="设置孩子的设备"></a>设置孩子的设备</h4><p>使用“快速开始”功能，轻松为孩子设置新 iOS 或 iPadOS 设备，更可直接套用所有相应的家长控制功能。</p><h4 id="信息-App-中的屏幕使用时间"><a href="#信息-App-中的屏幕使用时间" class="headerlink" title="信息 App 中的屏幕使用时间"></a>信息 App 中的屏幕使用时间</h4><p>孩子发出的屏幕使用时间申请会显示在信息 app 中，方便你准许或拒绝。</p><h4 id="家人共享核对清单"><a href="#家人共享核对清单" class="headerlink" title="家人共享核对清单"></a>家人共享核对清单</h4><p>家人共享核对清单可为你提供实用的提示和建议。例如，随着孩子的成长更新其账户设置，或提醒自己与每位家人共享 iCloud+ 订阅服务。</p><h3 id="适用车型将于-2023-年末公布CarPlay-车载"><a href="#适用车型将于-2023-年末公布CarPlay-车载" class="headerlink" title="适用车型将于 2023 年末公布CarPlay 车载"></a>适用车型将于 2023 年末公布CarPlay 车载</h3><h4 id="新一代-CarPlay-车载"><a href="#新一代-CarPlay-车载" class="headerlink" title="新一代 CarPlay 车载"></a>新一代 CarPlay 车载</h4><p>新一代 CarPlay 车载囊括了驾驶者在车内用到的各种屏幕，带来浑然一体的新体验。与车辆各个系统的深层通联，可实现在汽车仪表盘屏幕上显示驾驶信息，还能控制车载收音机和空调通风系统。新版 CarPlay 车载会为每款车型进行专门设计，以适配不同车型各自的屏幕形状和布局。个性化设定程度更高，允许驾驶者选择仪表盘的设计，还提供一些车辆品牌特有的选项。</p><h4 id="加油和驾驶任务类-App"><a href="#加油和驾驶任务类-App" class="headerlink" title="加油和驾驶任务类 App"></a>加油和驾驶任务类 App</h4><p>在 CarPlay 车载中，可使用加油和驾驶任务类 app。那些可协助加油，或是提供路况信息、通行费支持、拖车帮助等服务的常用 app，均可进驻 CarPlay 车载之中。</p><h4 id="自动发送信息-1"><a href="#自动发送信息-1" class="headerlink" title="自动发送信息"></a>自动发送信息</h4><p>在发送信息时跳过确认步骤。使用 CarPlay 车载时，你可以在 Siri 设置中启用此功能。</p><h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h3><h4 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h4><p>“设置”中的这一新增项可帮助遭受家庭暴力或亲密关系暴力的人们快速重设之前授予他人的权限，还能帮你管理已授予过权限的人和 app。</p><h4 id="粘贴板使用许可"><a href="#粘贴板使用许可" class="headerlink" title="粘贴板使用许可"></a>粘贴板使用许可</h4><p>App 需要得到你的许可，才能访问粘贴板，从另一个 app 中粘贴内容。</p><h4 id="流媒体传输优化"><a href="#流媒体传输优化" class="headerlink" title="流媒体传输优化"></a>流媒体传输优化</h4><p>直接从支持非隔空播放协议的设备以流媒体形式传输视频，无需提供蓝牙或本地网络访问权限。</p><h4 id="在照片-App-中锁定“已隐藏”和"><a href="#在照片-App-中锁定“已隐藏”和" class="headerlink" title="在照片 App 中锁定“已隐藏”和"></a>在照片 App 中锁定“已隐藏”和</h4><p>“最近删除”相簿</p><p>默认情况下，“已隐藏”和“最近删除”相簿已锁定。你可以用以下 iPhone 身份验证方式解除锁定：面容 ID、触控 ID 或你的密码。</p><h3 id="安全保护"><a href="#安全保护" class="headerlink" title="安全保护"></a>安全保护</h3><h4 id="快速安全响应"><a href="#快速安全响应" class="headerlink" title="快速安全响应"></a>快速安全响应</h4><p>你的设备可更快获得重要的安全更新。这些更新可在常规软件更新的间隔时段内自动生效。</p><h4 id="横屏使用面容-ID"><a href="#横屏使用面容-ID" class="headerlink" title="横屏使用面容 ID"></a>横屏使用面容 ID</h4><p>在部分支持的 iPhone 机型上，面容 ID 可以横屏使用。</p><h4 id="锁定模式"><a href="#锁定模式" class="headerlink" title="锁定模式"></a>锁定模式</h4><p>个别用户可能会面临有关电子数据安全的严重且具针对性的威胁，这个全新的安全模式，可为他们提供超强大的安全保护。它会进一步强化设备的防御机制，并严格限制某些功能，从而大大减少了可能会被目标高度明确的间谋软件利用的攻击面。</p><h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><h4 id="Apple-Watch-镜像功能"><a href="#Apple-Watch-镜像功能" class="headerlink" title="Apple Watch 镜像功能"></a>Apple Watch 镜像功能</h4><p>通过 iPhone 充分操控 Apple Watch，并可在 iPhone 上使用切换控制、语音控制等辅助操作功能，让 Apple Watch 物尽其用。</p><h4 id="放大器检测模式"><a href="#放大器检测模式" class="headerlink" title="放大器检测模式"></a>放大器检测模式</h4><p>这种新的放大器模式可为你详细地描述周边环境，包括门检测、人物检测和图像描述。</p><h4 id="放大器中的门检测功能"><a href="#放大器中的门检测功能" class="headerlink" title="放大器中的门检测功能"></a>放大器中的门检测功能</h4><p>可帮你找到门的位置、阅读门周围的标志或标签，并获得如何开门的提示。</p><h4 id="协控"><a href="#协控" class="headerlink" title="协控"></a>协控</h4><p>将多个游戏手柄的输入功能合而为一，让你的帮手助你在游戏中一路通关晋级。</p><h4 id="通过-Siri-结束通话"><a href="#通过-Siri-结束通话" class="headerlink" title="通过 Siri 结束通话"></a>通过 Siri 结束通话</h4><p>在 Siri 的助力下，你可以完全不用动手就结束 通话。只需说声“嘿 Siri，挂电话”(对方也会听到) 。可在“设置”中启用此功能。</p><h4 id="使用“语音控制”结束通话"><a href="#使用“语音控制”结束通话" class="headerlink" title="使用“语音控制”结束通话"></a>使用“语音控制”结束通话</h4><p>你可以使用语音控制功能来挂断电话或结束 FaceTime 通话。只需在“语音控制”启用的状态下，说出语音命令“挂电话”(对方也会听到) 即可。</p><h4 id="图书-App-新增辅助功能选项"><a href="#图书-App-新增辅助功能选项" class="headerlink" title="图书 App 新增辅助功能选项"></a>图书 App 新增辅助功能选项</h4><p>新增主题和自定选项，如文本加粗，调整线条、字体和文字间距等。</p><h4 id="旁白和朗读内容的新语言和新语音"><a href="#旁白和朗读内容的新语言和新语音" class="headerlink" title="旁白和朗读内容的新语言和新语音"></a>旁白和朗读内容的新语言和新语音</h4><p>旁白和朗读内容现增加 20 多种语言的支持，包括孟加拉语 (印度)、保加利亚语、加泰罗尼亚语、乌克兰语和越南语。此外还有数十种专为辅助功能优化的新语音可选。</p><h4 id="在助听设备上让-Siri-播报通知"><a href="#在助听设备上让-Siri-播报通知" class="headerlink" title="在助听设备上让 Siri 播报通知"></a>在助听设备上让 Siri 播报通知</h4><p>你可在 Made for iPhone 助听设备上，让 Siri 为你播报 iPhone 通知。</p><h4 id="Siri-响应时长"><a href="#Siri-响应时长" class="headerlink" title="Siri 响应时长"></a>Siri 响应时长</h4><p>调整 Siri 从你说完话后到响应你请求之间的停顿时长。</p><h4 id="Siri-支持开启或关闭自动接听通话功能"><a href="#Siri-支持开启或关闭自动接听通话功能" class="headerlink" title="Siri 支持开启或关闭自动接听通话功能"></a>Siri 支持开启或关闭自动接听通话功能</h4><p>你可以通过 Siri 开启或关闭电话和 FaceTime 通话的自动接听功能。</p><h2 id="更多精彩功能"><a href="#更多精彩功能" class="headerlink" title="更多精彩功能"></a>更多精彩功能</h2><h3 id="轻-App"><a href="#轻-App" class="headerlink" title="轻 App"></a>轻 App</h3><h4 id="文件大小上限提高"><a href="#文件大小上限提高" class="headerlink" title="文件大小上限提高"></a>文件大小上限提高</h4><p>文件大小上限提高 50%，让你能查找并下载更令人沉浸的轻 App。</p><h4 id="支持实时活动"><a href="#支持实时活动" class="headerlink" title="支持实时活动"></a>支持实时活动</h4><p>你可以在轻 App 中使用实时活动功能</p><h4 id="“聚焦”功能和“Siri-建议”小组件中可提供精确位置建议"><a href="#“聚焦”功能和“Siri-建议”小组件中可提供精确位置建议" class="headerlink" title="“聚焦”功能和“Siri 建议”小组件中可提供精确位置建议"></a>“聚焦”功能和“Siri 建议”小组件中可提供精确位置建议</h4><p>“聚焦”功能和“Siri 建议”小组件中可提供更精确的位置信息，便于你查看附近的轻 App 推荐。</p><h3 id="图书"><a href="#图书" class="headerlink" title="图书"></a>图书</h3><h4 id="自定阅读体验"><a href="#自定阅读体验" class="headerlink" title="自定阅读体验"></a>自定阅读体验</h4><p>新的阅读器中包含多个选项，可让你按需自定属于自己的阅读体验。你可根据不同环境和心情选择阅读主题，或更改字体、间距、文字大小等设置。</p><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><h4 id="人像照片前景虚化"><a href="#人像照片前景虚化" class="headerlink" title="人像照片前景虚化"></a>人像照片前景虚化</h4><p>使用人像模式拍照时，可虚化照片前景中的物体，带来更真实的景深效果。</p><h4 id="电影效果模式视频拍摄画质提升"><a href="#电影效果模式视频拍摄画质提升" class="headerlink" title="电影效果模式视频拍摄画质提升"></a>电影效果模式视频拍摄画质提升</h4><p>在 iPhone 13 和 iPhone 13 Pro 上以电影效果模式拍摄视频时，人物的轮廓棱角及其头发、眼镜周围所呈现的景深效果，显得更为精细了。</p><h3 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h3><h4 id="信息和通话状态"><a href="#信息和通话状态" class="headerlink" title="信息和通话状态"></a>信息和通话状态</h4><p>来自亲朋好友的未读信息、未接 FaceTime 通话和来电，直接在主屏幕上就能查看。</p><h3 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h3><h4 id="新的词典"><a href="#新的词典" class="headerlink" title="新的词典"></a>新的词典</h4><p>新增五个双语词典：孟加拉语 – 英语、捷克语 – 英语、芬兰语 – 英语、匈牙利语 – 英语、土耳其语 – 英语。</p><h3 id="FaceTime-通话"><a href="#FaceTime-通话" class="headerlink" title="FaceTime 通话"></a>FaceTime 通话</h3><h4 id="FaceTime-通话中的接力功能"><a href="#FaceTime-通话中的接力功能" class="headerlink" title="FaceTime 通话中的接力功能"></a>FaceTime 通话中的接力功能</h4><p>你可将 FaceTime 通话从 iPhone 顺畅地转移到 iPad 或 Mac 上，反过来操作也没问题。你已连接的蓝牙耳机也会同时切换到新设备上。</p><h4 id="发现支持同播共享的-App"><a href="#发现支持同播共享的-App" class="headerlink" title="发现支持同播共享的 App"></a>发现支持同播共享的 App</h4><p>你可在 FaceTime 通话控制选项中查看哪些已安装的 app 支持同播共享功能，并打开它们；你也可以通过浏览 App Store 来探索更多新体验，并分享给朋友。</p><h4 id="协作功能"><a href="#协作功能" class="headerlink" title="协作功能"></a>协作功能</h4><p>进行 FaceTime 通话时轻点“共享“按钮，即可在“文件”、Keynote 讲演、Numbers 表格、Pages 文稿、“备忘录”、“提醒事项”、Safari 浏览器以及支持的第三方 app 中展开协作。</p><h3 id="今年稍晚推出一款新的"><a href="#今年稍晚推出一款新的" class="headerlink" title="今年稍晚推出一款新的"></a>今年稍晚推出一款新的</h3><p>效率类 App</p><h4 id="灵活多用的画板"><a href="#灵活多用的画板" class="headerlink" title="灵活多用的画板"></a>灵活多用的画板</h4><p>这款 app 的画板非常适合用来绘制新项目草图、汇总重要素材，或进行创意讨论。有了这块不设限的画板，你可以尽情发挥创意。</p><h4 id="随处都可画"><a href="#随处都可画" class="headerlink" title="随处都可画"></a>随处都可画</h4><p>这款 app 让你即使身在途中，也可自在享用出色的白板功能。你可以在画板上随处书写、作画，还能根据需要选择并移动文字或图画。</p><h4 id="制作漂亮的图表"><a href="#制作漂亮的图表" class="headerlink" title="制作漂亮的图表"></a>制作漂亮的图表</h4><p>形状图库有 700 多种形状任你选择。你还可更改颜色和尺寸、添加文本，甚至创建和保存你自己的形状。</p><h4 id="各种内容都可添加"><a href="#各种内容都可添加" class="headerlink" title="各种内容都可添加"></a>各种内容都可添加</h4><p>嵌入图片、视频、音频、PDF、文稿和网页链接。你不用离开这块画板，便可以将各种类型的文件添加进来并在其中预览。</p><h3 id="Game-Center"><a href="#Game-Center" class="headerlink" title="Game Center"></a>Game Center</h3><h4 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h4><p>在重新设计的 Game Center 面板和个人资料中，集中一览朋友们的游戏活动和成就。</p><h4 id="同播共享支持"><a href="#同播共享支持" class="headerlink" title="同播共享支持"></a>同播共享支持</h4><p>支持 Gamer Center 多人联机的游戏整合了同播共享功能。与玩伴 FaceTime 通话中，便可以直接一起玩游戏。</p><h4 id="通讯录整合"><a href="#通讯录整合" class="headerlink" title="通讯录整合"></a>通讯录整合</h4><p>通讯录 app 会显示好友的 Gamer Center 个人资料。轻点几下，即可查看他们在玩的游戏和取得的成就。</p><h3 id="iCloud"><a href="#iCloud" class="headerlink" title="iCloud+"></a>iCloud+</h3><h4 id="在-App-中隐藏邮件地址"><a href="#在-App-中隐藏邮件地址" class="headerlink" title="在 App 中隐藏邮件地址"></a>在 App 中隐藏邮件地址</h4><p>隐藏邮件地址功能直接整合进快速输入键盘的建议中，让你能在第三方 app 中保持个人邮件地址的私密性。</p><h3 id="包容性语言"><a href="#包容性语言" class="headerlink" title="包容性语言"></a>包容性语言</h3><h4 id="选择你的称谓"><a href="#选择你的称谓" class="headerlink" title="选择你的称谓"></a>选择你的称谓</h4><p>在使用加拿大法语、欧洲地区法语、意大利语和巴西葡萄牙语时，你可以选择自己喜欢的称谓，让你的设备更具个性。在“语言与地区”设置中，你可以选择让整个系统以何方式称呼你：女性、男性或中性。</p><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><h4 id="新增双拼布局"><a href="#新增双拼布局" class="headerlink" title="新增双拼布局"></a>新增双拼布局</h4><p>现为双拼用户推出一款名为“常用”的新布局。</p><h4 id="繁体中文快速输入"><a href="#繁体中文快速输入" class="headerlink" title="繁体中文快速输入"></a>繁体中文快速输入</h4><p>使用拼音输入繁体中文现支持快速输入。</p><h4 id="粤语输入"><a href="#粤语输入" class="headerlink" title="粤语输入"></a>粤语输入</h4><p>用户现在可以使用粤拼等拼音方法输入粤语字词和短语。</p><h4 id="四川话方言支持"><a href="#四川话方言支持" class="headerlink" title="四川话方言支持"></a>四川话方言支持</h4><p>使用简体中文拼音键盘，可以更轻松地输入四川话字词和短语。</p><h4 id="支持自动纠正的新增语言"><a href="#支持自动纠正的新增语言" class="headerlink" title="支持自动纠正的新增语言"></a>支持自动纠正的新增语言</h4><p>支持自动纠正功能的语言新增三种：英语 (新西兰)、英语 (南非) 和哈萨克语。</p><h4 id="支持表情符号搜索的新增语言"><a href="#支持表情符号搜索的新增语言" class="headerlink" title="支持表情符号搜索的新增语言"></a>支持表情符号搜索的新增语言</h4><p>支持表情符号搜索的语言新增 19 种：阿尔巴尼亚语、亚美尼亚语、阿塞拜疆语、孟加拉语、缅甸语、爱沙尼亚语、菲律宾语、格鲁吉亚语、冰岛语、高棉语、老挝语、拉脱维亚语、立陶宛语、马拉地语、蒙古语、旁遮普语、泰米尔语、 乌尔都语和乌兹别克语 (拉丁字母)。</p><h4 id="可选键盘布局的新增语言"><a href="#可选键盘布局的新增语言" class="headerlink" title="可选键盘布局的新增语言"></a>可选键盘布局的新增语言</h4><p>阿帕奇语、宗卡语、萨摩亚语和意第绪语的用户现在可选择键盘布局。</p><h4 id="键盘触感反馈"><a href="#键盘触感反馈" class="headerlink" title="键盘触感反馈"></a>键盘触感反馈</h4><p>开启键盘触感反馈，可以让打字的手感清晰明确。</p><h3 id="拟我表情"><a href="#拟我表情" class="headerlink" title="拟我表情"></a>拟我表情</h3><h4 id="更多贴纸造型"><a href="#更多贴纸造型" class="headerlink" title="更多贴纸造型"></a>更多贴纸造型</h4><p>拟我表情贴纸自带六种富有表现力的新造型。</p><h4 id="联系人贴纸"><a href="#联系人贴纸" class="headerlink" title="联系人贴纸"></a>联系人贴纸</h4><p>所有拟我表情贴纸都可用作联系人图片，联系人贴纸还有三种全新造型可供选择。</p><h4 id="更多发型"><a href="#更多发型" class="headerlink" title="更多发型"></a>更多发型</h4><p>17 款新增和经过更新的发型可供选择，包括全新的卷发造型、经过更新的紧曲发型、非洲三股辫和拳击手辫。</p><h4 id="更多头饰"><a href="#更多头饰" class="headerlink" title="更多头饰"></a>更多头饰</h4><p>配上一顶帽子，让你的拟我表情更有型。</p><h4 id="更多鼻型"><a href="#更多鼻型" class="headerlink" title="更多鼻型"></a>更多鼻型</h4><p>自定义你的拟我表情时，有更多鼻型选项可供选择。</p><h4 id="更中性的唇色"><a href="#更中性的唇色" class="headerlink" title="更中性的唇色"></a>更中性的唇色</h4><p>使用更多选项自定义你的拟我表情，打造中性唇色。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><h4 id="追随你喜爱的音乐"><a href="#追随你喜爱的音乐" class="headerlink" title="追随你喜爱的音乐"></a>追随你喜爱的音乐</h4><p>有了全新的音乐通知和优化的推荐功能，你可以及时了解自己最关注的艺人的最新动向。</p><h3 id="音乐识别"><a href="#音乐识别" class="headerlink" title="音乐识别"></a>音乐识别</h3><h4 id="历史记录同步"><a href="#历史记录同步" class="headerlink" title="历史记录同步"></a>历史记录同步</h4><p>用控制中心的音乐识别功能识别的歌曲，可与 Shazam app 同步。</p><h4 id="嘿-Siri，这是什么歌？"><a href="#嘿-Siri，这是什么歌？" class="headerlink" title="嘿 Siri，这是什么歌？"></a>嘿 Siri，这是什么歌？</h4><p>用 Siri 识别的歌曲，可与 Shazam app 以及控制中心的音乐识别功能同步。</p><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><h4 id="iPhone-上的快速备忘录"><a href="#iPhone-上的快速备忘录" class="headerlink" title="iPhone 上的快速备忘录"></a>iPhone 上的快速备忘录</h4><p>通过 共享 菜单，可在 iPhone 的任何一款 app 中创建快速备忘录。</p><h4 id="优化的智能文件夹"><a href="#优化的智能文件夹" class="headerlink" title="优化的智能文件夹"></a>优化的智能文件夹</h4><p>基于功能强大的全新过滤条件，可自动整理智能文件夹中的备忘录。还可制定规则，用于创建日期、修改日期、共享、提及、核对清单、附件、文件夹、快速备忘录、置顶备忘录和锁定备忘录等事项。</p><h4 id="使用密码锁定"><a href="#使用密码锁定" class="headerlink" title="使用密码锁定"></a>使用密码锁定</h4><p>使用 iPhone 密码对锁定的备忘录进行端到端加密。</p><h4 id="按日期分组的备忘录"><a href="#按日期分组的备忘录" class="headerlink" title="按日期分组的备忘录"></a>按日期分组的备忘录</h4><p>备忘录按“今天”、“昨天”等时间类别进行分组，方便你在列表和图库视图中查看。</p><h4 id="通过链接进行协作"><a href="#通过链接进行协作" class="headerlink" title="通过链接进行协作"></a>通过链接进行协作</h4><p>允许具有链接的任何人共享备忘录。</p><h4 id="按任意或所有条件过滤"><a href="#按任意或所有条件过滤" class="headerlink" title="按任意或所有条件过滤"></a>按任意或所有条件过滤</h4><p>选择是否在“智能文件夹”或“标签浏览器”中按任意或所有条件过滤。</p><h3 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h3><h4 id="重复照片检测"><a href="#重复照片检测" class="headerlink" title="重复照片检测"></a>重复照片检测</h4><p>照片 app 能够识别“相簿 &gt;更多项目”中的重复照片，便于你快速清理图库。</p><h4 id="锁定“已隐藏”和“最近删除”相簿"><a href="#锁定“已隐藏”和“最近删除”相簿" class="headerlink" title="锁定“已隐藏”和“最近删除”相簿"></a>锁定“已隐藏”和“最近删除”相簿</h4><p>默认情况下，“已隐藏”和“最近删除”相簿已锁定，你可以用以下 iPhone 身份验证方式解除锁定：面容 ID、触控 ID 或你的密码。</p><h4 id="拷贝和粘贴编辑内容"><a href="#拷贝和粘贴编辑内容" class="headerlink" title="拷贝和粘贴编辑内容"></a>拷贝和粘贴编辑内容</h4><p>你在某张照片上所做的编辑，可以拷贝并粘贴到另一张或一批照片上。</p><h4 id="按字母顺序为人物排序"><a href="#按字母顺序为人物排序" class="headerlink" title="按字母顺序为人物排序"></a>按字母顺序为人物排序</h4><p>你可以按字母顺序对“人物”相簿进行排序。</p><h4 id="撤销和重做编辑步骤"><a href="#撤销和重做编辑步骤" class="headerlink" title="撤销和重做编辑步骤"></a>撤销和重做编辑步骤</h4><p>撤销和重做在照片中的多个编辑步骤。</p><h4 id="轻点即可重播“回忆”中的视频"><a href="#轻点即可重播“回忆”中的视频" class="headerlink" title="轻点即可重播“回忆”中的视频"></a>轻点即可重播“回忆”中的视频</h4><p>播放“回忆”中的视频时，轻点即可重新开始，在音乐继续播放的同时从头开始视频播放。</p><h4 id="新的回忆类型"><a href="#新的回忆类型" class="headerlink" title="新的回忆类型"></a>新的回忆类型</h4><p>新增“往年今日”和“儿童玩耍”两种回忆类型。</p><h4 id="关闭精选内容"><a href="#关闭精选内容" class="headerlink" title="关闭精选内容"></a>关闭精选内容</h4><p>停止在照片 app 和“照片”小组件中显示“回忆”和“精选照片”。</p><h3 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h3><h4 id="CarPlay-车载的新资料库"><a href="#CarPlay-车载的新资料库" class="headerlink" title="CarPlay 车载的新资料库"></a>CarPlay 车载的新资料库</h4><p>在 CarPlay 车载中，更快取用资料库的更多内容。你可以更轻松地找到已下载和保存的单集，还能看到在追的节目有哪些更新。</p><h3 id="提醒事项"><a href="#提醒事项" class="headerlink" title="提醒事项"></a>提醒事项</h3><h4 id="置顶列表"><a href="#置顶列表" class="headerlink" title="置顶列表"></a>置顶列表</h4><p>可将常用列表置顶，以便快速访问。</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>将列表保存为模板，以便重复用于日常事务、行李清单以及更多事项。创建链接以发布模板并与其他人分享，或下载其他人分享的模板。</p><h4 id="“已完成”智能列表"><a href="#“已完成”智能列表" class="headerlink" title="“已完成”智能列表"></a>“已完成”智能列表</h4><p>在同一个位置查看所有已完成的提醒事项，以及它们的完成时间等详情。</p><h4 id="优化的“已计划”和“今天”列表"><a href="#优化的“已计划”和“今天”列表" class="headerlink" title="优化的“已计划”和“今天”列表"></a>优化的“已计划”和“今天”列表</h4><p>基于时间和日期的分组，便于你更轻松地查看和添加提醒事项。“今天”列表按照“上午”、“下午”和“晚上”进行分组，帮你划分全天的时间。“已计划”列表新增了按周和按月分组，有助于进行更长期的组织规划。</p><h4 id="优化的列表分组"><a href="#优化的列表分组" class="headerlink" title="优化的列表分组"></a>优化的列表分组</h4><p>可轻点某个分组，以组合视图查看其包含的列表和提醒事项。</p><h4 id="共享列表中的通知"><a href="#共享列表中的通知" class="headerlink" title="共享列表中的通知"></a>共享列表中的通知</h4><p>当你的共享列表中有任务添加或完成时，你会收到相关通知。</p><h4 id="更丰富的备注"><a href="#更丰富的备注" class="headerlink" title="更丰富的备注"></a>更丰富的备注</h4><p>为提醒事项添加备注时，可创建项目符号，添加下划线、删除线，或加粗字体。</p><h4 id="按任意或所有条件过滤-1"><a href="#按任意或所有条件过滤-1" class="headerlink" title="按任意或所有条件过滤"></a>按任意或所有条件过滤</h4><p>选择是否在“自定智能列表”或“标签浏览器”中按任意或所有条件过滤。</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><h4 id="AirPods-设置"><a href="#AirPods-设置" class="headerlink" title="AirPods 设置"></a>AirPods 设置</h4><p>在同一界面取用和自定 AirPods 的功能与设置。连接至 AirPods 时，“设置”的顶部会出现 AirPods 菜单。</p><h4 id="编辑“已知网络”"><a href="#编辑“已知网络”" class="headerlink" title="编辑“已知网络”"></a>编辑“已知网络”</h4><p>无线局域网设置中的“已知网络”列表，让你可以删减已知网络，也可快速查看网络信息。</p><h3 id="聚焦"><a href="#聚焦" class="headerlink" title="聚焦"></a>聚焦</h3><h4 id="从主屏幕启动搜索"><a href="#从主屏幕启动搜索" class="headerlink" title="从主屏幕启动搜索"></a>从主屏幕启动搜索</h4><p>直接从主屏幕底部调用聚焦功能来搜索，便可轻松打开各款 app、查找联系人或是从网页上获取信息。</p><h4 id="优化的-Siri-建议"><a href="#优化的-Siri-建议" class="headerlink" title="优化的 Siri 建议"></a>优化的 Siri 建议</h4><p>“最近搜索”让你可以快速回访搜索结果。现在，Siri 建议会考虑你的前情后况，这样你可以加快一些事务的进度，诸如导航到下一场会议或是查看即将起飞的航班状态。</p><h4 id="更多-App-支持图像搜索"><a href="#更多-App-支持图像搜索" class="headerlink" title="更多 App 支持图像搜索"></a>更多 App 支持图像搜索</h4><p>聚焦功能可使用信息、备忘录和文件中的图像信息，并根据位置、人物、场景甚至图像中的事物 (如文本、一只狗或一辆汽车)，来进行搜索。</p><h4 id="快速操作-1"><a href="#快速操作-1" class="headerlink" title="快速操作"></a>快速操作</h4><p>使用“聚焦”快速执行各种操作，包括启动计时器、开启专注模式、用 Shazam 查找歌名、运行任何快捷指令等等。搜索某个 app 的名字即可查看适用于此 app 的快捷指令，你也可使用快捷指令 app 创建自己的快捷指令。</p><h4 id="开启实时活动"><a href="#开启实时活动" class="headerlink" title="开启实时活动"></a>开启实时活动</h4><p>直接从“聚焦”搜索结果开启实时活动功能。</p><h3 id="股市"><a href="#股市" class="headerlink" title="股市"></a>股市</h3><h4 id="收益报告发布日期"><a href="#收益报告发布日期" class="headerlink" title="收益报告发布日期"></a>收益报告发布日期</h4><p>查看某公司即将发布收益报告的日期并将其添加到日历。</p><h4 id="多个关注列表"><a href="#多个关注列表" class="headerlink" title="多个关注列表"></a>多个关注列表</h4><p>创建多个自定义关注列表，整理你追踪的股票行情。使用你选择的任意标准将股票代码分组，如行业、资产类型、所有权状态等。</p><h4 id="小组件新增选项"><a href="#小组件新增选项" class="headerlink" title="小组件新增选项"></a>小组件新增选项</h4><p>在中尺寸和大尺寸的“股市”小组件中使用全新的两栏布局，便于查看更多股票代码。</p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><h4 id="新增语言-1"><a href="#新增语言-1" class="headerlink" title="新增语言"></a>新增语言</h4><p>新的系统语言包括保加利亚语和哈萨克语。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="精选"><a href="#精选" class="headerlink" title="精选"></a>精选</h4><p>你现可根据主题和兴趣访问精选。</p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><h4 id="翻译相机"><a href="#翻译相机" class="headerlink" title="翻译相机"></a>翻译相机</h4><p>使用翻译 app 中的相机来翻译身边的文本。定住取景画面，翻译结果会以重叠的方式呈现于照片中的文本之上，放大可看得更清楚；你还可翻译照片图库中照片上的文本。</p><h4 id="新增语言-2"><a href="#新增语言-2" class="headerlink" title="新增语言"></a>新增语言</h4><p>翻译 app 及系统自带的翻译功能新增了对土耳其语、泰语、越南语、波兰语、印尼语和荷兰语的支持。</p><h3 id="看图查询"><a href="#看图查询" class="headerlink" title="看图查询"></a>看图查询</h3><h4 id="从背景提取主体"><a href="#从背景提取主体" class="headerlink" title="从背景提取主体"></a>从背景提取主体</h4><p>将主体从图像中提取出来，或通过移除背景分离出主体。可用于照片、截屏、快速查看和 Safari 浏览器等 app 或功能。</p><h3 id="天气-1"><a href="#天气-1" class="headerlink" title="天气"></a>天气</h3><h4 id="极端天气通知"><a href="#极端天气通知" class="headerlink" title="极端天气通知"></a>极端天气通知</h4><p>当周边地区发布极端天气警报时，你会收到通知。</p><h4 id="更多天气详情"><a href="#更多天气详情" class="headerlink" title="更多天气详情"></a>更多天气详情</h4><p>轻点天气 app 中的任意模块，即可显示一组更细化的新数据，比如未来 10 天的每小时气温和降水概率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;锁定屏幕&quot;&gt;&lt;a href=&quot;#锁定屏幕&quot; class=&quot;headerlink&quot; title=&quot;锁定屏幕&quot;&gt;&lt;/a&gt;锁定屏幕&lt;/h3&gt;&lt;h4 id=&quot;锁定屏幕图库&quot;&gt;&lt;a href=&quot;#锁定屏幕图库&quot; class=&quot;headerlink&quot; title=&quot;锁定屏幕图库&quot;&gt;&lt;/a&gt;锁定屏幕图库&lt;/h4&gt;&lt;p&gt;从包含众多样式的图库中寻找灵感，定制个性化的锁定屏幕，每款都有自己独特的背景、风格化的日期和时间显示方式，以及便于快速查看的信息。&lt;/p&gt;
&lt;h4 id=&quot;切换锁定屏幕&quot;&gt;&lt;a href=&quot;#切换锁定屏幕&quot; class=&quot;headerlink&quot; title=&quot;切换锁定屏幕&quot;&gt;&lt;/a&gt;切换锁定屏幕&lt;/h4&gt;&lt;p&gt;你可以随时切换锁定屏幕。只需按住锁定屏幕，然后手指轻扫即可。&lt;/p&gt;
&lt;h4 id=&quot;编辑锁定屏幕&quot;&gt;&lt;a href=&quot;#编辑锁定屏幕&quot; class=&quot;headerlink&quot; title=&quot;编辑锁定屏幕&quot;&gt;&lt;/a&gt;编辑锁定屏幕&lt;/h4&gt;&lt;p&gt;轻点锁定屏幕上的各项元素，即可轻松自定其字体、颜色或摆放位置。&lt;/p&gt;
&lt;h4 id=&quot;风格化的显示日期和时间&quot;&gt;&lt;a href=&quot;#风格化的显示日期和时间&quot; class=&quot;headerlink&quot; title=&quot;风格化的显示日期和时间&quot;&gt;&lt;/a&gt;风格化的显示日期和时间&lt;/h4&gt;&lt;p&gt;选择充满表现力的字体样式和颜色，自定锁定屏幕上日期和时间的显示外观。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS 16" scheme="https://fanbaoying.github.io/tags/iOS-16/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 43 字符串相乘</title>
    <link href="https://fanbaoying.github.io/LeetCode-43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>https://fanbaoying.github.io/LeetCode-43-字符串相乘/</id>
    <published>2022-09-09T11:14:40.000Z</published>
    <updated>2022-09-09T11:15:39.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 42 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>注意：</strong>不能使用任何内置的 <code>BigInteger</code> 库或直接将输入转换为整数。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li><li><code>num1</code> 和 <code>num2</code> 只能由数字组成。</li><li><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiplyStrings</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">multiply</span><span class="params">(<span class="number">_</span> num1: String, <span class="number">_</span> num2: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> num1 = num1.reversed(), num2 = num2.reversed()</span><br><span class="line">        <span class="keyword">var</span> res = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: num1.<span class="built_in">count</span> + num2.<span class="built_in">count</span>), resStr = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// calculate product for every digit</span></span><br><span class="line">        <span class="keyword">for</span> (i, char1) <span class="keyword">in</span> num1.enumerated() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> digit1 = <span class="type">Int</span>(<span class="type">String</span>(char1)) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fatalError</span>(<span class="string">"Invalid Input num1"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (j, char2) <span class="keyword">in</span> num2.enumerated() &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> digit2 = <span class="type">Int</span>(<span class="type">String</span>(char2)) <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">fatalError</span>(<span class="string">"Invalid Input num2"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                res[i + j] += digit1 * digit2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// update digits</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;res.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> num = res[i]</span><br><span class="line">            </span><br><span class="line">            res[i] = num % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; res.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">                res[i + <span class="number">1</span>] += num / <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            resStr = <span class="string">"<span class="subst">\(res[i])</span>"</span> + resStr</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// trim starting 0s</span></span><br><span class="line">        <span class="keyword">while</span> !resStr.isEmpty &amp;&amp; resStr.first! == <span class="string">"0"</span> &#123;</span><br><span class="line">            resStr.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resStr.isEmpty ? <span class="string">"0"</span> : resStr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：反向两个字符串，并使用嵌套循环将它们与每一位数字相乘，然后使用求和和进位的思想得到最终结果。</li><li>时间复杂度： O(nm)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/multiply-strings/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 42 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十二期/</id>
    <published>2022-08-29T03:29:50.000Z</published>
    <updated>2022-08-29T03:31:19.979Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/SwiftCommunityRes/image/blob/main/weekly/SwiftBanner.png?raw=true" alt=""></p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第三期</strong>，每个模块还在调整磨合期。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>夏夜恬静月色柔，绵绵思绪埋心头，<strong>Swift社区</strong>常逗留，今夕明朝百事欧。欧拉欧拉👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果曝出严重安全漏洞！黑客或可完全接管设备</p><p>提案：改进指针系列初始化和缓冲区</p><p>Swift 论坛：使用 Swift 5.5 / Xcode 14 构建后崩溃</p><p>推荐博文：iOS16 引入 SwiftUI Charts</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果曝出严重安全漏洞！黑客或可完全接管设备"><a href="#苹果曝出严重安全漏洞！黑客或可完全接管设备" class="headerlink" title="苹果曝出严重安全漏洞！黑客或可完全接管设备"></a>苹果曝出严重安全漏洞！黑客或可完全接管设备</h3><p>当地时间 8 月 19 日（周五），苹果公司（Apple）呼吁用户立刻下载最新更新。就在两天前，该公司报告了一个重大的安全漏洞，据称可以让黑客接管苹果设备。<br>在周三发布的安全更新中，苹果表示该漏洞可能已被用于攻击行为。</p><p>“这就是我们所说的零日漏洞，也就是在公司发现并能够做出回应之前，已经被黑客所使用过的漏洞，” 美国麦迪安网络安全公司（Mandiant）的高级威胁情报顾问杰米·科利尔（Jamie Collier）介绍道。</p><p>据介绍，受本次漏洞影响的设备涵盖了几乎所有的苹果产品。其中，手机包括 iPhone 6S 及以后的型号；平板包括第五代及以后的 iPad，所有 iPad Pro，以及 iPad Air 2；电脑则是运行 MacOS Monterey 的 Mac。此外，该漏洞还能影响到部分型号的 iPod。@看看新闻</p><h3 id="App-和-app-内购买项目即将实行税率和价格调整"><a href="#App-和-app-内购买项目即将实行税率和价格调整" class="headerlink" title="App 和 app 内购买项目即将实行税率和价格调整"></a>App 和 app 内购买项目即将实行税率和价格调整</h3><p>2022 年 8 月 19 日的下周开始，加纳和土耳其 App Store 的 App 及 App 内购买项目 (自动续期订阅除外) 的价格将有所提高。加纳的价格提升将包含 <strong>12.5%</strong> 的新增值税和 <strong>6%</strong> 的附加税。</p><p>您的收益将随之进行调整，并会根据不含税的价格来进行计算。《付费 App 协议》的附录 B 已更新，表明 Apple 在加纳征收和汇付适用税款。</p><p>此外，如果您在 App Store Connect. 中选择了适当的税收类别，爱沙尼亚的电子出版物的收益已经进行了调整，以反映增值税从 <strong>9%</strong> 下调至 5%。</p><p>以上调整生效后，在“我的 App”中“价格与销售范围”部分会随即更新。您可以随时在 App Store Connect 中更改您的 App 和 App 内购买项目的价格 (包括自动续期订阅)。如果您有提供订阅项目，您可以选择为现有订阅者保留当前价格。</p><p>苹果发言人没有立即透露这个电池百分比调整是否会延续到 iOS 16 的最终版本。这次更新目前只出现在开发者版和公测版。新 iOS 系统将于今年秋天发布，可能是在 9 月份，届时苹果预计将发布 <strong>iPhone 14</strong>。@凤凰网科技</p><h3 id="苹果-AppleOne-将捆绑销售电话套餐：英国运营商EE是第一家"><a href="#苹果-AppleOne-将捆绑销售电话套餐：英国运营商EE是第一家" class="headerlink" title="苹果 AppleOne 将捆绑销售电话套餐：英国运营商EE是第一家"></a>苹果 AppleOne 将捆绑销售电话套餐：英国运营商EE是第一家</h3><p>英国运营商 EE 近日宣布，它将成为第一家将苹果 Apple One 与电话套餐捆绑在一起的运营商。EE表示，苹果 Apple One 将从 8 月 31 日起包含在其 Full Works 计划中。该计划将包括 Apple One 的个人版订阅，每月费用为 14.95 英镑（约 122.44 元人民币）。</p><p>苹果 Apple One 订阅包将最多六项苹果服务捆绑到一个订阅中，个人版单独订阅价格为每月 14.95 美元（约 101.51 元人民币），包括四项苹果服务：50GB 的 iCloud+、Apple Music、Apple TV+ 和 Apple Arcade 订阅。</p><p>iPhone13 系列成美国最畅销手机机型# 2022 年 Q2 美国最畅销的 10 款智能手机机型，包括苹果、三星、联想三个品牌。其中，苹果 iPhone 13、iPhone 13 Pro Max、iPhone 13 Pro 包揽前三位。三星 Galaxy S21、Galaxy S22 / Ultra 等 5 款新机进入畅销榜前十，Galaxy S22 Ultra 5G 为 2022 年 Q2 美国最畅销的安卓机型。(来源：(来源： 极目新闻))</p><h3 id="赔偿-2-亿元！苹果因搜包耽误员工下班，遭-1-万多人集体起诉"><a href="#赔偿-2-亿元！苹果因搜包耽误员工下班，遭-1-万多人集体起诉" class="headerlink" title="赔偿 2 亿元！苹果因搜包耽误员工下班，遭 1 万多人集体起诉"></a>赔偿 2 亿元！苹果因搜包耽误员工下班，遭 1 万多人集体起诉</h3><p>据路透社 8 月 15 日报道消息，当地时间 13 日，美国加州一名法官已经签署了苹果公司的 3050 万美元（约合人民币 2 亿元）的和解协议。该诉讼持续 9 年，诉讼称苹果公司没有为下班时检查员工行李的时间付费。</p><p>起诉源于苹果之前的一项规定，这项规定要求在下班时检查苹果员工的包和个人物品。2013 年，一群苹果公司员工因被迫接受行李检查起诉苹果公司，称公司没有为搜包的时间付费。原告称，苹果零售员工在下班后通常要等几分钟，有时甚至更长时间，才能检查完他们的行李，然后才能离开他们工作的商店。在被提起诉讼后，苹果不再对员工下班前进行搜包检查。</p><p>据纽约邮报 2015 年 6 月的报道，公布的一份法庭文件显示，至少有两名苹果零售店员工直接向首席执行官库克投诉，称该公司将检查零售员工行李作为安全预防措施的规定令人尴尬和有辱人格。</p><p>集体诉讼于 2015 年被驳回，随后他们决定上诉。州法院在 2020 年对苹果作出裁决，称期望员工不带个人物品上班是不切实际的。联邦法院随后恢复了此案，美国地方法院法官威廉·阿尔苏普去年表示，他计划对原告作出简易判决，并下令对损害赔偿进行审判。</p><p>8 月 13 日，阿尔苏普在集体诉讼中批准了和解协议。这标志着该州历史上最大的安全搜查案和解。3050 万美元的和解金将支付给包括居住在加州的 14683 名苹果员工在内的一个群体，平均每位员工获得 1328 美元赔偿金。(来源：极目新闻)</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0367-conditional-attributes.md" title="SE-0367" target="_blank" rel="noopener">SE-0367</a> <strong>优化新属性的条件编译</strong> 提案已通过。该提案已在上期周报正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0371-isolated-synchronous-deinit.md" title="SE-0371" target="_blank" rel="noopener">SE-0371</a> <strong>Isolated synchronous deinit</strong> 提案正在审查。</p><p>此功能允许 <code>deinit</code> 中 <code>actor</code> 和 <code>global-actor</code> 的 <code>isolated</code> 类型 (GAIT)， 访问 <code>non-sendable</code> 的 <code>isolated</code> 状态，从而解除 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0327-actor-initializers.md" title="SE-0327" target="_blank" rel="noopener">SE-0327</a> 施加的限制。这是通过在 <code>__deallocating_deinit()</code> 中实现，为跳转到执行程序提供运行时支持。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0370-pointer-family-initialization-improvements.md" title="SE-0370" target="_blank" rel="noopener">SE-0370</a> <strong>改进指针系列初始化和缓冲区</strong> 提案正在审查。</p><p><code>UnsafeMutablePointer</code> 系列中的类型通常需要手动管理内存分配，包括管理其初始化状态。但是，并非该系列中的每个相关类型都具有一定的功能来管理内存的初始化状态。分配后涉及的状态如下：</p><ol><li>没有绑定和没有初始化（从 <code>UnsafeMutableRawPointer.allocate()</code> 返回）</li><li>绑定到类型，没有未初始化（从 <code>UnsafeMutablePointer&lt;T&gt;.allocate()</code> 返回）</li><li>绑定到类型，并初始化</li></ol><p>只要内存未初始化，就可以安全地释放内存。</p><p>我们打算完善该系列中每个相关成员的初始化功能：<code>UnsafeMutablePointer</code>、<code>UnsafeMutableRawPointer</code>、<code>UnsafeMutableBufferPointer</code>、<code>UnsafeMutableRawBufferPointer</code>、<code>Slice&lt;UnsafeMutableBufferPointer&gt;</code> 和 <code>Slice&lt;UnsafeMutableRawBufferPointer&gt;</code>。该功能将允许在更多种类的情况下管理初始化状态，包括更轻松地处理部分初始化的缓冲区。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0365-implicit-self-weak-capture.md" title="SE-0365" target="_blank" rel="noopener">SE-0365</a> <strong>增加对协议 CustomDebugStringConvertible 到 AnyKeyPath 的一致性</strong> 提案正在审查。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 围绕 <a href="https://forums.swift.org/t/pitch-async-buffered-channel/59854" title="Async buffered channel" target="_blank" rel="noopener">提议 Async buffered channel</a> 进行的讨论</p><p>内容概括：创建一个总集 channel 可以在 Tasks 之间交流，主要用于一个 task 产生的 value 可以被另一个 task 使用。</p><p>2) <a href="https://forums.swift.org/t/new-crash-after-building-with-swift-5-5-xcode-14/59798" title="使用 Swift 5.5 / Xcode 14 构建后崩溃" target="_blank" rel="noopener">新问题：使用 Swift 5.5 / Xcode 14 构建后崩溃</a></p><p>内容概括：swift 代码使用地址引用传入 NSMutableArray 类型给 Objective-C，Objective-C会返回 Array 的地址给 Swift 代码，当 iteration loop 返回的 array 时发生崩溃。可能原因：Swift ARC 内存优化释放指针引起的崩溃。</p><p>3) <a href="https://forums.swift.org/t/a-new-swift-parser-for-swiftsyntax/59813" title="用于 SwiftSyntax 的新 Swift 解析器" target="_blank" rel="noopener">用于 SwiftSyntax 的新 Swift 解析器</a></p><p>内容概括：SwiftSyntax 是一个 Swift Package，它可以解析 Swift 代码成一个树状的语义，可以对树进行操控也可以将树状的语义变回 Swift 代码。目前 SwiftSyntaxParser 是一个基于 C++ 库并且 Swift compiler 非常依赖于 C++ 库。<br>项目目标：完全取代 Swift parser 对 C++ 库的依赖</p><p>4) 围绕 <a href="https://forums.swift.org/t/pitch-pointer-family-initialization-improvements-better-buffer-slices/55689" target="_blank" rel="noopener">SE-0370 pointer family initialization improvements and better buffer slice</a> 展开的讨论</p><p>5) <a href="https://forums.swift.org/t/pitch-document-sorting-as-stable/59880" title="提议：标准库的稳定排序" target="_blank" rel="noopener">提议：标准库的稳定排序</a></p><p>稳定排序是：在比较相同元素的情况下保持输入的顺序：例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roster = [</span><br><span class="line">   <span class="type">Player</span>(first: <span class="string">"Sam"</span>, last: <span class="string">"Coffey"</span>),</span><br><span class="line">   <span class="type">Player</span>(first: <span class="string">"Ashley"</span>, last: <span class="string">"Hatch"</span>),</span><br><span class="line">   <span class="type">Player</span>(first: <span class="string">"Kristie"</span>, last: <span class="string">"Mewis"</span>),</span><br><span class="line">   <span class="type">Player</span>(first: <span class="string">"Ashley"</span>, last: <span class="string">"Sanchez"</span>),</span><br><span class="line">   <span class="type">Player</span>(first: <span class="string">"Sophia"</span>, last: <span class="string">"Smith"</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">roster.<span class="built_in">sort</span>(by: &#123; $<span class="number">0</span>.first &lt; $<span class="number">1</span>.first &#125;)</span><br><span class="line"><span class="comment">// roster == [</span></span><br><span class="line"><span class="comment">//    Player(first: "Ashley", last: "Hatch"),</span></span><br><span class="line"><span class="comment">//    Player(first: "Ashley", last: "Sanchez"),</span></span><br><span class="line"><span class="comment">//    Player(first: "Kristie", last: "Mewis"),</span></span><br><span class="line"><span class="comment">//    Player(first: "Sam", last: "Coffey"),</span></span><br><span class="line"><span class="comment">//    Player(first: "Sophia", last: "Smith"),</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>从例子中看出有两个一样的 first: “Ashley”, 由于输入 “Hatch” 在 “Sanchez” 之前, 稳定排序之后顺序不变。</p><p>6) <a href="https://www.reddit.com/r/swift/comments/wwgblk/best_way_to_run_a_function_only_once_while/" title="访问变量时只运行一次函数的最佳方法" target="_blank" rel="noopener">访问变量时只运行一次函数的最佳方法</a></p><p>7) <a href="https://www.reddit.com/r/swift/comments/wvpxmn/what_is_the_best_way_to_make_sure_a_nested/" title="确保 viewDidLoad 中的嵌套闭包在函数运行之前完成的最佳方法" target="_blank" rel="noopener">确保 viewDidLoad 中的嵌套闭包在函数运行之前完成的最佳方法</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swdevnotes.com/swift/2022/create-a-line-chart-with-swiftui-charts-in-ios-16/" title="在 iOS 16 中使用 SwiftUI Charts 创建折线图" target="_blank" rel="noopener">在 iOS 16 中使用 SwiftUI Charts 创建折线图</a></p><p><strong>摘要：</strong> Apple 在 <code>WWWDC 2022</code> 上推出了 <code>SwiftUI Charts</code>，在 <code>SwiftUI</code> 视图中实现图表功能变得非常容易。如下图：</p><p><img src="https://files.mdnice.com/user/17787/67441474-df56-42c8-8ce4-ec4e3a1f1a25.png" alt=""></p><p><a href="https://swdevnotes.com/swift/2022/customise-a-line-chart-with-swiftui-charts-in-ios-16/" title="在 iOS 16 中使用 SwiftUI Charts 自定义折线图" target="_blank" rel="noopener">在 iOS 16 中使用 SwiftUI Charts 自定义折线图</a></p><p><strong>摘要：</strong> iOS 16 中引入的 SwiftUI Charts，可以快速的实现各种统计图，通过图表直观的呈现数据。本文介绍了几种自定义的折线统计图。</p><p><a href="https://swdevnotes.com/swift/2021/how-to-create-bar-chart-swiftui/" title="如何在 SwiftUI 中创建条形图" target="_blank" rel="noopener">如何在 SwiftUI 中创建条形图</a></p><p><strong>摘要：</strong> 本文展示了如何创建一个垂直条形图，其中 Y 轴表示每个类型的值。如下图：</p><p><img src="https://files.mdnice.com/user/17787/369e7b63-cf7c-40bc-816d-d33e2bb6d137.png" alt=""></p><p><a href="https://swdevnotes.com/swift/2021/horizontal-bar-chart-in-swiftui/" title="货拉拉 iOS 司机端线程治理总结" target="_blank" rel="noopener">如何在 SwiftUI 中创建水平条形图</a></p><p><strong>摘要：</strong> 根据 UI 设计以及交互需求，有时候统计图需要调整 X 和 Y 轴。本文主要介绍了如何创建水平的条形图，如下图：</p><p><img src="https://files.mdnice.com/user/17787/190c7254-5ee2-4f01-a298-4594d21acfb3.gif" alt=""></p><p><a href="https://github.com/SwiftCommunityRes/article-ios/blob/main/resource/%E4%BD%BF%E7%94%A8%20SwiftUI%20%E7%9A%84%20Eager%20Grids.md" title="使用 SwiftUI 的 Eager Grids" target="_blank" rel="noopener">使用 SwiftUI 的 Eager Grids</a></p><p><strong>摘要：</strong> 本篇文章主要讲解如何使用 <code>Eager Grids</code> 绘制网格视图，其中讲解了十几种网格的实现方法，并详细介绍了网格的实现原理。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/SwiftCommunityRes/image/blob/main/weekly/SwiftBanner.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第三期&lt;/strong&gt;，每个模块还在调整磨合期。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;夏夜恬静月色柔，绵绵思绪埋心头，&lt;strong&gt;Swift社区&lt;/strong&gt;常逗留，今夕明朝百事欧。欧拉欧拉👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果曝出严重安全漏洞！黑客或可完全接管设备&lt;/p&gt;
&lt;p&gt;提案：改进指针系列初始化和缓冲区&lt;/p&gt;
&lt;p&gt;Swift 论坛：使用 Swift 5.5 / Xcode 14 构建后崩溃&lt;/p&gt;
&lt;p&gt;推荐博文：iOS16 引入 SwiftUI Charts&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第十一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5%E7%AC%AC%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报第十一期/</id>
    <published>2022-08-25T03:43:01.000Z</published>
    <updated>2022-08-25T04:14:01.884Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/SwiftCommunityRes/image/blob/main/weekly/SwiftBanner.png?raw=true" alt=""></p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二期</strong>，每个模块还在调整磨合期。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>平凡的八月，不平凡的世界，你若落后，必定挨打，你若前进，方得始终！<strong>Swift社区</strong>，给你最新的指引，给你最真的铠甲！</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：已消失 5 年 iPhone 电量百分比为何现在回归</p><p>提案：和脚本语言相媲美的字符串算法</p><p>Swift 论坛：你是否希望支持在 Windows 上构建 Swift</p><p>推荐博文：Swift社区 成立文章仓库</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="已消失-5-年-iPhone-电量百分比为何现在回归？"><a href="#已消失-5-年-iPhone-电量百分比为何现在回归？" class="headerlink" title="已消失 5 年 iPhone 电量百分比为何现在回归？"></a>已消失 5 年 iPhone 电量百分比为何现在回归？</h3><p>2017年，iPhone X 以后，电量百分比一直隐藏在下拉通知栏，而现在，在最新测试版的 iOS 16系统中，电量百分比以数字形式被写入电池图标内。</p><p><img src="https://github.com/SwiftCommunityRes/image/blob/main/weekly/weekly1101.png?raw=true" alt=""></p><p>如果苹果在下一代 iPhone 上增加一个常亮显示功能，那么这种电池百分比调整也会很有用，因为用户可以在不碰手机的情况下就可查看电池状态。还有传言称，iPhone14 系列将会在 Pro 机型上采用挖孔屏，顶部更大的显示面积或许也是苹果复活百分比显示的原因之一。</p><p>苹果发言人没有立即透露这个电池百分比调整是否会延续到 iOS 16 的最终版本。这次更新目前只出现在开发者版和公测版。新iOS系统将于今年秋天发布，可能是在 9 月份，届时苹果预计将发布iPhone 14。@凤凰网科技</p><h3 id="线上讲座：App-内购买的新功能"><a href="#线上讲座：App-内购买的新功能" class="headerlink" title="线上讲座：App 内购买的新功能"></a>线上讲座：App 内购买的新功能</h3><p>诚挚邀请您参加我们于 2022 年 8 月 18 日(周四)在线举办的“线上讲座：App 内购买的新功能”。 </p><p>建议参会对象：开发人员。</p><p>注册成功并收到活动确认函后方可参会。名额有限，报满即止。<br>设计开发加速器活动注册指南：<br><a href="https://essentials.applesurveys.com/WRQualtricsControlPanel_rel/File.php?F=F_a4rFfRXziNGhoAm" target="_blank" rel="noopener">https://essentials.applesurveys.com/WRQualtricsControlPanel_rel/File.php?F=F_a4rFfRXziNGhoAm</a></p><p>请持续关注 Apple 开发者官网：<a href="https://developer.apple.com/cn/accelerator/" target="_blank" rel="noopener">https://developer.apple.com/cn/accelerator/</a><br>我们会不定期地发布下期活动信息，届时可自行申请，获得批准后即可参加活动。 </p><p>了解如何使您的 App 内购买体验更加完美, 并探索 StoreKit 2 和 App Store Server API 的增强功能和 App Store Server 通知的改进。了解如何利用 App Transaction API 验证 App 的购买，为 StoreKit 模型添加属性，并在交易中保留 App 的 applicationUsername。如果您是服务器端开发人员，我们将向您展示如何充分利用 App Store 服务器通知、检索用户交易历史的其他方法，以及当您的服务器出现故障时如何进行恢复。了解如何迁移到最新的 App Store Server API 并整合 App Store 服务器通知。</p><p>在线活动议程：<br>10:00-10:30 StoreKit 2 的新功能<br>10:30-11:00 App Store 服务器 API 和服务器通知新功能 </p><h3 id="外媒：苹果要供应商从台湾地区向中国大陆供货时严格遵守中方规定"><a href="#外媒：苹果要供应商从台湾地区向中国大陆供货时严格遵守中方规定" class="headerlink" title="外媒：苹果要供应商从台湾地区向中国大陆供货时严格遵守中方规定"></a>外媒：苹果要供应商从台湾地区向中国大陆供货时严格遵守中方规定</h3><p>【环球时报综合报道】在美国众议院议长佩洛西窜访台湾遭谴责之际，美国科技巨头苹果公司已要求其供应商从台湾地区向中国大陆供货时严格遵守中国海关有关规定。截至记者 5 日发稿时，苹果方面尚未就有关报道予以置评。</p><p>《日经亚洲》5 日引述消息人士的说法报道称，苹果公司告诉其供应商，中国海关要求台湾地区生产的元件进入大陆时必须标注产地为“中国台湾”或“中国台北”。苹果公司敦促供应商严肃对待此事，避免因违规导致供货受影响。报道称，苹果公司供应商目前正在为新款iPhone和今秋其他苹果新品的元件供货做准备。消息人士称，如在进口文件、表格中或包装箱上将商品生产地标注为“台湾”，中国海关可能将商品扣留检查，违规商品将被处以 4000 元人民币罚款，或被拒绝通关。</p><h3 id="Apple-Entrepreneur-Camp-已开放申请，欢迎女性、黑人和西班牙裔-拉丁裔创业者参加"><a href="#Apple-Entrepreneur-Camp-已开放申请，欢迎女性、黑人和西班牙裔-拉丁裔创业者参加" class="headerlink" title="Apple Entrepreneur Camp 已开放申请，欢迎女性、黑人和西班牙裔/拉丁裔创业者参加"></a>Apple Entrepreneur Camp 已开放申请，欢迎女性、黑人和西班牙裔/拉丁裔创业者参加</h3><p><img src="https://github.com/SwiftCommunityRes/image/blob/main/weekly/weekly1102.png?raw=true" alt=""></p><p>Apple Entrepreneur Camp 旨在为 App 驱动型组织中的少数群体创业者及开发者提供支持，助力其研发新一代的前沿 App 并开拓全球网络，鼓励这些创业者在技术领域不断探索并取得持续发展。</p><p>三组面向女性、黑人以及西班牙裔及拉丁裔创业者的在线课程将在 2022 年 10 月开展，欢迎选择合适的一组提交申请。课程期间，Apple 工程师将为学员提供编程指导，Apple 高层也将作为导师分享见解、启发灵感。申请截止日期为 2022 年 8 月 24 日。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0365-implicit-self-weak-capture.md" title="SE-0365" target="_blank" rel="noopener">SE-0365</a> <strong>在 <code>self</code> 被解包后，允许为<code>weak self</code>捕获隐式<code>self</code></strong> 提案已通过。</p><p>从 <strong>SE-0269</strong> 开始，当 <code>self</code> 在捕获列表中显式写入时，允许在闭包中使用<strong>隐式 self</strong>。 应该将这种方式支持扩展到 <code>weak self</code> 捕获，并且只要 <code>self</code> 已解包，就允许<strong>隐式 self</strong> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> button: <span class="type">Button</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        button.tapHandler = &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            dismiss()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dismiss</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0362-piecemeal-future-features.md" title="SE-0362" target="_blank" rel="noopener">SE-0362</a> <strong>即将到来的语言改进的逐渐采用</strong> 提案已通过。该提案已在上期周报正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0357-regex-string-processing-algorithms.md" title="SE-0357" target="_blank" rel="noopener">SE-0357</a> <strong>基于正则表达式的字符串算法</strong> 提案已通过。</p><p>与其他比较常用的编程语言或者脚本语言相比，Swift 标准库处理字符串算法的功能明显不足。其中一些功能可以在 <code>NSString</code> 中找到，但是这些基础的功能应该在 Swift 标准库中完善。</p><p><strong>本提案中的建议如下：</strong></p><ol><li>新增加到标准库的正则表达式字符串算法，功能性和实用性要和脚本语言相媲美</li><li>就子序列而言，这些算法与通用 <code>Collection</code> 相同</li><li><code>CustomConsumingRegexComponent</code> 协议允许第三方库提供 <code>industrial-strength</code> 作为正则表达式的可混合组件</li></ol><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0368-staticbigint.md" title="SE-0368" target="_blank" rel="noopener">SE-0368</a> <strong>StaticBigInt</strong> 正在审查</p><p>Swift 源代码中的整数文字可以表示任意大的值。但是符合 <code>ExpressibleByIntegerLiteral</code> 协议的标准库之外的类型，在实际使用过程中受限于使用多大的文字值来构建。</p><p>因为传递给 <code>init(integerLiteral:)</code> 的值必须是标准库支持的类型，因此很难在标准库之外编写新的整数类型。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0367-conditional-attributes.md" title="SE-0367" target="_blank" rel="noopener">SE-0367</a> <strong>优化新属性的条件编译</strong> 正在审查</p><p>随着时间的推移，Swift 引入了一些新的属性来优化性能，提供更多的表达能力和编译检查等功能。但是在现有的源码中增加新属性意味着旧的编译器无法进行编译。</p><p>可以使用条件编译来解决这个问题，但是实现代码冗长很不方便。例如，使用 #if 检查编译器版本确定是否可以使用 <code>@preconcurrency</code> 属性，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> compiler(&gt;=<span class="number">5.6</span>)</span><br><span class="line">@preconcurrency <span class="class"><span class="keyword">protocol</span> <span class="title">P</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>通过上面的代码可以看到，这样实现会有很多重复的代码。另外 <code>Swift 5.6</code> 编译器是第一个包含 <code>@preconcurrency</code> 属性的编译器，但是有可能这个属性在 5.6 以前就被启用，或者在 <code>Swift 5.6</code> 的开发过程中启用，通过判断版本号就会有误差。建议采用下面的代码方式来规避这些问题。代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> hasAttribute(preconcurrency)</span><br><span class="line">@preconcurrency</span><br><span class="line">#endif</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md" title="SE-0366" target="_blank" rel="noopener">SE-0366</a> <strong>代码上下文新增敏感关键字 move</strong> 正在审查</p><p>在代码中使用 <code>move</code> 关键字，可以结束 <code>let</code>、<code>var</code> 或者 <code>consuming</code> 函数参数的生命周期。并通过编译器实时做出判断强制执行此操作。示例代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useX(x) <span class="comment">// do some stuff with local variable x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ends lifetime of x, y's lifetime begins.</span></span><br><span class="line"><span class="keyword">let</span> y = move x <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">useY(y) <span class="comment">// do some stuff with local variable y</span></span><br><span class="line">useX(x) <span class="comment">// error, x's lifetime was ended at [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ends lifetime of y, destroying the current value.</span></span><br><span class="line">move y <span class="comment">// [2]</span></span><br><span class="line">useX(x) <span class="comment">// error, x's lifetime was ended at [1]</span></span><br><span class="line">useY(y) <span class="comment">// error, y's lifetime was ended at [2]</span></span><br></pre></td></tr></table></figure><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) <a href="https://forums.swift.org/t/swift-as-a-cross-platform-language-and-windows-support/12547/9" title="Swift as a cross-platform language and Windows support" target="_blank" rel="noopener">关于支持在 Windows 上构建 Swift 的讨论</a></p><p>2) <a href="https://forums.swift.org/t/how-to-read-uint32-from-a-data/59431" title="How To Read UInt32 from a Data?" target="_blank" rel="noopener">如何从数据中读取 UInt32</a></p><p>3) <a href="https://forums.swift.org/t/any-way-to-show-what-led-to-a-dependency/59512" title="Any way to show what led to a dependency?" target="_blank" rel="noopener">有什么方法可以显示依赖发生的原因</a></p><p>是否有 <code>SPM</code> 命令来显示依赖项是如何产生的？可以显示指定 Swift 包在构建中生成的所有依赖路径。</p><p>4) <a href="https://forums.swift.org/t/how-do-delay-the-response-to-an-async-method/59504" title="How do delay the response to an async method?" target="_blank" rel="noopener">如何延迟对异步方法的响应</a></p><p>有一个网络请求，源码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadRequested</span><span class="params">(<span class="number">_</span> request: DownloadRequest)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Response</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> download = <span class="keyword">try</span> await <span class="keyword">self</span>.download(<span class="keyword">for</span>: request)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">self</span>.transferIdMap[download.transferId] = download.itemId</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> size = <span class="keyword">try</span> <span class="type">Int64</span>(download.dataProvider.size())</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> (download.transferId, size, download.originalFilename, download.dataProvider.mimeType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个网络请求的速率进行限制。当有很多的请求未完成时，希望延迟此方法的执行，并将异步回调返回给方法调用者。维持 <code>async/await</code> 流程。</p><p>5) <a href="https://forums.swift.org/t/use-a-dynamic-library-in-a-swift-package-on-linux/59510" title="Use a dynamic library in a swift package on Linux" target="_blank" rel="noopener">在 Linux 上使用 swift Package 中的动态库</a></p><p>在 Apple 平台上，使用 swift Package 中的动态库非常容易。只需要创建一个 <code>.xcframework</code> 其中包含 <code>.dylib</code> 文件和头文件，并使用 <code>binaryTarget</code> 将其添加到 Package 中。在 Linux 上，没有这么简单的解决方案。</p><p>6) <a href="https://forums.swift.org/t/pitch-swift-tooling-workgroup/59515" title="Swift Tooling Workgroup" target="_blank" rel="noopener">提议成立 Swift Tooling 工作组</a></p><p>目前有许多工具类领域处于无人管理的状态。应该需要有一个小组来监督、推动和指导工作。这些领域包含：<strong>SwiftPM、SourceKit-LSP</strong>、<strong>VSCode 扩展</strong>、<strong>LSP、Swift Format</strong>、<strong>API Breaking Change checker</strong>、<strong>Swiftly</strong>、<strong>Docker 镜像</strong>、<strong>DocC</strong>、<strong>SwiftMarkdown</strong> 等等。</p><p>7) <a href="https://developer.apple.com/forums/thread/711772" title="Call Swift functions from JS" target="_blank" rel="noopener">通过 JS 调用 Swift 方法</a></p><p>8) <a href="https://developer.apple.com/forums/thread/711841" title="NavigationLink" target="_blank" rel="noopener">如何对 NavigationLink 中的 tag 和 selection 进行转换</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(workoutTypes) &#123; workoutType <span class="keyword">in</span></span><br><span class="line">    <span class="type">NavigationLink</span>(</span><br><span class="line">        workoutType.name,</span><br><span class="line">        destination: <span class="type">SessionPagingView</span>(),</span><br><span class="line">        tag: workoutType,</span><br><span class="line">        selection: $workoutManager.selectedWorkout</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 iOS 16中 <code>init(_:destination:tag:selection:)</code> 方法被弃用。Apple 建议在<code>NavigationStack</code> 或者<br><code>NavigationSplitView</code> 的列表中使用 <code>NavigationLink(_:value:)</code>。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://mp.weixin.qq.com/s/U1Uw7Ze9Bsmzx0Of4hh1gw" target="_blank" rel="noopener">Swift 社区文章仓库</a></p><p><strong>摘要：</strong> 给大家推荐一下 Swift社区 的文章仓库，里面整理了公众号中的文章，并进行分类（<strong>Swift 进阶</strong>、<strong>Swift 基础</strong>、<strong>SwiftUI 进阶</strong>、<strong>SwiftUI 基础</strong>、<strong>Tips</strong>、<strong>iOS</strong>、<strong>面试</strong>）。方便大家查找阅读。以后会同步更新维护。</p><p><a href="https://mp.weixin.qq.com/s/exaRmdUnpzSvlJ2BGSODgw" target="_blank" rel="noopener">解决 Flutter 引起的 iOS 内存崩溃问题</a></p><p><strong>摘要：</strong> 业界首发，很多开发者会被这个问题困扰。如果你的 Flutter 版本号小于等于 <code>2.5.3</code> 或大于等于 <code>3.0.5</code>，以下描述的问题将不会发生在你的应用中，但是我相信大部分应用都会命中此区间。</p><p><a href="https://mp.weixin.qq.com/s/3emjAHwr7GDExBiB2cAqWQ" target="_blank" rel="noopener">swift-5.5.1-RELEASE源码编译（Xcode）</a></p><p><strong>摘要：</strong> 使用 ninja 构建 <code>swift-5.2.4-RELEASE</code> 版本，然后通过 vscode 和 <code>lldb</code> 插件来调试 swift 源码。</p><p><a href="https://juejin.cn/post/7129391597967376415" title="货拉拉 iOS 司机端线程治理总结" target="_blank" rel="noopener">货拉拉 iOS 司机端线程治理总结</a></p><p><strong>摘要：</strong> 经常会收到司机反馈手机发烫，耗电，crash等等问题。线程治理专项应运而生，目的就是降低crash，手机发烫，耗电等问题，尽量给原本并不富裕的内存，雪中送炭。</p><p><a href="https://mp.weixin.qq.com/s/0ZHfaTiJXAXrWj5qTunhLg" target="_blank" rel="noopener">使用 Swift Package 插件生成代码</a></p><p><strong>摘要：</strong> 在 Xcode 14 的公告中说明，允许在 Xcode 项目中使用 Swift Package 插件，以及一些架构更改。例如本文的Swift Package 插件生成代码。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/SwiftCommunityRes/image/blob/main/weekly/SwiftBanner.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;周报仓库：&lt;a href=&quot;https://github.com/SwiftCommunityRes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二期&lt;/strong&gt;，每个模块还在调整磨合期。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;平凡的八月，不平凡的世界，你若落后，必定挨打，你若前进，方得始终！&lt;strong&gt;Swift社区&lt;/strong&gt;，给你最新的指引，给你最真的铠甲！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：已消失 5 年 iPhone 电量百分比为何现在回归&lt;/p&gt;
&lt;p&gt;提案：和脚本语言相媲美的字符串算法&lt;/p&gt;
&lt;p&gt;Swift 论坛：你是否希望支持在 Windows 上构建 Swift&lt;/p&gt;
&lt;p&gt;推荐博文：Swift社区 成立文章仓库&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>App Store 已上架项目打开瞬闪问题</title>
    <link href="https://fanbaoying.github.io/App-Store-%E5%B7%B2%E4%B8%8A%E6%9E%B6%E9%A1%B9%E7%9B%AE%E6%89%93%E5%BC%80%E7%9E%AC%E9%97%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://fanbaoying.github.io/App-Store-已上架项目打开瞬闪问题/</id>
    <published>2022-08-25T03:42:47.000Z</published>
    <updated>2022-08-25T04:11:59.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h3><p>用户反馈 iPhone11 iOS14.7 下载安装 App 后，点击图标，App 闪一下就回到了桌面。</p><p>收到问题反馈之后，使用手上测试机测试，iPhone11 iOS15.5 和 iPhone12 iOS15.0 均没有复现问题。</p><p>一时没有找到和用户相同的版本的测试手机，找到一台 iPhone11 iOS13.6 的手机。复现了问题。</p><p>后面使用 iPhone7 iOS13.6 也复现了问题。iPhoneX iOS16.0 没有问题。</p><a id="more"></a><h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><p>问题分析使用的是 iPhone11 iOS13.6 和 iPhone7 iOS13.6 两部手机。</p><p>App 安装版本限制是 iOS13 及以上版本。</p><p><strong>怀疑一：</strong> 是项目中引入的音频动态库版本太老不兼容导致。</p><p>检查之后发现虽然和最新版本差了2个小版本，并且文档中没有更新提示相关兼容性问题。并且项目打包上架，经过了 <code>Validate App</code>。排除怀疑。</p><p><strong>怀疑二：</strong> 系统 Api 在 iOS15.0 以下版本不兼容 。</p><p>如果是系统 Api 不兼容，不管是直接在 App store 下载安装，还是直接编译到手机，都会有问题。实际测试，直接编译到手机没有复现问题。</p><p><strong>怀疑三：</strong> 群友提出可能是因为 Xcode 版本太老导致的问题</p><p>我目前的 Xcode 版本是 13.3.1，最新版本是 13.4.1，只差了一个小版本。</p><p><strong>怀疑四：</strong> 群友提出可能电脑是 M1 芯片导致</p><p>感觉关系不大。</p><h3 id="3-问题调试"><a href="#3-问题调试" class="headerlink" title="3. 问题调试"></a>3. 问题调试</h3><p>根据以上的四个疑问，逐个排查。</p><p>在调试之前，已经清除掉手机上已经存在的 App，并且卸载清除掉所有缓存。</p><p><strong>1. 联机调试</strong></p><p>手机连接电脑，直接编译到手机中。App 正常使用，没有闪退问题</p><p><strong>2. Crashes</strong></p><p>Xcode 中的 Crashes 也没有收到任何崩溃信息。</p><p><strong>3. TestFlight</strong></p><p>通过 TestFlight 的内外部测试，收集闪退的问题。</p><p><strong>4. 升级 Xcode</strong></p><p>申请使用备用电脑，进行 Xcode 升级，项目打包上架。在 Xcode 升级到 13.4.1 后打包上架的项目，闪退的问题消失。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题背景&quot;&gt;&lt;a href=&quot;#1-问题背景&quot; class=&quot;headerlink&quot; title=&quot;1. 问题背景&quot;&gt;&lt;/a&gt;1. 问题背景&lt;/h3&gt;&lt;p&gt;用户反馈 iPhone11 iOS14.7 下载安装 App 后，点击图标，App 闪一下就回到了桌面。&lt;/p&gt;
&lt;p&gt;收到问题反馈之后，使用手上测试机测试，iPhone11 iOS15.5 和 iPhone12 iOS15.0 均没有复现问题。&lt;/p&gt;
&lt;p&gt;一时没有找到和用户相同的版本的测试手机，找到一台 iPhone11 iOS13.6 的手机。复现了问题。&lt;/p&gt;
&lt;p&gt;后面使用 iPhone7 iOS13.6 也复现了问题。iPhoneX iOS16.0 没有问题。&lt;/p&gt;
    
    </summary>
    
      <category term="问题集" scheme="https://fanbaoying.github.io/categories/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="Tips" scheme="https://fanbaoying.github.io/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>使用 Swift Package 插件生成代码</title>
    <link href="https://fanbaoying.github.io/%E4%BD%BF%E7%94%A8-Swift-Package-%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/"/>
    <id>https://fanbaoying.github.io/使用-Swift-Package-插件生成代码/</id>
    <published>2022-08-25T03:42:38.000Z</published>
    <updated>2022-08-25T04:10:42.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不久前，我正在工作中开发一项新服务，该服务由 Swift Package 组成，该 Package 公开了一个类似于<code>Decodable</code>协议，供我们应用程序的其余部分使用。事实上，该协议是从<code>Decodable</code>本身继承下来的，看起来像这样：</p><blockquote><p> Fetchable.swit</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Fetchable</span>: <span class="title">Decodable</span>, <span class="title">Equatable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>新的 package 将采用符合<code>Fetchable</code>的类型来尝试从远程或缓存的JSON数据块中解码它们。</p><p>由于这项服务对应用程序的正确运行至关重要，作为这项工作的一部分，我们希望确保始终存在故障安全（ fail-safe）。因此，我们让该应用程序附带了一个备用的JSON文件，如果远程和缓存的数据解码失败，将使用该文件，来保证程序的正常运行。</p><p><strong>无论如何</strong>，我们需要符合<code>Fetchable</code>的新类型从备用数据中正确解码。然而，有一个问题，有时很难发现备用JSON文件或模型本身是否有任何错误，因为解码错误会在<strong>运行时</strong>发生，并且只有在访问某些屏幕/功能时才会发生。</p><p>为了让我们对我们要发送的代码更有<strong>信心</strong>，我们添加了一些<strong>单元测试</strong>，试图根据我们附带的备用JSON解码符合<code>Fetchable</code>协议的每个模型。这些将使我们在CI上有一个早期指示，表明备用数据或模型中存在错误，如果所有测试都通过，我们将确定，一旦我们发布新服务，它始终具有<strong>故障安全功能</strong>。</p><p>我们<strong>手动</strong>编写了这些测试，但我们很快就意识到这个解决方案是<strong>不可扩展的</strong>，因为随着越来越多的符合<code>Fetchable</code>协议的类型被添加，我们引入了大量的代码复制，并可能有人最终忘记为特定功能编写这些测试。</p><p>我们考虑过自动化该过程，但由于我们的代码库的性质，我们遇到了一些问题，代码库高度模块化，混合了Xcode项目和Swift Package。一些架构决策还意味着我们必须收集大量符号信息，才能获得生成测试的正确类型。</p><h2 id="是什么让我再次关注到它？"><a href="#是什么让我再次关注到它？" class="headerlink" title="是什么让我再次关注到它？"></a>是什么让我再次关注到它？</h2><p>在我忘记了这件事一段时间后，Xcode 14的公告允许在Xcode项目中使用 Swift Package 插件，以及一些架构更改使提取类型信息变得容易得多，这让我有动力再次开始研究这个问题。</p><blockquote><p>请注意，Xcode项目的构建工具插件尚未按照发布说明在Xcode 14 Beta 2中提供，但将在Xcode 14的未来版本中提供。</p><p><img src="https://www.polpiella.dev/assets/posts/code-generation-using-swift-package-plugins/release-notes.png" alt="图片取自 Xcode Beta 2 版的发布说明"></p></blockquote><p>在过去的几周里，我一直在研究如何使用软件包插件生成单元测试，在这篇文章中，我将解释我在向哪个方向尝试以及它涉及了什么。</p><h2 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节</h2><p>我开始了一项任务，即创建一个<a href="https://www.polpiella.dev/an-early-look-at-swift-extensible-build-tools" target="_blank" rel="noopener">构建工具插件</a>，与 Xcode 14 引入的<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md" target="_blank" rel="noopener">命令插件</a>不同，该插件可以任意运行并依赖用户输入，作为Swift软件包构建过程的一部分运行。</p><p>我知道我需要创建一个可执行文件，因为 Build Tool 插件依赖这些来执行操作。这个脚本将完全用 Swift 编写，因为这是我最熟悉的语言，并承担以下职责：</p><ol><li>扫描目标目录并提取所有<code>.swift</code>文件。目标将被递归扫描，以确保不会错过子目录。</li><li>使用<a href="https://github.com/apple/swift/tree/main/tools/SourceKit" target="_blank" rel="noopener">sourcekit</a>，或者更具体地说，<a href="https://github.com/jpsim/SourceKitten" target="_blank" rel="noopener">SourceKitten</a>，扫描这些<code>.swift</code>文件并收集类型信息。这将允许提取符合<code>Fetchable</code>协议的所有类型，以便可以针对它们编写测试。</li><li>获得这些类型后，生成一个带有<code>XCTestCase</code>的<code>.swift</code>文件，其中包含每种类型的单元测试。</li></ol><h2 id="让我们写一些代码吧"><a href="#让我们写一些代码吧" class="headerlink" title="让我们写一些代码吧"></a>让我们写一些代码吧</h2><p>与所有 Swift Package 一样，最简单的入门方法是在命令行上运行<code>swift package init</code>。</p><p>这创建了两个目标，一个是包含<code>Fetchable</code>协议定义和符合该定义的类型的实现代码，另一个是应用插件为此类类型生成单元测试的测试目标。</p><blockquote><p>Package.swit</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift-tools-version: 5.6</span></span><br><span class="line"><span class="comment">// The swift-tools-version declares the minimum version of Swift required to build this package.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">    platforms: [.macOS(.v10_11)],</span><br><span class="line">    products: [</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">            targets: [<span class="string">"CodeGenSample"</span>]),</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">            dependencies: []</span><br><span class="line">        ),</span><br><span class="line">        .testTarget(</span><br><span class="line">            name: <span class="string">"CodeGenSampleTests"</span>,</span><br><span class="line">            dependencies: [<span class="string">"CodeGenSample"</span>]</span><br><span class="line">        )</span><br><span class="line">     ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编写可执行文件"><a href="#编写可执行文件" class="headerlink" title="编写可执行文件"></a>编写可执行文件</h3><p>如前所述，所有构建工具插件都需要可执行文件来执行所有必要的操作。</p><p>为了帮助开发此命令行，将使用几个依赖项。第一个是<a href="https://github.com/jpsim/SourceKitten" target="_blank" rel="noopener">SourceKitten</a>——特别是其SourceKitten框架库，这是一个Swift包装器，用于帮助使用Swift代码编写<a href="https://github.com/apple/swift/tree/main/tools/SourceKit" target="_blank" rel="noopener">sourcekit</a>请求，第二个是<a href="https://github.com/apple/swift-argument-parser" target="_blank" rel="noopener">快速参数解析器</a>，这是苹果提供的软件包，可以轻松创建命令行工具，并以更快、更安全的方式解析在执行过程中传递的命令行参数。</p><p>在创建<code>executableTarget</code>并赋予它两个依赖项后，<code>Package.swift</code>就是这个样子：</p><blockquote><p>Package.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift-tools-version: 5.6</span></span><br><span class="line"><span class="comment">// The swift-tools-version declares the minimum version of Swift required to build this package.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">    platforms: [.macOS(.v10_11)],</span><br><span class="line">    products: [</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">            targets: [<span class="string">"CodeGenSample"</span>]),</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(url: <span class="string">"https://github.com/jpsim/SourceKitten.git"</span>, exact: <span class="string">"0.32.0"</span>),</span><br><span class="line">        .package(url: <span class="string">"https://github.com/apple/swift-argument-parser"</span>, from: <span class="string">"1.0.0"</span>)</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">            dependencies: []</span><br><span class="line">        ),</span><br><span class="line">        .testTarget(</span><br><span class="line">            name: <span class="string">"CodeGenSampleTests"</span>,</span><br><span class="line">            dependencies: [<span class="string">"CodeGenSample"</span>]</span><br><span class="line">        ),</span><br><span class="line">        .executableTarget(</span><br><span class="line">            name: <span class="string">"PluginExecutable"</span>,</span><br><span class="line">            dependencies: [</span><br><span class="line">                .product(name: <span class="string">"SourceKittenFramework"</span>, package: <span class="string">"SourceKitten"</span>),</span><br><span class="line">                .product(name: <span class="string">"ArgumentParser"</span>, package: <span class="string">"swift-argument-parser"</span>)</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">     ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可执行目标需要一个入口点，因此，在<code>PluginExecutable</code>目标的源目录下，必须创建一个名为<code>PluginExecutable.swift</code>的文件，其中所有可执行逻辑都需要创建。</p><blockquote><p>请注意，这个文件可以随心所欲地命名，我倾向于以与我在<code>Package.swift</code>中创建的目标相同的方式命名它。</p></blockquote><p>如下所示的脚本导入必要的依赖项，并创建可执行文件的入口点（必须用<code>@main</code>装饰），并声明在执行时传递的4个输入。</p><p>所有逻辑和方法调用都存在于<code>run</code>函数中，该函数是调用可执行文件时运行的方法。这是<code>ArgumentParser</code>语法的一部分，如果您想了解更多信息，<a href="https://www.andyibanez.com/posts/writing-commandline-tools-argumentparser-part1/" target="_blank" rel="noopener">Andy Ibañez</a>有<a href="https://www.andyibanez.com/posts/writing-commandline-tools-argumentparser-part1/" target="_blank" rel="noopener">一篇</a>关于该主题<a href="https://www.andyibanez.com/posts/writing-commandline-tools-argumentparser-part1/" target="_blank" rel="noopener">的精彩文章</a>，可能非常有帮助。</p><blockquote><p>PluginExecutable.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SourceKittenFramework</span><br><span class="line"><span class="keyword">import</span> ArgumentParser</span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PluginExecutable</span>: <span class="title">ParsableCommand</span> </span>&#123;</span><br><span class="line">    @<span class="type">Argument</span>(help: <span class="string">"The protocol name to match"</span>)</span><br><span class="line">    <span class="keyword">var</span> protocolName: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">Argument</span>(help: <span class="string">"The module's name"</span>)</span><br><span class="line">    <span class="keyword">var</span> moduleName: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">Option</span>(help: <span class="string">"Directory containing the swift files"</span>)</span><br><span class="line">    <span class="keyword">var</span> input: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">Option</span>(help: <span class="string">"The path where the generated files will be created"</span>)</span><br><span class="line">    <span class="keyword">var</span> output: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> files = <span class="keyword">try</span> deepSearch(<span class="type">URL</span>(fileURLWithPath: input, isDirectory: <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        setenv(<span class="string">"IN_PROCESS_SOURCEKIT"</span>, <span class="string">"YES"</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> structures = <span class="keyword">try</span> files.<span class="built_in">map</span> &#123; <span class="keyword">try</span> <span class="type">Structure</span>(file: <span class="type">File</span>(path: $<span class="number">0</span>.path)!) &#125;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">var</span> matchedTypes = [<span class="type">String</span>]()</span><br><span class="line">        structures.forEach &#123; walkTree(dictionary: $<span class="number">0</span>.dictionary, acc: &amp;matchedTypes) &#125;</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">try</span> createOutputFile(withContent: matchedTypes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们专注于上面的<code>run</code>方法，以了解当插件运行可执行文件时会发生什么：</p><ol><li>首先，扫描目标目录以找到其中的所有<code>.swift</code>文件。这是递归完成的，这样子目录就不会错过。此目录的路径作为参数传递给可执行文件。</li><li>对于上次调用中找到的每个文件，通过<a href="https://github.com/jpsim/SourceKitten" target="_blank" rel="noopener">SourceKitten</a>发出<code>Structure</code>请求，以查找文件中Swift代码的类型信息。请注意，环境变量（<code>IN_PROCESS_SOURCEKIT</code>）也被设置为true。这需要确保选择源套件的进程中版本，以便它能够遵守插件的沙盒规则。</li></ol><blockquote><p>Xcode附带两个版本的sourcekit可执行文件，一个版本解析进程中的文件，另一个使用XPC向解析进程外文件的守护进程发送请求。后者是mac上的默认版本，为了能够将sourcekit用作插件进程的一部分，必须选择进程中版本。<a href="https://github.com/jpsim/SourceKitten/pull/728" target="_blank" rel="noopener">这最近在SourceKitten上作为环境变量实现</a>，是运行引擎盖下使用sourcekit的其他可执行文件的关键，例如<code>SwiftLint</code>。</p></blockquote><ol><li><p>浏览上次调用的所有响应，并扫描类型信息以提取符合<code>Fetchable</code>协议的任何类型。</p></li><li><p>在传递给可执行文件的<code>output</code>参数指定的位置创建一个输出文件，其中包含每种类型的单元测试。</p></li></ol><blockquote><p>请注意，上面没有重点介绍每个调用的具体细节，但如果你对实现感兴趣，包含所有代码的repo现在已经在Github上公开了! </p></blockquote><h3 id="创建该插件"><a href="#创建该插件" class="headerlink" title="创建该插件"></a>创建该插件</h3><p>与可执行文件一样，必须向<code>Package.swift</code>添加<code>.plugin</code>目标，并且必须创建包含插件实现的<code>.swift</code>文件（<code>Plugins/SourceKitPlugin/SourceKitPlugin.swift</code>）。</p><blockquote><p>Package.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift-tools-version: 5.6</span></span><br><span class="line"><span class="comment">// The swift-tools-version declares the minimum version of Swift required to build this package.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">    platforms: [.macOS(.v10_11)],</span><br><span class="line">    products: [</span><br><span class="line">        .library(</span><br><span class="line">            name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">            targets: [<span class="string">"CodeGenSample"</span>]),</span><br><span class="line">    ],</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(url: <span class="string">"https://github.com/jpsim/SourceKitten.git"</span>, exact: <span class="string">"0.32.0"</span>),</span><br><span class="line">        .package(url: <span class="string">"https://github.com/apple/swift-argument-parser"</span>, from: <span class="string">"1.0.0"</span>)</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">"CodeGenSample"</span>,</span><br><span class="line">            dependencies: []</span><br><span class="line">        ),</span><br><span class="line">        .testTarget(</span><br><span class="line">            name: <span class="string">"CodeGenSampleTests"</span>,</span><br><span class="line">            dependencies: [“<span class="type">CodeGenSample</span><span class="string">"],</span></span><br><span class="line"><span class="string">plugins: [“SourceKitPlugin”],</span></span><br><span class="line"><span class="string">        ),</span></span><br><span class="line"><span class="string">        .executableTarget(</span></span><br><span class="line"><span class="string">            name: "</span><span class="type">PluginExecutable</span><span class="string">",</span></span><br><span class="line"><span class="string">            dependencies: [</span></span><br><span class="line"><span class="string">                .product(name: "</span><span class="type">SourceKittenFramework</span><span class="string">", package: "</span><span class="type">SourceKitten</span><span class="string">"),</span></span><br><span class="line"><span class="string">                .product(name: "</span><span class="type">ArgumentParser</span><span class="string">", package: "</span>swift-argument-parser<span class="string">")</span></span><br><span class="line"><span class="string">            ]</span></span><br><span class="line"><span class="string">        ),</span></span><br><span class="line"><span class="string">        .plugin(</span></span><br><span class="line"><span class="string">            name: "</span><span class="type">SourceKitPlugin</span><span class="string">",</span></span><br><span class="line"><span class="string">            capability: .buildTool(),</span></span><br><span class="line"><span class="string">            dependencies: [.target(name: "</span><span class="type">PluginExecutable</span><span class="string">")]</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">     ]</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><p>以下代码显示了插件的初始实现，其<code>struct</code>符合<code>BuildToolPlugin</code>的协议。这需要实现一个返回具有单个构建命令的数组的<code>createBuildCommands</code>方法。</p><blockquote><p>此插件使用<code>buildCommand</code>而不是<code>preBuildCommand</code>，因为它需要作为构建过程的一部分运行，而不是在它之前运行，因此它有机会构建和使用它所依赖的可执行文件。在这种情况下，支持使用<code>buildCommand</code>的另一点是，它只会在输入文件更改时运行，而不是每次构建目标时运行。</p></blockquote><p>此命令必须为要运行的可执行文件提供名称和路径，这可以在插件的上下文中找到：</p><blockquote><p>SourceKitPlugin.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PackagePlugin</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SourceKitPlugin</span>: <span class="title">BuildToolPlugin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createBuildCommands</span><span class="params">(context: PluginContext, target: Target)</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Command</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            .buildCommand(</span><br><span class="line">                displayName: <span class="string">"Protocol Extraction!"</span>,</span><br><span class="line">                executable: <span class="keyword">try</span> context.tool(named: <span class="string">"PluginExecutable"</span>).path,</span><br><span class="line">                arguments: [</span><br><span class="line">                    <span class="string">"FindThis"</span>,</span><br><span class="line">                    🤷,</span><br><span class="line">                    <span class="string">"--input"</span>,</span><br><span class="line">                    🤷,</span><br><span class="line">                    <span class="string">"--output"</span>,</span><br><span class="line">                    🤷</span><br><span class="line">                ],</span><br><span class="line">                environment: [<span class="string">"IN_PROCESS_SOURCEKIT"</span>: <span class="string">"YES"</span>],</span><br><span class="line">                outputFiles: [🤷]</span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示，还有一些空白需要填充（🤷）：</p><ol><li><p>提供<code>outputPath</code>，用于生成单元测试文件。此文件可以在<code>pluginWorkDirectory</code>中生成，也可以在插件的上下文中找到。该目录提供读写权限且其中创建的任何文件都将是软件包构建过程的一部分。</p></li><li><p>提供输入路径和模块名称。这是最棘手的部分，这些需要指向正在测试的目标的来源，而不是插件正在应用于的目标——单元测试。谢天谢地，插件的目标依赖项是可访问的，我们可以从该数组中获取我们感兴趣的依赖项。此依赖项将是内部的（<code>target</code>而不是<code>product</code>），它将为可执行文件提供其名称和目录。</p></li></ol><blockquote><p>SourceKitPlugin.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PackagePlugin</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SourceKitPlugin</span>: <span class="title">BuildToolPlugin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createBuildCommands</span><span class="params">(context: PluginContext, target: Target)</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Command</span>] &#123;</span><br><span class="line">        <span class="keyword">let</span> outputPath = context.pluginWorkDirectory.appending(“<span class="type">GeneratedTests</span>.swift”)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dependencyTarget = target</span><br><span class="line">            .dependencies</span><br><span class="line">            .compactMap &#123; dependency -&gt; <span class="type">Target</span>? <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> dependency &#123;</span><br><span class="line">                <span class="keyword">case</span> .target(<span class="keyword">let</span> target): <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="built_in">filter</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>.name)</span>Tests"</span> == target.name  &#125;</span><br><span class="line">            .first <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Diagnostics</span>.error(<span class="string">"Could not get a dependency to scan!”)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                return []</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return [</span></span><br><span class="line"><span class="string">            .buildCommand(</span></span><br><span class="line"><span class="string">                displayName: "</span><span class="type">Protocol</span> <span class="type">Extraction</span>!<span class="string">",</span></span><br><span class="line"><span class="string">                executable: try context.tool(named: "</span><span class="type">PluginExecutable</span><span class="string">").path,</span></span><br><span class="line"><span class="string">                arguments: [</span></span><br><span class="line"><span class="string">                    "</span><span class="type">Fetchable</span><span class="string">",</span></span><br><span class="line"><span class="string">                 dependencyTarget.name,</span></span><br><span class="line"><span class="string">                    "</span>--input<span class="string">",</span></span><br><span class="line"><span class="string">                    dependencyTarget.directory,</span></span><br><span class="line"><span class="string">                    "</span>--output<span class="string">",</span></span><br><span class="line"><span class="string">                    outputPath</span></span><br><span class="line"><span class="string">                ],</span></span><br><span class="line"><span class="string">                environment: ["</span><span class="type">IN_PROCESS_SOURCEKIT</span><span class="string">": "</span><span class="type">YES</span><span class="string">"],</span></span><br><span class="line"><span class="string">                outputFiles: [outputPath]</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意上述可选性处理方式。如果在测试目标的依赖项中找不到<em>合适的</em>目标，则使用<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0303-swiftpm-extensible-build-tools.md#plugin-api" target="_blank" rel="noopener">Diagnostics API</a>将错误转发回Xcode，并告诉它完成构建过程。</p></blockquote><h2 id="让我们看下结果"><a href="#让我们看下结果" class="headerlink" title="让我们看下结果"></a>让我们看下结果</h2><p>插件这就完成了！现在让我们在 Xcode 中运行它！为了测试这种方法，将包含以下内容的文件添加到<code>CodeGenSample</code>目标中：</p><blockquote><p>CodeGenSample.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Fetchable</span>: <span class="title">Decodable</span>, <span class="title">Equatable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FeatureABlock</span>: <span class="title">Fetchable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> featureA: <span class="type">FeatureA</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FeatureA</span>: <span class="title">Fetchable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> url: <span class="type">URL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RootBlock</span>: <span class="title">Fetchable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> url: <span class="type">URL</span></span><br><span class="line">        <span class="keyword">let</span> areAllFeaturesEnabled: <span class="type">Bool</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，脚本将在结构中首次出现<code>Fetchable</code>协议时停止。这意味着任何嵌套的符合<code>Fetchable</code>协议的类型都将被测试，只是外部模型。</p></blockquote><p>给定此输入并在主目标上运行测试，生成并运行<code>XCTestCase</code>，其中包含符合<code>Fetchable</code>协议的两种类型的测试。</p><blockquote><p>GeneratedTests.swift</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> CodeGenSample</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratedTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFeatureABlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">assertCanParseFromDefaults(<span class="type">FeatureABlock</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testRoot_RootBlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">assertCanParseFromDefaults(<span class="type">Root</span>.<span class="type">RootBlock</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">assertCanParseFromDefaults</span>&lt;T: Fetchable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Logic goes here...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有测试都通过了😅✅而且，尽管他们目前没有做很多事情，但可以扩展实现，以提供一些示例数据和一个<code>JSONDecoder</code>实例来对每个单元测试进行解析。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不久前，我正在工作中开发一项新服务，该服务由 Swift Package 组成，该 Package 公开了一个类似于&lt;code&gt;Decodable&lt;/code&gt;协议，供我们应用程序的其余部分使用。事实上，该协议是从&lt;code&gt;Decodable&lt;/code&gt;本身继承下来的，看起来像这样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; Fetchable.swit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fetchable&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Decodable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Equatable&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使用 Swift 的并发系统并行运行多个任务</title>
    <link href="https://fanbaoying.github.io/%E4%BD%BF%E7%94%A8-Swift-%E7%9A%84%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%A1%8C%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1/"/>
    <id>https://fanbaoying.github.io/使用-Swift-的并发系统并行运行多个任务/</id>
    <published>2022-08-25T03:42:26.000Z</published>
    <updated>2022-08-25T04:09:51.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Swift 内置并发系统的好处之一是它可以更轻松地并行执行多个异步任务，这反过来又可以使我们显着加快可以分解为单独部分的操作。</p><p>在本文中，让我们看一下几种不同的方法，以及这些技术中的每一种何时特别有用。</p><a id="more"></a><h2 id="从异步到并发"><a href="#从异步到并发" class="headerlink" title="从异步到并发"></a>从异步到并发</h2><p>首先，假设我们正在开发某种形式的购物应用程序来显示各种产品，并且我们已经实现了一个<code>ProductLoader</code>允许我们使用一系列异步 API 加载不同产品集合的应用程序，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadFeatured</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Product</span>] &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadFavorites</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Product</span>] &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadLatest</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Product</span>] &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管大多数情况下上述每个方法都可能会被单独调用，但假设在我们应用程序的某些部分中，我们还希望形成一个<code>Recommendations</code>包含这三个<code>ProductLoader</code>方法的所有结果的组合模型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Recommendations</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> featured: [<span class="type">Product</span>]</span><br><span class="line">        <span class="keyword">var</span> favorites: [<span class="type">Product</span>]</span><br><span class="line">        <span class="keyword">var</span> latest: [<span class="type">Product</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法是使用<code>await</code>关键字调用每个加载方法，然后使用这些调用的结果来创建我们<code>Recommendations</code>模型的实例——如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadRecommendations</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Product</span>.<span class="type">Recommendations</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> featured = <span class="keyword">try</span> await loadFeatured()</span><br><span class="line"><span class="keyword">let</span> favorites = <span class="keyword">try</span> await loadFavorites()</span><br><span class="line"><span class="keyword">let</span> latest = <span class="keyword">try</span> await loadLatest()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Product</span>.<span class="type">Recommendations</span>(</span><br><span class="line">            featured: featured,</span><br><span class="line">            favorites: favorites,</span><br><span class="line">            latest: latest</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现确实有效——然而，即使我们的三个加载操作都是完全异步的，它们目前正在<em>按顺序</em>执行，一个接一个。因此，尽管我们的顶级<code>loadRecommendations</code>方法相对于我们应用程序的其他代码正在并发执行，但实际上它还没有利用并发来执行其内部操作集。</p><p>由于我们的产品加载方法不以任何方式相互依赖，因此实际上没有理由按顺序执行它们，所以让我们看看如何让它们完全同时执行。</p><p>关于如何做到这一点的初步想法可能是将上述代码简化为单个表达式，这将使我们能够使用单个<code>await</code>关键字来等待我们的每个操作完成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadRecommendations</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Product</span>.<span class="type">Recommendations</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> await <span class="type">Product</span>.<span class="type">Recommendations</span>(</span><br><span class="line">            featured: loadFeatured(),</span><br><span class="line">            favorites: loadFavorites(),</span><br><span class="line">            latest: loadLatest()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，即使我们的代码现在<em>看起来是</em>并发的，它实际上仍会像以前一样完全按顺序执行。</p><p>相反，我们需要利用 Swift 的<code>async let</code>绑定来告诉并发系统并行执行我们的每个加载操作。使用该语法使我们能够在后台启动异步操作，而无需我们立即等待它完成。</p><p><code>await</code>如果我们在实际<em>使用</em>加载的数据时（即形成模型时）将其与单个关键字组合<code>Recommendations</code>，那么我们将获得并行执行加载操作的所有好处，而无需担心状态管理或数据竞争之类的事情：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ProductLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadRecommendations</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Product</span>.<span class="type">Recommendations</span> &#123;</span><br><span class="line">        async <span class="keyword">let</span> featured = loadFeatured()</span><br><span class="line">async <span class="keyword">let</span> favorites = loadFavorites()</span><br><span class="line">async <span class="keyword">let</span> latest = loadLatest()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> await <span class="type">Product</span>.<span class="type">Recommendations</span>(</span><br><span class="line">            featured: featured,</span><br><span class="line">            favorites: favorites,</span><br><span class="line">            latest: latest</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很整齐！因此<code>async let</code>，当我们有一组已知的、有限的任务要执行时，它提供了一种同时运行多个操作的内置方法。但如果不是这样呢？</p><h2 id="任务组"><a href="#任务组" class="headerlink" title="任务组"></a>任务组</h2><p>现在假设我们正在开发一个<code>ImageLoader</code>可以让我们通过网络加载图像的工具。要从给定的 加载单个图像<code>URL</code>，我们可以使用如下所示的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadImage</span><span class="params">(from url: URL)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使一次加载一系列图像变得简单，我们还创建了一个方便的 API，它接受一个 URL 数组并异步返回一个图像字典，该字典由下载图像的 URL 键控：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadImages</span><span class="params">(from urls: [URL])</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">URL</span>: <span class="type">UIImage</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> images = [<span class="type">URL</span>: <span class="type">UIImage</span>]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls &#123;</span><br><span class="line">            images[url] = <span class="keyword">try</span> await loadImage(from: url)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> images</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们说，就像我们<code>ProductLoader</code>之前的工作一样，我们想让上面的<code>loadImages</code>方法并发执行，而不是按顺序下载每个图像（目前是这种情况，因为我们<code>await</code>在调用时直接使用<code>loadImage</code>我们的<code>for</code>环形）。</p><p>但是，这次我们将无法使用<code>async let</code>，因为我们需要执行的任务数量在编译时是未知的。值得庆幸的是，Swift 并发工具箱中还有一个工具可以让我们并行执行动态数量的任务——<em>任务组</em>。</p><p>要形成一个任务组，我们可以调用<code>withTaskGroup</code>或<code>withThrowingTaskGroup</code>，这取决于我们是否希望可以选择在我们的任务中抛出错误。在这种情况下，我们将选择后者，因为我们的底层<code>loadImage</code>方法是用<code>throws</code>关键字标记的。</p><p>然后我们将遍历每个 URL，就像以前一样，只是这次我们将每个图像加载任务添加到我们的组中，而不是直接等待它完成。相反，我们将<code>await</code>在添加每个任务之后单独分组结果，这将允许我们的图像加载操作完全并发执行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImageLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadImages</span><span class="params">(from urls: [URL])</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">URL</span>: <span class="type">UIImage</span>] &#123;</span><br><span class="line">        <span class="keyword">try</span> await withThrowingTaskGroup(of: (<span class="type">URL</span>, <span class="type">UIImage</span>).<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> urls &#123;</span><br><span class="line">                group.addTask&#123;</span><br><span class="line">    <span class="keyword">let</span> image = <span class="keyword">try</span> await <span class="keyword">self</span>.loadImage(from: url)</span><br><span class="line">    <span class="keyword">return</span> (url, image)</span><br><span class="line">&#125; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> images = [<span class="type">URL</span>: <span class="type">UIImage</span>]()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">try</span> await (url, image) <span class="keyword">in</span> group &#123;</span><br><span class="line">    images[url] = image</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> images</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要了解有关上述<code>for try await</code>语法和一般异步序列的更多信息，请查看<a href="https://www.swiftbysundell.com/articles/async-sequences-streams-and-combine" target="_blank" rel="noopener">“异步序列、流和组合”</a>。</p><p>就像使用 时一样<code>async let</code>，以我们的操作不会直接改变任何状态的方式编写并发代码的一个巨大好处是，这样做可以让我们完全避免任何类型的数据竞争问题，同时也不需要我们引入任何锁定或序列化代码混合在一起。</p><p><code>await</code>因此，在可能的情况下，让我们的每个并发操作返回一个完全独立的结果，然后依次返回这些结果以形成我们的最终数据集，这通常是一种很好的方法。</p><p>在以后的文章中，我们将更仔细地研究避免数据竞争的其他方法（例如通过使用 Swift 的新<code>actor</code>类型）。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>重要的是要记住，仅仅因为给定的函数被标记为<code>async</code>并不一定意味着它同时执行它的工作。相反，如果这是我们想要做的，我们必须故意让我们的任务并行运行，这只有在执行一组可以独立运行的操作时才有意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Swift 内置并发系统的好处之一是它可以更轻松地并行执行多个异步任务，这反过来又可以使我们显着加快可以分解为单独部分的操作。&lt;/p&gt;
&lt;p&gt;在本文中，让我们看一下几种不同的方法，以及这些技术中的每一种何时特别有用。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 文集" scheme="https://fanbaoying.github.io/categories/Swift-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
