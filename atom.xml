<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2024-03-06T08:04:17.904Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift-周报-第三十九期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十九期/</id>
    <published>2024-03-06T07:56:54.000Z</published>
    <updated>2024-03-06T08:04:17.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十九期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>梦想之所以遥不可及，是因为今天的你和昨天一样，并没有拉近与梦想的距离。<strong>Swift社区</strong>陪你努力每一天，一同迈向象牙塔！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：卖不动了 iPhone 在美国市场销量或陷入停滞</p><p>提案：在导入声明上使用访问级别修饰符</p><p>Swift 论坛：讨论从头开始的基本 HTTP 客户端</p><p>推荐博文：用示例解释了 Swift 中的值和类型参数包</p><p><strong>话题讨论：</strong> </p><p>如果公司允许远程办公但要降薪，薪资降多少可以接受？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/4e9ccec8-5750-40b8-9a4d-93d52d0260b5.jpg" alt=""></p><p>这个投票结果反映了人们在度过假期时的不同偏好，有些人喜欢冒险和旅行，有些人更愿意宅在家里，而还有一些人则追求休闲和享受。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="卖不动了-iPhone-在美国市场销量或陷入停滞"><a href="#卖不动了-iPhone-在美国市场销量或陷入停滞" class="headerlink" title="卖不动了 iPhone 在美国市场销量或陷入停滞"></a>卖不动了 iPhone 在美国市场销量或陷入停滞</h3><p>10 月 8 日消息，作为苹果公司总部的所在地，iPhone 在美国当地市场的销量一直是很可观的。之前就有报告披露 iPhone 在美国市场有 1.67 亿用户，要比安卓系统用户的 1.44 亿高出 2300 万。</p><p>不仅如此，美洲市场向来也是苹果主要的营收来源，常年在占据在 40% 左右。苹果的财报显示，在截至 7 月 1 日的 2023 财年第三财季，营收的 817.97 亿美元美洲市场贡献了 353.83 亿美元，远高于欧洲等市场。而在第二财季 948.36 亿美元的营收中，美洲市场则是贡献了 377.84 亿美元。</p><p>但是这一情况或将在明年有所改变，根据 Business Insider（BI）的第三轮专项年度调查数据显示。由于经济形势的不确定以及手机更新周期延长，在美国市场许多用户将会继续使用老款手机而不是升级到 iPhone 15，预计明年 iPhone 在美销量或将陷入停滞。</p><p>不过该调查还强调，虽然 iPhone 的销量会走低，但是苹果公司的营收仍有望增加。这主要还是因为消费者更偏向购买价格更高的 Pro Max 系列，这也在一定程度上保证在面临销量压力时能保持较高收入水平。</p><p>此外调查还发现，决定转用安卓系统的用户占比远高于转用苹果的用户，也有很多用户表示计划减少 iCloud 和 Apple TV+ 等增值服务。</p><p>据多家投行预测，iPhone 15 的出货量将在 7000 万到 8000 万部之间，低于去年同期的 iPhone 14 的 9000 万部以上。而根据 IDC 最新发布的数据，2023 年全球智能手机出货量预计同比减少 4.7% 至 11.5 亿部，创十年来新低。（来源：快科技）</p><h3 id="与-Apple-专家会面交流"><a href="#与-Apple-专家会面交流" class="headerlink" title="与 Apple 专家会面交流"></a>与 Apple 专家会面交流</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/053312EB-FF8B-40A6-A4D9-DCFE9BC7A628/2048.jpeg" alt=""></p><p>欢迎参加为全球开发者量身打造的各种讲座、咨询、实验室等，与我们一起探索相关问题。</p><p>Apple 开发者活动为处于开发之旅各个阶段的人士打造，全年以线上和线下的形式在世界各地举行。无论你是希望提升现有的 App 或游戏、完善设计还是启动新项目，总有活动适合你。</p><p>申请设计一对一咨询，2023 年 10 月 16 日 上午 10:00 – 下午 5:00 (GMT+8) ，30 分钟线上咨询，地点：Shanghai，与 Apple 专家远程交流，共同探索如何设计美观易用的出色 App。在时长 25 分钟的线上咨询中，你可以征询关于最新 UI/UX 设计原理、最佳实践、设计模式等方面的建议。活动语言为普通话。</p><p>App 曝光度和营销入门，2023 年 10 月 31 日 中午 11:00 – 中午 12:00 (GMT+8) ，线上讲座，地点：Beijing，在这个线上讲座中，了解如何提高你的 App 在 App Store 上的曝光度。探索人们如何在 App Store 上查找 App，了解优秀产品页应包含的要素，并学习如何提升 App 的曝光度。我们还将探讨搜索功能、推荐流量的作用以及可带来更多下载次数的推广功能。活动语言为普通话。</p><p>Apple Vision Pro 开发者实验室 - 上海，2023 年 10 月 31 日 上午 9:30 – 2023 年 11 月 2 日 下午 5:00 (GMT+8)，线下讲座，地点：上海设计开发加速器。参加为期一天的开发者实验室，体验在 Apple Vision Pro 上运行的 visionOS、iPadOS 或 iOS App。你将能够在 Apple 的帮助下测试、细化并优化你的 App 和游戏，让它们在无边的空间画布中提供卓越的体验。由于场地有限，我们会审核每个请求，然后你会收到一封告知申请状态的电子邮件。请务必详细回答所有必填问题。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md" title="SE-0409" target="_blank" rel="noopener">SE-0409</a> <strong>在导入声明上使用访问级别修饰符</strong> 提案通过审查。该提案已在 <strong>三十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0408-pack-iteration.md" title="SE-0408" target="_blank" rel="noopener">SE-0408</a> <strong>包迭代</strong> 提案通过审查。该提案已在 <strong>三十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/emitting-module-takes-25x-the-time-in-xcode-15-1-beta/67671" title="Emitting 模块花费的时间是 XCode 15.1 beta 的 25 倍" target="_blank" rel="noopener">Emitting 模块花费的时间是 XCode 15.1 beta 的 25 倍</a></p><p>XCode 15.0 ( Swift 5.9.0.128.108 ) 和 XCode 15.1 Beta ( Swift 5.9.2.1.6 ) 之间的构建“发出模块”阶段似乎存在一些退化。</p><p>我的 XCWorkspace 中有几个不同的框架和应用程序。 在 15.1 beta 中，大多数编译速度都差不多，或者稍快一些。 然而，我们拥有的一个框架的时间似乎是以前的 10 倍以上。 当在 Xcode 时间线中查看时，几乎所有时间都花在“Emitting Module”阶段。 </p><p>在干净的构建中，时间从约 56 秒缩短到约 1440 秒。 另外，有些文件的编译速度似乎确实慢了一些，但这是一个很大的瓶颈，除了当时的“发射模块”之外，时间线中没有其他真正发生的事情。 </p><p>如果我当时观看 Activity Monitor，我的 CPU 的 swift-frontend 进程在此期间将保持在 100%。 但除此之外似乎没有什么可疑的。 比较输出，框架的大小几乎相同，我没有看到任何其他真正值得注意的东西。</p><p>关于什么会导致这种巨大差异有什么想法吗？</p><p><strong>回答</strong></p><p>我刚刚发现并修复了 39 个案例，当模块中包含大量 Swift 文件时，我们会看到这种情况发生。 （大量宏展开也可能发生）。对于我们看到回归的项目，“发射模块”阶段从 300 秒下降到 32 秒。</p><p>它很可能与您所看到的相同。 如果您能够捕获一个旋转转储，我们可以使用旋转转储来验证这一点，或者如果您想尝试的话，我们可以启动工具链构建。</p><p>[编辑：对于那些好奇的人来说，编译器有一个线性时间算法，可以从源位置的内部表示映射到该位置所在的源文件。 该算法“永远”是线性时间的，但最近的错误修复将其置于热路径中。 解决方法是将其转换为具有单元素最近使用的缓存的对数算法。]</p><p>2) 讨论<a href="https://forums.swift.org/t/status-check-int128-uint128/67694" title="状态检查：Int128 和 UInt128" target="_blank" rel="noopener">状态检查：Int128 和 UInt128</a></p><p>Swift 标准库实际上包含 Int128 和 UInt128，它们只是没有作为公共 API 公开。 它们是作为 SE-0329 的先决条件添加的：时钟、即时和持续时间。 他们在公共 API 中的明显缺席甚至在该提案的[第三次]审查期间被提出，但因超出范围而被推迟。 多年来，一直有人对它们提出要求，甚至可以追溯到这些论坛存在之前。</p><p>swift-numerics（本质上）拥有自己的 128 位整数重新实现，现在基金会也正在考虑添加自己的。</p><p>更不用说各种第 3 方包，以及其他 Swift 库和程序中这些类型的大量私有重新实现。</p><p>复制粘贴扩散这样一个基本的数字类型似乎有点愚蠢，当它已经在标准库中时，只需要发布它即可。 不过，我怀疑这已经是实现这一目标的目标，所以我希望问题只是：预计到达时间？</p><p><strong>回答</strong></p><p>需要明确的是：Foundation 库不考虑添加自己的。 他们建议使用 Numerics 现有的 DoubleWidth 测试支持来进行测试。 我们很快就会为 stdlib 推荐 Int128，但即使它可用，由于可用性限制（至少在中期），Foundation 和 Numerics 仍应使用双宽度类型进行测试。 所以无论如何，这都是正确的前进道路。</p><p>3) 讨论<a href="https://forums.swift.org/t/do-i-have-to-manually-check-macro-parameters-to-be-literals/67687" title="我是否必须手动检查宏参数是否为文字？" target="_blank" rel="noopener">我是否必须手动检查宏参数是否为文字？</a></p><p>在做了一些实验来了解如何开发一个真正的宏之后，我遇到了一个问题：我试图开发一个 <code>@AddCompletionHandler</code> 宏（如 WWDC 演讲中提到的那样），并且我尝试将完成参数名称传递为 宏的参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@attached(peer, names: overloaded)</span><br><span class="line"><span class="keyword">public</span> macro <span class="type">AddCompletionHandler</span>(completionName: <span class="type">String</span> = <span class="string">"onCompletion"</span>) = #externalMacro(...)</span><br></pre></td></tr></table></figure><p>我应该得到一个字符串，我将使用它来构建要添加到函数签名的新参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionParameter: <span class="type">FunctionParameterSyntax</span> = <span class="string">"<span class="subst">\(raw: completionParameterName)</span>: @escaping (<span class="subst">\(returnType)</span>) -&gt; Void"</span></span><br></pre></td></tr></table></figure><p>并在新生成的函数块内调用完成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newCode: <span class="type">CodeBlockItemListSyntax</span> = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    Task.detached &#123;</span></span><br><span class="line"><span class="string">        await <span class="subst">\(raw: completionParameterName)</span>(<span class="subst">\(functionDeclaration.wrappedInvocation)</span>)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><p>这样做的问题是宏声明接受任何返回字符串的表达式，因此您可以像这样调用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">AddCompletionHandler</span>(completionName: <span class="string">"on"</span> + <span class="string">"Completion"</span>)</span><br></pre></td></tr></table></figure><p>我发现自己手动检查 AttributeSyntax 树是否包含一个名为completionName 的参数，该表达式的类型为 <code>StringLiteralExprSyntax</code>，只有一个段，最后提取该值作为该唯一段的 <code>.content.text</code>。 如果这些步骤中的任何一个失败，我都会发出一条诊断消息，要求该值是一个文字。</p><p>这是应该如何工作的吗？ 对于看似常见的用例来说，这似乎是一个极其繁琐的过程。 我在这里错过了什么吗？</p><p><strong>回答</strong></p><p>这是实现它的一种迂回方式，但您可以执行以下操作：</p><p>定义符合 <code>ExpressibleByStringLiteral</code> 的自定义类型，并使用该类型作为宏的参数而不是 String。 用户仍然可以将字符串文字直接传递给宏调用，但他们无法执行任何接近但不是文字的操作，例如 “hello”+“world”。</p><p>但是，这仍然会让有人这样做，这是你不希望的，因为你无法评估 x：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">YourCustomType</span> = <span class="string">"onCompletion"</span></span><br><span class="line">@<span class="type">AddCompletionHandler</span>(completionName: x)</span><br></pre></td></tr></table></figure><p>因此，下一个技巧是，当您在自定义类型中实现 init(stringLiteral:) 时，只需将其设置为 fatalError() 即可。 这将阻止任何人尝试创建它的实例并将其存储在某个地方。 但该类型在宏使用中仍然有效，因为在宏调用中使用宏时，该类型实际上并不调用 init(stringLiteral:) 。 它所要做的就是类型检查它是否有效，确实如此。 （如果有人确实尝试在某处创建显式实例，则直到运行时才会捕获该错误。）</p><p>使这变得更容易的是某种参数必须为常量的功能，这些功能之前已经在这些论坛上讨论过。</p><p>仅当用户尝试直接实例化新类型时才会发生运行时错误，否则除了在宏签名中命名之外，该新类型对他们是隐藏的。 将其命名为 <code>CompletionHandlerNameLiteral</code> 之类的名称，这样就不会混淆其用途。</p><p>没有编译时失败被转移到运行时，因为它严格阻止了编译器以前允许的使用：现在编译器不再允许像“hello”+“world”这样的表达式并要求宏检查它，而是 编译器会停止它，宏不再需要检查它。</p><p>这不是一个完美的解决方案，但我可以理解，用户并不都希望为“这是一个文字吗”之类的事情编写相同的检查，因此最好让编译器在可能的情况下为您完成工作。 在缺乏 const-value 强制功能的情况下，SwiftSyntax 将成为此类辅助 API 的良好家园，至少可以减轻负担。</p><p>4) 讨论<a href="https://forums.swift.org/t/swift-runtime-unable-to-suspend-thread-when-compiling-in-qemu/67676" title="从头开始的基本 HTTP 客户端" target="_blank" rel="noopener">从头开始的基本 HTTP 客户端</a></p><p>我想使用 Swift 从头开始创建基本的 HTTP 客户端，以达到学习目的，以了解互联网上 http 的发送者和接收者是如何工作的。 这只是出于原始学习目的，所以我只想使用套接字。 现在我正在本地主机中尝试，我在SO 1中发布了相同的内容。我尝试了下面的代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Darwin</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> host: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> port: <span class="type">UInt16</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(host: <span class="type">String</span>, port: <span class="type">UInt16</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.host = host</span><br><span class="line">        <span class="keyword">self</span>.port = port</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="number">_</span> completionHandler: @escaping<span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a socket</span></span><br><span class="line">        <span class="keyword">let</span> sock = socket(<span class="type">AF_INET</span>, <span class="type">SOCK_STREAM</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> serveraddr = sockaddr_in()</span><br><span class="line">        serveraddr.sin_family = sa_family_t(<span class="type">AF_INET</span>)</span><br><span class="line">        serveraddr.sin_port = <span class="keyword">self</span>.port</span><br><span class="line">        serveraddr.sin_addr.s_addr = inet_addr(<span class="keyword">self</span>.host)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect to the server</span></span><br><span class="line">          </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Connecting...."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">withUnsafePointer</span>(to: &amp;serveraddr) &#123; sockaddrInPtr <span class="keyword">in</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">let</span> sockaddrPtr = <span class="type">UnsafeRawPointer</span>(sockaddrInPtr).assumingMemoryBound(to: sockaddr.<span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">let</span> connection = connect(sock, sockaddrPtr, socklen_t(<span class="type">MemoryLayout</span>&lt;sockaddr_in&gt;.size))</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> connection == <span class="number">0</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Form an HTTP GET request</span></span><br><span class="line">                <span class="keyword">let</span> request = <span class="string">"GET / HTTP/1.1\r\nHost: <span class="subst">\(<span class="keyword">self</span>.host)</span>\r\n\r\n"</span></span><br><span class="line">                <span class="keyword">let</span> bytes = [<span class="type">UInt8</span>](request.data(using: .utf8)!)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Send the request over the socket</span></span><br><span class="line">                send(sock, bytes, request.<span class="built_in">count</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // Receive and print the response</span></span><br><span class="line"><span class="comment">                var response = [UInt8](repeating: 0, count: 1024)</span></span><br><span class="line"><span class="comment">                let bytesRead = recv(sock, &amp;response, response.count, 0)</span></span><br><span class="line"><span class="comment">                if bytesRead &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">                    if let httpResponse = String(bytes: response, encoding: .utf8) &#123;</span></span><br><span class="line"><span class="comment">                        print(httpResponse)</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // Close the socket</span></span><br><span class="line"><span class="comment">                close(sock)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"not connected <span class="subst">\(connection)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> client: <span class="type">Client</span> = .<span class="keyword">init</span>(host: <span class="string">"127.0.0.1"</span>, port: <span class="number">8080</span>)</span><br><span class="line">client.<span class="keyword">get</span> &#123;</span><br><span class="line">                </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"GET request successfully executed!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用 python3 -m http.server 8080 作为包含一些文件的文件夹上的测试服务器。 它适用于浏览器和邮递员 GET 请求。</p><p>但问题是 cleint 退出，打印未连接 -1</p><p>我该如何解决此问题并成功请求？</p><p><strong>回答</strong></p><p>从 Swift 正确使用 BSD 套接字是一个严峻的挑战。 我自己在这个问题上反复讨论了很多次，最终选择了从 <a href="https://developer.apple.com/forums/thread/734124" title="Swift 调用 BSD 套接字中所示的方法" target="_blank" rel="noopener">Swift 调用 BSD 套接字中所示的方法</a>。 正如那篇顶级文章中所解释的，这并不适用于生产代码，而是适用于我们在这里讨论的测试项目。</p><p>至于您是否应该使用 BSD 套接字，这是我在 TN3151 <a href="https://developer.apple.com/documentation/technotes/tn3151-choosing-the-right-networking-api" title="选择正确的网络 API" target="_blank" rel="noopener">选择正确的网络 API</a> 中介绍的内容。</p><p>哦，实现一个正确的 HTTP 客户端非常困难，即使您将自己限制为 HTTP/1.1 而没有 HTTPS。 因此，虽然为这样的测试项目编写自己的 HTTP 代码很好，但如果您打算部署它，我建议您使用现有的 HTTP 库。<br>需要明确的是，ATS 仅适用于 URLSession 及以上版本。 低级 API，如网络框架和 BSD 套接字，只是忽略 ATS。</p><p>应用程序沙箱适用于所有网络连接，因此这是正确的举措（-：</p><p>5) 讨论<a href="https://forums.swift.org/t/different-macro-implementation-for-different-platforms/67693" title="不同平台不同的宏实现" target="_blank" rel="noopener">不同平台不同的宏实现</a></p><p>我正在尝试创建一个宏，允许我在资源包中按名称引用颜色。</p><p>例如，能够执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myColor = #color(<span class="string">"MyColor"</span>)</span><br></pre></td></tr></table></figure><p>在 macOS 上，我希望将其为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"NSColor(named: <span class="subst">\(argument)</span>) ?? NSColor.clear"</span></span><br></pre></td></tr></table></figure><p>在 iOS 上，我希望它是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"UIColor(named: <span class="subst">\(argument)</span>)"</span></span><br></pre></td></tr></table></figure><p>我写了以下宏：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">ColorMacro</span>: <span class="title">ExpressionMacro</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">expansion</span><span class="params">(of node: some FreestandingMacroExpansionSyntax, <span class="keyword">in</span> context: some MacroExpansionContext)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">ExprSyntax</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> argument = node.argumentList.first?.expression <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">MacroError</span>.invalidArguments</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> canImport(<span class="type">AppKit</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"NSColor(named: <span class="subst">\(argument)</span>) ?? NSColor.clear"</span></span><br><span class="line">#elseif canImport(<span class="type">UIKit</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UIColor(named: <span class="subst">\(argument)</span>)"</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">        #error(<span class="string">"Unsupported platform"</span>)</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> canImport(<span class="type">AppKit</span>)</span><br><span class="line"><span class="keyword">import</span> AppKit</span><br><span class="line"></span><br><span class="line">@freestanding(expression)</span><br><span class="line"><span class="keyword">public</span> macro color(<span class="number">_</span> named: <span class="type">String</span>) -&gt; <span class="type">NSColor</span> = #externalMacro(module: <span class="string">"SwatchbookMacrosMacros"</span>, type: <span class="string">"ColorMacro"</span>)</span><br><span class="line">#elseif canImport(<span class="type">UIKit</span>)</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line">@freestanding(expression)</span><br><span class="line"><span class="keyword">public</span> macro color(<span class="number">_</span> named: <span class="type">String</span>) -&gt; <span class="type">UIColor</span> = #externalMacro(module: <span class="string">"SwatchbookMacrosMacros"</span>, type: <span class="string">"ColorMacro"</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在为 macOS 构建时效果很好，但在为 iOS 构建的目标中使用时，它似乎仍在尝试使用 AppKit 分支并引用 NSColor。</p><p>难道我做错了什么？ 是否使用正在构建的平台来确定可用性，而不是目标平台？</p><p><strong>回答</strong></p><p>这里的问题是 #if 块是 IfConfigDeclSyntax，而不是表达式。 不过，您可以将整个事情包装在立即执行的闭包中，使其成为一个表达式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    #if canImport(AppKit)</span></span><br><span class="line"><span class="string">      NSColor(named: <span class="subst">\(argument)</span>) ?? NSColor.clear</span></span><br><span class="line"><span class="string">    #elseif canImport(UIKit)</span></span><br><span class="line"><span class="string">      UIColor(named: <span class="subst">\(argument)</span>)</span></span><br><span class="line"><span class="string">    #else</span></span><br><span class="line"><span class="string">      #error("</span><span class="type">Unsupported</span> platform<span class="string">")</span></span><br><span class="line"><span class="string">    #endif</span></span><br><span class="line"><span class="string">  &#125;()</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><p>但如果您打算执行所有这些操作，那么在宏的库目标中创建一个辅助函数并调用它可能会更干净、更简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">__colorHelper</span><span class="params">(<span class="number">_</span> name: String)</span></span> &#123;</span><br><span class="line">  #<span class="keyword">if</span> canImport(<span class="type">AppKit</span>)</span><br><span class="line">    <span class="type">NSColor</span>(named: name) ?? <span class="type">NSColor</span>.clear</span><br><span class="line">  #elseif canImport(<span class="type">UIKit</span>)</span><br><span class="line">    <span class="type">UIColor</span>(named: name)</span><br><span class="line">  #<span class="keyword">else</span></span><br><span class="line">    #error(<span class="string">"Unsupported platform"</span>)</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并让您的宏实现调用该函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  YourModuleName.__colorHelper(<span class="subst">\(argument)</span>)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/whats-new-swift-debugging-5.9/" title="Swift 5.9 中的调试改进" target="_blank" rel="noopener">Swift 5.9 中的调试改进</a></p><p><strong>摘要：</strong>  本篇官方文章介绍了 Swift 5.9 在编译器和 LLDB 调试器中引入了许多新的调试功能。以下是三个改变，可以帮助你在日常调试工作中更加便捷。首先，通过使用快捷命令别名 p 和 po 进行变量检查可以更快速地进行操作。</p><p>其次，LLDB 的 dwim-print 命令提供了更加用户友好的方式来打印变量。而且，在 Swift 5.9中，使用 p 命令不再会创建像 $R0 这样的持久结果变量，这些变量常常在调试会话中未被使用。最后， LLDB 现在支持在表达式评估中使用泛型类型参数，这使得在调试过程中能更好地区分不同的变量。Swift 5.9 还引入了更精确的词法作用域信息，使得调试器能够更好地区分不同的变量。</p><p><a href="https://www.avanderlee.com/swift/value-and-type-parameter-packs/" title="用示例解释了 Swift 中的值和类型参数包" target="_blank" rel="noopener">用示例解释了 Swift 中的值和类型参数包</a></p><p><strong>摘要：</strong>  本文介绍了 Swift 中的值和类型参数包，并结合示例进行了详细解释。类型参数包和值参数包允许你编写一个接受任意数量具有不同类型参数的通用函数。在 Swift 5.9 中，由于 SE-393、SE-398 和SE-399 的提案，这一新特性得以实现。</p><p>采用参数包的最显著影响之一是在 SwiftUI 中的10个视图限制已经不存在，这是由于在这些提案之后可实现了可变参数泛型。本文还解释了参数包的解决方案，它们帮助我们编写可重用的代码，避免编写大量的函数重载。从 Swift 5.9 开始，我们可以使用参数包重写类似的函数。本文末尾总结了参数包的优势，并提供了进一步学习 Swift 的资源链接。</p><p><a href="https://juejin.cn/post/7288178532861886504/" title="SwiftData 中的并发编程" target="_blank" rel="noopener">SwiftData 中的并发编程</a></p><p><strong>摘要：</strong> 本文介绍了在 SwiftData 中进行并发编程的方法。尽管在 Core Data 中进行并发编程可能有一些陷阱，但 SwiftData 作为 Core Data 的继任者提供了更加安全和优雅的并发编程机制。文章讨论了如何使用串行队列来避免数据竞争问题，如何创建使用私有队列的 ModelContext ，以及如何使用 Actor 实现更优雅的并发编程。</p><p>此外，还介绍了通过 PersistentIdentifier 来获取数据以及在非主线程中修改主线程上的对象属性的方法。通过深入了解 SwiftData 的并发编程特性，开发者可以提高代码的安全性和可读性。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>如果公司允许远程办公但要降薪，薪资降多少可以接受？</strong></p><ol><li>10%以下</li><li>25%以下</li><li>50% 以下</li><li>保持，不接受降薪</li><li>应该加薪，工作量增加</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十九期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;梦想之所以遥不可及，是因为今天的你和昨天一样，并没有拉近与梦想的距离。&lt;strong&gt;Swift社区&lt;/strong&gt;陪你努力每一天，一同迈向象牙塔！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：卖不动了 iPhone 在美国市场销量或陷入停滞&lt;/p&gt;
&lt;p&gt;提案：在导入声明上使用访问级别修饰符&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论从头开始的基本 HTTP 客户端&lt;/p&gt;
&lt;p&gt;推荐博文：用示例解释了 Swift 中的值和类型参数包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;如果公司允许远程办公但要降薪，薪资降多少可以接受？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十八期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十八期/</id>
    <published>2024-03-06T07:56:49.000Z</published>
    <updated>2024-03-06T08:03:56.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十八期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>三餐四季，春夏秋冬，平凡如尔，与众不同。<strong>Swift社区</strong>陪你苦尽甘来，笑看山河星月！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通3年</p><p>提案：在导入声明上使用访问级别修饰符</p><p>Swift 论坛：讨论 Swift 测试的新方法</p><p>推荐博文：Swift 中使用 actors 实现线程安全</p><p><strong>话题讨论：</strong> </p><p>中秋遇上了国庆，诗和远方开始了躁动，假期将至，你准备怎么过？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/799581b0-b4e6-472e-84db-e9c53aed2b28.jpg" alt=""></p><p>从投票结果可以看出，苹果的品牌忠诚度和声誉在一些用户中仍然很高，而华为和小米等品牌则通过不同的性价比策略吸引了其他一些用户。手机市场竞争激烈，消费者有幸拥有多种选择，以满足他们的不同需求。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通-3-年"><a href="#苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通-3-年" class="headerlink" title="苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通 3 年"></a>苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通 3 年</h3><p>去年底的测试发现，苹果自研的调制解调器芯片速度太慢且容易过热，电路板尺寸太大，占据半个 iPhone 的面积，无法使用。这些芯片基本上比高通最好的调制解调器芯片落后 3 年。</p><p>熟悉该项目的苹果前工程师和高管透露，由于技术挑战、沟通不畅，以及高层对尝试设计芯片而不是购买芯片是否明智的问题存在分歧，苹果调制解调器芯片的工程团队工作进展缓慢，且设定了不切实际的目标。</p><p><img src="https://d.ifengimg.com/w1125_q90_webp/x0.ifengimg.com/res/2023/D3966516AE536448301F83F355C2A452F896CC5C_size627_w2000_h1200.jpg" alt=""></p><p>苹果硬件技术高级副总裁约翰尼·斯鲁吉（Johny Srouji）领导了芯片研发。</p><p>据苹果公司前工程师和高管透露，该公司原计划将其自研调制解调器芯片用在最新的 iPhone 机型中，但去年年底的测试发现，该芯片速度太慢且容易过热，电路板尺寸太大，占据半个 iPhone 的面积，无法使用。</p><p>调制解调器芯片的作用是连接手机与无线运营商，iPhone 目前依赖高通公司生产的调制解调器芯片。本月上旬，高通宣布将苹果的采购合同延长 3 年，业界推测苹果自主研发调制解调器芯片的计划遇到挫折。</p><p>2018 年，苹果首席执行官蒂姆·库克（Tim Cook）下达设计和制造调制解调器芯片的命令，并招聘数千名工程师。目标是切断苹果对高通的依赖。据估计，去年苹果已向高通支付了超过 72 亿美元芯片采购费用。在 2017 年的诉讼中，苹果指控高通对其专利使用费收取过高费用。</p><p>熟悉该项目的苹果前工程师和高管告诉《华尔街日报》，由于技术挑战、沟通不畅，以及高层对尝试设计芯片而不是购买芯片是否明智的问题存在分歧，苹果调制解调器芯片的工程团队工作进展缓慢。团队被孤立在美国和国外的不同小组中，没有全球领导者。一些高管不鼓励工程师传播有关延误或挫折的坏消息，从而导致设定不切实际的目标和最后期限。</p><p>苹果在十多年前就致力于生产用于其产品的各种芯片。2010 年 1 月，苹果创始人史蒂夫·乔布斯在第一代 iPad 发布会上低调展示了自研的 A4 芯片，这枚 45nm 制程的芯片由三星代工，一开始并不被业界看好。一年之后，苹果在 iPhone 4S 发布会上展示了第二代芯片 A5，性能提升巨大。此后，苹果构建了由 A 系列（手机和平板）、M 系列（桌面电脑）、H 系列（耳机）、S 系列（手表）等多个产品线的芯片家族。特别是在 2020 年，苹果用 M1 芯片替代 Mac 电脑中使用多年的英特尔处理器芯片，震动了市场。今年 9 月发布的 iPhone 15 Pro 系列更是搭载了全球首款 3nm 工艺制程芯片—— A17 Pro。</p><h3 id="App-Store-现已接受适用于最新版操作系统的-App-和游戏提交"><a href="#App-Store-现已接受适用于最新版操作系统的-App-和游戏提交" class="headerlink" title="App Store 现已接受适用于最新版操作系统的 App 和游戏提交"></a>App Store 现已接受适用于最新版操作系统的 App 和游戏提交</h3><p>iOS 17、iPadOS 17、macOS Sonoma、Apple tvOS 17 和 watchOS 10 即将面向全球用户推出。使用发布候选版 Xcode 15 和最新 SDK 构建你的 App 和游戏，通过 TestFlight 进行测试，然后提交到 App Store 以供审核。现在，你可以着手从 Xcode Cloud 将你的 App 和游戏无缝部署到 TestFlight 和 App Store。借助激动人心的新功能，以及针对各种语言、框架、工具和服务的重大改进，你可以在 Apple 平台上提供更加独特的体验。</p><p>Xcode 和 Swift：Xcode 15 提供增强的代码补齐功能、交互式预览和实时动画，可让你更快地推进 App 的编码和设计。Swift 通过引入宏解锁了多个新的 API 类型，不但表现力强，且直观易用。全新的 SwiftData 框架使用声明式代码，可轻松保留数据。SwiftUI 还支持使用相位和关键帧创建更复杂的动画，并通过新的 Observation 框架简化数据流。</p><p>小组件和实时活动：小组件现在支持交互操作，并且可以在新的位置运行，例如 iPhone 上的待机界面、iPad 上的锁定屏幕、Mac 上的桌面以及 Apple Watch 上的智能叠放。借助 SwiftUI，系统会根据情境调整小组件的颜色和间距，从而提高它在各个平台中的实用性。通过 WidgetKit 和 ActivityKit 构建的实时活动现已在 iPad 上推出，以帮助用户实时了解 App 中正在发生的事情。</p><p>Metal：借助新的游戏移植工具包，可以比以往更轻松地将游戏移植到 Mac，Metal 着色器转换器大大简化了游戏着色器和图形代码的转换过程。借助最新的光线追踪更新，可将你的游戏和产品渲染器扩展到更逼真、更细腻的场景。此外还能利用许多其他增强功能，在 Apple 芯片上更轻松地提供精彩的游戏和专业 App。</p><p>App 快捷指令：如果你适配了 App 快捷指令，App 的主要功能会自动出现在聚焦中，方便用户快速访问 App 中最重要的视图和操作。新的设计让 App 快捷指令的运行变得更加容易，新的自然语言功能让用户能够更加灵活地用自己的声音来执行你的快捷指令。</p><p>App Store：借助 StoreKit 中的全新 SwiftUI 视图，你现在可以更轻松地在所有平台上推销 App 内购买项目和订阅。利用 Xcode 中的 StoreKit 测试、Apple 沙盒环境以及 TestFlight 的最新增强功能，你还可以对更多产品内容进行测试。通过按地区预购功能，你可以在新地区提供 App 并设置不同的发布日期，让用户更期待你的 App 发布。App Store 提供极为灵活且个性化的 App 发现体验，根据用户的兴趣和偏好提供量身定制的推荐内容，帮助他们找到更多出色的 App。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0407-member-macro-conformances.md" title="SE-0407" target="_blank" rel="noopener">SE-0407</a> <strong>成员 Macro 一致性</strong> 提案通过审查。该提案已在 <strong>三十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md" title="SE-0409" target="_blank" rel="noopener">SE-0409</a> <strong>在导入声明上使用访问级别修饰符</strong> 提案正在审查。</p><p>通过在导入声明上使用访问级别修饰符来声明依赖项的可见性，可以强制规定哪些声明可以引用导入的模块。可以将依赖项标记为仅对源文件、模块、包或所有客户端可见。这将让声明的访问级别行为对依赖项和导入的声明也适用。此功能可以隐藏实现细节，有助于管理依赖项的扩散。</p><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0406-async-stream-backpressure.md" title="SE-0406" target="_blank" rel="noopener">SE-0406</a> <strong>对 AsyncStream 的 Backpressure 支持</strong> 提案被驳回。该提案已在 <strong>三十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/structural-sum-types-used-to-be-anonymous-union-types/67432" title="结构和类型（以前是匿名联合类型）" target="_blank" rel="noopener">结构和类型（以前是匿名联合类型）</a></p><p>从状态检查中衍生出一个关于匿名联合类型主题的新讨论<a href="https://forums.swift.org/t/status-check-typed-throws/66637" target="_blank" rel="noopener">线程：类型抛出</a>。</p><p>关于这个主题的衍生讨论是围绕这个<a href="https://forums.swift.org/t/status-check-typed-throws/66637/100" target="_blank" rel="noopener">评论</a>开始的。</p><p>类型化抛出就像类一样，是静态类型信息的重要载体。 你所说的相当于说“不应允许类实例在弹性库中具有特定的类类型，而应始终为 AnyObject”。 这显然是非常错误的。 不小心将自己锁定在特定错误类型中，然后在主要版本发布后后悔的可能性不是语言问题，而是工程无能问题。 作者应该采取预防措施，在设计错误类型时考虑到未来的扩展（例如，具有可选元数据的结构而不是裸枚举）。</p><p>当我们谈论这个话题时：</p><p>匿名联合类型 (A | B) 也是如此，它们只不过是某些通用枚举周围的语法糖（例如 Either<a, b="">）。 这不是什么新鲜事，Swift 已经完全能够表达这种类型，因此我不断听到的“由于编译器复杂性而经常被拒绝的提案”显然也是非常错误的。</a,></p><p><strong>结论：</strong></p><p>类型系统必须具有工程师认为合适的表达能力，以使他们的代码具有表达能力。 仅仅因为有人想不出保留静态类型信息的理由（通过使用特定的错误类型或使用匿名联合类型），并不意味着没有理由。</p><p>2) Swift使用<a href="https://forums.swift.org/t/announcing-swift-sdk-generator/67409" title="推出 Swift SDK 生成器" target="_blank" rel="noopener">推出 Swift SDK 生成器</a><br>我们很高兴地宣布推出新的<a href="https://github.com/apple/swift-sdk-generator" target="_blank" rel="noopener">开源实用程序</a>，它可以简化 Swift 包的交叉编译！</p><p>使用 Xcode 时，许多 Swift 开发人员每天都会使用从 macOS 到其他 Darwin 平台的交叉编译。 与此同时，使用命令行开发工具对 Linux 和 Swift 支持的其他平台进行交叉编译并不那么容易设置。 通过 SE-0387 35，我们希望缩小这一差距，并使交叉编译成为 SwiftPM 命令行界面中的一流功能。</p><p>虽然 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0387-cross-compilation-destinations.md" target="_blank" rel="noopener">SE-0387</a> 指定了 Swift SDK 捆绑包的格式和文件系统布局，但它没有规定如何生成这些捆绑包。 我们提供了此类生成器的参考实现，它支持 macOS 作为主机平台和一些主要的 Linux 发行版作为目标平台。</p><p>区分 Swift SDK 作者和 Swift SDK 用户非常重要。 新的 Swift SDK Generator 应主要由 Swift SDK 作者使用，他们可以根据自己的需求对其进行自定义并发布自己的 Swift SDK 捆绑包。 反过来，Swift SDK 用户可以依赖 Swift 5.9 中引入的 swift Experimental-sdk 命令来安装 Swift SDK 作者之前生成的捆绑包。</p><p>我们正在努力增加对 Swift 项目正式支持的所有 Linux 发行版的支持。</p><p>3) 讨论<a href="https://forums.swift.org/t/a-new-approach-to-testing-in-swift/67425" title="Swift 测试的新方法" target="_blank" rel="noopener">Swift 测试的新方法</a><br>大家好，</p><p>我很高兴地宣布一个新的开源项目，旨在探索 Swift 测试体验的改进。 我和我的同事最近几个月一直在致力于此工作，并取得了一些早期进展，我们很高兴与大家分享。</p><p>受到 Swift 宏的启发，我们构建了一个测试库 API，它可以：</p><p>使用名为 @Test 的附加宏提供有关各个测试的详细信息。 这使得许多新功能成为可能，例如表达需求、传递参数或添加自定义标签，所有这些都直接在代码中而不是单独的配置文件中实现。</p><p>使用拼写为 #expect(…) 的表达式宏，通过详细且可操作的故障信息验证测试中的预期条件。 它通过自动捕获传入表达式的值及其源代码来通知失败消息，并且比专门的断言函数更容易学习，因为它接受内置运算符表达式，如 <code>#expect(a == b)</code>。</p><p>通过向函数添加参数并在 @Test 属性中指定其参数，可以使用不同的输入轻松重复测试多次。</p><p>这是一个示例：它显示了一个测试函数，使用 @Test 表示，其中包含两个特征：自定义显示名称和决定测试是否应运行的条件。 该测试创建一辆食品卡车，在其中存放食物，然后使用 #expect 检查食物数量是否等于我们期望的值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span>(<span class="string">"The Food Truck has enough burritos"</span>,</span><br><span class="line">      .enabled(<span class="keyword">if</span>: <span class="type">FoodTruck</span>.isAvailable))</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foodAvailable</span><span class="params">()</span></span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> foodTruck = <span class="type">FoodTruck</span>()</span><br><span class="line">    <span class="keyword">try</span> await foodTruck.stock(.burrito, quanity: <span class="number">15</span>)</span><br><span class="line">    #expect(foodTruck.quantity(of: .burrito) == <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述测试失败，#expect 将捕获数量(of: .burrito) 等子表达式的值以及源代码文本。 这允许在输出中包含丰富的诊断信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">✘ <span class="type">Test</span> <span class="string">"The Food Truck has enough burritos"</span> recorded an issue at <span class="type">FoodTruckTests</span>.swift:<span class="number">8</span>:<span class="number">6</span>:</span><br><span class="line"><span class="type">Expectation</span> failed: (foodTruck.quantity(of: .burrito) → <span class="number">15</span>) == <span class="number">20</span></span><br></pre></td></tr></table></figure><p>使用这种方法，使用不同的输入多次重复测试（称为参数化测试 15）也很简单。 @Test 属性可以包含参数，并且该函数将被重复调用并传递每个参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span>(arguments: [<span class="type">Food</span>.burrito, .taco, .iceCream])</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foodAvailable</span><span class="params">(food: Food)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> foodTruck = <span class="type">FoodTruck</span>()</span><br><span class="line">    #expect(foodTruck.quantity(of: food) == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-testing/blob/main/Documentation/Vision.md" title="Swift 测试的新 API 方向" target="_blank" rel="noopener">Swift 测试的新 API 方向</a>深入探讨了我们的愿景，描述了项目的目标，并展示了我们提出的方法的更多示例。</p><p>这些想法已在名为 <a href="https://github.com/apple/swift-testing" target="_blank" rel="noopener">swift-testing</a> 的新包中原型化，该包目前被认为是实验性的，尚未推荐用于一般生产用途。 如果你感兴趣，我们鼓励你克隆它，探索它的实现，并尝试使用它为你的项目编写测试。</p><p>4) 讨论<a href="https://forums.swift.org/t/vscode-with-5-9-stopping-server-failed/67397" title="VSCode 5.9：停止服务器失败" target="_blank" rel="noopener">VSCode 5.9：停止服务器失败</a></p><p>自从升级到 5.9 以来，VSCode 上的 sourcekit-lsp 变得更加不稳定，我不断收到“客户端 SourceKit 语言服务器：与服务器的连接出错。 关闭服务器。” 问题，它打印的唯一日志输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Error - 4:44:34 PM] Stopping server failed</span><br><span class="line">  Message: Cannot call write after a stream was destroyed</span><br><span class="line">  Code: -32099</span><br></pre></td></tr></table></figure><p>我相信，这是应该解决该问题的 PR：<a href="https://github.com/apple/sourcekit-lsp/pull/828" target="_blank" rel="noopener">Don’t crash when unregistering for change notifications of a file that isn’t watched by ahoppen · Pull Request #828 · apple/sourcekit-lsp · GitHub</a></p><p>5) 讨论<a href="https://forums.swift.org/t/is-sendable-necessary-for-closures-passed-into-asynchronous-scope-functions/67403" title="对于传递到异步作用域函数的闭包来说，Sendable 是否是必需的？" target="_blank" rel="noopener">对于传递到异步作用域函数的闭包来说，Sendable 是否是必需的？</a></p><p>我一直在思考以下函数代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transaction</span>&lt;T&gt;<span class="params">(<span class="number">_</span> closure: @Sendable @escaping <span class="params">(Database)</span></span></span> async <span class="keyword">throws</span> -&gt; <span class="type">T</span>) async <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> await <span class="keyword">self</span>.transaction &#123; db -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> promise = <span class="keyword">self</span>.eventLoop.makePromise(of: <span class="type">T</span>.<span class="keyword">self</span>)</span><br><span class="line">            promise.completeWithTask&#123; <span class="keyword">try</span> await closure(db) &#125;</span><br><span class="line">            <span class="keyword">return</span> promise.futureResult</span><br><span class="line">        &#125;.<span class="keyword">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是来自 Vapor 框架的实际代码。</p><p>以下是供参考的网址：<a href="https://github.com/vapor/" target="_blank" rel="noopener">https://github.com/vapor/</a> Fluent-kit/blob/main/Sources/FluentKit/Concurrency/Database%2BConcurrency.swift 1</p><p>在这个事务函数中，参数闭包具有 <code>@Sendable</code> 和 <code>@escaping</code> 属性。</p><p>我想知道是否可以将两者删除。</p><p>特别是，<code>@Sendable</code> 属性意味着传递给闭包的类型必须是 Sendable，这施加了相当严格的限制。因此，如果我们可以省略它，那就方便多了。</p><p>我认为它可以被删除的原因是，虽然这个闭包确实被传递到事件循环线程，当它离开交易功能时，它正在等待 <code>EventLoopFuture.get()</code>,确保闭包的函数调用完成。</p><p>换句话说，两个不同线程不可能同时调用闭包。</p><p>确实，理论上由于 eventLoop 类型被抽象为任何 EventLoop，实现一种将传递给 <code>completeWithTask</code> 的闭包存储到全局变量或类似的东西中的方法是可能的，但这对于 EventLoop 和 EventLoopFuture 来说显然是不自然的行为，我认为没有什么可担心的。</p><p>此外，我认为出于同样的原因可以消除@escaping。 闭包实际上并没有逃脱。</p><p>上面的想法可能是对的吗？</p><p>我很想听听有更多见解的人的想法来权衡。</p><p>作为参考，具体实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transaction</span>&lt;T&gt;<span class="params">(<span class="number">_</span> closure: <span class="params">(any Database)</span></span></span> async <span class="keyword">throws</span> -&gt; <span class="type">T</span>) async <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> await withoutActuallyEscaping(closure) &#123; (closure) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> closureBox = <span class="type">UncheckedSendableBox</span>(closure)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> await <span class="keyword">self</span>.transaction &#123; db -&gt; <span class="type">EventLoopFuture</span>&lt;<span class="type">T</span>&gt; <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> dbBox = <span class="type">UncheckedSendableBox</span>(db)</span><br><span class="line">                <span class="keyword">let</span> promise = <span class="keyword">self</span>.eventLoop.makePromise(of: <span class="type">T</span>.<span class="keyword">self</span>)</span><br><span class="line">                promise.completeWithTask &#123;</span><br><span class="line">                    <span class="keyword">let</span> db = dbBox.value</span><br><span class="line">                    <span class="keyword">let</span> closure = closureBox.value</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">try</span> await closure(db)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> promise.futureResult</span><br><span class="line">            &#125;.<span class="keyword">get</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我相信这个想法可以推广。</p><p>我将这些接受值并允许使用闭包进行灵活处理的函数称为作用域函数。</p><p>这样的作用域函数确实可以是异步的，但是，即使它们是异步的，在我看来，只要作用域函数中的闭包执行是串行完成的，它们不一定必须是 <code>@Sendable</code> 或 <code>@escaping</code>。</p><p>你对此有何看法？</p><p><strong>回答</strong></p><p>这个问题很好理解，但解决方案不是放弃当前语言中的 Sendable 要求，而是让编译器可以推断出根本不需要它。 请参阅 <a href="https://forums.swift.org/t/pitch-safely-sending-non-sendable-values-across-isolation-domains/66566" target="_blank" rel="noopener">Pitch 跨隔离域安全发送非“可发送”值</a>，了解编译器如何增强此功能的示例。</p><p>我同意你的观点，只要我们排除异步代码中不安全的行为，这种使用模式可能是安全的，但此时我仍然不愿意删除注释。</p><p>6) 讨论<a href="https://forums.swift.org/t/whats-the-recommended-way-to-write-a-tcp-client-application/67433" title="编写 TCP 客户端应用程序的推荐方法是什么？" target="_blank" rel="noopener">编写 TCP 客户端应用程序的推荐方法是什么？</a></p><p>我需要为 TCP/IP 上的自定义专有协议编写一个客户端。 我希望它能够在 macOS、iOS 和 Linux 上使用。 推荐的方法是什么？</p><p>我有一组现有的 Objective-C 代码来执行此操作，并且我只使用原始 BSD 套接字。 它们很简单，并且由于不需要是高性能服务器，所以我非常乐意阻塞：我只需将代码粘贴在 NSOperation 中，在串行 NSOperationQueue 上运行它，并使用回调来传递结果。 在 Swift 中使用 BSD 套接字感觉就像我在与该语言作斗争：很多都陷入了 UnsafePointer 领域。</p><p>我查看了 Mojave 和 Swift-NIO 中引入的网络框架，但在这两种情况下，我真的不确定如何构建客户端。 我需要做很多来回操作：向事物发送命令，读回响应，发送下一个命令，读取响应等。通过单个通道读取处理程序（在 Swift-NIO 的情况下）感觉所有内容， 再次，就像我做错事一样。</p><p>有谁知道 Swift-NIO 类似的来回通信示例吗？ 或者我看错了方向？</p><p><strong>回答</strong></p><p>自从我上次查看我的代码以来已经过去很长时间了，我确信自那时起 API 已经发生了很大的变化，但对我帮助最大的是查看 Java 的 Netty 文档。 Swift-NIO 现在似乎有相当好的文档，所以我会先阅读一下。</p><p>同样，它已经很老了，而且事情可能已经发生了变化，但这里有一个简单的示例，说明 Swift-NIO 客户端和处理程序类如何<a href="https://github.com/jonathanwong/TCPClient/tree/master/Sources/TCPClient" title="协同工作" target="_blank" rel="noopener">协同工作</a>。 这个默认实现会让你遇到你提到的确切问题，但是如果你在 TCP 客户端类之外声明通道、处理程序、事件循环等，你可以处理处理程序类中发生的更改，例如断开连接或接收消息， 在客户端类的其他方法中。 我不确定这是否是“正确”的处理方式，但它足以让它在我正在构建的应用程序中顺利运行。</p><p>你可能会考虑由 IBM 开发并在 macOS、iOS 和 Linux 上运行的 BlueSocket。</p><p>我向这个库添加了对 Windows 的支持，并以 GreenSocket 的名称提供。</p><p>BlueSocket 此处（macOS、iOS、Linux）：<br><a href="https://github.com/Kitura/BlueSocket" target="_blank" rel="noopener">https://github.com/Kitura/BlueSocket</a><br><a href="https://github.com/litewrap/GreenSocket" target="_blank" rel="noopener">https://github.com/litewrap/GreenSocket</a></p><p>7) 讨论<a href="https://forums.swift.org/t/can-protocol-extension-define-class-api-overrides/67404/3" title="协议扩展可以定义类 API 覆盖吗？" target="_blank" rel="noopener">协议扩展可以定义类 API 覆盖吗？</a></p><p>我有几个符合协议的 UIViewController 子类（它们不共享相同的父类）。 我想添加几个 UIViewController API 重写的默认实现，以避免在每个子类中重写它们。 无论如何要让这项工作成功吗？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StylingController</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StylingController</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">        </span><br><span class="line">        becomeFirstResponder()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidDisappear(animated)</span><br><span class="line">        </span><br><span class="line">        resignFirstResponder()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>在这种情况下，只需创建两个父类而不是一个：一个基于 UIViewController，另一个基于 UITableViewController。 如果有很多重叠的功能，并且希望它尽可能DRY，可以进一步将通用功能提取到协议扩展中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseViewController</span>: <span class="title">UIViewController</span>, <span class="title">CommonVCFunctionality</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">        commonVCFunctionality()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTableViewController</span>: <span class="title">UITableViewController</span>, <span class="title">CommonVCFunctionality</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">        commonVCFunctionality()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CommonVCFunctionality</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">commonVCFunctionality</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CommonVCFunctionality</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">commonVCFunctionality</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/09/19/thread-safety-in-swift-with-actors/" title="Swift 中使用 actors 实现线程安全" target="_blank" rel="noopener">Swift 中使用 actors 实现线程安全</a></p><p><strong>摘要：</strong>  本文介绍了在 Swift 中使用 actors 实现线程安全的方法。首先，文章回顾了 Store 类型的定义，它允许我们可预测地实现状态管理，但这个类型不是线程安全的。为了解决这个问题，文章使用了一个 NSRecursiveLock 类型的实例来确保线程安全。然而，作者指出使用锁存在一些缺点，并引入了 actors 这个新的 Swift 语言特性。介绍了如何使用 actors 以及与使用锁相比的优点，并讨论了 actor 的重入问题。最后总结了actors在 Swift 中的重要性和优势。</p><p><a href="https://onevcat.com/2023/08/observation-framework/" title="深入理解 Observation - 原理，back porting 和性能" target="_blank" rel="noopener">深入理解 Observation - 原理，back porting 和性能</a></p><p><strong>摘要：</strong>  喵神这篇文章讨论了 SwiftUI 中的状态管理，特别是引用类型的状态管理，以及 Apple 在 iOS 14 中推出的新 Observation 框架。Observation 框架可以在 View 中实现属性粒度的订阅，避免不必要的刷新。它实质上通过添加 @ObservationTracked 宏将存储属性转换为计算属性，并添加与 ObservationRegistrar 相关的内容来实现。通过阅读本文，你将更了解 SwiftUI 中的新 Observation 框架及其优势。</p><p><a href="https://juejin.cn/post/7281159113882320915?searchId=20230922142040421750A2476F6B944434" title="货拉拉 iOS 用户端 10 万分位 Crash 率攻坚之战" target="_blank" rel="noopener">货拉拉 iOS 用户端 10 万分位 Crash 率攻坚之战</a></p><p><strong>摘要：</strong> 该文主要介绍了货拉拉 iOS 用户端在 Crash 治理方面的经验和技术方案。文章探讨了 iOS 平台下 Crash 监控方案的优缺点，并分享了自建 Crash 监控平台的思路和经验。随后，总结了 Crash 治理的思路和经验，包括分级治理、版本追踪、定期分析和团队合作。最后，文章分享了常见的 Crash 类型及其解决方案，并总结了长期 Crash 治理的经验和收益。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>中秋遇上了国庆，诗和远方开始了躁动，假期将至，你准备怎么过？</strong></p><ol><li>旅游团已报名，攻略方案已熟记，静待启程，我的青春我做主。</li><li>老婆孩子，三餐四季，和生活对线，已倾尽了所有，钱包已然羞涩，岁月静好足矣。</li><li>钱不钱的无所谓，主要是我爬山嫌累，涉水呛口，梦想也是会变的嘛，西瓜啤酒，空调刷剧也是极好的。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十八期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;三餐四季，春夏秋冬，平凡如尔，与众不同。&lt;strong&gt;Swift社区&lt;/strong&gt;陪你苦尽甘来，笑看山河星月！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果自研调制解调器芯片受挫：速度太慢容易过热，落后高通3年&lt;/p&gt;
&lt;p&gt;提案：在导入声明上使用访问级别修饰符&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Swift 测试的新方法&lt;/p&gt;
&lt;p&gt;推荐博文：Swift 中使用 actors 实现线程安全&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;中秋遇上了国庆，诗和远方开始了躁动，假期将至，你准备怎么过？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十七期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十七期/</id>
    <published>2024-03-06T07:56:43.000Z</published>
    <updated>2024-03-06T08:03:34.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十七期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>浅尝辄止必将黯然神伤，坚持不懈终会柳暗花明。<strong>Swift社区</strong>值得与之同行，一起成就卓越！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果跌近 3% 市值两天蒸发 1898亿 美元</p><p>提案：包迭代提案正在审查</p><p>Swift 论坛：提议用户定义的元组一致性</p><p>推荐博文：Swift 中的线程安全性和使用锁的方法</p><p><strong>话题讨论：</strong> </p><p>HUAWEI Mate 60 Pro 和 iPhone 15 你会如何选择？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/dc237f3b-c4d9-405f-96ef-1e913c5cfed3.jpg" alt=""></p><p>这个结果反映了人们对核污水排放问题的担忧，以及对个人健康和环境保护的重视。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果跌近-3-市值两天蒸发-1898-亿-美元"><a href="#苹果跌近-3-市值两天蒸发-1898-亿-美元" class="headerlink" title="苹果跌近 3% 市值两天蒸发 1898 亿 美元"></a>苹果跌近 3% 市值两天蒸发 1898 亿 美元</h3><p>苹果股价连续两天大跌，实属罕见。截至收盘，苹果报 177.56 美元，跌幅 2.92% ，最新市值 2.8万 亿美元。苹果连续两天累计跌幅 6.5% ，其市值两天蒸发 1898 亿 美元（约 13911 亿元）。</p><p><img src="https://files.mdnice.com/user/17787/bc24b290-75fc-4510-87fc-c43c618683ec.png" alt=""></p><p>消息面上，据中国基金报，一方面，下周公布 iPhone 15 系列手机，会跟目前卖爆的华为手机形成激烈竞争，另一方面有报道称 iPhone 手机在某些场合已被禁用。</p><p>另据报道，欧盟公布最严数字监管名单，苹果等科技巨头名列其中。</p><p>据上海证券报，欧盟将于周三公布首批受《数字市场法案》（简称 DMA ）监管的服务清单。这份清单将列出部分“守门人”，即处于绝对垄断地位的科技巨头。目前苹果、微软、亚马逊、Alphabet、Meta 和三星等已经在名单上，这些公司将承担不得滥用市场支配地位打压或并购竞争对手、与竞争对手建立链接等 DMA 规定的义务。</p><p>根据 DMA 的规定，“看门人”公司指在数字市场上扮演了关键的角色，拥有巨大的市场影响力，因此需要受到更严格的监管。具体条件为：公司年营业额超过 75亿 欧元、市值超过 750 亿 欧元(820 亿 美元)，在欧盟拥有 4500万 月活用户的平台。不过，在这些原始指标之外，欧盟方面对这些规定拥有一定的自由裁量权。</p><p>与此同时，欧盟委员会还启动了四项市场调查，以进一步评估微软 Bing、Edge 和微软广告以及苹果 iMessage 是否能获豁免。</p><p>苹果公司的一位发言人表示，该公司仍然“非常担心 DMA 给我们的用户带来的隐私和数据安全风险。”“我们的重点将是如何减轻这些影响，并继续为我们的欧洲客户提供最好的产品和服务。(来源：每日经济新闻)</p><h3 id="iPhone-15-系列订单量下滑，苹果公司面临双重市场冲击"><a href="#iPhone-15-系列订单量下滑，苹果公司面临双重市场冲击" class="headerlink" title="iPhone 15 系列订单量下滑，苹果公司面临双重市场冲击"></a>iPhone 15 系列订单量下滑，苹果公司面临双重市场冲击</h3><p>9 月 4 日，根据第三方机构的消息称，苹果公司预计 2023 年下半年全球智能手机市场将呈现疲软态势，因此订购的 iPhone 15 数量可能会减少。</p><p>此前，苹果公司宣布 2023 年的秋季新品发布会时间为北京时间 9 月 13 日凌晨一点，备受瞩目的 iPhone 15 系列智能手机也将在发布会上正式亮相。</p><p><img src="https://files.mdnice.com/user/17787/ef172311-dad7-475b-970b-f0a0d0723110.png" alt=""></p><p>随着发布会的时间临近，iPhone 15 系列的供应链备货情况也受到行业关注。</p><p>有分析师透露称，苹果公司在今年 8 月份就已经向供应链下达了 iPhone 15 系列在今年下半年的订单，订单量在 8000 万部到 9000 万部之间。</p><p>然而，2022 年 8 月份 iPhone 14 即将亮相的时候，苹果公司向供应链下达的 iPhone 14 系列订单在 9000万 部到 1 亿部之间，如今 iPhone 15 的订单量，相比去年 iPhone 14 的订单出现了大幅下滑！</p><p>8 月份的时候，苹果公司下达订单量主要考虑的是下半年的市场情况。对于订单量的下滑，苹果公司给出的原因是全球智能手机市场的疲软。</p><p>根据 Canalys 发布的研究数据显示，2023 年上半年，全球智能手机出货量达 5.28 亿部，同比下降 12% ，中国智能手机市场的出货量为 1.32 亿部，同比下滑 8% 。</p><p>无论是中国手机市场，还是全球手机市场，都没有从手机行业的下行中走出来，出货量仍在下跌。(来源：腾讯网新行情Pro)</p><h3 id="苹果的对手回来了"><a href="#苹果的对手回来了" class="headerlink" title="苹果的对手回来了"></a>苹果的对手回来了</h3><p>8 月 29 日中午，在没有任何预告、发布会的情况下，华为官方发布了《致华为用户的一封信》，信中称华为推出了“ HUAWEI Mate 60 Pro 先锋计划”，当天 12 时 08 分在华为商城正式上线华为 Mate 60 Pro。</p><p><img src="https://files.mdnice.com/user/17787/4332804f-27e3-47a3-b423-21d0c4357d26.png" alt=""></p><p>虽然毫无征兆，但是华为 Mate 60 Pro 依然受到了广泛关注，华为的消息一下子就冲上了微博热搜。</p><p>随后，在短短几个小时之内，华为商城首批 Mate 60 Pro 就被抢购一空，无数网友直呼华为赶紧出下一批！</p><p>更令人惊喜的是，华为 Mate 60 Pro 的网速已经达到了 5G 水平，还有卫星通话功能，这预示着手机内的芯片质量已经达到了 5G 芯片水平，华为真正劫后重生，王者归来。</p><p>这一下子，苹果公司直接慌了神，慌慌张张地宣布将于 9 月 13 日发布 iPhone 15 系列手机，作为对华为发布新手机的对冲。</p><p>苹果公司和华为，可以说是手机行业的老对手了。2019 年，如果不出意外的情况下，华为当年的手机销量、市场份额将会全面超越苹果，成为全球第一大手机厂商。</p><p>然而，在那之后所有人都看到了，华为的供应链出现了危机，不得不将荣耀子品牌脱离，甚至在手机全面进入 5G 时代的时候，只能推出 4G 的手机。</p><p>今年上半年，华为手机的销量已经彻底跌出了行业前 7 的位置，业内一度认为华为有可能会退出手机行业了。</p><p>然而，如今华为真正攻克了难关，携 Mate 60 王者归来，直接震撼了全球手机市场！</p><p>9 月 4 日，据媒体报道称，华为已将 Mate 60 系列手机的订单量提升至 1500 - 1700 万台。</p><p>业内人士预测，Mate 60 Pro 将有望成为华为 Mate 系列销量最高的手机，最终的订单量将在 1700 万台左右。(来源：腾讯网新行情Pro)</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0405-string-validating-initializers.md" title="SE-0405" target="_blank" rel="noopener">SE-0405</a> <strong>具有编码验证的 String Initializers</strong> 提案通过审查。该提案已在 <strong>三十五期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0408-pack-iteration.md" title="SE-0408" target="_blank" rel="noopener">SE-0408</a> <strong>包迭代</strong> 提案正在审查。</p><p>在基于值和类型参数包提案 SE-0393 的基础上，这个提案使允许在值参数包中对每个元素进行迭代，并使用 <code>for-in</code> 语法将每个值绑定到本地变量。</p><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0403-swiftpm-mixed-language-targets.md" title="SE-0403" target="_blank" rel="noopener">SE-0403</a> <strong>软件包管理器混合语言目标支持</strong> 提案被驳回。该提案已在 <strong>三十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-user-defined-tuple-conformances/67154" title="用户定义的元组一致性" target="_blank" rel="noopener">用户定义的元组一致性</a></p><p><strong>介绍</strong></p><p>元组无法符合当今的协议，这以明显的限制形式表现出来，例如无法使用可哈希值的元组作为字典键。</p><p><strong>动机</strong></p><p>SE-0283 的动机先前解决了元组符合某些标准库协议的愿望，该动机提出了对 Equatable、Comparable 和 Hashable 元组的内置语言支持。 独立地，Swift 并发工作添加了一个语言扩展，其中可发送值的元组本身就是可发送的。 我们建议将所有这些特殊情况行为与用户定义的元组一致性统一起来，现在可以使用参数包（SE-0393）来表达。 SE-0283 和 SE-0393 都将元组一致性列为未来方向。</p><p><strong>建议的解决方案</strong></p><p>我们建议引入参数化扩展语法，如泛型宣言中所述。 在一种特定情况下，允许使用此语法以最通用的形式声明元组一致性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> &lt;<span class="title">each</span> <span class="title">T</span>&gt; (<span class="title">repeat</span> <span class="title">each</span> <span class="title">T</span>): <span class="title">P</span> <span class="title">where</span> <span class="title">repeat</span> <span class="title">each</span> <span class="title">T</span>: <span class="title">P</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>我们还将允许描述元组的通用类型别名通过条件一致性进行扩展； 我们建议将以下元组类型别名添加到标准库中以方便实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Tuple</span>&lt;each <span class="type">Element</span>&gt; = (<span class="keyword">repeat</span> each <span class="type">Element</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Tuple</span>: <span class="title">Shape</span> <span class="title">where</span> <span class="title">repeat</span> <span class="title">each</span> <span class="title">Element</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">repeat</span> (each <span class="keyword">self</span>).draw()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回想一下，协议中的要求是由具体符合类型的见证人实现的。 在上面，我们声明了一个元组扩展，因此draw()的见证者在元组上实现了协议要求 draw()。 实际的实现对每个元素调用 draw()，它本身符合 Shape。 请注意在 draw() 主体的重复模式中每个 self 的使用。</p><p><strong>详细设计</strong></p><p>任何未标记元组都可以通过“最通用”未标记元组类型的类型替换来获得。 如果每个 T 都是某种类型参数包，则这个最通用的类型是（重复每个 T）； 即，由每个 T 的元素的包扩展形成的元组类型。</p><p>如今，扩展的扩展类型必须是名义类型，无论是结构、枚举、类还是协议。 我们建议允许扩展最通用的元组类型； 这称为元组扩展。 由于扩展可以声明协议一致性，因此元组扩展可以实现最通用元组类型的协议要求。 这称为元组一致性。</p><p>这意味着元组扩展中 self 的类型是（重复每个 T），其中每个 T 是声明一致性的扩展的通用参数。 由于 SE-0399，对包扩展表达式中每个 self 的引用将扩展到元组的元素上。</p><p>与结构、枚举和类的扩展一样，元组扩展中的 Self 指的是 self 的类型，即（重复每个 T）。</p><p>一旦声明了对某个协议 P 的元组一致性，只要元组的元素满足元组一致性的条件要求，任意元组类型都将满足 P 的一致性要求。 我们将在下面看到，条件要求必须恰好由重复每个 T:P 的一个要求组成。当对元组类型的值调用协议要求时，由元组类型的元素形成一个包； 这成为调用协议见证中每个 T 的通用参数。</p><p><strong>孤儿规则</strong></p><p>在大多数情况下，元组一致性的行为就好像它们是标准库类型上的用户定义的追溯一致性。 特别是，两个模块定义两个不同的元组符合同一协议是无效的。 因此，我们禁止元组符合定义模块之外的协议。</p><p><strong>单元素元组展开</strong></p><p>根据参数包提案中规定的规则，单元素元组类型在替换后展开。 这意味着元组一致性必须与此展开保持一致。</p><p>这对元组一致性可以采取的形式施加了一些限制。 我们可以通过交换图的形式理解以下所有限制。 最上面一行显示了最通用的元组类型、相应的元组一致性以及某些关联类型 A 的见证。现在，我们对每个对象应用替换，将每个 T 的类型参数包替换为包含单个具体类型的包， 说 X。我们要求图中所有在同一对象处开始和结束的路径都产生相同的结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">repeat</span> each <span class="type">T</span>) ---&gt; [(<span class="keyword">repeat</span> each <span class="type">T</span>): <span class="type">P</span>] ---&gt; (<span class="keyword">repeat</span> each <span class="type">T</span>).<span class="type">A</span></span><br><span class="line">      |                        |                        |</span><br><span class="line">      |                        |                        |</span><br><span class="line">      v                        v                        v</span><br><span class="line">      <span class="type">X</span> -------------------&gt; [<span class="type">X</span>: <span class="type">P</span>] -----------------&gt; <span class="type">X</span>.<span class="type">A</span></span><br></pre></td></tr></table></figure><p>具体而言，这些限制如下：</p><ul><li><p>元组扩展必须声明符合一个协议。</p></li><li><p>此一致性的条件要求必须精确重复每个 T: P，其中每个 T 是扩展的类型参数包，P 是一致性协议。</p></li><li><p>也就是说，一个元组扩展扩展 Tuple: P ，其中重复每个 T: Q 是没有意义的，因为在单元素情况下，它会衰减到 X: P 其中 X: Q; 当 P 和 Q 可能是不相关的协议时，一般情况下该陈述是错误的。</p></li><li><p>P 的关联类型要求 A 必须由其底层类型恰好为 (repeat (each T).A) 的类型别名见证； 也就是说，从每个元素投影 A 的元组类型。</p></li></ul><p>也就是说，如果 X.A 是 Int，Y.A 是 String，那么我们别无选择，只能要求 (X, Y).A 等于 (Int, String)。<br>请注意，由于所有这些规则，空 tuple() 将符合每个具有元组一致性的协议。</p><p><strong>动态行为</strong></p><p>上述规则使我们能够保证元组一致性见证永远不会被单元素包调用，在这种情况下调用将直接转发到元素一致性。 因此，元组一致性中 Self 的运行时类型必须始终是真正的元组类型，而不是未包装的元素。</p><p>如果某个函数本身使用参数包从包中形成元组值，则对该值调用协议要求将调用元组一致性见证或单个元素的见证，具体取决于包的大小。</p><p><strong>标记元组和方差</strong></p><p>元组标签不是参数包可以抽象的东西。 然而，表达式类型系统定义了标记元组和相应的未标记元组之间的子类型关系。</p><p>与类类比，如果在非最终类 C 上声明了一致性，并且存在 D 继承自 C 的子类关系，则该一致性也被 D 继承。</p><p>为了在类继承的情况下用 D 替换 C 是有效的，我们要求 Self 仅用于协变或逆变位置，而不是不变的。 因此，我们必须对元组施加与当前对非最终类相同的限制。</p><p>这允许以下操作：</p><ul><li>符合 Equatable 等协议，Self 出现在参数位置。</li><li>符合假设的 Clonable 协议，具有返回 Self 的 <code>func clone() -&gt; Self</code> 要求。</li></ul><p>另一方面，这是禁止的：</p><ul><li>符合要求Self位置不变的协议，例如 <code>func f() -&gt; G&lt;Self&gt;</code>。</li></ul><p>在这种情况下，采用标记元组并将 <code>G&lt;&gt;</code> 应用于相应的未标记元组类型并不完全合理。</p><p><strong>使用范围</strong></p><p>由于上面概述的微妙的静态和动态行为，我们期望元组一致性仍然是一项高级功能。 对于许多目的，最好通过 SE-0398 声明一个特殊用途的可变参数泛型结构，并使其符合协议，因为这提供了完全的灵活性，而不会在一致性方面出现任何复杂情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EggFactory</span>&lt;<span class="title">each</span> <span class="title">Bird</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EggFactory</span>: <span class="title">OmletMaker</span> <span class="title">where</span> <span class="title">repeat</span> <span class="title">each</span> <span class="title">Bird</span>: <span class="title">Chicken</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此模式还允许可变参数类型定义自定义构造函数和访问器以强制不变量等。</p><p>元组应该只符合具有明显“代数”实现的协议，该实现以归纳方式推广到元素类型的所有组合，例如上面讨论的三个标准库协议。</p><p>例如，使元组符合 IteratorProtocol 可能不是一个好主意，因为至少有两个明显的实现； 要么是压缩，要么是串联（在这种情况下，我们还需要要求所有序列具有相同的元素类型，这是元组一致性甚至无法表达的）。</p><p>2) 讨论<a href="https://forums.swift.org/t/is-dispatchprecondition-a-reasonable-way-to-implement-an-unchecked-sendable-type/67159" title="dispatchPrecondition 是实现 @unchecked Sendable 类型的合理方法吗？" target="_blank" rel="noopener">dispatchPrecondition 是实现 @unchecked Sendable 类型的合理方法吗？</a></p><p>我正在尝试提高我对何时使用 <code>@unchecked Sendable</code> 有意义的理解。</p><p>举个例子，使用 <code>dispatchPrecondition</code> 保证值只能在主线程上读取或修改：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A wrapper that guaruntees that its value is only read or modified on the main thread.</span></span><br><span class="line"><span class="comment">/// For simplicity assume `T` is a value type.</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">T</span>) &#123;</span><br><span class="line">    dispatchPrecondition(condition: .onQueue(.main))</span><br><span class="line">    _value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> value: <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      dispatchPrecondition(condition: .onQueue(.main))</span><br><span class="line">      <span class="keyword">return</span> _value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      dispatchPrecondition(condition: .onQueue(.main))</span><br><span class="line">      _value = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _value: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于讨论，我们假设包装的值是值类型（而不是引用类型），因此我们不需要考虑不经过值设置器的修改。</p><p>使用 <code>@unchecked Sendable</code> 一致性将该类型设置为可发送是否合理？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Is this reasonable, given the expectations of Sendable?</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainThreadWrapper</span>: @<span class="title">unchecked</span> <span class="title">Sendable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>使用这种类型时不可能出现数据竞争。 如果在错误的线程上使用了不正确的类型（例如，在主要参与者之外的任务中），<code>dispatchPrecondition</code> 将失败并阻止不允许的使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotSendable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper = <span class="type">MainThreadWrapper</span>(<span class="type">NotSendable</span>(value: <span class="string">"foo"</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">  <span class="comment">// Allowed by the compiler since wrapper is Sendable, </span></span><br><span class="line">  <span class="comment">// but a triggers a runtime error:</span></span><br><span class="line">  <span class="built_in">print</span>(wrapper.value)</span><br><span class="line"></span><br><span class="line">  await <span class="type">MainActor</span>.run &#123;</span><br><span class="line">    <span class="comment">// Safe, prints "NotSendable(value: "foo")"</span></span><br><span class="line">    <span class="built_in">print</span>(wrapper.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于这种类型可以安全地跨并发域传递，而不会出现数据竞争，我倾向于认为这是 <code>@unchecked Sendable</code> 的合理用例。</p><p>人们怎么看？ 我特别有兴趣听到任何潜在的反驳意见。</p><p><strong>回答</strong></p><p>这里的包装器确实保证了底层数据的“安全”，但如果该类型在主队列之外使用过，它会崩溃。 这仅适用于声明为 <code>@MainActor</code> 的类型…但是一旦你以这种方式对其进行注释，那么你就已经获得了跨并发域的保证，即你将成为主要演员。</p><p>关于“安全”对你意味着什么，<code>@unchecked Sendable</code> 是一个承诺，你的类型可以在任何并发域中使用，并且仍然保护其自己的状态。 我认为这样标记你的包装纸是不正确的。 它仍然只能安全地从主队列使用。 （如果不是这种情况，它就会快速而有效地崩溃。）</p><p>3) 讨论<a href="hhttps://forums.swift.org/t/swift-wont-compile-dictionary-with-referencewritablekeypath-unless-its-a-class-property/67148" title="Swift 不会使用 ReferenceWritableKeyPath 编译dictionary，除非它是一个类属性" target="_blank" rel="noopener">Swift 不会使用 ReferenceWritableKeyPath 编译dictionary，除非它是一个类属性</a></p><p>这段代码编译可以通过：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span>Members <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DriversLicense1</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="built_in">map</span>: [<span class="type">String</span>: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">DriversLicense1</span>, <span class="type">String</span>&gt;] = [</span><br><span class="line">        <span class="string">"DAA"</span>: \<span class="type">DriversLicense1</span>.nameFull,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> nameFull: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (key, keyPath) <span class="keyword">in</span> <span class="built_in">map</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>[keyPath: keyPath] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这段代码编译不能通过 - 错误是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert value of type '<span class="type">KeyPath</span>&lt;<span class="type">DriversLicense2</span>, <span class="type">String</span>&gt;' to expected dictionary value type '<span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">DriversLicense2</span>, <span class="type">String</span>&gt;'</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">let</span> <span class="built_in">map</span>: [<span class="type">String</span>: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">DriversLicense2</span>, <span class="type">String</span>&gt;] = [</span><br><span class="line">    <span class="string">"DAA"</span>: \<span class="type">DriversLicense2</span>.nameFull,</span><br><span class="line">]</span><br><span class="line"><span class="meta">@objc</span>Members <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DriversLicense2</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> nameFull: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (key, keyPath) <span class="keyword">in</span> <span class="built_in">map</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>[keyPath: keyPath] = key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么？</p><p><strong>回答</strong><br>这绝对感觉像是一个诊断可能更有帮助的地方 - 如果你尝试直接在同一位置使用设置器，你会得到更好的消息：</p><p>无法分配给属性：“nameFull”设置器无法访问</p><p>似乎我们可以查看尝试 <code>KeyPath -&gt; (Reference)WritableKeyPath</code> 转换的情况，并提供特殊的诊断，如果我们可以在 setter 在当前范围内可见的情况下形成适当的可写密钥路径。</p><p>4) 讨论<a href="https://forums.swift.org/t/unable-to-call-swift-extension-method-from-objective-c-class/67174" title="无法从 Objective C 类调用 swift 扩展方法" target="_blank" rel="noopener">无法从 Objective C 类调用 swift 扩展方法</a></p><p>我为 ViewController 类创建了 swift 扩展，并在其中定义了一种方法。 当我尝试从同一个 Obj-c ViewController 调用相同的方法时，它给出了以下错误：</p><p><code>ViewController</code> 没有可见的 <code>@interface</code> 声明选择器 <code>testMe</code></p><p>我的代码如下：</p><p>Objective-C类</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface <span class="type">ViewController</span> : <span class="type">UIViewController</span></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation <span class="type">ViewController</span></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> testMe]; <span class="comment">// No visible @interface for 'ViewController' declares the selector 'testMe'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Swift extension:<br>// ViewController+extnesion.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testMe</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Vish"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>你的 .m 文件需要导入 Swift 编译器发出的兼容性标头。</p><p>5) 讨论<a href="https://forums.swift.org/t/generic-struct-using-type-pack-cant-store-closure-using-same-type-pack-in-property/67145" title="使用类型包的通用结构无法在属性中使用相同类型包存储闭包" target="_blank" rel="noopener">使用类型包的通用结构无法在属性中使用相同类型包存储闭包</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&lt;<span class="title">each</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> foo: (<span class="keyword">repeat</span> each <span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(</span><br><span class="line">        fn: @escaping (<span class="keyword">repeat</span> each <span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.foo = fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器使用 Xcode 15.0 beta 8 (15A5229m) 和 swift-DEVELOPMENT-SNAPSHOT-2023-09-04-a 工具链响应以下消息</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: type of expression <span class="keyword">is</span> ambiguous without a type annotation</span><br><span class="line">        <span class="keyword">self</span>.foo = fn</span><br><span class="line">        ~~~~~~~~~^~~~</span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7275590714712883256?searchId=20230908113707B1CB34D5F133E8B64AD9" title="SwiftDataKit：让你在 SwiftData 中使用 Core Data 的高级功能" target="_blank" rel="noopener">SwiftDataKit：让你在 SwiftData 中使用 Core Data 的高级功能</a></p><p><strong>摘要：</strong>  SwiftDataKit 旨在帮助开发者在 SwiftData 中使用 Core Data的高级功能。由于 SwiftData 是 Core Data 的继任者，它在多个方面都对 Core Data 进行了改进和扩展。然而，当前版本的 SwiftData 还不能完全实现 Core Data 的所有高级功能，这对一些开发者而言可能是一个困扰。</p><p>为了解决这个问题，作者创建了 <code>SwiftDataKit</code> 库，通过提取 SwiftData 中底层的 Core Data 对象，使开发者能够在 SwiftData 中使用 Core Data 的高级功能 </p><p><a href="https://swiftwithmajid.com/2023/09/05/thread-safety-in-swift-with-locks/" title="Swift 中的线程安全性和使用锁的方法" target="_blank" rel="noopener">Swift 中的线程安全性和使用锁的方法</a></p><p><strong>摘要：</strong>  这篇文章讨论了 Swift 中的线程安全性和使用锁的方法。首先介绍了线程安全性的重要性，并提到了在代码库中发现的相关问题。接着通过一个简单的示例代码演示了状态管理的概念，并说明了这种代码可能导致数据竞争和竞争条件的情况。</p><p>为了解决这个问题，作者介绍了使用锁机制来控制对共享变量的并发访问。为了实现线程安全，博客展示了如何在 Swift 中使用 <code>OSAllocatedUnfairLock</code> 和 <code>NSRecursiveLock</code> 两种类型的锁。最后，博客总结了保证类的线程安全性的重要性，并鼓励在开发过程中早期就投入时间来构建类型安全的代码。</p><p><a href="https://juejin.cn/post/7275225666029797433?searchId=20230908125940173984B583F745BF08A0" title=" Swift 语言底层原理剖析 - Array 系列-高阶函数" target="_blank" rel="noopener"> Swift 语言底层原理剖析 - Array 系列-高阶函数</a></p><p><strong>摘要：</strong> 文章介绍了Swift的数组中的 <code>filter</code>, <code>forEach</code>, <code>map</code> , <code>compactMap</code>, <code>flatMap</code>, <code>reduce</code> 等函数内部源码，剖析实现逻辑。Array系列的高阶函数其实是 <code>Collection</code> 的高阶函数，同样适合与 <code>Dictionary</code> ， Set 等其他集合类型。整体的设计也比较巧妙，用到了很多 Swift 特有的 <code>Protocol</code> 特性，对我们日后设计 Swift代 码也会有一些启发。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>近期华为推出了“ HUAWEI Mate 60 Pro 先锋计划”，真正劫后重生，王者归来。而苹果公司将于 9 月 13 日发布 iPhone 15 系列手机，真正的王者碰撞开始了，那么假如你近期考虑换手机的话，你会如何选择呢？</p><p>1.果粉无需抉择，犹豫一秒都是对苹果的不尊重。<br>2.果断选华为呀，超高的性价比，绝对理性的选择。<br>3.我觉得一两千块钱的小米就挺好的，我再买两斤排骨不香吗？</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十七期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;浅尝辄止必将黯然神伤，坚持不懈终会柳暗花明。&lt;strong&gt;Swift社区&lt;/strong&gt;值得与之同行，一起成就卓越！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果跌近 3% 市值两天蒸发 1898亿 美元&lt;/p&gt;
&lt;p&gt;提案：包迭代提案正在审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议用户定义的元组一致性&lt;/p&gt;
&lt;p&gt;推荐博文：Swift 中的线程安全性和使用锁的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;HUAWEI Mate 60 Pro 和 iPhone 15 你会如何选择？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十六期/</id>
    <published>2024-03-06T07:56:38.000Z</published>
    <updated>2024-03-06T08:03:05.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十六期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>一米阳光下阴雨绵绵，一米阳光上晴空万里，这就是生活。<strong>Swift社区</strong>伴你一起，走过风雨，沐浴暖阳！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通</p><p>提案：对 AsyncStream 的 Backpressure 支持</p><p>Swift 论坛：提议全局变量的严格并发</p><p>推荐博文：WWDC23 10105 - 打造响应更快的相机体验</p><p><strong>话题讨论：</strong> </p><p>日本核污水排海，你还会吃海鲜吗？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/85a89025-a0a8-48f0-bffe-bd7f7a5acde8.jpeg" alt=""></p><p>根据投票结果可以看出，大家有不同的想法。小编认为家长应该根据孩子的个性特点和兴趣爱好灵活调整，注重培养他们的创新精神和独立思考能力。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能"><a href="#消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能" class="headerlink" title="消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能"></a>消息称苹果公司和印度财政部官员磋商，扩大在印度的制造产能</h3><p>8 月 25 日消息，根据印度当地媒体 Business Today 报道，苹果印度地区的高管已经和当地财政部会面，探讨扩大 iPhone 在印度产能相关事宜。</p><p>消息称本次探讨涉及面很广，印度政府希望以苹果公司带头下，进一步推动本土智能手机制造业，并磋商相关的扶持政策。</p><p>而苹果公司在交流中也表示，印度是非常重要的生产地和消费市场，乐于扩大在印度市场的产能，但希望能获得更多的补贴，以及政策福利。</p><p>IT之家此前报道，根据市场调查机构 Counterpoint Research 公布的统计数据，2023 年第 2 季度印度市场营收表现首次超过法国和德国，成为苹果第五大 iPhone 市场。</p><p>苹果 iPhone 零售业在印度市场的快速增长的同时，苹果也加快了 iPhone 在印度制造的脚步。苹果加大了在印度市场的投资力度，希望供应链实现多元化发展。（来源：IT之家）</p><h3 id="iPhone-15-Pro-机型新增泰坦灰"><a href="#iPhone-15-Pro-机型新增泰坦灰" class="headerlink" title="iPhone 15 Pro 机型新增泰坦灰"></a>iPhone 15 Pro 机型新增泰坦灰</h3><p>新渲染图曝光，消息称苹果 iPhone 15 Pro 机型泰坦灰将替代金色 iPhone15Pro新增灰色。8 月 25 日消息，根据国外科技媒体 9to5Mac 报道，苹果今年将调整 iPhone 15 Pro 和 iPhone 15 Pro Max 两款机型的颜色选项，取消金色，新增灰色。<br>在最新报道称这种全新灰色官方名称为“泰坦灰”（Titan Gray），并分享了这种颜色的概念渲染图，可以看到“泰坦灰”颜色要比现有的银色 / 白色更深一些，但比深空黑要更淡一些。<br>该媒体还透露苹果今年推出的 iPhone 15 Pro 机型将会取消暗紫色，并由深蓝色替代。<br>注： iPhone 14 Pro 机型共有暗紫色、金色、银色和深空黑四种颜色。<br>苹果预估将于 9 月 12 日发布 iPhone 15 系列，其中 iPhone 15 系列标准版将有黑色，绿色，蓝色，黄色和粉红色。（来源：IT之家）</p><p><img src="https://files.mdnice.com/user/17787/1e3e2489-9b4e-4202-8189-a234f10d0559.png" alt=""></p><h3 id="iPhone-15-全系配-USB-C-苹果拒绝接口和安卓互通"><a href="#iPhone-15-全系配-USB-C-苹果拒绝接口和安卓互通" class="headerlink" title="iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通"></a>iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通</h3><p>8月19日消息，据供应链最新消息称，iPhone 15 全系将会配备 USB-C 接口，不过不同型号会被差异对待。</p><p>按照供应链说法，iPhone 15 标准版只是配备普通版本的 USB-C 接口，而 iPhone 15 Pro 系列则在速度上有明显的提升，同时这个功能只能在 MFi 认证的 USB 数据线下发挥功效。</p><p>具体来说就是，iPhone 15 标准版提供 USB 2.0 版本，传输速度最高 480 Mbps，与之前的 Lightning 接口差不多。而 iPhone 15 Pro 系列用的是 USB 3.2，传输速度能达到 20 Gbps，比标准版快 20 倍以上。</p><p>对于消费者来说，这将是多年来 iPhone 系列手机最大的改进之一。配备该端口后，iPhone 用户在旅行时不再需要为手机和其他移动设备携带两根不同的充电线，不过想法是好的，但苹果却不会这么干。</p><p>按照供应链配件商的说法，苹果不会让 iPhone 15 的 USB-C 接口与安卓通用，即便是有违法的行为，但依然会如此做，毕竟 MFi 认证背后一年是几十亿美元的盈利。</p><p>此外，从苹果的备货来看，Pro 系列占比超过 60%，他们也是想从这些细节的地方卡位用户，让大家主动去买高价版本。</p><p><img src="https://files.mdnice.com/user/17787/3eab2868-eefd-4141-92c3-a3e1835847c5.png" alt=""></p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0407-member-macro-conformances.md" title="SE-0407" target="_blank" rel="noopener">SE-0407</a> <strong>成员 Macro 一致性</strong> 提案正在审查。</p><p>SE-0402中从一致性宏到扩展宏的转变包括扩展宏能够了解类型已经遵循了哪些协议(例如，因为遵循了超类或在某处声明了显式一致性)，这样宏就可以避免添加不需要的声明和一致性。这也意味着添加的任何新声明都是扩展的一部分——而不是原始类型定义的一部分——这通常是有益的，因为这意味着(例如)新的初始化器不会抑制成员初始化器。将协议一致性拆分为各自的扩展通常也被认为是一种很好的形式。</p><p>然而，有时用于一致性的成员确实需要成为原始类型定义的一部分。例如:</p><ul><li>非 final 类中的初始化项必须是必需的初始化项，以满足协议要求。</li><li>非 final 类的可重写成员。</li><li>存储的属性或大小写只能在主类型定义中。</li></ul><p>对于这些情况，成员宏可以生成声明。然而，成员宏并没有提供任何关于应该为哪种协议一致性提供成员的信息，因此宏可能会错误地尝试将一致性成员添加到已经符合协议的类型中(例如，通过超类)。这可能使某些宏(例如实现 <code>Encodable</code> 或 <code>Decodable</code> 协议的宏)无法实现。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0406-async-stream-backpressure.md" title="SE-0406" target="_blank" rel="noopener">SE-0406</a> <strong>对 AsyncStream 的 Backpressure 支持</strong> 提案正在审查。</p><p>SE-0314引入了新的 <code>Async[Throwing]Stream</code> 类型，作为根异步序列。这两种类型允许从同步回调（如委托）桥接到异步序列。该提案增加了一种构建异步流的新方法，目的是将 Backpressure 系统桥接成异步序列。此外，该提案旨在澄清消费任务取消和生产方表示终止时的取消行为。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-macro-literal-protocols/66915" title="宏文字协议" target="_blank" rel="noopener">宏文字协议</a></p><p>目前仅允许在顶层使用宏。 然而，在某些情况下，嵌套宏会很有好处。</p><p>例如，我们可以添加具有宏要求的新文字协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ExpressibleByMacroIntegerLiteral</span> </span>&#123;</span><br><span class="line">  associatedtype <span class="type">IntegerLiteralType</span>: _ExpressibleByBuiltinIntegerLiteral</span><br><span class="line"></span><br><span class="line">  @freestanding(expression)</span><br><span class="line">  macro <span class="type">Init</span>(integerLiteral: <span class="type">IntegerLiteralType</span>) -&gt; <span class="type">Self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用编译器的魔法，酱子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">Decimal</span> = <span class="number">5.3</span></span><br></pre></td></tr></table></figure><p>可以变成酱子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = #<span class="type">Decimal</span>.<span class="type">Init</span>(integerLiteral: <span class="number">5.3</span>)</span><br></pre></td></tr></table></figure><p>然后将扩大</p><p>我知道宏的设计目标之一是避免这种不可见的宏使用，但是已经有很多编译器魔法可以通过 _ 文字协议来表达，这将使它们更加通用。</p><p>例如，当前如果类型是 <code>ExpressibleByStringLiteral</code> 但只有某些字符串文字有效，则唯一的选择是在运行时遇到无效字符串文字时捕获。 这违背了文字的编译时性质，而文字应该允许检查文字。 在基金会提出将 URL 改为 ExpressibleByStringLiteral 时，这个问题在某种程度上被掩盖了，但已经完全解决了。</p><p>这个语句：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadFile(at: <span class="string">"https://apple.com"</span>)</span><br></pre></td></tr></table></figure><p>看起来比这个好很多:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadFile(at: #<span class="type">URL</span>(<span class="string">"https://apple.com"</span>))</span><br></pre></td></tr></table></figure><p>2) 提议<a href="https://forums.swift.org/t/pitch-nested-if-let-and-guard-let/66927" title="嵌套 if let 和 guard let" target="_blank" rel="noopener">嵌套 if let 和 guard let</a></p><p><strong>介绍</strong></p><p>在 Swift 中，if let 语句通常用于可选的解包。 它通过处理可选值帮助开发人员编写更干净、更安全的代码。</p><p>目前，if let 语句解包单个可选值。 然而，在某些情况下，我们希望以更简洁的方式解开嵌套对象的可选属性。</p><p>该提案建议扩展 if let 和 Guard let 语句以支持嵌套可选展开。</p><p><strong>1. if let 嵌套</strong></p><p>嵌套 if let 的拟议语法将允许开发人员有条件地解包嵌套对象的可选属性。 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> myOptionalObject?.optionalValue &#123;</span><br><span class="line">    <span class="comment">// 'optionalValue' is now safely unwrapped and ready to use // *1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the case where 'optionalValue' is nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 嵌套的 guard let</strong></p><p>类似地，所提议的嵌套 Guard Let 语法将允许开发人员有条件地解开嵌套对象的可选属性。 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> myOptionalObject?.optionalValue <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the case where 'myOptionalObject' or 'optionalValue' is nil</span></span><br><span class="line">    <span class="comment">// This could include returning from the current function, loop, or throwing an error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'optionalValue' is now safely unwrapped and ready to use // *1</span></span><br></pre></td></tr></table></figure><p>3) 提议<a href="https://forums.swift.org/t/pitch-strict-concurrency-for-global-variables/66908" title="全局变量的严格并发" target="_blank" rel="noopener">全局变量的严格并发</a></p><p><strong>介绍</strong></p><p>该提案定义了无数据竞争的全局变量的使用选项。 在此提案中，全局变量包含静态持续时间的任何存储：在全局范围内声明或作为静态成员变量声明的 let 和存储变量。</p><p><strong>动机</strong></p><p>全局状态在并发性中提出了挑战，因为它是可以从任何程序上下文访问的内存。 全局变量在数据隔离检查中受到特别关注，因为它们违背了其他强制隔离的尝试。 </p><p>本地且未捕获的变量只能从本地上下文访问，这隐式地隔离了它们。 值类型的存储属性已经通过排他性规则隔离。 </p><p>可以通过使用可发送性强制或使用参与者限制来隔离引用类型的包含对象，从而隔离引用类型的存储属性。 但全局变量可以从任何地方访问，所以这些工具不起作用。</p><p><strong>建议的解决方案</strong></p><p>在严格的并发检查下，要求每个全局变量要么与全局参与者隔离，要么两者都隔离：</p><ul><li>不可变的（immutable）</li><li>可发送类型（Sendable）</li></ul><p>immutable 并且 Sendable 的全局变量可以从任何上下文安全地访问，否则需要隔离。</p><p><strong>详细设计</strong></p><p>这些要求可以在声明时在类型检查器中强制执行。</p><p><strong>源兼容性</strong></p><p>由于增加了限制，因此在使用严格的并发检查时可能需要更改某些类型声明。 然而，此类源代码更改仍然向后兼容任何具有并发功能的 Swift 版本。</p><p><strong>ABI兼容性</strong></p><p>该提案本身不会添加或影响 ABI(Application Binary Interface)，但是它可能对采用的项目引发的类型声明更改可能会影响该项目的 ABI。</p><p><strong>对采用的影响</strong></p><p>在采用严格并发检查的项目中，可能需要修改某些全局变量类型。</p><p><strong>考虑的替代方案</strong></p><p>为了隔离，我们可以隐式锁定变量的访问，而不需要全局参与者。 在提供内存安全的同时，这可能会给线程安全带来问题，因为开发人员可以轻松编写 non-atomic 的模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value of global may concurrently change between</span></span><br><span class="line"><span class="comment">// the read for the multiplication expression</span></span><br><span class="line"><span class="comment">// and the write for the assignment</span></span><br><span class="line">global = global * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>虽然如果我们需要在旧语言模式中做一些源兼容的事情，我们可以考虑隐式锁定，但通常我们的方法只是说旧语言模式是并发不安全的。 </p><p>它也不适用于非可发送类型，除非我们强制该值在访问它时保持隔离。我们可能可以通过提议的<a href="https://forums.swift.org/t/pitch-safely-sending-non-sendable-values-across-isolation-domains/66566" title="跨隔离域安全发送不可发送值" target="_blank" rel="noopener">跨隔离域安全发送不可发送值</a>功能来实现这一目标，但这可能是一个过于先进的功能，无法作为此类基本问题的解决方案来推动。</p><p>我们可以将所有需要隔离的全局变量默认为 <code>@MainActor</code>。 可以说，让开发人员考虑选择会更好（例如，也许它应该只是一个 let 常量）。</p><p>访问控制在理论上是有用的：例如，我们可以知道全局变量是并发安全的，因为它是文件私有的，并且该文件中的所有访问都来自单个全局参与者上下文，或者因为它永远不会 变异了。 </p><p>不过，这比我们通常希望在编译器中进行的分析更加全局化； 我们必须检查上下文中的所有内容，然后开发人员可能很难理解它为什么起作用。</p><p><strong>未来发展方向</strong></p><p>我们不一定需要明确地要求隔离全球参与者； 有空间推断正确的全球行动者。 全局角色约束类型的全局可变变量可以被推断为约束到该全局角色（尽管如果变量是不可变的，则没有必要，因为全局角色约束类类型是可发送的）。</p><p>4) 讨论<a href="https://forums.swift.org/t/method-marked-with-globalactor-modifying-property-in-class/66898" title="用 globalActor 标记的方法修改类中的属性" target="_blank" rel="noopener">用 globalActor 标记的方法修改类中的属性</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Po</span> </span>&#123;</span><br><span class="line">    @<span class="type">MainActor</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>: <span class="title">Po</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">""</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        str = <span class="string">"w"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"foo: <span class="subst">\(Thread.isMainThread)</span>"</span>) <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> #available(macOS <span class="number">10.15</span>, *) &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="type">Base</span>()</span><br><span class="line">        await b.foo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">RunLoop</span>.main.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我不明白为什么我可以直接在标有MainActor的方法中修改属性？</p><p>因为这对我来说似乎是错误的。<br>我相信 Base 及其属性不在 MainActor 上运行。</p><p><strong>回答</strong></p><p>您在顶层创建 Task，这隐式地使其在 main actor 上运行。 由于 Base 只是一个类（而不是 actor），因此它的方法在其调用者所在的任何上下文中运行，在本例中这是 main actor。<br>属性和方法可以单独与特定参与者相关联，包括作为协议要求的一部分。 在这种情况下 foo 隐式是 @MainActor，因为 Po 协议如此声明它。</p><p>这可能有点太神奇了 - foo 也是隐式异步的，尽管它从未真正被标记为异步，即使在原始协议声明中也是如此。</p><p>为了进一步测试这一点，如果您添加到 Base 例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将收到编译器错误 <code>Call to main actor-isolated instance method &#39;foo()&#39; in a synchronous nonisolated context</code>，表明编译器将 foo 视为 @MainActor（但 Base 的其余部分不是）。</p><p>5) 讨论<a href="https://forums.swift.org/t/self-used-before-super-init-call-conflicts-with-property-not-initialized-at-super-init-call/66896" title="在 &quot;super.init&quot; 调用之前使用的 &quot;self&quot; 与 &quot;在 super.init 调用时未初始化属性&quot; 冲突" target="_blank" rel="noopener">在 “super.init” 调用之前使用的 “self” 与 “在 super.init 调用时未初始化属性” 冲突</a></p><p>我需要在 init 中创建一个捕获 self 的闭包来初始化属性，但我无法使用 self，因为 super.init 尚未被调用。 但是，我无法调用 super.init，因为该属性尚未初始化！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>: <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer: <span class="type">Timer</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// option 1 - try to initialize the property</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// ERROR: 'self' used before 'super.init' call</span></span><br><span class="line">        timer = .scheduledTimer(withTimeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>!.value += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// option 2 - try to initialize super first</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()  <span class="comment">// ERROR: Property 'self.timer' not initialized at super.init call</span></span><br><span class="line">        timer = .scheduledTimer(withTimeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>!.value += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使属性既可选又可变（在 super.init 期间初始化为 nil，然后在之后更改它）之外，还有什么办法可以解决这个问题吗？</p><p>我有点明白为什么编译器不能接受这种情况，但是必须使属性可选且可变，这很烦人，而一旦类完全初始化，它实际上既不应该为零，也不应该变。</p><p><strong>回答</strong></p><p>需要在函数内有一个本地变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> futureSelf: <span class="type">Sub</span>? = <span class="literal">nil</span></span><br><span class="line">    timer = .scheduledTimer(withTimeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; [<span class="keyword">weak</span> futureSelf] <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            futureSelf?.value += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    futureSelf = <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，编译器无法知道采用闭包捕获 self 的对象是否不会立即被调用，并且它试图避免使用半初始化的 self 实例调用闭包。</p><p>6) 讨论<a href="https://forums.swift.org/t/should-deinit-be-called-after-explicit-consume-of-reference-type/66920" title="显式使用引用类型后是否应该调用 deinit？" target="_blank" rel="noopener">显式使用引用类型后是否应该调用 deinit？</a></p><p>我想通过使用 <code>_ = Consumer</code> 对象显式结束演员/类的生命周期，以避免引入具有单独作用域的另一级嵌套。 但是，在显式消费之后不会调用该对象的 deinit。 相反，它是在作用域末尾调用的。 这是预期行为还是编译器错误？ 对于不可复制的结构，它可以按预期工作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"deinit object"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Noncopyable</span>: ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"deinit noncopyable"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDeinitAfterConsume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> object = <span class="type">Object</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"before consume"</span>)</span><br><span class="line">        <span class="number">_</span> = consume object</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"after consume"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> noncopyable = <span class="type">Noncopyable</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"before consume"</span>)</span><br><span class="line">        <span class="number">_</span> = consume noncopyable</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"after consume"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before consume</span><br><span class="line">after consume</span><br><span class="line"><span class="keyword">deinit</span> object</span><br><span class="line"></span><br><span class="line">before consume</span><br><span class="line"><span class="keyword">deinit</span> noncopyable</span><br><span class="line">after consume</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>这是可以理解的。 一般来说，每当对象丢失最后一个引用时，类析构器就会运行，而不考虑变量范围。</p><p>在某种程度上不鼓励在类去初始化中依赖共享可变状态，并且强烈不鼓励依赖与常规代码中的副作用相关的顺序。 即使没有优化，它通常也会很棘手并且容易出错。</p><p>对对象生命周期的显式控制是 Swift 中依赖类取消初始化顺序的官方方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">withExtendedLifetime</span>(object) &#123;</span><br><span class="line">    <span class="comment">// Modify shared mutable state without accessing object.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于局部变量（包括参数），编译器（5.7 后）遵循一些保守的生命周期规则，以便大多数“看起来正常”的编程模式无需显式生命周期管理即可工作。 事实上，如果我们按照字面意思理解这个示例，则 deinit 将不会发生，并且我们永远不会看到以下输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> object</span><br><span class="line">before consume</span><br><span class="line">after consume</span><br></pre></td></tr></table></figure><p>额外的安全规则是：</p><p>如果不安全指针或弱引用可能依赖于局部变量的生命周期，则编译器会自动扩展该变量持有的任何引用。</p><p>如果常规代码在 Swift 外部调用（包括所有 I/O）或跨任务同步（调用异步函数），则类析构器将不会跨这些边界重新排序。 这也意味着程序员可以通过添加同步代码来控制对象的生命周期，而无需 withExtendedLifetime。 在此示例中，调用 “print” 被视为同步点，从而阻止优化。</p><p>这里有更详细的描述：<a href="https://gist.github.com/atrick/cc03c4d07fb0a7bee92c223ae5e5695b#lexical-variable-scope-can-affect-object-lifetime" target="_blank" rel="noopener">https://gist.github.com/atrick/cc03c4d07fb0a7bee92c223ae5e5695b#lexical-variable-scope-can-affect-object-lifetime</a><br>在这方面，消耗参数与 “let”、“var” 和非 “消耗” 参数不同，因为它们的生命周期可以在隐式消耗时提前结束：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(<span class="number">_</span> object: consuming Object)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(object: consuming Object)</span></span> &#123;</span><br><span class="line">    bar(object)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"after consume"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总是得到结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> object</span><br><span class="line">after consume</span><br></pre></td></tr></table></figure><p>这为那些关心 ARC 开销和 CoW 行为的人提供了理想的编程模型。 很快，我希望所有局部变量都具有“消耗”的效果。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/08/01/mastering-storekit2" title="掌握 StoreKit2" target="_blank" rel="noopener">掌握 StoreKit2</a></p><p><strong>摘要：</strong> 本文介绍了 Swift 中的 StoreKit2，这是一个用于构建应用内购买和订阅的框架。文章从配置项目和创建 StoreKit 配置文件开始，介绍了如何使用 Store 类型处理应用内购买逻辑。通过示例代码和说明，文章展示了如何使用 Store 类型来获取和显示应用内购买产品列表，并启动购买流程。还介绍了产品类型和其 purchase 函数，在成功购买时处理交易和验证过程。文章还涉及了处理挂起状态和监视交易更新的方法。此外，提到了 StoreKit2 提供的 currentEntitlements 属性，用于获取活动订阅和已购买产品列表。最后，文章给出了一个基本的 App 结构示例，其中包含了 Store 对象，并在应用程序启动时获取活动交易。 </p><p><a href="https://juejin.cn/post/7251501966592917563" title=" iOS 防 dump 可行性调研报告" target="_blank" rel="noopener"> iOS 防 dump 可行性调研报告</a></p><p><strong>摘要：</strong>  文章介绍了如何防止 iOS App 被 dump ，包括代码混淆、加密、完整性检查等多层防御策略，以及服务器端验证、动态加载、API 安全性和多因素认证等方案。此外，监控与告警、定期安全审计和安全培训等后置方案也可以提高 App 的安全性。最后，还介绍了禁止越狱设备的实施方案，以及 DeviceCheck 和 App Attest API 等新技术方案。</p><p><a href="https://juejin.cn/post/7268119060055031865" title=" WWDC23 10105 - 打造响应更快的相机体验" target="_blank" rel="noopener"> WWDC23 10105 - 打造响应更快的相机体验</a></p><p><strong>摘要：</strong> 文章介绍了 iOS17 提供了一些新的特性，通过延迟图片处理、快门零延迟、响应捕获等新特性，以及状态监听等措施，能大幅提高相机响应速度，创造更流畅的拍摄体验。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>日本核污水排海，你还会吃海鲜吗？</strong></p><ol><li>会</li><li>不会</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十六期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;一米阳光下阴雨绵绵，一米阳光上晴空万里，这就是生活。&lt;strong&gt;Swift社区&lt;/strong&gt;伴你一起，走过风雨，沐浴暖阳！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：iPhone 15 全系配 USB-C 苹果拒绝接口和安卓互通&lt;/p&gt;
&lt;p&gt;提案：对 AsyncStream 的 Backpressure 支持&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议全局变量的严格并发&lt;/p&gt;
&lt;p&gt;推荐博文：WWDC23 10105 - 打造响应更快的相机体验&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;日本核污水排海，你还会吃海鲜吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十五期/</id>
    <published>2024-03-06T07:56:33.000Z</published>
    <updated>2024-03-06T08:02:31.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十五期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>是站在生命之巅，嘲笑死神的无能？还是跪在生活边缘，寻求生存的可能？<strong>Swift社区</strong>始于渺小，行至辽阔！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：五天市值蒸发 2000 亿美元，苹果公司怎么了？</p><p>提案：具有编码验证的 <code>String Initializers</code></p><p>Swift 论坛：Swift 分布式追踪</p><p>推荐博文：iOS ReplayKit 与 屏幕录制</p><p><strong>话题讨论：</strong> </p><p>苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/d83bb1a9-5218-4d1c-892c-bc767e2cfe00.jpg" alt=""></p><p>从投票结果可以看出来，购买决策不再仅仅只受价格影响，用户更注重手机性能、价值、国产支持等多个方面。你怎么看～</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="五天市值蒸发-2000-亿美元，苹果公司怎么了？"><a href="#五天市值蒸发-2000-亿美元，苹果公司怎么了？" class="headerlink" title="五天市值蒸发 2000 亿美元，苹果公司怎么了？"></a>五天市值蒸发 2000 亿美元，苹果公司怎么了？</h3><p>不久前的 6 月份，苹果公司刚成为首家市值超过 3 万亿美元的企业，但其最新一季的财报却引发了投资者对其手机与其他设备需求不振的担忧。</p><p>8 月 4 日，苹果公司公布了三季度财报。财报显示，苹果第三财季营收 817.97 亿美元，不及上一财年同期的 829.59 亿美元，较上一财季的 948.36 亿美元大幅下滑。在看到新一季财报数据后，投资者惊讶地发现，这家巨无霸上市公司的营业收入已经连续 3 个财季下滑，且苹果在第四季展望中预测当季表现也不大会有差别。</p><p>公司股价接连下跌</p><p>苹果公司三季报发布日恰在其新产品 iPhone15 系列新机上市前，但市场预期苹果手机这一新机型受追捧程度不如以往。在悲观情绪影响下，苹果公司股价在 8 月 4 日财报公布日重挫 4.8% ，创下今年以来最大单日跌幅，市值一天之内蒸发逾 1600 亿美元。而后，苹果股价并未能止住跌势，截至本周一（8 月 7 日），苹果的股价已经遭遇“五连跌”，股价暴跌近 10% ，总市值蒸发超过 2000 亿美元，约合人民币 1.44万 亿元。</p><p>美国银行的分析师在一份业绩报告中表示，苹果正面临美国智能手机市场疲软的大环境。此外，估值过高可能也是苹果此次下跌的又一重要原因。对于苹果销售额的“三连降”，第一手机界研究院院长孙燕飙表示，消费电子市场持续低迷削弱了对智能手机的需求，叠加创新力不足难以拉动新机销量，苹果手机的销售收入连续下滑。如果苹果在第四财季的销售额继续同比下降，这将是该公司 20 年来销售额同比下降持续时间最长的一次。（来源：金融时报）</p><h3 id="在你的-App-中帮助顾客解决账单问题"><a href="#在你的-App-中帮助顾客解决账单问题" class="headerlink" title="在你的 App 中帮助顾客解决账单问题"></a>在你的 App 中帮助顾客解决账单问题</h3><p>正如我们在 4 月份宣布的那样，很快，你的顾客就能直接在你的 App 中解决付款问题，以便更轻松地继续订阅你的内容、服务和高级功能。</p><p>自 2023 年 8 月 14 日起，如果自动续期订阅因账单问题而无法续订，你的 App 中会显示一个系统提供的表单，提示顾客更新其 Apple ID 的付款方式。你可以在沙盒中先测试一下此表单，还可以使用 StoreKit 中的 messages (英文) 和 display (英文) 来推迟或禁止显示此表单。这项功能在 iOS 16.4 和 iPadOS 16.4 或更高版本中提供，无需采取任何操作即可采用。</p><h3 id="需要声明原因的-API-列表现已推出"><a href="#需要声明原因的-API-列表现已推出" class="headerlink" title="需要声明原因的 API 列表现已推出"></a>需要声明原因的 API 列表现已推出</h3><p>Apple 致力于保护我们平台上的用户隐私。我们知道，有一小部分 API 可能会被滥用来通过信息指纹收集用户设备的相关数据，这是我们的 Developer Program 许可协议禁止的一种做法。为了防止滥用这些 API，我们在 WWDC23 (英文) 上宣布了开发者需要在 App 的隐私清单中声明使用这些 API 的原因。这将有助于确保 App 仅将这些 API 用于预期用途。在这个流程中，你需要选择一个或多个能够准确反映你的 App 如何使用相应 API 的批准原因，并且你的 App 只能出于你选择的原因使用相应 API。</p><p>从 2023 年秋季开始，如果你上传到 App Store Connect 的新 App 或 App 更新使用了需要声明原因的 API (包括来自第三方 SDK 的内容)，而你没有在 App 的隐私清单中提供批准的原因，那么你会收到通知。从 2024 年春季开始，若要将新 App 或 App 更新上传到 App Store Connect，你需要在 App 的隐私清单中注明批准的原因，以准确反映你的 App 如何使用相应 API。</p><p>如果目前批准原因的涵盖范围内并未包含某个需要声明原因的 API 的用例，且你确信这个用例可让你的 App 用户直接受益，请告诉我们。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0403-swiftpm-mixed-language-targets.md" title="SE-0403" target="_blank" rel="noopener">SE-0403</a> <strong>软件包管理器混合语言目标支持</strong> 提案通过审查。该提案已在 <strong>三十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0405-string-validating-initializers.md" title="SE-0405" target="_blank" rel="noopener">SE-0405</a> <strong>具有编码验证的 String Initializers</strong> 提案正在审查。</p><p>我们建议添加新的 <code>String</code> 可失败 <code>Initializer</code>s，用于验证编码输入，并在输入包含任何无效元素时返回 <code>nil</code>。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/swift-string-comparison-doesnt-consider-ligatures-equivalent-to-their-components/66665" title="Swift 字符串比较不将连字等同于其组件" target="_blank" rel="noopener">Swift 字符串比较不将连字等同于其组件</a></p><p><strong>内容大概</strong></p><p>我刚刚发现 Swift 字符串将 “office” 和 “oﬃce” 视为不相等，这让我感到惊讶，因为它将 “caña” 和 “caña” 视为相等（即，都是组合和分解形式）。对于一般用户来说，这些情况是等价的 - 它们只是以不同的方式表示相同的字形（至少在某些字体中是如此）。</p><p>我进行了一些调查，似乎这是因为 Swift 承诺在 Unicode 术语中使用 “规范” 比较，而不是 “兼容” 比较。文档提到了这一点，但没有解释其含义。</p><p>我进一步查找并发现了有关 Unicode 中连字的一些争议和历史，这可能会为此提供一些启示（例如，目前 Unicode 关于连字的观点似乎是不应该用于字距调整，例如 “ﬃ”，但它仍然包含一些”不恰当” 的连字 - 再次，如 “ﬃ” - 这些连字是在这种心态转变之前添加的）。</p><p><code>NSString</code> 也类似，除非你在使用 <code>compare(_:options:)</code> 时选择了 <code>caseInsensitive</code> 选项，这时它会将连字视为其分解形式。这很奇怪，因为这与字符大小写无关。</p><p>我猜这篇文章主要是向其他人提供信息和警告。但我很好奇为什么 Swift 选择执行 “规范” 比较，而不是 “兼容” 比较？此外，似乎在 Swift 标准库中没有办法执行 “兼容” 比较 - 必须导入 Foundation 才能获取字符串重叠部分，以便访问前面提到的 <code>NSString</code> 方法。</p><p><strong>回答</strong></p><p>兼容性分解是 Unicode 在需要与早期编码兼容（作为超集）的情况下所迫不得已的妥协。如果这些字符直接提议给 Unicode，它们将永远不会被编码。通常情况下，即使您在使用它们，也可能是在做错误的事情，因为它们所编码的内容（例如连字）不是文本的属性，而是显示格式的属性。</p><p>在 Unicode 的观点中，它们本身就不应该出现在原始字符串中。然而，将它们折叠到规范形式会丢失有关格式的信息，因此不能安全地应用于实际使用了它们的传统文本。（以“ff”为例，不是每一对“f”都要在显示中连接；那些跨越复合词两半的“f”应该保持分开。不能通过简单查看上下文来恢复这种区别，需要手动进行或通过字典查询来完成。）这与类似“ñ”的规范分解根本不同，后者在规范化过程中不会丢失信息。</p><p>如果想知道两个字符串是否在兼容性方面是等价的，则可以使用 Foundation 的 <code>decomposedStringWithCompatibilityMapping</code> 方法。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-swift-distributed-tracing/66679" title="Swift 分布式追踪" target="_blank" rel="noopener">Swift 分布式追踪</a></p><p><strong>动机</strong></p><p>虽然 <a href="https://github.com/apple/swift-log" title="Logging" target="_blank" rel="noopener">Logging</a> 和 <a href="https://github.com/apple/swift-metrics" title="Metrics" target="_blank" rel="noopener">Metrics</a> 可以用于仪器化应用程序的特定部分，但 <a href="https://github.com/apple/swift-distributed-tracing" title="Distributed Tracing" target="_blank" rel="noopener">Distributed Tracing</a> 提供了对整个分布式系统的整体视图。与这两者一起，分布式跟踪将完成“可观察性的三大支柱”。</p><p>与 Logging 和 Metrics 一样，如果在库和框架中直接使用一个共同的 API 来实现分布式跟踪，社区将从中受益最多。最终用户应该能够自由选择合适的后端实现，而无需更改他们正在使用的库或框架。</p><p><strong>建议的解决方案</strong></p><p>Swift 分布式跟踪围绕着创建跨度（span），这些跨度共同形成一种树状结构。跟踪可以由在单个服务中记录的跨度组成，也可以跨多个服务传播。Swift 分布式跟踪使用基于任务本地的 <a href="https://github.com/apple/swift-service-context" title="Swift Service Context" target="_blank" rel="noopener">Swift Service Context</a> 来实现透明的传播，无需手动传递上下文。</p><p>我们提出的解决方案是一个针对三个“角色”的库：</p><ul><li>终端用户</li><li>库和框架作者</li><li>跟踪器后端实现</li></ul><p><strong>用户端</strong></p><p>最终用户是从分布式跟踪中受益的人。他们选择适合自己需求的跟踪后端，使用具有内置的 Swift 分布式跟踪支持的库，并在自己的代码中进行手动仪器化。</p><p><strong>库和框架作者</strong></p><p>诸如 HTTP 服务器/客户端、数据库库等库/框架最了解如何仪器化其库的内部。他们使用 Swift 分布式跟踪 API 实现通用的跟踪支持，而无需考虑特定的跟踪后端。</p><p>例子:</p><ul><li><a href="https://github.com/hummingbird-project/hummingbird/releases/tag/1.6.0" title="Hummingbird" target="_blank" rel="noopener">Hummingbird</a></li><li><a href="https://github.com/soto-project/soto-core/pull/575" title="Soto" target="_blank" rel="noopener">Soto</a></li></ul><p><strong>跟踪后端实现</strong></p><p>最后一个难题是跟踪器后端实现。它们为导出跟踪 span 提供特定于供应商的支持。</p><p>例子</p><p><a href="https://github.com/slashmo/swift-otel" title="Swift OTel" target="_blank" rel="noopener">Swift OTel</a> 公开了一个导出到 <a href="https://opentelemetry.io/docs/collector" title="OpenTelemetry Collector" target="_blank" rel="noopener">OpenTelemetry Collector</a> 的跟踪器。这已经允许该跟踪库的采用者导出到与 OpenTelemetry 兼容的流行后端，例如 Zipkin、Jaeger、Honeycomb 等。</p><p><strong>到期理由</strong></p><p>我们提议这个软件包处于“孵化”成熟度级别。 我们相信这个包是服务器生态系统的重要构建块，就像许多服务器和客户端库采用 <a href="https://github.com/apple/swift-log" title="swift-log" target="_blank" rel="noopener">swift-log</a> 和 <a href="https://github.com/apple/swift-metrics" title="swift-metrics" target="_blank" rel="noopener">swift-metrics</a> 一样。</p><p>该项目已经成熟超过3年，有多个活跃的维护人员，并且在生产环境中满足了采用要求。</p><p>3) 讨论<a href="https://forums.swift.org/t/attributedstring-index-fetching-causes-internal-unwrap-of-nil-value/66677" title="AttributedString 索引获取导致 nil 值的内部解包" target="_blank" rel="noopener">AttributedString 索引获取导致 nil 值的内部解包</a></p><p><strong>问题描述</strong></p><p>我有一个富文本字符串，其中一个子字符串正在被替换，但是会引发 fatalError：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="type">AttributedString</span>(<span class="string">"café"</span>)</span><br><span class="line"><span class="keyword">let</span> replaceIndex = string.index(beforeCharacter: string.endIndex)</span><br><span class="line"><span class="keyword">let</span> range = replaceIndex..&lt;string.endIndex</span><br><span class="line">string.replaceSubrange(range, with: <span class="type">AttributedString</span>(<span class="string">"e"</span>))</span><br><span class="line"><span class="keyword">let</span> next = string.index(afterCharacter: replaceIndex)</span><br><span class="line"><span class="comment">//                ^---- Unexpectedly found nil while unwrapping an Optional value</span></span><br><span class="line"><span class="built_in">assert</span>(next == string.endIndex)</span><br></pre></td></tr></table></figure><p>这令人惊讶，因为我认为在更改之前，索引会保持稳定。更奇怪的是，改变如何创建范围不会导致失败。以下代码可以正常工作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="type">AttributedString</span>(<span class="string">"café"</span>)</span><br><span class="line"><span class="keyword">let</span> range = range(of: <span class="string">"é"</span>)!</span><br><span class="line">string.replaceSubrange(range, with: <span class="type">AttributedString</span>(<span class="string">"e"</span>))</span><br><span class="line"><span class="keyword">let</span> next = string.index(afterCharacter: replaceIndex)</span><br><span class="line"><span class="built_in">assert</span>(next == string.endIndex)</span><br></pre></td></tr></table></figure><p>使用 ASCII 字符而不是重音符号 ‘é’ 不会导致两种范围技术中的任何一种失败。我仔细分析了开源实现，试图揭示出现 nil 可选值的源头，但我看不到任何问题，我认为这与当前发布的代码不同。</p><p>对于我哪里的逻辑出了问题，有什么建议吗？</p><p>我使用的是 macOS 13.4.1 和 Xcode 15b5。</p><p><strong>回答</strong></p><p>明确一点，<code>RangeReplaceableCollection</code> 的变异操作可能会使现有索引失效，因为这些索引可能包含对于变异集合不再有效的信息（例如，在字符串的情况下，计算的字节偏移不再有效）。从 <code>RangeReplaceableCollection.replaceSubrange(_:with:)</code> 文档中可以看出：</p><blockquote><p>调用此方法可能会使任何现有索引在与此集合一起使用时失效。</p></blockquote><p>并且，这个方法几乎是 <code>RangeReplaceableCollection</code> 上所有其他操作的基础，所以人们应该假设（除非为特定类型另有说明）任何可能改变索引相关信息的变异操作都会使现有索引失效。</p><p>4) 提议<a href="https://forums.swift.org/t/pitch-access-level-on-import-statements/66657" title="导入语句的访问级别" target="_blank" rel="noopener">导入语句的访问级别</a></p><p>这是一个关于在 Swift 中更好地控制依赖和导入的提案。通过这个特性，可以将导入标记为公共的（当前的常规导入方式），对于模块的实现细节，可以标记为内部，对于源文件的实现细节，可以标记为私有或文件私有。</p><p>另外，更新后的包访问级别允许将依赖标记为仅对同一包中的模块可见。这会像源文件中的常规访问级别一样进行强制执行。将作为内部导入的声明只能从内部声明或更低的访问级别中引用，而在公共或包声明中使用则会报错。</p><p>下面是一个典型的用例，其中依赖项是我们不希望在模块 API 中暴露给客户端的实现细节，以及预期的诊断信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">import</span> DatabaseAdapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">internalFunc</span><span class="params">()</span></span> -&gt; <span class="type">DatabaseAdapter</span>.<span class="type">Entry</span> &#123; ... &#125; <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">publicFunc</span><span class="params">(entry: DatabaseAdapter.Entry)</span></span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// error: function cannot be declared public because its parameter uses an internal type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">useInBody</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">DatabaseAdapter</span>.foo() <span class="comment">// Ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inlinable</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">useInInlinableBody</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">DatabaseAdapter</span>.foo()</span><br><span class="line">    <span class="comment">// error: global function 'foo()' is internal and cannot be referenced from an '@inlinable' function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该提案还定义了一组条件，其中可以从客户端隐藏依赖项。这提供了一种强大的方法来完全隐藏实现细节，并可以加快客户端的构建时间。</p><p>这个提案旨在提供一个正式且更清晰的替代方案，来取代 <code>@_implementationOnly</code>。与此相反，此版本提供了熟悉的诊断信息，更多级别的控制，以及与非弹性模块和 <code>@testable</code> 客户端更好的兼容性。</p><p>根据社区对建议的 Swift 6 行为的反应，我们可以将其纳入该提案。</p><p>5) 讨论<a href="https://forums.swift.org/t/actors-that-serialise-file-access/66652" title="序列化文件访问的 Actor" target="_blank" rel="noopener">序列化文件访问的 Actor</a></p><p><strong>问题描述</strong></p><p>我想知道使用 Actor 是否是保护资源免受并发访问的好选择，例如一个文件目录。在过去，我曾使用 dispatch queues 实现这种情况。使用 Actor 作为阻塞文件访问 API 的通道点的优缺点是什么？</p><p><strong>回答</strong></p><blockquote><p>仅仅是在文件系统中进行典型的CRUD操作</p></blockquote><p>在这里，Actor并不能帮助你。即使在 Actor 可重入性的考虑之外，从 Actor 外部调用的 Actor 方法的执行顺序也无法保证。</p><p>CRUD 操作已经是线程安全的（如果它们不是，那将是一个相当令人失望的文件系统）。由于 Actor 不以执行方法的调用顺序“串行化”任何内容，因此不需要 Actor。</p><p>可能需要的是一个 FIFO 队列，这就是（串行的）DispatchQueue 解决方案为此提供的好处。</p><p>现在，如果谈论的是将一系列操作有效地“原子化”（例如，在枚举目录时不允许同时对其进行变异），那么需要保护的是一些可变状态，Actor 可以保护它。在我看来，这是比 CRUD 更高层次的抽象。在这方面，我认为 <code>@tera</code> 的问题在这里比想象的更相关。</p><p>6) 讨论<a href="https://forums.swift.org/t/l-shaped-enums/66661" title="L-shaped 枚举" target="_blank" rel="noopener">L-shaped 枚举</a></p><p><strong>问题描述</strong></p><p>用于缺乏更好的术语，我有很多“L-shaped”枚举，它们具有一些不同的有效载荷类型和一些共同的有效载荷类型。</p><p>以下是一个示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Request</span>:<span class="title">Sendable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">get</span>    (<span class="type">Get</span>, <span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;)</span><br><span class="line">        <span class="keyword">case</span> post   (<span class="type">Post</span>, <span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;)</span><br><span class="line">        <span class="keyword">case</span> delete (<span class="type">Delete</span>, <span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span>.<span class="title">Request</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Get</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Post</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Delete</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种布局存在问题：</p><p>很难访问共同的字段（<code>EventLoopPromise&lt;ServerResponse&gt;</code>），除非在枚举上进行 switch 操作。</p><p>很难在实际的变体有效载荷上进行 switch，因为您必须使用 _ 忽略共同字段。</p><p>这里有一个明显的重构方法，即将变体有效载荷提升到另一个嵌套类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Request</span>:<span class="title">Sendable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> operation:<span class="type">Operation</span></span><br><span class="line">        <span class="keyword">let</span> promise:<span class="type">EventLoopPromise</span>&lt;<span class="type">ServerResponse</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span>.<span class="title">Request</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Operation</span>:<span class="title">Sendable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">get</span>    (<span class="type">Get</span>)</span><br><span class="line">        <span class="keyword">case</span> post   (<span class="type">Post</span>)</span><br><span class="line">        <span class="keyword">case</span> delete (<span class="type">Delete</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ServerDelegate</span>.<span class="title">Request</span>.<span class="title">Operation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Get</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Post</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Delete</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这感觉像是过多的嵌套和（过多？）的类型结构，与我尝试建模的复杂性成正比。而且 <code>ServerDelegate.Request.Operation.Get</code>、<code>ServerDelegate.Request.Operation.Post</code> 等枚举本身可能还有更多的嵌套结构。</p><p>我们有哪些替代方案呢？”</p><p><strong>回答</strong></p><p>命名空间中的点是嵌套的结果，这与这里的类型结构并不是真正的基本关系。提供便利的 API 来处理一些 <code>.init</code> 繁琐的情况似乎也是合理的，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(url: URL, params: [String: String], mintPromise: <span class="params">()</span></span></span> -&gt; <span class="type">EventLoopPromise</span>) -&gt; <span class="type">Self</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7217692600647254071/" title="iOS ReplayKit 与 屏幕录制" target="_blank" rel="noopener">iOS ReplayKit 与 屏幕录制</a></p><p><strong>摘要：</strong> 这篇文章主要介绍了使用 Apple 的 ReplayKit 框架来实现屏幕录制功能，包括应用内录制和系统级录制。 ReplayKit 从 iOS 9中第一次提供，已经发展并增强了许多特性。文章对创建和接入 ReplayKit  Extension ，系统级录制流程，以及在 LOOK 直播中的实践例子等进行了详细介绍。然而，屏幕录制开发面临着一些挑战，如内存限制、开发和调试困难、内存控制等。文章强调在开发过程中要小心应对这些问题，保持内存使用远离 50MB 的限制阈值，以及充分利用日志来解决问题，使能够优雅地完成屏幕录制功能。 </p><p><a href="https://juejin.cn/post/7264503433965518911/" title="TheRouter-iOS 轻量化路由中间件" target="_blank" rel="noopener">TheRouter-iOS 轻量化路由中间件</a></p><p><strong>摘要：</strong>  TheRouter 是一款由货拉拉打造的轻量级路由中间件，旨在支持 Android 和 iOS 平台。该中间件在 iOS 端吸取了其他语言的特性，增加了注解功能，强化了路由在 iOS 端的使用体验。 TheRouter 摒弃了传统 iOS 的 target-action 或 protocol 理念，对齐了更广泛的后台或 Android 应用。主要功能包括依赖注入、硬编码消除、动态化能力和页面导航跳转能力。文章详细解释了 TheRouter 的实现原理，如注解式依赖注入，路径硬编码处理等，并提供了详细的使用介绍和示例。</p><p><a href="https://juejin.cn/post/7116301510887079967/" title="iOS App Store 上架被拒 case" target="_blank" rel="noopener">iOS App Store 上架被拒 case</a></p><p><strong>摘要：</strong> 这篇文章主要记录了 App Store 上架过程中遇到的一些被拒绝的案例，以及对应的原因分析和解决策略。案例涵盖了从功能完整性、信息需要、隐私确认，到软件需求和上传被拒等不同阶段的问题。文章还详细阐述了各种问题的产生原因，如 APP 功能不全、集成未使用的库、隐私信息填写不全等，并提出相应的解决方案。通过这些案例的分享，开发者可以理解和学习如何避免类似的错误，更顺利地完成 App Store 的上架过程。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>报道称曾红极一时的少儿编程培训，如今现爆雷隐患。你认为儿童是否有必要提早接触编程课？</strong></p><ol><li>有必要：编程课可以激发儿童创造力，培养解决问题的能力。</li><li>没必要：缺乏基础和成熟度，编程需要数学和逻辑思维能力，导致理解困难和挫败感。</li><li>因人而异：有些儿童适合提早接触，有天赋和热情，发挥潜力，其他儿童可以在稍后阶段考虑。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十五期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;是站在生命之巅，嘲笑死神的无能？还是跪在生活边缘，寻求生存的可能？&lt;strong&gt;Swift社区&lt;/strong&gt;始于渺小，行至辽阔！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：五天市值蒸发 2000 亿美元，苹果公司怎么了？&lt;/p&gt;
&lt;p&gt;提案：具有编码验证的 &lt;code&gt;String Initializers&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swift 论坛：Swift 分布式追踪&lt;/p&gt;
&lt;p&gt;推荐博文：iOS ReplayKit 与 屏幕录制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十四期/</id>
    <published>2024-03-06T07:56:27.000Z</published>
    <updated>2024-03-06T08:01:44.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组整理周报的第三十四期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>恰似烈日灼身，清风缕缕慰我清静。恰似无边心海，<strong>Swift社区</strong>渡我心安！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄</p><p>提案：允许在非泛型上下文中嵌套协议</p><p>Swift 论坛：提议 DocC 中的数学排版</p><p>推荐博文：Swift HTTP Types 的介绍</p><p><strong>话题讨论：</strong> </p><p>苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/9206a50e-e85e-4b70-bcff-5396ed536173.jpg" alt=""></p><p>这只是一个简单的投票结果，虽然不能完全反映实际的社会情况，但是也能帮助大家了解目前的生活状态（仅作参考）。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="iPhone-Pro-要提价！新款-iPhone-或会使用-USB-C-充电器，边框更薄"><a href="#iPhone-Pro-要提价！新款-iPhone-或会使用-USB-C-充电器，边框更薄" class="headerlink" title="iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄"></a>iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄</h3><p>据彭博社当地时间 7 月 24 日报道，苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格。</p><p>苹果公司通常在 9 月份发布新款 iPhone 。自 2019 年以来，苹果公司一直在销售高端的 iPhone Pro ，其起售价在美国为 999 美元，而屏幕更大的 Max 型号至少为 1099 美元。据报道，苹果公司最新的高端型号可能会涨价，这将通过提高新 iPhone 的平均售价来增加苹果公司的总收入。</p><p><img src="https://pics0.baidu.com/feed/34fae6cd7b899e51482ccff515245e3fca950dc4.jpeg@f_auto?token=8eb543197d27f0d69f5479a7a2299a2b" alt="图片来源：苹果官网"></p><p>在疫情期间，苹果公司没有提高美国新款 iPhone 的价格，尽管该公司面临零部件短缺，并表示通货膨胀导致了一些服务（如运输和零部件）的成本上升。</p><p>然而，苹果公司经常根据汇率波动调整其在全球各地的产品价格，包括去年推出的 iPhone 14 设备。</p><p>苹果公司没有回应置评请求。</p><p>新款 iPhone 可能会使用 USB-C 充电器，而不是专有的 Lightning 充电器，这是去年欧洲通过新规定后的结果。据供应链分析师郭明錤称，新款 Pro 型号可能会采用钛合金外壳和更薄的边框。</p><p>价格上涨也可能有助于苹果公司利用智能手机行业近期的趋势。总体而言，智能手机出货量下降并已持续一年，但消费者仍然对最好和最贵的设备有需求，分析师们说。</p><p>“尽管全球智能手机需求复苏低于预期，但看起来高端市场（因此也是苹果）受到的影响较小。”德意志银行分析师何思迪（Sidney Ho）周一在一份报告中写道。</p><p>另据科创板日报 7 月 24 日援引外媒报道，苹果供应链消息称，2023 年 iPhone 15 零部件备货力道不及 2022 年同期，略估初步备货量仅约 8300 万 ~ 8500 万支水准，同比下降逾 8%。2022 年同期 iPhone 备货预估量约 9000 万支以上，甚至“还有喊到近 1 亿支”。</p><p>之前市场认为，手机市场已开始出现回温，但大立光董事长林恩平认为，这只是中低阶手机市场销售的略为走升，至于高阶市场的销售，客户端看法仍然相对保守，主要问题在于“卖不好”。</p><p>美国银行分析师 Wamsi Mohan 在报告中指出，iPhone 15 设备可能会推迟“几周”，部分机型或将推迟到 10 月上市，但 The Information 认为苹果仍将如期在 9 月份上市 iPhone 15 的 Pro 系列。(来源：每日经济新闻)</p><h3 id="与-App-Store-专家会面交流"><a href="#与-App-Store-专家会面交流" class="headerlink" title="与 App Store 专家会面交流"></a>与 App Store 专家会面交流</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/7ED4820B-E3B1-4F08-A0FE-1708671981CC/2048.jpeg" alt=""></p><p>加入我们，参与 8 月 1 日至 8 月 24 日的在线讲座，了解最新的 App Store 功能并获取问题的解答。我们将在多个时区以多种语言进行实时演讲和答疑。</p><p>探索 App Store 定价机制升级，包括增强的全球定价机制、用于按店面管理定价的工具，以及额外的价格点。<br>你将学习如何通过 App 分析来衡量用户获取情况，以及如何使用 App Store 的各项功能来发展你的订阅业务。<br>探索产品页优化如何助你测试产品页的不同元素，以找出哪些元素最能引起用户的共鸣。<br>了解自定产品页如何助你创建额外的产品页版本，以突出显示特定功能或内容。<br>你还能了解怎样通过 Game Center 来提高曝光度和参与度，以及 App 内活动的配置操作。</p><h3 id="让你的-App-和游戏在-visionOS-模拟器外更进一步"><a href="#让你的-App-和游戏在-visionOS-模拟器外更进一步" class="headerlink" title="让你的 App 和游戏在 visionOS 模拟器外更进一步"></a>让你的 App 和游戏在 visionOS 模拟器外更进一步</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/4CC97B65-CD76-433A-8139-18D6DD7BB227/2048.jpeg" alt=""></p><p><strong>Apple Vision Pro 兼容性评估</strong></p><p>我们可协助你确保 visionOS、iPadOS 和 iOS App 在 Vision Pro 上正常运行。而且，我们会先根据新发布的兼容性核对清单调整你的 App，然后再要求直接在 Vision Pro 上对你的 App 进行评估。</p><p><strong>Apple Vision Pro 开发者实验室</strong></p><p>体验在 Vision Pro 上运行的 visionOS、iPadOS 和 iOS App。你将能够在 Apple 的支持下测试并优化你的 App，为无边的空间画布做好准备。我们分别在库比蒂诺、伦敦、慕尼黑、上海、新加坡和东京设立了实验室。</p><p><strong>Apple Vision Pro 开发者套件</strong></p><p>如果你有任何 visionOS App 的好创意是需要在 Vision Pro 真机上构建和测试的，欢迎申请 Vision Pro 开发者套件。通过持续直接访问 Vision Pro，你将能够快速构建、测试和优化 App，在 visionOS 上提供出色的空间体验。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" title="SE-0400" target="_blank" rel="noopener">SE-0400</a> <strong>Init 访问器</strong> 提案通过审查。该提案已在 <strong>三十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md" title="SE-0401" target="_blank" rel="noopener">SE-0401</a> <strong>移除由属性包装器引起的 Actor 隔离推断</strong> 提案通过审查。该提案已在 <strong>三十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0402-extension-macros.md" title="SE-0402" target="_blank" rel="noopener">SE-0402</a> <strong>将 conformance 宏作为 extension 宏</strong> 提案通过审查。该提案已在 <strong>三十三期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0403-swiftpm-mixed-language-targets.md" title="SE-0403" target="_blank" rel="noopener">SE-0403</a> <strong>软件包管理器混合语言目标支持</strong> 提案正在审查。</p><p>改提案旨在为包含 Swift 和 C 等基于语言的混合源代码的目标添加软件包管理器支持。目前，一个目标的源代码可以是 Swift 或 C 等基于语言（根据SE-0038），但不能同时存在两者。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0404-nested-protocols.md" title="SE-0404" target="_blank" rel="noopener">SE-0404</a> <strong>允许在非泛型上下文中嵌套协议</strong> 提案正在审查。</p><p>允许在非泛型的结构体、类、枚举和 actors 中嵌套协议。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-mathematical-typesetting-in-docc/66418" title="DocC 中的数学排版" target="_blank" rel="noopener">DocC 中的数学排版</a></p><p>提出了一个新的 DocC 指令，@Math：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The sample variance of the collection.</span></span><br><span class="line"><span class="comment">/// - Returns: The sample variance:</span></span><br><span class="line"><span class="comment">/// @Math("sample-variance.xml", description: "Sum, from i = 1 to n, of the squared norm of x_i minus mu. Everything divided by n minus 1.")</span></span><br><span class="line"><span class="comment">/// where 𝑛 is the collection's `count` and ‖𝑥ᵢ - 𝜇‖ is the Euclidean distance from each element 𝑥ᵢ to the sample mean 𝜇.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sampleVariance</span> …</span></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/17787/40fb523c-b052-4582-90e1-abd730fa72fb.png" alt=""></p><p><strong>动机</strong></p><p>文档页面通常需要包含数学表达式。例如，Apple 的 Accelerate 1 文档页面（使用 DocC 制作）通过方程式和矩阵来丰富文档的内容，以帮助阐明文档的文本内容。</p><p>虽然已经可以将数学表达式添加到 DocC 文档中，但所有现有的方法都还不够完善。</p><ul><li><p>对于只包含单行的表达式，使用 Unicode 数学符号通常就足够了，比如 <code>‖𝑥ᵢ - 𝜇‖²</code>。但是对于包含多行的表达式，使用 Unicode 数学符号往往不够美观或不易阅读。例如，对于上面所示的 TL;DR 表达式，能做到的最好效果是 <code>¹⁄₍ₙ₋₁₎ ∑ᵢ₌₁ⁿ ‖𝑥ᵢ - 𝜇‖²</code>。而且，很多时候，多行表达式在 Unicode 数学符号中根本无法表示。例如，Unicode 中没有上标希腊字母。矩阵也是无法表示的。</p></li><li><p>可以将排版好的数学表达式（例如 <code>LaTeX</code> 的 .tex 文件或 MathML 的 .xml 文件）编译为图像（比如 .png 或 .svg 格式）。这需要保持 2 - 3 个文件同步：浅色模式下的图像、深色模式下的图像，以及可选的（但最好有的）源文件。这就是 Accelerate 文档所采用的方法（不包含深色模式支持）。</p></li><li><p>也可以使用链接中提到的第六种方法，这是我个人比较喜欢的方式，但它也有自己的缺点（在链接的帖子中有详细介绍）。</p></li></ul><p>因此，为 DocC 提供对数学排版的一流支持将是一个受欢迎的补充。有许多不同的方法可以实现这一点，所以我在此发布帖子是为了让我们讨论潜在的解决方案。我将包含我个人的首选方案，以及一些替代方法。</p><p><strong>建议的解决方案</strong></p><p>保持简单：采用 MathML 编写，输出 MathML。DocC 输出的是网页；我认为我们应该充分利用这一事实，并在可能的情况下坚持使用 Web 标准。与 LaTeX 相比，MathML 的语法更加繁琐，但这个解决方案具有以下优势：</p><ul><li>不添加任何依赖，比如 MathJax 或 KaTeX。</li><li>避免了在运行时将 LaTeX 编译为 SVG（或将 LaTeX 编译为 MathML，或将 MathML 编译为 SVG）的性能问题。对于前两种情况（LaTeX 转 SVG 和 LaTeX 转 MathML），MathJax 是臭名昭著的，因为它可能导致屏幕上有许多方程式时的滞后。</li><li>无需额外工作即可适应明暗模式，因为 MathML 元素使用当前的字体颜色。可以试一下：检查 DocC 网页，添加一个带有一些 MathML 的 <code>&lt;math&gt;</code> 标签，然后在明暗模式之间切换。</li><li>是最容易实现和维护的。在验证源 MathML 有效性后，DocC 只需将其未经修改地粘贴到网页中。</li></ul><p>另外，无论输入是 MathML 还是 LaTeX，只要输出是 MathML（而不是 SVG 等其他格式），都将具有很好的可访问性，因为用户可以通过屏幕阅读器浏览 <math> 方程式。这比仅提供 alt 文本要好，因为在 DocC 支持数学排版之前，这是我们能做的最好的方式。 （话虽如此，MathJax 对于屏幕阅读器的支持也非常出色。）</math></p><p>作为未来的方向，我们可以考虑支持 LaTeX 作为源语言。如果我们这样做，我认为我们应该将 .tex 文件编译为 MathML（而不是 SVG、PNG 等）以保持一致性和最佳可访问性。另外，我们应该在编译文档时将源 LaTeX 编译为 MathML（即不通过 MathJax 或 KaTeX 在运行时进行编译），以获得更轻的文档网页并避免性能问题。</p><p>2) 讨论<a href="https://forums.swift.org/t/cannot-find-type-bar-in-scope-in-extension/66394" title="在扩展范围内找不到类型 Bar" target="_blank" rel="noopener">在扩展范围内找不到类型 Bar</a></p><p>给定以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面这个看似无害的扩展中，会产生错误：Cannot find type ‘Bar’ in scope</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123; <span class="comment">// Error: Cannot find type 'Bar' in scope</span></span><br><span class="line">        <span class="type">Bar</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，使用 typealias 可以解决这个问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Bar</span> = <span class="type">Foo</span>.<span class="type">Bar</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123; <span class="comment">// Okay</span></span><br><span class="line">        <span class="type">Bar</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不出来。有谁能解释这个错误的原因吗？</p><p>这两者不是等价的吗？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123;</span><br><span class="line">            <span class="type">Bar</span> ()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Bar</span> &#123;</span><br><span class="line">        <span class="type">Bar</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答：</strong></p><p>值得注意的是，在扩展中，令人惊讶的是，Self 解析为 Bar：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> </span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Foo</span>.<span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">bar</span> <span class="params">()</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Self</span> ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 讨论<a href="https://forums.swift.org/t/dealing-with-non-deterministic-task-execution-order/66411" title="处理非确定性任务执行顺序" target="_blank" rel="noopener">处理非确定性任务执行顺序</a></p><p>首先，想说明这个问题的范围超出了 TCA 本身，但我很好奇 TCA 是否能提供解决方案。</p><p>假设我们希望在 Main Actor 之外向数据库写入数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">Database</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> value: Int)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"insert <span class="subst">\(value)</span>"</span>) &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">(<span class="number">_</span> value: Int)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"delete <span class="subst">\(value)</span>"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们有一个 Reducer，例如，从 UI 接收输入。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AppReducer</span>: <span class="title">ReducerProtocol</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span>: <span class="title">Equatable</span> </span>&#123; … &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> insert(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> delete(<span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @<span class="type">Dependency</span>(\.database) <span class="keyword">var</span> database</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">ReducerProtocol</span>&lt;<span class="type">State</span>, <span class="type">Action</span>&gt; &#123;</span><br><span class="line">    <span class="type">Reduce</span> &#123; state, action <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">switch</span> action &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">let</span> .insert(value):</span><br><span class="line">        <span class="keyword">return</span> .run &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">          await database.insert(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="keyword">let</span> .delete(value):</span><br><span class="line">        <span class="keyword">return</span> .run &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">          await database.delete(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Reducer 按照特定的顺序接收操作，由于 Actor 的重入性，数据库可能不会按照相应的顺序被调用。例如，如果 Reducer 接收以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viewStore.send(.insert(<span class="number">0</span>))</span><br><span class="line">viewStore.send(.delete(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>由于 Swift Concurrency 中的每个挂起点都涉及非确定性的执行顺序，数据库可能会以错误的顺序执行，打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete 0</span><br><span class="line">insert 0</span><br></pre></td></tr></table></figure><p>在 GCD 世界中，会在串行队列上执行数据库写入操作，但是使用 Swift Concurrency 似乎没有很好的方法来模拟这种行为。因为每个挂起点都涉及非确定性的执行顺序。想知道是如何处理这个问题的。是否有根本不同的方式来思考 Swift Concurrency 中的设计模式？在其他情况下也遇到过这个问题，例如按照拍摄顺序显示照片。它适用于任何存在输入流进入异步进程并产生与输入相同顺序的输出的情况。</p><p><strong>回答：</strong></p><p>TCA 测试存储在序列化到主执行器时将表现出确定性（这是当前版本的配置选项，在即将发布的 1.0 版本中将成为默认设置）。</p><p>对于应用程序代码，如果需要在继续之前完全处理一个操作，可以使用 await：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">await viewStore.send(.insert(<span class="number">0</span>)).finish()</span><br><span class="line">viewStore.send(.delete(<span class="number">0</span>))  <span class="comment">// 在上面的操作完成之前不会执行</span></span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/i-just-want-to-write-extensions-that-i-can-make-available-wherever-i-want/66407" title="我只想编写能在任何地方使用的扩展" target="_blank" rel="noopener">我只想编写能在任何地方使用的扩展</a></p><p><strong>提问：</strong></p><p>为 String 和 Int 等类型编写和使用扩展很有趣，但是当这样做时，拉取请求没有获得批准，因为它们不符合 SOLID 原则。希望可以在协议内编写扩展，这样就可以在继承协议的任何地方使用扩展。</p><p><strong>回答：</strong></p><p>在 Swift 中，扩展遵循与任何其他类型声明相同的访问控制规则，因此，如果发现编写的扩展范围太广，可能希望利用一些工具来帮助解决这个问题。</p><p>例如，可以通过将扩展放在一个模块中，并且不将其设为 <code>public</code> 来限定其作用域，这样只有该模块中的类型才能看到并调用在该扩展中定义的方法。</p><p>或者，如果团队关心的是这些扩展是否合适，因为添加了在所有 String/Int/ 或其他类型上都不合理使用的功能，因此不应该广泛访问，那么更好的解决方案可能是引入一个新的特定于领域的类型，它包含一个 String/Int/ 或其他类型，并在其上提供特定于领域的接口。（例如，URL 类型可以被实现成包含一个 String，并提供相应工具的方式，而不是在 String 本身上提供 URL 类型的扩展）。”</p><p>5) 讨论<a href="https://forums.swift.org/t/enum-tuple-case-composing-decomposing-disparity/66406/1" title="Enum Tuple case 组合/分解差异" target="_blank" rel="noopener">Enum Tuple case 组合/分解差异</a></p><p>在这个例子中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Tuple</span> = (first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TupleEnum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> tuple(<span class="type">Tuple</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(value: TupleEnum)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> value &#123;</span><br><span class="line">    <span class="comment">// case let .tuple(t: Tuple): break // 很明显</span></span><br><span class="line">    <span class="comment">// case let .tuple((first, second)): break // 很明显</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .tuple(first, second): <span class="keyword">break</span> <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TupleEnum</span>.tuple(first: <span class="number">0</span>, second: <span class="number">0</span>) <span class="comment">// 🛑 枚举 case 'tuple' 需要一个类型为 'Tuple' (也就是 '(first: Int, second: Int)') 的单一参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用两个单独的变量匹配一个接受元组的枚举 case，但不能反过来做：用两个单独的变量构造该 case。</p><p>同样在这个例子中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Tuple</span> = (first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PairEnum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> pair(first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(e: PairEnum)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="comment">// case let .pair(first, second): break // 很明显</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .pair(v: <span class="type">Tuple</span>): <span class="keyword">break</span> <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tuple = <span class="type">Tuple</span>(first: <span class="number">0</span>, second: <span class="number">0</span>)</span><br><span class="line">    <span class="type">PairEnum</span>.pair(tuple) <span class="comment">// 🛑 枚举 case 'two' 需要2个单独的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用元组匹配接受两个单独变量的枚举 case，但不能反过来：用元组构造该 case。</p><p>是否可以以某种方式修复这个问题，使组合和分解行为保持一致？</p><p><strong>回答：</strong></p><p>更有趣的是，通过传递到泛型上下文，可以这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PairEnum</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> pair(first: <span class="type">Int</span>, second: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;T, U&gt;<span class="params">(<span class="number">_</span> f: <span class="params">(T)</span></span></span>-&gt;<span class="type">U</span>, <span class="number">_</span> x: <span class="type">T</span>) -&gt; <span class="type">U</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tuple = (first: <span class="number">0</span>, second: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> result = apply(<span class="type">PairEnum</span>.pair, tuple)    <span class="comment">// 这是有效的！</span></span><br></pre></td></tr></table></figure><p>…只是不能直接这样做，因为存在 SE-0029。</p><p>6) 讨论<a href="https://forums.swift.org/t/why-does-casting-type-metadata-to-anyobject-later-result-in-destroy-value-being-called-on-the-anyobject/66371" title="为什么将类型元数据转换为 AnyObject 后，最后会调用 destroy_value 以销毁 AnyObject？" target="_blank" rel="noopener">为什么将类型元数据转换为 AnyObject 后，最后会调用 destroy_value 以销毁 AnyObject？</a></p><blockquote><p>此帖子可能看起来有点抽象和学术，但它源自一个真实的问题！</p></blockquote><p>给定以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="number">_</span> = <span class="type">A</span>.<span class="keyword">self</span> <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器为函数 b 生成以下原始 SIL 代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">0</span> = metatype $@thick <span class="type">A</span>.<span class="type">Type</span>                    <span class="comment">// user: %1</span></span><br><span class="line">%<span class="number">1</span> = thick_to_objc_metatype %<span class="number">0</span> : $@thick <span class="type">A</span>.<span class="type">Type</span> to $<span class="meta">@objc</span>_metatype <span class="type">A</span>.<span class="type">Type</span> <span class="comment">// user: %2</span></span><br><span class="line">%<span class="number">2</span> = objc_metatype_to_object %<span class="number">1</span> : $<span class="meta">@objc</span>_metatype <span class="type">A</span>.<span class="type">Type</span> to $<span class="type">AnyObject</span> <span class="comment">// user: %3</span></span><br><span class="line">destroy_value %<span class="number">2</span> : $<span class="type">AnyObject</span>                   <span class="comment">// id: %3</span></span><br><span class="line">%<span class="number">4</span> = tuple ()                                   <span class="comment">// user: %5</span></span><br><span class="line"><span class="keyword">return</span> %<span class="number">4</span> : $()                                 <span class="comment">// id: %5</span></span><br></pre></td></tr></table></figure><p>为什么在函数的末尾有一个 <code>destroy_value</code>？据我所见，没有平衡的“retain”存在吗？</p><p><strong>回答：</strong></p><ol><li><code>AnyObject</code> 值默认始终被视为已保留，因此编译器必须释放它。</li><li>当将一个类转换为 <code>AnyObject</code> 时，编译器可以选择保留它，但它选择不这样做，因为它知道类是永久存在的，因此可以通过不执行此操作来节省代码大小和运行时间。</li></ol><p>这两个局部推理的结果导致了遇到的问题。如果释放操作与创建 <code>AnyObject</code> 值的地方足够远（例如，可能将一个类分配给全局变量，然后稍后将其他内容分配给它），对（1）进行更智能的处理是不可能的。因此，唯一100％正确的选择是在（2）方面更加保守，从而为这种罕见的使用情况提供好处，但同时为其他所有人带来不必要的操作成本。</p><p>7) 讨论<a href="https://forums.swift.org/t/why-this-pattern/66392" title="为什么会有这种设计模式？" target="_blank" rel="noopener">为什么会有这种设计模式？</a></p><p>这与一般编程以及 Swift 本身都有关。</p><p>从 UIKit 中，我们得到了以下函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> touches: Set&lt;UITouch&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    with event: UIEvent?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>如果没有事件对象，这个函数几乎没有意义。文档并没有提到会收到空事件。那么为什么事件是一个可选类型呢？</p><p><strong>回答：</strong></p><p>我不认为 UIKit 会用空事件调用 <code>touchesBegan()</code>，但这是一个需要重写方法并手动转发事件的 API，如果您没有处理事件，则需要手动转发，但该转发可能无法正确转发事件。不幸的是，最初允许转发空事件，而在事后将其更改为非可选类型是困难的。</p><p>如果同样的 API 是在今天使用 Swift 设计的，我怀疑事件参数将不会是可选的。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.avanderlee.com/swift/backdeployed-function-back-deployment/" title=" @backDeployed 用于将函数的可用性扩展到旧版本的操作系统" target="_blank" rel="noopener"> @backDeployed 用于将函数的可用性扩展到旧版本的操作系统</a></p><p><strong>摘要：</strong> 文章主要介绍了 @backDeployed 属性以及如何将函数的可用性扩展到旧的操作系统版本。 @backDeployed 属性是 Swift 5.8 首次实现的一项功能，并且在较低的最小部署目标和框架对比下，允许将新的声明提供给应用程序。文章详细解释了 @backDeployed 如何工作，并通过一个假设的 “Temperature” 类型的例子进行了演示。 @backDeployed 属性允许将函数回溯部署并使其对运行在旧版操作系统的应用程序可用。文章还指出，功能回溯部署主要对 SDK 开发者有用，同时也解释了为什么苹果不能将所有新的API回溯部署到旧的 OS 版本。使用 @backDeployed 属性进行函数回溯部署对于 SDK 开发者来说是一个很好的工具，能够使其 API 支持更有老旧的操作系统版本。虽然这不能解决所有新 API 的回溯部署问题，但它已经允许你使用一些新的、独立的 Swift API 。 </p><p><a href="https://www.swift.org/blog/introducing-swift-http-types/" title="Swift HTTP Types 的介绍" target="_blank" rel="noopener">Swift HTTP Types 的介绍</a></p><p><strong>摘要：</strong>  这篇 Swift 官方博客介绍了一个名为 “Swift HTTP Types” 的新的开源软件包。该软件包旨在为 Swift 中的客户端/服务器 HTTP 操作提供共享的通用类型。<br>文章指出，网络化应用中的网络技术对于许多用例来说在 Swift 中是无处不在的，包括客户端、服务器、中介和其他网络参与者。在苹果平台上，系统的 HTTP 实现通过 Foundation 框架中的 URLSession API 进行暴露。而对于 Swift 服务器项目，推荐使用 SwiftNIO 实现 HTTP。<br>为了在 Swift 中提供最佳的 HTTP 使用体验，共享的通用类型在许多项目中至关重要。 Swift HTTP Types 提供了一种表示 HTTP 消息核心构建块的通用表现形式。它包括 HTTPRequest 和 HTTPResponse ，分别代表客户端和服务器使用的 HTTP 消息。通过在多个项目中采用这些类型，可以在不同框架之间共享更多的代码，并消除在使用多个框架时的类型转换成本。</p><p><a href="https://juejin.cn/post/7260523399252475961?searchId=202307281123557A68223DBAE2C4960FFC/" title="Qunar 客户端 iOS 实时活动接入实践" target="_blank" rel="noopener">Qunar 客户端 iOS 实时活动接入实践</a></p><p><strong>摘要：</strong> 这篇文章介绍了去哪儿（Qunar）客户端如何实时接入了苹果在 iOS16 上推出的实时活动 (Live Activities) 功能。该功能允许应用在用户锁屏界面上展示实时信息，与常规推送相比，实时活动可以在一定时间段内持续展示，并于合适的时机自行消失，为用户提供更优秘体验。<br>通过实时活动功能，去哪儿的用户可以在出行全周期内，通过锁屏或灵动岛看到最新实时的出行信息。根据 Qunar 的数据，该功能自上线以来影响力显著，其中50%的用户已经与此功能互动，超过80%的用户因此而享受到更便捷的出行信息展示。目前，实时活动主要覆盖了航班和火车的出行场景，未来还可能延伸至船票、汽车票、景点门票等业务线场景，为 Qunar 的产品生态带来更大的贡献。<br>作者还详细介绍了实时活动的原理和机制，包括如何在主 APP 端启动一个实时活动实例，如何利用推送服务进行数据更新，如何关闭或更新实时活动等，并分享了在接入过程中遇到的问题及解决思路，希望帮助读者更好地理解和接入实时活动功能。。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？</strong></p><ol><li>必须买，因为贵不是它的缺点，也不是我的缺点。</li><li>超过一万元的话，那我现在的 iphone 还是可以将就用的。</li><li>我有钱但不代表我傻，手里的钱买两斤排骨它不香吗？</li><li>不买，当它超过一万快的时候，我的爱国情怀已悄然攀升。</li><li>别说一万块钱啦，就是降价到五千，我也不买。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组整理周报的第三十四期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;恰似烈日灼身，清风缕缕慰我清静。恰似无边心海，&lt;strong&gt;Swift社区&lt;/strong&gt;渡我心安！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：iPhone Pro 要提价！新款 iPhone 或会使用 USB-C 充电器，边框更薄&lt;/p&gt;
&lt;p&gt;提案：允许在非泛型上下文中嵌套协议&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议 DocC 中的数学排版&lt;/p&gt;
&lt;p&gt;推荐博文：Swift HTTP Types 的介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;苹果公司正在考虑在今年秋季推出新款 iPhone Pro 时提高其高端手机的价格，那么如果到时候新款 iPhone Pro 在国内的价格超过了一万元，你还会买吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-周报-第三十三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十三期/</id>
    <published>2024-03-06T07:56:00.000Z</published>
    <updated>2024-03-06T08:01:11.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十四期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>看那碧水蓝天，波澜又壮阔。浅读<strong>Swift社区</strong>，充实而豁然。期许光亮，皆在其中！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：App 内购买项目和订阅即将实行价格与税率调整</p><p>提案：将 conformance 宏作为 extension 宏</p><p>Swift 论坛：讨论 <code>\</code> 和 <code>$</code> 的意义</p><p>推荐博文：轻量化的 iOS 动画框架实现</p><p><strong>话题讨论：</strong> </p><p>最新薪酬排行出炉，广州平均月薪 10883 元，北京平均月薪 13438 元，你的月薪处于什么水平？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/6efb3a39-c887-439f-a0a6-909472e4961b.jpg" alt=""></p><p>这个结果表明大多数人对 vision pro 在推动虚拟现实技术发展方面持乐观态度。Vision pro 具备强大的图像处理和感知能力，可以为虚拟现实应用提供更加逼真、沉浸式的体验。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="App-内购买项目和订阅即将实行价格与税率调整"><a href="#App-内购买项目和订阅即将实行价格与税率调整" class="headerlink" title="App 内购买项目和订阅即将实行价格与税率调整"></a>App 内购买项目和订阅即将实行价格与税率调整</h3><p>App Store 的交易和支付机制旨在帮助你在覆盖全球的 175 个国家和地区的店面中，以 44 种货币为你的产品和服务便捷地进行定价与销售。当税务法规或外汇汇率变化时，App Store 中某些地区的价格有时会随之更新，且你的收入亦将调整。这些调整将根据金融数据机构提供的公开汇率信息进行，以此确保 App 和 App 内购买项目的定价在所有店面中保持平衡。</p><p>从 7 月 25 日起，App 和 App 购买项目 (不包括自动续期订阅) 在埃及、尼日利亚、坦桑尼亚和土耳其店面中的定价将会进行调整。这些调整还包含了以下税率变更：</p><p>埃及：收取 14% 的增值税 (VAT)<br>坦桑尼亚：收取 18% 的增值税和 2% 的数字服务税<br>土耳其：增值税率从 18% 上调至 20%<br>这些调整对定价的影响<br>如果你选择了埃及、尼日利亚、坦桑尼亚或土耳其作为 App 或 App 内购买项目 (不包括自动续期订阅) 的基准店面，则对应店面中的价格不会发生变化。其他店面中的价格将会进行更新，以便与你选择的基准价格保持持平。<br>如果你为 App 或 App 内购买项目 (不包括自动续期订阅) 选择的基准店面不是埃及、尼日利亚、坦桑尼亚或土耳其，则埃及、尼日利亚、坦桑尼亚和土耳其店面中的价格将会上调。<br>如果你的 App 内购买项目是自动续期订阅，或者如果你手动管理各个店面的价格，而不是使用自动均衡价格，那么你的价格不会发生变化。<br>App Store Connect 中“我的 App”的“价格与销售范围”部分现已更新，以显示这些即将进行的价格调整。一如既往，你可以随时更改你的 App、App 内购买项目和自动续期订阅的价格。</p><p>这些调整对收益和税务管理的影响<br>你从 App 和 App 内购买项目 (包括自动续期订阅) 销售中获得的收益将会发生变化，以反映新的税率和更新后的价格。《付费 App 协议》的附录 B 已更新，表明 Apple 在埃及和坦桑尼亚征收和汇付适用税款。</p><h3 id="为家庭提供安全的-App-体验"><a href="#为家庭提供安全的-App-体验" class="headerlink" title="为家庭提供安全的 App 体验"></a>为家庭提供安全的 App 体验</h3><p>App Store 的创建目的是为用户提供一个安全且值得信赖的 App 下载平台，并为开发者提供绝佳的商机。由于孩子们会使用我们的产品和服务，来探索数字世界并与家人和朋友进行交流，因此对许多家庭而言，Apple 平台和你构建的 App 变得非常重要。针对面向儿童的 App，以及那些具有用户生成内容和互动的 App，我们设立了极高的标准。为了继续为家庭打造安全的体验，谨在此提醒你，我们提供了各种工具和资源，并制定了相关要求，以帮助你保障用户在 App 中的安全。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>将 conformance 宏作为 extension 宏</strong> 提案正在审查。</p><p>该提案将 <code>conformance</code> 宏角色推广为 <code>extension</code> 宏角色，除了协议和 where 子句外，还可以向扩展中添加成员列表。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/are-these-typos/66118" title="这些是错别字吗？" target="_blank" rel="noopener">这些是错别字吗？</a></p><p>提问：</p><p>在观看 SwifUIi 视频时，看到两处看起来像是拼写错误的东西。想知道为什么它们的表达如此含糊：</p><p>反斜杠有什么用？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">List</span> (graphics, children: \.children) &#123; graphic <span class="keyword">in</span></span><br><span class="line">        <span class="type">GraphicRow</span> (graphic)</span><br><span class="line">    &#125;</span><br><span class="line">    .listStyle(<span class="type">SidebarListStyle</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>美元符号有什么用？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">DocumentGroup</span> (newDocument: <span class="type">SketchDocument</span>()) &#123; file <span class="keyword">in</span></span><br><span class="line">        <span class="type">DocumentView</span>(file.$document)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>这些不是拼写错误。它们是用于访问特定语言功能的符号，这些功能会生成与命名属性相关的内容，而不是正常访问该属性。</p><p>Swift 在前缀运算符位置中使用 \ 来创建“关键路径”，该对象通常表示（在本例中）<code>Graphic.children</code> 属性，而不是特定 <code>Graphic</code> 的 <code>Children</code>属性；该对象可以应用于 Graphic 的任何实例以访问其 Children 属性。</p><p>在其他语言中，\ 字符在字符串文字中很常见，它开始一个“转义序列”，但它很少用作运算符，并且使用它的语言之间几乎没有一致性。</p><p>这里与“转义”的想法有某种模糊的联系，因为在这两种情况下，你都在逐步提升到更抽象的含义水平，但在大多数情况下，它被选择是因为它是一个未使用的符号，通常是 易于打字并且看起来不错。 该功能的演变提案实际上讨论了几种不同的语法，<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0161-key-paths.md#spelling" title="并解释了为什么选择反斜杠" target="_blank" rel="noopener">并解释了为什么选择反斜杠</a>。</p><p>$ 前缀意味着您正在访问相关属性的属性包装器提供的特殊功能。在这里，该属性是 <code>FileDocumentConfiguration.document</code>，<a href="https://developer.apple.com/documentation/swiftui/filedocumentconfiguration/document" target="_blank" rel="noopener">根据文档</a>有一个 <code>@Binding</code> 属性包装器。 这意味着 $document 将公开一个到文档的 Binding - 一个可用于访问和修改该文档属性的对象，而无需关心它实际存储的位置。</p><p>我们将此 $ 变量称为“投影值”而不是“绑定值”或其他任何名称，因为 $ 语法是通用语言功能，因此如果您使用 @Binding 以外的其他内容，$ 属性可能不会创建绑定；可能被赋予一些其他功能。</p><p>选择这两种语法并不是因为它们会立即熟悉，而是因为我们确定没有一种语法可以立即熟悉，最好选择开发人员需要学习但一旦学习后会发现易于使用的语法。</p><p>2) 讨论<a href="https://forums.swift.org/t/nslock-lock-plus-await-plus-nslock-unlock-leads-to-main-thread-freeze/66113" title="NSLock.Lock 加 Await 加 NSLock.Unlock 导致主线程冻结" target="_blank" rel="noopener">NSLock.Lock 加 Await 加 NSLock.Unlock 导致主线程冻结</a></p><p>提问：</p><p>以下代码模拟了当外部库的作者引入锁时的情况，这可能包含等待调用。 </p><p>有什么办法可以防止这种情况</p><p>noasync 注释不是解决方案，因为：</p><p>1）如果函数包装在另一个没有 noasync 注释的函数中，它不起作用；<br>2）第三方库的作者可能会忘记添加这样的注释。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">thirdPartyLibLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"- do sum work and lock"</span>)</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     I also tried to replace it with:</span></span><br><span class="line"><span class="comment">         await withCheckedContinuation(&#123; c in</span></span><br><span class="line"><span class="comment">             lock.lock()</span></span><br><span class="line"><span class="comment">             c.resume()</span></span><br><span class="line"><span class="comment">         &#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">thirdPartyLibUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"- do sum work and unlock"</span>)</span><br><span class="line">    lock.unlock()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     I also tried to replace it with:</span></span><br><span class="line"><span class="comment">         await withCheckedContinuation(&#123; c in</span></span><br><span class="line"><span class="comment">             lock.unlock()</span></span><br><span class="line"><span class="comment">             c.resume()</span></span><br><span class="line"><span class="comment">         &#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Console:</span></span><br><span class="line"><span class="comment">     - start 4</span></span><br><span class="line"><span class="comment">     - do sum work and lock</span></span><br><span class="line"><span class="comment">     - start 1</span></span><br><span class="line"><span class="comment">     - do sum work and lock</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     And that's all. We have suspended main thread.</span></span><br><span class="line"><span class="comment">     Numbers 4 and 1 could differ between app launches, it's ok.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">1000</span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- start <span class="subst">\(i)</span>"</span>)</span><br><span class="line"></span><br><span class="line">            thirdPartyLibLock()</span><br><span class="line">            <span class="keyword">try</span> await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line">            thirdPartyLibUnlock()</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- end <span class="subst">\(i)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Won't be executed.</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="number">3</span>, execute: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"- ping"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><p>由于多种原因，锁定+解锁 API 对在设计上是不安全的，这就是其中之一。 更好的设计是使用一个函数来获取锁，调用回调，然后在回调返回后释放锁。</p><p>（理想情况下，该函数还可以提供对受锁保护的资源的回调访问，否则将无法访问。）只需使整个过程同步，就可以非常巧妙地表达在锁定和解锁之间不挂起的要求。</p><p>3) 讨论<a href="https://forums.swift.org/t/desired-swift-language-features-that-can-advance-the-state-of-c-interoperability-support/66144" title="所需的 Swift 语言功能可以提升 C++ 互操作性支持的状态" target="_blank" rel="noopener">所需的 Swift 语言功能可以提升 C++ 互操作性支持的状态</a></p><p>内容：</p><p>Swift 5.9 可以在 Swift 中导入和使用多种 C++ 类型。 但是，并非所有类型类别都受支持。这篇文章列出了一组所需的 Swift 语言功能，这些功能使我们能够支持 Swift 中的大多数 C++ 类型：</p><p>对不可复制类型的泛型支持。 虽然 Swift 5.9 添加了对不可复制结构和枚举的支持，但这些类型仍然不允许用作泛型类型参数。 </p><p>这是阻止我们在 Swift 中完全完成对仅移动 C++ 类型的支持的一个关键问题，因为我们需要形成像 UnsafePointer<moveonlycxxtype> 这样没有语言限制的类型。</moveonlycxxtype></p><p>添加到上面的一点，像 UnsafePointer 和 UnsafeMutablePointer 这样的类型应该提供对借用和可变借用不可复制指针对象的支持。</p><p>不可移动/不可逃避的 Swift 类型类别。 不可转义和不可复制的 Swift 类型将允许我们在 Swift 中导入和建模不可复制和不可移动的 C++ 类型。</p><p>此外，以下语言功能将有助于改善 Swift 中对 C++ 类型执行的一些常见操作的人体工程学：</p><p>能够在 Swift 序列上执行借用 for 循环，这确实需要经过 IteratorProtocol，但可以使用索引迭代。 这将使我们能够自动在 std::map 等非随机访问集合上使用 for 循环。</p><p>回答：</p><p>这些听起来与我们计划完善不可复制类型支持的项目一致，这很好。 在此列表中包含内部导入以及支持导入 C 和 C++ 类型而不间接公开其 ABI 是否也有意义，以便允许包在内部使用 C++ 互操作而不要求依赖项了解它？</p><p>4) 讨论将协议添加到同名模块<br>提问：</p><p>我有一个名为 HTML 的模块，其中包含同名的类型 HTML。 它的树看起来像这样：</p><ul><li>HTML（模块）</li><li>HTML（结构）</li><li>HTML.属性（枚举）</li><li>HTML.ContainerElement（枚举）</li><li>HTML.VoidElement（枚举）</li></ul><p>到目前为止，一切都很好。 不可能限定对该模块中的声明的引用，因为它是同名的，但这没关系，因为 HTML 类型本身在功能上是命名空间限定符。</p><p>现在想向这个模块添加一个协议，称之为 <code>HTMLOutputStreamable</code>。但是不能向未命名为 HTML 的 HTML 模块添加顶级类型，因为该模块是同名的，并且无法使用 <code>HTML.HTMLOutputStreamable</code> 来限定对此协议的引用。</p><p><strong>该如何解决这个问题？</strong></p><p>回答：</p><p>我发现的唯一方法就是使用不同的名称。</p><p>从这个角度来看，Swift 仍然缺少完整的命名空间功能。 可以是模块级命名空间，但更完整和可靠。 我更喜欢像 C++ 那样的命名空间，或者像 Rust 那样的显式模块定义，但这似乎不是 Swift 进化愿景的一部分。</p><p>5) 讨论<a href="https" title="嵌套函数和 @ViewBuilder：奇怪的编译器错误">嵌套函数和 <code>@ViewBuilder</code>：奇怪的编译器错误</a></p><p>以下代码给出了一个奇怪的编译器错误，该错误似乎不相关：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">world</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">            <span class="string">"world"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello, <span class="subst">\(world()</span>)!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误信息是：</p><p>包含声明的闭包不能与结果生成器 “ViewBuilder” 一起使用</p><p>有趣的是，如果我在 world() 中添加 return （即 return “world”），编译器会在其他地方显示错误并添加警告，两者也不是很相关。 这看起来更像是一个编译器错误。</p><p>有什么想法吗？</p><p>回答：</p><p>从历史上看，结果构建器对其内部运行的语法有一些限制。 其中许多限制在 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0373-vars-without-limits-in-result-builders.md" target="_blank" rel="noopener">SE-0373</a>：解除结果构建器中变量的所有限制中被删除，但如果仍然存在一些限制，我不会感到惊讶。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7252586606091419708/" title="轻量化的 iOS 动画框架实现" target="_blank" rel="noopener">轻量化的 iOS 动画框架实现</a></p><p><strong>摘要：</strong> 在这篇博客中，介绍了日常开发中对视图进行动画处理的常见问题，并提供了一种解决方案。文章首先展示了普通的动画代码，并指出了其回调函数回溯的问题。接着介绍了一些流行的动画库，如 Spring ， Hero 和 TweenKit ，但它们都存在一些限制。为了解决这些问题，引入了一种简洁、易于使用和维护的动画执行方式。该方案基于 Animator 和 Animation 的封装实现，其中 Animator 定义了动画执行器的基本协议，并封装了几种不同类型的动画执行器。 Animation 定义了动画执行的参数，并为不同的 Animato r制定了不同的协议。此外，文章还介绍了类型擦除的概念，以解决参数类型不一致的问题。具体实现方面，通过扩展UIView添加了串行和并行动画的方法。最后，总结了该方案的优点和可能的改进点。 </p><p><a href="https://www.polpiella.dev/load-custom-fonts-with-no-code-using-swift-package-plugins/" title="使用 Swift Package 插件将自定义字体加载到您的应用程序中" target="_blank" rel="noopener">使用 Swift Package 插件将自定义字体加载到您的应用程序中</a></p><p><strong>摘要：</strong>  本文介绍了如何使用 Swift Package 插件将自定义字体加载到应用程序中。通过创建一个 Swift Package 来包含共享的字体文件和字体加载代码，可以加快新应用的发布速度，减少代码重复，并提供一个统一更新字体文件的地方。结合 Swift Package 的可重用性和 Swift Package 插件的强大功能，甚至可以在构建时从字体文件自动生成所有必要的代码。本文使用 SwiftGen 来演示如何实现这一点。首先创建一个名为 “Fonts” 的 Swift Package ，并在其中添加自定义字体资源。然后添加 SwiftGen 插件来生成加载字体所需的代码。最后，可以使用生成的代码来在 SwiftUI 和 UIKit 中使用自定义字体。</p><p><a href="https://swiftwithmajid.com/2023/07/04/mastering-swift-foundation-formatter-api-custom-format-styles/" title="掌握 Swift Foundation Formatter API 。自定义格式样式" target="_blank" rel="noopener">掌握 Swift Foundation Formatter API 。自定义格式样式</a></p><p><strong>摘要：</strong> 本篇博客介绍了如何使用 Swift Foundation Formatter API 中的自定义格式样式。作者分享了自己在每个项目中都使用该 API 并构建自定义格式化逻辑的经验。博客中详细讲解了 FormatStyle 协议以及如何创建符合该协议的自定义格式样式。通过示例，展示了如何创建短数字格式样式和粗体数字格式样式，并说明了如何在自定义类型中重用这些格式样式。最后，作者还提供了一种封装格式化逻辑的方法。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>最新薪酬排行出炉，广州平均月薪 10883 元，北京平均月薪 13438 元，你的月薪处于什么水平？</strong></p><ol><li>巨富</li><li>豪</li><li>小富</li><li>小康</li><li>穷</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十四期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;看那碧水蓝天，波澜又壮阔。浅读&lt;strong&gt;Swift社区&lt;/strong&gt;，充实而豁然。期许光亮，皆在其中！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：App 内购买项目和订阅即将实行价格与税率调整&lt;/p&gt;
&lt;p&gt;提案：将 conformance 宏作为 extension 宏&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 &lt;code&gt;\&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 的意义&lt;/p&gt;
&lt;p&gt;推荐博文：轻量化的 iOS 动画框架实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;最新薪酬排行出炉，广州平均月薪 10883 元，北京平均月薪 13438 元，你的月薪处于什么水平？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十二期/</id>
    <published>2023-07-04T07:20:25.000Z</published>
    <updated>2023-07-04T07:32:29.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十三期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>骚年，努力去成为你期待已久的自己吧，就像<strong>Swift社区</strong>一样，时刻心怀梦想，不断向前！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果已提供新的设计资源</p><p>提案：本期提案没有最新内容</p><p>Swift 论坛：讨论 Non-Reentrant Actors</p><p>推荐博文：AngularGradient 在 swiftUI 中的使用</p><p><strong>话题讨论：</strong> </p><p>你认为 vision pro 是否会加速虚拟现实技术的发展？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/976e8f1f-d753-438d-8117-a58b5a020286.jpeg" alt=""></p><p>根据投票结果，小编认为企业应根据自身情况和员工需求，平衡薪资保密与透明的利弊，制定适合的薪资政策。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="现已提供新的设计资源"><a href="#现已提供新的设计资源" class="headerlink" title="现已提供新的设计资源"></a>现已提供新的设计资源</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/7DD13ED0-F50B-4568-813A-2C89D0D8DB25/2048.jpeg" alt=""></p><p>为方便开发者在 Apple 平台上构建 App，我们现在提供了全新及更新后的设计资源，让你可以更便捷、更准确地设计 App。</p><p>visionOS 设计资料库以及适用于 Figma 和 Sketch 的模板 (英文)。</p><p>适用于 Figma 和 Sketch 的 iOS 17 和 iPadOS 17 设计套件 (英文)。</p><p>适用于 Figma 和 Sketch 的 macOS Sonoma 设计套件 (英文)。</p><p>适用于 Sketch 的 watchOS 10 设计套件 (英文)。</p><p>SF Symbols 5 Beta 版，包含 700 多个新符号 (英文)。</p><p>更新后的《人机界面指南》(英文)，现提供简体中文和日文版本。</p><p>SF 脚本扩展，现已支持亚美尼亚语、格鲁吉亚语和希伯来语 (英文页面)。</p><h3 id="visionOS-SDK-现已发布"><a href="#visionOS-SDK-现已发布" class="headerlink" title="visionOS SDK 现已发布"></a>visionOS SDK 现已发布</h3><p>Apple Vision Pro 提供了一幅无边的画布，你现在就可以开始为这幅画布打造前沿的空间计算 App。下载 Xcode 15 Beta 版 2，其中包含 visionOS SDK 和 Reality Composer Pro — 这是一种新的工具，可让你轻松地预览和准备适用于 visionOS 的 3D 内容。将 visionOS 目标添加到你的现有项目中或构建一个全新的 App，然后在 Xcode 预览中迭代你的 App。你可以在全新的 visionOS 模拟器中与你的 App 互动，探索各种房间布局和光线条件，并创建测试和可视化效果。此外，我们还提供了新的文档和示例代码，帮助你完成整个开发过程。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>本期提案没有最新内容，期待下期更新～～</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/request-for-feedback-partial-consumption-of-fields-of-noncopyable-types/65884" title="使用部分不可复制类型的字段" target="_blank" rel="noopener">使用部分不可复制类型的字段</a></p><p><strong>介绍</strong></p><p>当前给定一个类似于 var 的构造（例如：var、inout），Swift 不允许部使用耗该类型的存储字段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> : ~<span class="title">Copyable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> : ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> first: <span class="type">E</span></span><br><span class="line">    <span class="keyword">var</span> second: <span class="type">Klass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="number">_</span> = s.e <span class="comment">// Error! Cannot partially consume s</span></span><br></pre></td></tr></table></figure><p><strong>不可复制类型的部分使用</strong></p><p>在设计空间中考虑以下几个不同的轴：</p><ol><li>关于带有 deinit 的类型</li><li>启用 Library Evolution 时</li><li>当 Library Evolution 被禁用时</li><li>无论哪种情况，是否应该只允许方法中的部分消耗。</li></ol><p>具有 Deinits 的类型的部分消耗</p><p>禁止使用 deinits 部分消耗不可复制类型，因为当字段被部分消耗，允许该类型被销毁</p><p>例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> : ~<span class="title">Copyable</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> : ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> first: <span class="type">E</span></span><br><span class="line">   <span class="keyword">var</span> second: <span class="type">E</span></span><br><span class="line">   <span class="keyword">deinit</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="number">_</span> = s.first <span class="comment">// s.first is destroyed here</span></span><br><span class="line">doSomething()</span><br><span class="line"><span class="comment">// s.second is destroyed here</span></span><br></pre></td></tr></table></figure><p>由于这里的 s 已被部分消耗，因此永远不会将其全部销毁，这意味着永远不会调用它自己的 deinit，这意味着不能允许发生。 </p><p><strong>请注意</strong>，即使不允许这样做，仍然允许使用方法的作者使用丢弃运算符来关闭值的 deinit，然后部分解构该值。</p><p>2) 提问<a href="https://forums.swift.org/t/can-a-group-of-weak-references-conform-to-collection/65899" title="一组弱引用可以符合Collection吗？" target="_blank" rel="noopener">一组弱引用可以符合Collection吗？</a></p><p>问题陈述：</p><p>有一个收集弱引用的类型，可以对其进行迭代并追加。 </p><p>希望它符合 RangeReplaceableCollection，但是不能做任何比 Sequence 更具体的事情。</p><p>该类型本身是一个经典的指针长度容量三元组，其中指针指向弱引用缓冲区。 一旦长度==容量，在尝试重新分配之前，会扫描缓冲区以查找可以丢弃的 nils。 仅当无法删除足够的 nil 来为新元素腾出空间时，才会执行重新分配。</p><p>使其符合 Collection 的问题是下标(<code>_:</code>)。 如果索引类型只是缓冲区中的索引，则其他线程可能会导致弱引用从下面删除，因此索引可能会变得无效，而不会对集合进行明显的更改。</p><p>可以想到两种方法来解决这个问题，但都不能令人满意。</p><p>第一个是使索引类型也持有对该对象的强引用。 但是担心当用户没有意识到他们通过索引持有强大的参考时，可能会产生问题。</p><p>第二个是使元素类型为T？ 而不是 T。这是一种误导，因为迭代器会跳过 nils，但会使下标可实现。</p><p>第三个选项是在不实际遵守协议的情况下实现许多（但不是全部）收集操作。 担心这是我必须做的，除非能证明其他两种行为之一是合理的。 </p><p>有没有一种方法可以在不改变类型语义的情况下实现协议？</p><p>回答：</p><p>不是集合似乎是所提供的数据结构的固有属性，而不是实现限制。 如果序列中的第 n 个项目可以从 x 更改为 y，因为 x（或序列中较早的某个其他对象）已被收集，则序列没有稳定的索引。</p><p>3) 提问<a href="https://forums.swift.org/t/no-such-module-uikit-in-swift-macro/65885" title="swift Macro 中没有这样的模块“UIKit”" target="_blank" rel="noopener">swift Macro 中没有这样的模块“UIKit”</a></p><p>在 swift Macro 中导入 UIKit 时，报错 No such module ‘UIKit’ 。</p><p>宏包有以下平台</p><p>平台：[.macOS(.v10_15)、.iOS(.v13)、.tvOS(.v13)、.watchOS(.v6)、.macCatalyst(.v13)]</p><p>回答：</p><p>在构建过程中，宏在编码的计算机（可能是 Mac/Windows/Linux）上运行。 它不在 iOS 上运行，因此无法访问 UIKit。</p><p>为什么在宏中需要 UIKit（而不是在声明宏的包中）？</p><p>可以尝试创建一个可以导入 UIKit 的“Mac Catalyst”宏，但即使有可能，也可能没有用</p><p>4) 提议<a href="https://forums.swift.org/t/pitch-low-level-linkage-control-attributes-used-and-section/65877" title="低级联动控制属性：@used 和@section" target="_blank" rel="noopener">低级联动控制属性：@used 和@section</a></p><p><strong>动机</strong></p><p>动机有两个目标：</p><p>提供低级构建块来构建更多高级 API，例如 “链接器集”（见下文）或自定义每种类型元数据，如 SE-0385 中所述（swift-evolution/proposals/0385-custom-reflection-metadata.md，位于 main·apple/swift-evolution·GitHub 2）。</p><p>尽管这个推介/提案实际上并没有尝试添加或设计高级 API，只是提供了一条单独解锁设计的路径。</p><p>为系统编程用例提供低级机制（这些用例是针对具体系统的定制案例），并构建一个通常可重用的高级 API 是没有意义的（项目作者可以自由地构建这样一个高级 API，例如项目的内部机制）。</p><p>“链接器集”机制是 Swift 已经在使用的一种方法：几乎任何类型的编译器发出的元数据都被放入二进制文件中专门命名的部分中，并给出固定布局的记录。 </p><p>然后，想要查找某些信息时（例如，在二进制文件中查找协议一致性），要求加载器（Darwin 上的 dyld）为我们提供每个加载的该部分的起始/结束地址。 图像，然后可以迭代这些部分中的所有记录。 </p><p>还可以从进程外部提取一些元数据，或者从二进制文件本身中挖掘它。使用现有的反射库来完成此操作，例如 <code>swift-inspect</code> 和 <code>swift-reflection-dump</code>。</p><p>在 Swift 语言中添加功能来表达该机制的第一部分：将固定布局记录放入专门命名的部分。</p><p><strong>提议</strong></p><p>其中一些已经在功能标志下实现为 main 中的下划线属性（ <code>@_section</code>、<code>@_used</code>），通过 <a href="https://github.com/apple/swift/pull/65901" target="_blank" rel="noopener">https://github.com/apple/swift/pull/65901</a> 实现。 总之：</p><p>@used 属性，通过 llvm.used 将全局变量或顶级函数标记为“不要死区”，大致相当于 C/C++ 中的 <strong>attribute</strong>((used)) 。</p><p>@section(“…”) 属性，将全局变量或顶级函数放入具有该名称的节中，大致相当于 C/C++ 中的 <strong>attribute</strong>((section(“…”))) 。</p><p>这些注释只能应用于保证最终“静态初始化”（而不是通过 init_once 运行时调用延迟初始化）的全局变量，因为否则注释没有任何意义。</p><p>这就提出了一个有趣的问题：当用于初始化全局时，哪些表达式可以保证“静态初始化”？ 建议从一组非常基本的表达式开始，并在将来对其进行改进。</p><p>强制优化管道已经使整数文字、元组和简单算术表达式进行“静态初始化”，如果存在任何具有 <code>@section</code> 属性的全局变量，可以在 SIL 管道末尾明确拒绝编译 这不是静态初始化的。 </p><p>然后，作为后续改进，应该考虑允许 POD 结构类型也在强制优化管道中处理，并允许与 <code>@section</code> 一起使用。</p><p>虽然超出了本次推介的范围，但以下是“链接器集”API 的运行时端的草图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// in Module1</span></span><br><span class="line">@used @section(<span class="string">"__DATA,mysection"</span>) <span class="keyword">private</span> <span class="keyword">let</span> my_entry: <span class="type">Int</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// in Module2</span></span><br><span class="line">@used @section(<span class="string">"__DATA,mysection"</span>) <span class="keyword">private</span> <span class="keyword">let</span> my_entry: <span class="type">Int</span> = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> <span class="type">SwiftRuntime</span>.section(<span class="string">"__DATA,mysection"</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; <span class="comment">// this uses the loader's APIs to locate and iterate over the section</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，将其包装到基于宏的解决方案中可能是有意义的，这样就根本不会公开低级属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">LinkerSet</span>(name: <span class="string">"myLinkerSet"</span>) <span class="keyword">private</span> <span class="keyword">let</span> myEntry: <span class="type">Int</span> = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> <span class="type">SwiftRuntime</span>.linkerSet(<span class="string">"myLinkerSet"</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，在想要将元数据附加到类型的情况下（由 SE-0385 推动）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Registered</span>(name: <span class="string">"My Favorite Type"</span>) <span class="comment">// this creates a hidden global in a named section</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> regType <span class="keyword">in</span> allRegisteredTypes &#123; <span class="comment">// queries over the entries in the section</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5) 提问<a href="https://forums.swift.org/t/enable-preprocessor-flags-during-build/65892" title="在构建期间启用预处理器标志" target="_blank" rel="noopener">在构建期间启用预处理器标志</a></p><p>有一个 C++ 头文件，仅在设置了预处理器标志时才公开一个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIX_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Some_Class</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UNIX_ENABLED</span></span></span><br></pre></td></tr></table></figure><p>当调用 swift 编译器时：</p><p>swiftc MyApp.swift -cxx-互操作性模式=默认-Xcc -std=c++17 -I cxx -c -parse-as-library</p><p>并尝试在 MyApp.swift 中使用 Some_Class ，但显然找不到该类。 尝试使用 -D UNIX_ENABLED 但这没有帮助。</p><p>有什么想法可以进行此编译吗？</p><p>回答：</p><p>可以尝试将 -Xcc -D -Xcc UNIX_ENABLED 传递给 swiftc 以确保它将 -D 转发给 clang</p><p>6) 讨论<a href="https://forums.swift.org/t/non-reentrant-actors/65888" title="Non-Reentrant Actors" target="_blank" rel="noopener">Non-Reentrant Actors</a></p><p>每当编写涉及 Actor 的代码时，发现自己想要对 Actor 进行有意义的工作，但最终会在此过程中引入难以捕获的错误。 以这个简单的例子为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">HeavyLifting</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cachedResult: <span class="type">String</span>?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doHeavyLifting</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cachedResult &#123; <span class="keyword">return</span> cachedResult &#125;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">try</span> await <span class="comment">// load some resource and process it.</span></span><br><span class="line">        cachedResult = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发人员可能会认为这是确保只执行一次“繁重工作”并缓存结果的完全足够的方法。然而，更精明的审阅者可能会注意到，虽然这不会导致灾难性的失败，实际上也不会保护繁重的工作不被多次完成，因为对此方法的多个并发请求虽然不是“ 一旦达到每个负载的暂停点，每个负载就会开始繁重的工作负载。</p><p>更具冒险精神的开发人员的工具带中确实有一个工具可以解决这个问题 - 非结构化任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">HeavyLifting</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heavyLiftingTask: <span class="type">Task</span>&lt;<span class="type">String</span>, <span class="type">Error</span>&gt;?</span><br><span class="line">    <span class="keyword">var</span> heavyLiftingResult: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> heavyLiftingTask &#123; <span class="keyword">return</span> <span class="keyword">try</span> await heavyLiftingTask.value &#125;</span><br><span class="line">            <span class="keyword">let</span> task = <span class="type">Task</span> &#123; <span class="keyword">try</span> await <span class="comment">// load some resource and process it. &#125;</span></span><br><span class="line">            heavyLiftingTask = task</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> await task.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在引入了不完整样板的微妙平衡，更不用说缺乏对取消传播的适当支持，所有这些都是以防止死锁的名义，而实际上并没有阻止富有冒险精神的开发人员编写可能会导致死锁的代码。</p><p>代码中到处都是这样的样板文件，最终肯定会弄错，当一天结束时，希望并假设在错误的等待最终潜入之前所做的事情，是为了 Actor 的方法在进行过程中不可调用，而 Actor 的其余部分则继续其业务。</p><p>已经使用过 Actor 一段时间，重新审视不可重入性，因为它是比较有用的工具。可以看到单独的方法或函数是希望以某种能力强制执行串行访问的东西，但是也可以看到将其应用于对整个参与者的所有访问的好处。</p><p>回答：</p><p>在未来方向（有任务链重入的奖励积分，但没有任务链重入绝对非常有用）将如那里所描述的那样非常棒。不希望应用于整个 Actor。</p><p>会有助于避免现在很容易变得脆弱的模式来解决缺乏此功能的问题。</p><p>可选的参与者“发送”对 Void 返回函数的支持一起将释放参与者的很大一部分潜力。</p><p>7) 讨论<a href="https://forums.swift.org/t/accessing-source-code-after-macro-expansion/65881" title="宏扩展后访问源代码" target="_blank" rel="noopener">宏扩展后访问源代码</a></p><p>当构建一个使用 SwiftSyntax 遍历 Swift 源代码的工具时，是否有一种直接的方法来遍历宏扩展后的源代码？</p><p>这是否需要通过尝试扩展每个源文件来手动完成？</p><p>正在构建的工具中，复制源文件并对其进行操作，但这是直接来自文件系统和预扩展的。 具体来说，该工具会遍历有效的 .swift 文件并捕获符合给定协议的所有类型。使用宏来添加对该协议的一致性，但是构建插件无法仅通过阅读非扩展源代码来了解最终的一致性。 使用 <code>Target.directory</code> 来确定给定目标的源文件所在的位置，但是是否有更好的方法来访问扩展源所在的构建目录？</p><p>回答：</p><p>如果对宏扩展的工作原理感到好奇，可以在<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/#Macro-Expansion" target="_blank" rel="noopener">这个文档</a>中阅读。</p><p>Swift 中的宏扩展基于语法的内存表示，这意味着无法在不手动执行扩展的情况下直接从源文件中检索扩展的代码。</p><p>可能会考虑尝试使用此方法扩展所有宏：<a href="https://github.com/apple/swift-syntax/blob/b556ac7c099539ed058f6fcfd978d66cb133176e/Sources/SwiftSyntaxMacros/MacroSystem.swift#L576" target="_blank" rel="noopener">SyntaxProtocol.expand(macros:in:)</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swdevnotes.com/swift/2023/angulargradient-in-swiftui/" title="AngularGradient 在swiftUI中的使用" target="_blank" rel="noopener">AngularGradient 在swiftUI中的使用</a></p><p><strong>摘要：</strong> 本篇文章讲解了如何在 swiftUI 中使用  AngularGradient，用于从一种颜色过渡到另一种颜色，可选地通过围绕指定中心点的放射状图案中的一系列颜色。本文探讨了设置不同中心点以及指定渐变的起始角度和结束角度范围的效果。 AngularGradient 可用于在 SwiftUI 视图中创建引人注目的视觉效果，尤其是在圆形或弧形中使用时。</p><p><a href="https://juejin.cn/post/7095940115532349454/" title=" 字节跳动 DanceCC 工具链系列之Swift 调试性能的优化方案" target="_blank" rel="noopener">字节跳动 DanceCC 工具链系列之Swift 调试性能的优化方案</a></p><p><strong>摘要：</strong>  本篇文章讲解了大型 Swift 项目如何通过开关，以及自定义 LLDB ，优化 Swift 开发同学的调试速度，提高整体的研发效能。其中讲解了 LLDB 的部分工作流程，以及针对性优化的技术细节，以及实际效果。</p><p><a href="https://juejin.cn/post/7244809939839434808/" title="Swift 的可选值优化" target="_blank" rel="noopener">Swift 的可选值优化</a></p><p><strong>摘要：</strong> 在 Swift 中，nil 的语义与 Objective-C 中的 nil 不同，它代表没有值的概念。为了表示没有值，Swift 引入了 nil 关键字，但在内存中的表示方式与 Objective-C 不同。文章通过代码展示了 nil 在内存中的真正表示，发现可选的 Int? 类型比普通的 Int 类型多占一个字节，用来表示是否有值。然而，Swift 编译器已经进行了优化，例如 Bool? 类型只占用一个字节，用2来表示 nil 。 String 类型也可以在内存中用0表示没有值。对于 Class 类型和 Enum 类型，空指针或越界值可以表示没有值，也没有内存浪费。总之， Swift 编译器会尽可能地优化可选值的内存占用，但仍建议在某些情况下尽量少使用可选值，特别是在结构体中连续多个可选的 Int 的情况下，可以使用非可选值并用0初始化它们。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>你认为vision pro是否会加速虚拟现实技术的发展？</strong></p><ol><li>会</li><li>不会</li><li>AI发展才是王道</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十三期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;骚年，努力去成为你期待已久的自己吧，就像&lt;strong&gt;Swift社区&lt;/strong&gt;一样，时刻心怀梦想，不断向前！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果已提供新的设计资源&lt;/p&gt;
&lt;p&gt;提案：本期提案没有最新内容&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Non-Reentrant Actors&lt;/p&gt;
&lt;p&gt;推荐博文：AngularGradient 在 swiftUI 中的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为 vision pro 是否会加速虚拟现实技术的发展？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十一期/</id>
    <published>2023-07-04T07:20:20.000Z</published>
    <updated>2023-07-04T07:31:54.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十二期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>若目标远大，就要有大动作。若追求卓越，便须有大改变。<strong>Swift社区</strong>已整装待发，你要不要一起呢？👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：Apple Vision Pro 和 visionOS 撼世登场</p><p>提案：移除由属性包装器引起的 Actor 隔离推断</p><p>Swift 论坛：为什么只能将结构附加到数组一次</p><p>推荐博文：Swift OpenAPI Generator 的介绍</p><p><strong>话题讨论：</strong> </p><p>你认为企业实行薪资保密有哪些利弊</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/273d30d8-22a4-4ef9-9e4b-b6a692f6aac3.png" alt=""></p><p>上期话题投票结果表明，在 2023 年工作更难找的情况下，大家面临着更大的工作压力，裁员消息的传出也增加了担忧。大量的媒体报道可能强调了经济衰退的迹象，这也会加强大家对经济危机的看法。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="注册-WWDC23-实验室和活动"><a href="#注册-WWDC23-实验室和活动" class="headerlink" title="注册 WWDC23 实验室和活动"></a>注册 WWDC23 实验室和活动</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/1AC9D4F4-43B5-4913-B149-B0486FFE64FE/2048.jpeg" alt=""></p><p>通过在线实验室和活动这种绝佳方式，你可以在一整周内与 Apple 工程师、设计师和专家进行交流沟通。</p><p>一对一实验室<br>从开发的基础知识到复杂概念，你都可以在这里获得个性化指导。了解如何运用全新 Apple 技术、探索 UI 设计原则、优化产品在 App Store 上的形象，以及更多主题。</p><p>活动<br>每日都有许多精彩的活动在 Slack 中展开。</p><p>在 Q&amp;A 中就工程和设计主题提问。<br>在大家一起观看讲座视频期间加入或关注实时对话，并与演讲者进行 Q&amp;A。<br>在社区暖场活动中了解其他开发者和 Apple 团队。<br>体验最新的框架，尝试各种设计理念，并在学习区分享你的创作。<br>在 6 月 6 日，与业内的佼佼者比试一下专业知识问答。<br>实验室和活动对 Apple Developer Program 和 Apple Developer Enterprise Program 的所有成员，以及 2023 Swift Student Challenge 参赛者开放。</p><h3 id="Apple-Vision-Pro-和-visionOS-撼世登场"><a href="#Apple-Vision-Pro-和-visionOS-撼世登场" class="headerlink" title="Apple Vision Pro 和 visionOS 撼世登场"></a>Apple Vision Pro 和 visionOS 撼世登场</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/213FE0A2-813D-404D-B093-D766AC8D7AF3/2048.jpeg" alt=""></p><p>Apple Vision Pro 是一款革命性的空间计算设备，可实现数字化内容与真实世界的无缝融合，让用户在沉浸于当下的同时还能与他人沟通交流。在 Apple Vision Pro 中，各种 App 将突破传统显示器的束缚限制，拥有一幅无边的画布。此外，Apple Vision Pro 还推出了一个全三维用户界面，而控制这个界面，仅需要用户的眼睛、双手和语音 — 最自然、最直观的输入工具。Apple Vision Pro 搭载了全球首个空间操作系统 visionOS，让用户能够以一种绝妙的方式与数字化内容互动，如同它们真的存在于现实世界之中。Apple Vision Pro 采用了突破性设计：在显示方面，采用超高分辨率显示屏系统，两块显示屏的总像素为 2,300 万；在性能方面，采用独特的双芯片设计并搭载定制的 Apple 芯片，确保每一刻的体验都真实无比，让人沉浸当下。</p><p>探索丰富实用的资源，助你通过一种全新而又熟悉的方式将空间计算方面的创意变为现实，打造出能够重新定义沟通、效率和娱乐的 App。</p><h3 id="App-Store-中新增的隐私功能"><a href="#App-Store-中新增的隐私功能" class="headerlink" title="App Store 中新增的隐私功能"></a>App Store 中新增的隐私功能</h3><p>在 Apple，我们将隐私视作每个人的基本权利。因此，我们构建了许多功能来帮助用户了解开发者在隐私以及数据收集和共享方面的做法，让用户能够自主掌控他们的数据。通过 App 跟踪透明度 (ATT)，用户可以选择 App 是否有权跟踪用户在其他公司的 App 和网站内的活动，以便投放广告或者与数据代理商共享。借助隐私标签和 App 隐私报告，用户可以查看 App 收集哪些数据以及如何使用这些数据。</p><p>许多 App 会利用第三方软件开发工具包 (SDK)，这些工具包可以提供出色的功能，但可能会对 App 处理用户数据的方式产生影响。为了让开发者可以更轻松地打造出色的 App，同时告知用户数据使用情况并尊重他们在这方面做出的选择，我们推出了两项新功能。</p><p>首先，为了帮助开发者了解第三方 SDK 如何使用数据，我们推出了新的隐私清单。隐私清单是一份文件，会以单一标准格式概述 App 中第三方代码的隐私做法。当开发者准备分发他们的 App 时，Xcode 会将开发者使用的所有第三方 SDK 中的隐私清单合并为一个简单易用的报告。这个报告内容全面，总结了 App 中的所有第三方 SDK，使开发者能够更轻松地创建更准确的隐私标签。</p><p>此外，为了向用户提供额外的隐私保护，如果 App 引用的 API 可能会被用于指纹识别（在 App Store 中被禁止的一种做法），现在需要选择合理的原因来解释为什么使用此 API 并在隐私清单中声明已使用此 App。在这个过程中，App 必须准确描述其对于这些 API 的使用情况，并且只能出于隐私清单中所述的原因而使用这些 API。</p><p>第二，我们希望帮助开发者改善软件供应链的完整性。使用第三方 SDK 时，开发者可能很难知道他们下载的代码是不是由期望的开发者编写的。为了解决这个问题，我们推出了适用于 SDK 的签名功能，这样一来，当开发者在 App 中采用新版本的第三方 SDK 时，Xcode 将验证它是否由同一开发者签名。这个功能将对开发者和用户都十分有帮助。</p><p>我们将在今年晚些时候发布更多信息，包括：</p><p>影响隐私的 SDK 列表 (对用户隐私产生重大影响的第三方 SDK)<br>“需要指明原因”的 API 列表，使用它们时必须给出合理的原因<br>开发者反馈表，用于就调用涉及的 API 提出新的原因<br>其他文档，详细介绍签名和隐私清单、他们的优势以及何时需要使用它们</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" title="SE-0400" target="_blank" rel="noopener">SE-0400</a> <strong>Init 访问器</strong> 提案正在审查。</p><p>该提案的目的是，Init 访问器将属性包装器的离线初始化特性泛化，使得类型中的任何计算属性都可以选择参与确定性初始化分析，并且可以替代使用自定义初始化代码对一组存储属性进行初始化。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0401-remove-property-wrapper-isolation.md" title="SE-0401" target="_blank" rel="noopener">SE-0401</a> <strong>移除由属性包装器引起的 Actor 隔离推断</strong> 提案正在审查。</p><p>SE-0316：全局 Actors 引入了像 <code>@MainActor</code> 这样的注释，将类型、函数或属性隔离到特定的全局 Actor。还引入了各种规则，用于推断全局 Actor 隔离。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UIUpdating</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">  @<span class="type">MainActor</span> <span class="keyword">var</span> wrappedValue: <span class="type">Wrapped</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CounterView</span> </span>&#123; <span class="comment">// infers @MainActor from use of @UIUpdating</span></span><br><span class="line">  @<span class="type">UIUpdating</span> <span class="keyword">var</span> intValue: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该提案主张在使用 Swift 6 语言模式编译时移除此推断规则。根据上面的示例，<code>CounterView</code> 在 Swift 6 中将不再推断 <code>@MainActor</code> 隔离。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="SE-0400: Init Accessors" target="_blank" rel="noopener">SE-0400: Init Accessors</a></p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0400-init-accessors.md" target="_blank" rel="noopener">SE-0400</a>：Init Accessors 314 的审查从现在开始，一直持续到 2023 年 6 月 26 日。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-improve-the-proposal-template-for-better-feature-experimentation/65604" title="改进提案模板以获得更好的功能实践" target="_blank" rel="noopener">改进提案模板以获得更好的功能实践</a></p><p><strong>介绍</strong></p><p>强制性工具链和示例项目以及 Experiment It 部分将允许开发人员在提案审查期间更轻松地进行实验并参与讨论。</p><p><strong>动机</strong></p><p>试验正在审查的功能这是评估提案的重要方式，即使是写得很好和详细的提案也可以从让开发人员试验它中受益。 提案模板可以改进，使任何人在审查期间更容易试用提议的功能。</p><p><strong>建议的解决方案</strong></p><p>将以下标题字段添加到提案模板：工具链和示例项目以及新的 Experiment It 部分。</p><p><strong>工具链</strong></p><p>该字段应指向一个链接，从中可以下载一个 swift 工具链，其中该功能是在实验性标志下实现的。</p><p>目前大多数提案只提到主分支中有一个功能可用，尽管大多数时候该功能都在 Swift.org 上可用的开发快照中 - 下载 Swift 对于新手来说了解这一点并不是那么微不足道，有时还有一个提案审查期 甚至在没有工作快照的情况下启动。</p><p>该链接应该从第一天起就可用，并在审核期间尽可能更新。</p><p>一种可能性是在网站下载页面上添加一个额外的部分，其中包含专用于正在审查的提案的工具链，这可以允许工具链可用，即使由于某种原因它不能出现在主快照中也是如此。</p><p>3) 提问<a href="https://forums.swift.org/t/why-can-i-only-append-a-struct-to-an-array-once/65601" title="为什么只能将结构附加到数组一次？" target="_blank" rel="noopener">为什么只能将结构附加到数组一次？</a></p><p>我的应用程序的目标是提醒用户与他们亲近的人互动。 因此，我的应用程序主要使用两个结构体，称为 Relation（代表一个人）和 Interaction（代表与人的一次交互）。</p><p>我构建了一个名为 “NewInteractionSheet” 的工作表，其目标是向关系的交互数组之一添加一个新的交互。</p><p>在添加交互时，此工作表非常有效。 但是，由于某种原因，它只能工作一次。 为什么要这样做？ 这就是我想要弄清楚的。</p><p>这是 “NewInteractionSheet.swift” 代码的一部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PhotosUI</span><br><span class="line"><span class="keyword">import</span> CoreLocation</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewInteractionSheet</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> isPresentingNewInteractionView: <span class="type">Bool</span></span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> relations: [<span class="type">Relation</span>]</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> newInteraction = <span class="type">Interaction</span>.emptyInteraction</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> relation: <span class="type">Relation</span> = <span class="type">Relation</span>.emptyRelation</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPresentingLocationPicker: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">Form</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">Section</span>(<span class="string">"You interacted with..."</span>) &#123;</span><br><span class="line">                    <span class="type">RelationPicker</span>(relations: $relations, relation: $relation)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">Section</span>(<span class="string">"Interaction details"</span>) &#123;</span><br><span class="line">                    <span class="type">InteractionDatePicker</span>(dateToSet: $newInteraction.date)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">TypePicker</span>(typeToSet: $newInteraction.type)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">DurationPicker</span>(shouldShow: newInteraction.type.hasDuration,</span><br><span class="line">                                   hoursToSet: $newInteraction.durationHours,</span><br><span class="line">                                   minutesToSet: $newInteraction.durationMinutes)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">SummaryTextField</span>(summaryToSet: $newInteraction.summary)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">LocationPicker</span>(shouldShow: newInteraction.type.hasLocation,</span><br><span class="line">                                   coordinatesToSet: $newInteraction.location.coordinates,</span><br><span class="line">                                   locationNameToSet: $newInteraction.location.name,</span><br><span class="line">                                   isPresentingLocationPicker: $isPresentingLocationPicker)</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">InteractionPhotosPicker</span>(images: $newInteraction.pictures)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .toolbar &#123;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .cancellationAction) &#123;</span><br><span class="line">                    <span class="type">Button</span>(<span class="string">"Dismiss"</span>) &#123;</span><br><span class="line">                        isPresentingNewInteractionView = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .confirmationAction) &#123;</span><br><span class="line">                    <span class="type">Button</span>(<span class="string">"Add"</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> index = relations.firstIndex(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.id == relation.id &#125;) &#123;</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">"\nBefore appending to relations"</span>)</span><br><span class="line">                            <span class="built_in">print</span>(relations[index])</span><br><span class="line">                            <span class="built_in">print</span>(newInteraction)</span><br><span class="line">                            relations[index].interactions.append(newInteraction)</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">"\nAfter having appended to relations"</span>)</span><br><span class="line">                            <span class="built_in">print</span>(relations[index])</span><br><span class="line">                            <span class="built_in">print</span>(newInteraction)</span><br><span class="line">                        &#125;</span><br><span class="line">                        isPresentingNewInteractionView = <span class="literal">false</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//AJOUTER LA PLANIFICATION D'UNE NOTIFICATION</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">"New interaction"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如在代码中看到的，我包含了三个“打印”指令来帮助我调试它。 当我尝试添加两个交互时，以下是控制台中打印的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Before</span> appending to relations</span><br><span class="line"><span class="type">Relation</span>(id: <span class="type">EA18AAD4</span>-<span class="type">E576</span>-49A9-90BF-<span class="type">CC58C5000ECE</span>, firstName: <span class="string">"Johanna"</span>, lastName: <span class="string">"Duby"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1814400.0</span>, birthday: <span class="type">Optional</span>(<span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">40</span> +<span class="number">0000</span>), notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.blue, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">After</span> having appended to relations</span><br><span class="line"><span class="type">Relation</span>(id: <span class="type">EA18AAD4</span>-<span class="type">E576</span>-49A9-90BF-<span class="type">CC58C5000ECE</span>, firstName: <span class="string">"Johanna"</span>, lastName: <span class="string">"Duby"</span>, photo: <span class="literal">nil</span>, interactions: [<span class="type">Relations</span>.<span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])], contactFrequency: <span class="number">1814400.0</span>, birthday: <span class="type">Optional</span>(<span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">40</span> +<span class="number">0000</span>), notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.blue, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 106CD832-<span class="number">1949</span>-<span class="number">4800</span>-<span class="type">AC75</span>-<span class="type">E21B8890E580</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">43</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"><span class="type">Before</span> appending to relations</span><br><span class="line"><span class="type">Relation</span>(id: 8D3D2012-<span class="type">D8A2</span>-<span class="number">4092</span>-<span class="type">B1A9</span>-<span class="type">D476F7E05B9A</span>, firstName: <span class="string">"Nastassja"</span>, lastName: <span class="string">"Ferrari"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1209600.0</span>, birthday: <span class="literal">nil</span>, notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.green, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 5C4EE2E1-7D2D-4E32-<span class="type">BC00</span>-<span class="type">FCA781EC8C20</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">49</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">After</span> having appended to relations</span><br><span class="line"><span class="type">Relation</span>(id: 8D3D2012-<span class="type">D8A2</span>-<span class="number">4092</span>-<span class="type">B1A9</span>-<span class="type">D476F7E05B9A</span>, firstName: <span class="string">"Nastassja"</span>, lastName: <span class="string">"Ferrari"</span>, photo: <span class="literal">nil</span>, interactions: [], contactFrequency: <span class="number">1209600.0</span>, birthday: <span class="literal">nil</span>, notes: <span class="string">""</span>, theme: <span class="type">Relations</span>.<span class="type">Theme</span>.green, reminders: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Interaction</span>(id: 5C4EE2E1-7D2D-4E32-<span class="type">BC00</span>-<span class="type">FCA781EC8C20</span>, date: <span class="number">2023</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">49</span> +<span class="number">0000</span>, type: <span class="type">Relations</span>.<span class="type">InteractionType</span>.audioCall, durationHours: <span class="number">0</span>, durationMinutes: <span class="number">0</span>, summary: <span class="string">""</span>, location: <span class="type">Relations</span>.<span class="type">Location</span>(name: <span class="string">""</span>, coordinates: <span class="literal">nil</span>), pictures: [])</span><br></pre></td></tr></table></figure><p>4) 提问<a href="https://forums.swift.org/t/are-nested-recursive-macros-supported-in-swift-5-9/65569" title="Swift 5.9 是否支持嵌套/递归宏？" target="_blank" rel="noopener">Swift 5.9 是否支持嵌套/递归宏？</a></p><p>5) 提问<a href="https://forums.swift.org/t/how-to-reference-an-article-in-a-different-module/65581" title="如何引用不同模块中的文章？" target="_blank" rel="noopener">如何引用不同模块中的文章？</a></p><p>查看 DocC 代码链接的语法，似乎我们有办法引用同一模块中的文章：</p><doc:gettingstarted><p>但是我们不能使用前导斜杠语法来指定模块相对路径，因为它已经被 tutorials 命名空间占用：</p><p><a href="doc:/tutorials/SlothCreator" target="_blank" rel="noopener">doc:/tutorials/SlothCreator</a></p><p>如何引用来自不同模块的文章？</p><p>回答：</p><p>库存 DocC 尚不支持外部 - 或者更具体地说，尚未提供公共解决方案。 早期的 DocC 代码中有一些关于允许某些过程的外部引用解析器的位，@ronnqvist 一直在研究更新的解决方案（“分层解析器”）——但我只关注了一些 PR（最近的一个 提取了很多旧代码：通过 d-ronnqvist 添加成功解析的外部引用到参考索引, <a href="https://github.com/apple/swift-docc/pull/582" target="_blank" rel="noopener">Pull Request #582</a>）</p><p>6) 提问<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="Macros包会嵌入到App中吗？" target="_blank" rel="noopener">Macros包会嵌入到App中吗？</a></p><p>例如，当我使用 #stringify Swift 宏在我的应用程序中生成代码时，它会在编译期间用新代码替换我的一些源代码。 那么这个宏包会随我的应用程序一起提供吗？ 或者它只是在编译期间发生</p><p>回答：替换发生在编译时。 宏目标不应链接到应用该目标中包含的宏的代码。</p><p>7) 提问<a href="https://forums.swift.org/t/se-0400-init-accessors/65583" title="哪个 Apple Networking Api 用于 UDP 多播和单播？" target="_blank" rel="noopener">哪个 Apple Networking Api 用于 UDP 多播和单播？</a></p><p>一般而言，iOS 开发和网络的新手。 开发一个游戏节目类型的应用程序，其中“主机”设备需要多播到“参赛者”设备。 参赛者设备也需要能够响应。 实际上传递的信息很少，但速度很重要，因此使用 UDP。 </p><p>我一直在研究苹果设备的一些常用网络 api：network.framework、CocoaAsyncSocket、Multipeer-Connectivity、BSD 套接字等。总的来说，我倾向于只使用高级 network.framework 但缺乏 示例和资源使决策变得困难。 任何意见，将不胜感激。</p><p>回答：<a href="https://developer.apple.com/documentation/technotes/tn3151-choosing-the-right-networking-api" target="_blank" rel="noopener">TN3151: Choosing the right networking API</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.swift.org/blog/introducing-swift-openapi-generator/" title=" Swift OpenAPI Generator 的介绍" target="_blank" rel="noopener">Swift OpenAPI Generator 的介绍</a></p><p><strong>摘要：</strong> Swift OpenAPI Generator是一个 SwiftPM 插件，它可以生成客户端代码或服务器端代码，以便处理 HTTP 调用。 OpenAPI 是一种用于记录HTTP服务的规范，可以使用YAML或JSON编写，并可被工具读取，以帮助自动化工作流程，例如生成必要的代码以发送和接收HTTP请求。Swift OpenAPI Generator 可以帮助我们通过 OpenAPI 文档描述HTTP请求和响应的结构，包括 HTTP 方法、 URL 路径和查询参数、HTTP状态码和内容类型，使用 JSON Schema 描述响应体的结构，使得我们能够在开发应用程序时生成网络代码，而不需要手动编写和维护网络代码，专注于核心业务逻辑。要使用 Swift OpenAPI Generator 插件，需要添加 SwiftPM 依赖项以及运行时库和传输实现，然后使用生成的API客户端或服务器端存根。 Swift OpenAPI Generator 支持大多数常用特性，但仍有一些特性需要实现，项目跟踪进展情况可以使用 GitHub issues </p><p><a href="https://www.avanderlee.com/swift/macros/" title=" Swift 宏：使用新的表达方式扩展 Swift" target="_blank" rel="noopener"> Swift 宏：使用新的表达方式扩展 Swift</a></p><p><strong>摘要：</strong>  Swift 宏是在 Swift 5.9发布的一项新功能，它允许你通过自定义编译时检查和生成新的代码，在编译时将它们写入到你的文件中，从而消除冗余的样板代码。本文讲解了宏的工作原理、如何编写自定义宏以及如何进行测试，以验证一个允许在编译时验证 URL 并在 URL 有效时返回解包值的宏的例子。本文还讨论了宏的不同角色，包括独立和附加宏，并解释了为什么你可能考虑在代码中使用宏。</p><p><a href="https://www.avanderlee.com/swift/share-swift-code-swift-on-server-vapor/" title="在 Swift 服务器端 Vapor 和客户端应用之间共享 Swift 代码" target="_blank" rel="noopener">在 Swift 服务器端 Vapor 和客户端应用之间共享 Swift 代码</a></p><p><strong>摘要：</strong> 这篇博客讨论了在客户端应用和后端服务器之间共享 Swift 代码的好处以及如何通过 Swift 包和 Vapor 实现这一目标。通过共享模型和端点定义，您可以确保两个侧面都使用相同的层，避免出现意料之外的请求失败。博客提供了定义软件包结构、暴露模型、共享端点定义和在后端软件包中配置端点的代码示例。此外，它提供了一个通用方法，用于请求端点并在客户端应用中使用它们。作者还提到了优化适用于所有支持的 HTTP 方法的代码的重要性。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>薪酬保密作为人力资源管理中一项颇具争议的举措，近年来学界对其研究越来越多。有人提出，实行薪酬保密，能让企业根据员工绩效的高低提供差异较大的薪酬，提升薪酬激励作用，同时也能避免因为收入差距产生内部冲突。也有人提出公开的薪酬制度能使内部沟通更为有效，减少误传，增强信任感，作为一种制度，薪酬的等级体系、岗位差距以及操作程序还应以公开为准则。<strong>你认为企业实行薪资保密有哪些利弊？</strong></p><p>1.保护员工个人隐私。</p><p>2.避免员工之间的比较和嫉妒心理，减少内部矛盾。</p><p>3.难以查看薪资公正性，更少的保密性意味着更多的平等。</p><p>4.易产生员工对公司不信任，让员工产生长期处于被剥削的感觉。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p></doc:gettingstarted>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十二期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;若目标远大，就要有大动作。若追求卓越，便须有大改变。&lt;strong&gt;Swift社区&lt;/strong&gt;已整装待发，你要不要一起呢？👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：Apple Vision Pro 和 visionOS 撼世登场&lt;/p&gt;
&lt;p&gt;提案：移除由属性包装器引起的 Actor 隔离推断&lt;/p&gt;
&lt;p&gt;Swift 论坛：为什么只能将结构附加到数组一次&lt;/p&gt;
&lt;p&gt;推荐博文：Swift OpenAPI Generator 的介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为企业实行薪资保密有哪些利弊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第三十期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%B8%89%E5%8D%81%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第三十期/</id>
    <published>2023-07-04T07:20:16.000Z</published>
    <updated>2023-07-04T07:31:19.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十一期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>求人不如求己，你多一样本领，就少一点啊乞求；<strong>Swift社区</strong>让你多一样技能，少一些嘲讽！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：码出新宇宙，WWDC23 就在眼前</p><p>提案：有 4 个提案通过，本期没有产生新的提案</p><p>Swift 论坛：PermutableCollection 协议</p><p>推荐博文：SwiftUI 中 LinearGradient的用法</p><p><strong>话题讨论：</strong> </p><p>有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/6f2a4159-0a47-4f33-b6d2-5f7516d78f89.png" alt=""></p><p>上期话题讨论结果表明，<strong>社交隔阂</strong>和<strong>个人选择标准的提高</strong>是导致男女群体互不干涉的主要原因，而<strong>社会观念的变化</strong>也起到了一定的影响。这些因素共同作用导致了男群体和女群体相互独立地寻找伴侣的现象。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="App、App-内购买项目和订阅即将实行税率调整"><a href="#App、App-内购买项目和订阅即将实行税率调整" class="headerlink" title="App、App 内购买项目和订阅即将实行税率调整"></a>App、App 内购买项目和订阅即将实行税率调整</h3><p>App Store 的交易和支付机制旨在帮助你在覆盖全球的 175 个国家和地区的商店中，以 44 种货币为你的产品和服务便捷地进行定价与销售。Apple 会为开发者管理其中 70 多个国家和地区的税收，而且你还能够为 App 和 App 内购买项目分配税务类别。我们会根据税务法规的变化，定期更新你在某些地区的收益。</p><p>从 5 月 31 日起，你从 App 和 App 内购买项目 (包括自动续期订阅) 销售中获得的收益将进行调整，以反映以下税率调整。请注意，相关内容的价格将保持不变。</p><p>加纳：增值税率从 12.5% 上调至 15%。<br>立陶宛：对于符合条件的电子书和有声书，增值税率从 21% 下调至 9%。<br>摩尔多瓦：对于符合条件的电子书和期刊，增值税率从 20% 下调至 0%。<br>西班牙：收取 3% 的数字服务税。<br>由于巴西税务法规的变化，在巴西开展的所有 App Store 销售现由 Apple 代扣税款。我们会按月代扣代缴应向相应税务机关缴纳的税款。自 2023 年 6 月开始，你可以在 5 月份的收入中查看从你的收益中扣除的税款金额。巴西境内的开发者不会受到这一变化的影响。</p><p>以上调整生效后，App Store Connect 中“我的 App”的“价格与销售范围”部分会随即更新。一如既往，你可以随时更改你的 App 和 App 内购买项目的价格 (包括自动续期订阅)。现在，你可以从 900 个价格点中选择，为任何店面更改定价。</p><h3 id="码出新宇宙"><a href="#码出新宇宙" class="headerlink" title="码出新宇宙"></a>码出新宇宙</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/B6D2ADBF-1563-457E-82CE-374A654AA6B0/2048.jpeg" alt=""></p><p>WWDC23 就在眼前。太平洋夏令时间 6 月 5 日上午 10 点，Apple 主题演讲将在 apple.com 和 Apple Developer App 线上提供，为本次大会拉开序幕。你还可以通过同播共享，邀请朋友一起观看。</p><p>现在，符合条件的开发者可以开始报名参加活动了。相关活动包括 Q&amp;A、“会见演讲者”以及社区暖场活动等线上聊天室活动，旨在促进你与开发者社区和 Apple 专家的沟通和交流。</p><h3 id="Apple-公证服务更新"><a href="#Apple-公证服务更新" class="headerlink" title="Apple 公证服务更新"></a>Apple 公证服务更新</h3><p>正如去年在 WWDC (简体中文字幕) 上宣布的那样，如果你目前使用 altool 命令行工具或者 Xcode 13 或更早版本通过 Apple 公证服务对 Mac 软件进行公证，则需要改为使用 notarytool 命令行工具，或者升级到 Xcode 14 或更高版本。自 2023 年 11 月 1 日起，Apple 公证服务将不再接受从 altool 或者 Xcode 13 或更早版本上传的内容。已经过公证的现有软件可以继续正常工作。</p><p>Apple 公证服务是一个自动化系统，它会扫描 Mac 软件中有没有恶意内容，检查有没有代码签名问题，并快速返回结果。对软件进行公证可向用户保证，Apple 已检查且未发现软件中包含恶意软件。</p><p>为改进 Apple 平台的安全性和隐私保护，用于验证 App 和关联 App 内购买项目销售的 App Store 收据签名媒介证书将更新为使用 SHA-256 加密算法。此更新将分多个阶段完成，新的 App 和 App 更新可能会受影响，具体取决于它们验证收据的方式。</p><h3 id="Apple-设计大奖入围名单公布"><a href="#Apple-设计大奖入围名单公布" class="headerlink" title="Apple 设计大奖入围名单公布"></a>Apple 设计大奖入围名单公布</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/020C144B-0FE5-49A1-ADB2-7B01072574C7/2048.jpeg" alt=""></p><p>Apple 设计大奖旨在表彰在多元包容、乐趣横生、出色互动、社会影响、视觉图像，以及创新思维等类别中表现出色的 App 和游戏。马上一睹今年的入围作品，我们将在太平洋夏令时间 6 月 5 日下午 6:30 揭晓获奖者，敬请关注。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0399-tuple-of-value-pack-expansion.md" title="SE-0399" target="_blank" rel="noopener">SE-0399</a> <strong>value 包展开的元组</strong> 提案通过审查。该提案已在 <strong>二十九期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0397-freestanding-declaration-macros.md" title="SE-0397" target="_blank" rel="noopener">SE-0397</a> <strong>独立声明 Macros</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0392-custom-actor-executors.md" title="SE-0392" target="_blank" rel="noopener">SE-0392</a> <strong>自定义 Actor 执行器</strong> 提案通过审查。该提案已在 <strong>二十五期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md" title="SE-0390" target="_blank" rel="noopener">SE-0390</a> <strong>引入 @noncopyable </strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://translate.google.com/?sl=en&amp;tl=zh-CN&amp;text=Migrating%20from%20Realm%20Database%20Tips%3F&amp;op=translate" title="从 Realm 数据库迁移提示？" target="_blank" rel="noopener">从 Realm 数据库迁移提示？</a></p><p><strong>提问</strong></p><p>目前正在寻求迁移到更轻量级的解决方案（realm 目前对我的用例来说太过分了）并且想迁移到 grdb，但不必将 realm 作为依赖项持续一年或更长时间……</p><p><strong>回答</strong></p><p>在没有 Realm 库的情况下，您是否能够读取 Realm 数据库文件的内容？ 否则，您必须将 Realm 作为依赖项保留，直到您的用户迁移完毕。</p><p>您可以通过发布能够要求用户升级的应用程序版本来缩短时间跨度。 这将允许您使用 “Realm-only”、“Realm-to-GRDB” 和最终的 “GRDB-only” 版本进行过渡。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-allow-protocols-to-be-nested-in-non-generic-contexts/65285" title="允许 protocol 嵌套在非通用上下文中" target="_blank" rel="noopener">允许 protocol 嵌套在非通用上下文中</a></p><p><strong>介绍</strong></p><p>允许协议嵌套在非通用 struct/class/enum/actors 和函数中。</p><p><strong>动机</strong></p><p>将标称类型嵌套在其他标称类型中允许开发人员表达内部类型的自然范围——例如，String.UTF8View 是嵌套在 struct String 中的 struct UTF8View，它的名称清楚地传达了它作为 UTF-8 代码接口的用途 - 字符串值的单位。</p><p>但是，嵌套目前仅限于在其他 struct/class/enum/actors 中的 struct/class/enum/actors； 协议根本不能嵌套，因此必须始终是模块中的顶级类型。 这很不幸，我们应该放宽此限制，以便开发人员可以表达自然作用于某些外部类型的协议。</p><p><strong>建议的解决方案</strong></p><p>我们将允许在非泛型 struct/class/enum/actors 中以及在不属于泛型上下文的函数中嵌套协议。</p><p>例如，TableView.Delegate 自然是与表视图相关的委托协议。 开发人员应该这样声明它——嵌套在他们的 TableView 类中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableView</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">Delegate</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span>: TableView, didSelectRowAtIndex: Int)</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegateConformer</span>: <span class="title">TableView</span>.<span class="title">Delegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span>: TableView, didSelectRowAtIndex: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前，开发人员采用复合名称（例如 TableViewDelegate）来表达可以通过嵌套表达的相同自然范围。</p><p>作为一个额外的好处，在 TableView 的上下文中，可以使用更短的名称来引用嵌套协议委托（与所有其他嵌套类型一样）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">Delegate</span>?</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">protocol</span> <span class="title">Delegate</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议也可以嵌套在非泛型函数和闭包中。 不可否认，这在某种程度上是有限的实用性，因为对此类协议的所有一致性也必须在同一功能内。 但是，也没有理由人为地限制开发人员在函数中创建的模型的复杂性。 一些代码库（值得注意的是，Swift 编译器本身）使用带有嵌套类型的大型闭包，并且它们受益于使用协议的抽象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">protocol</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     associatedtype <span class="type">ResultType</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">ResultType</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">SomeConformance</span>: <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AnotherConformance</span>: <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">requirement</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">impl</span>&lt;T: Abstraction&gt;<span class="params">(<span class="number">_</span> input: T)</span></span> -&gt; <span class="type">T</span>.<span class="type">ResultType</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">let</span> <span class="number">_</span>: <span class="type">Int</span> = impl(<span class="type">SomeConformance</span>())</span><br><span class="line">   <span class="keyword">let</span> <span class="number">_</span>: <span class="type">String</span> = impl(<span class="type">AnotherConformance</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 提议<a href="https://forums.swift.org/t/permutablecollection-protocol/65314" title="PermutableCollection 协议" target="_blank" rel="noopener">PermutableCollection 协议</a></p><p><strong>简介</strong></p><p>该提案旨在添加一个 PermutableCollection 协议，该协议将位于集合协议层次结构中的 Collection 和 MutableCollection 之间。</p><p><strong>动机</strong></p><p>在某些情况下，人们希望能够移动和排序元素，同时不允许（或限制）元素的突变。 鉴于大量不太重要的收集协议，这是一个值得注意的遗漏。 创建自定义集合类型时，PermutableCollection 协议在任何强制元素唯一性和/或身份的有序集合中都是首选。 用例将包括即将推出的 OrderedDictionary 和 OrderedSet。 对于不可变和可变集合，它还可以提供对 Swift 使用的底层（并且可能是高度优化的）排序算法的统一访问。</p><p><strong>设计</strong></p><p>协议设计简单，只需一个 swapAt 要求</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A collection that supports sorting.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PermutableCollection</span>&lt;<span class="title">Element</span>&gt; : <span class="title">Collection</span> <span class="title">where</span> <span class="title">Self</span>.<span class="title">SubSequence</span> : <span class="title">PermutableCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  mutable <span class="function"><span class="keyword">func</span> <span class="title">swapAt</span><span class="params">(<span class="number">_</span> i: Index, <span class="number">_</span> j: Index)</span></span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 swapAt 函数，通过扩展添加额外的排序函数实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PermutableCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(fromOffsets source: IndexSet, toOffset destination: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// move algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(by belongsInSecondPartition: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">    <span class="comment">// partition algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">()</span></span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">RandomAccessCollection</span>, <span class="type">Self</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// partition algorithm enacts changes via swapAt()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... more permutation operations that mimic those available for MutableCollection</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/vapor-and-query-caching/65278" title="Vapor和query缓存？" target="_blank" rel="noopener"> Vapor 和 query 缓存？</a></p><p>5) 讨论<a href="https://forums.swift.org/t/in-swift-system-how-does-one-read-a-files-contents-to-a-string/65294" title="在 Swift 系统中，如何将文件内容读取为字符串？" target="_blank" rel="noopener">在 Swift 系统中，如何将文件内容读取为字符串？</a></p><p><strong>提问</strong></p><p>我有一个文件的 FileDescriptor：</p><p>let fd = try FileDescriptor.open(&lt;#filepath#&gt;, .readOnly) 我可以使用 fd.read(into:) 将文件内容加载到 UnsafeMutableRawBufferPointer，但这是将文件内容加载到字符串中的正确第一步吗？ 如果是这样，</p><p>在将它传递给 fd.read(into:) 之前，</p><ol><li>我需要使用 .allocate(byteCount:alignment:) 分配 UnsafeMutableRawBufferPointer。 正确的 byteCount 取决于文件的大小。那么如何使用 Swift System 获取文件的大小呢？</li><li>如何从 UnsafeMutableRawBufferPointer 获取字符串？</li></ol><p><strong>回答</strong></p><p>可以参考这个Git库：<a href="https://github.com/tayloraswift/swift-unidoc/blob/master/Sources/System/FileDescriptor.swift" target="_blank" rel="noopener">https://github.com/tayloraswift/swift-unidoc/blob/master/Sources/System/FileDescriptor.swift</a></p><p>6) 讨论<a href="https://forums.swift.org/t/why-can-t-i-forward-enum-cases-with-dynamicmemberlookup/65290" title="为什么我不能使用 @dynamicMemberLookup 转发 enum cases？" target="_blank" rel="noopener">为什么我不能使用 @dynamicMemberLookup 转发 enum cases？</a></p><p>7) 讨论<a href="https://forums.swift.org/t/how-to-do-performance-testing-properly-in-swift-foundation/65282" title="如何在 swift-foundation 中正确地进行性能测试？" target="_blank" rel="noopener">如何在 swift-foundation 中正确地进行性能测试？</a></p><p><strong>提问</strong></p><p>我想对比一下swift-foundation 和 Xcode 自带的 JSONDecoder 解码的速度。</p><p>我在一个新项目中使用单元测试和 measureBlock 以及在 swift-foundation 中使用 JSONEncoderTests 对其进行了测试。</p><p>swift-foundation 中的 JSONDecoder 看起来太慢了，我认为这是因为 swift-foundation 还没有作为一个库被引入。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7238802590661476412/" title="iOS crash 报告分析系列 - 看懂 crash 报告的内容" target="_blank" rel="noopener">iOS crash 报告分析系列 - 看懂 crash 报告的内容</a></p><p><strong>摘要：</strong> 本篇文章主要介绍了iOS崩溃报告的解读方法，从报告的 Header、Exception information、Diagnostic messages、Backtraces、Thread state 和 Binary images 六个部分详细讲解了各字段含义，并提供示例代码帮助读者更好地理解。同时也引导读者去深入学习符号化的相关知识来获得更多信息。通过阅读本文，开发者可轻松看懂代码中产生的崩溃报告，并进行问题定位和处理。</p><p><a href="https://swdevnotes.com/swift/2023/lineargradient-in-swiftui/" title="SwiftUI 中 LinearGradient的用法" target="_blank" rel="noopener">SwiftUI 中 LinearGradient的用法</a></p><p><strong>摘要：</strong> 这篇博文探讨了在 SwiftUI 中使用 LinearGradient 为对象创建渐变颜色效果。它展示了如何定义颜色数组、使用标准和自定义起点和终点，以及设置坐标以改进铅笔对象上的颜色笔尖。本文还包括用于创建具有各种起点终点组合的不同线性渐变的示例代码。文章以示例结束，展示了如何使用这些技术来自定义一支蓝色铅笔或整套铅笔的外观。</p><p><a href="https://swiftwithmajid.com/2023/05/23/dynamic-member-lookup-in-swift/" title="Swift 中的动态成员查找" target="_blank" rel="noopener">Swift 中的动态成员查找</a></p><p><strong>摘要：</strong> 本文介绍了 Swift 语言中的动态成员查找（Dynamic Member Lookup）特性。通过在类型上使用 @dynamicMemberLookup 属性，我们可以重载该类型的 subscript 方法来更方便地访问其数据。但是，这也意味着缺乏编译时安全性。为了解决这个问题，本文提到了使用 KeyPath 作为参数的 subscript 方法来实现编译时安全检查。最后，作者建议我们可以谨慎地使用 <code>@dynamicMemberLookup</code> 特性来改进 API 设计。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？</strong></p><p>1.是的。确实已经经济危机了，今年工作很难找，同事比以前更卷啦，各种裁员消息不断。</p><p>2.经济危机不可能。五一淄博接待游客超过了100万人次，人挤人的旅游景象依然常在。</p><p>3.经济危机应该是相对的。对于大多数上班族来说，2023年很难，奉劝大家且行且珍惜。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十一期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;求人不如求己，你多一样本领，就少一点啊乞求；&lt;strong&gt;Swift社区&lt;/strong&gt;让你多一样技能，少一些嘲讽！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：码出新宇宙，WWDC23 就在眼前&lt;/p&gt;
&lt;p&gt;提案：有 4 个提案通过，本期没有产生新的提案&lt;/p&gt;
&lt;p&gt;Swift 论坛：PermutableCollection 协议&lt;/p&gt;
&lt;p&gt;推荐博文：SwiftUI 中 LinearGradient的用法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;有博主在视频社交平台说，2023年已然迎来了经济危机，只是有些人不愿意相信而已，那么你认为国内2023年是否真的进入了经济危机？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十九期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十九期/</id>
    <published>2023-07-04T07:20:09.000Z</published>
    <updated>2023-07-04T07:30:45.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第二十期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>最无情的永远不是环境，而是缺乏勇气的内心。<strong>Swift社区</strong>与你一起，赤胆平乱世，长枪定江山！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：担心泄密！外媒：苹果公司限制员工使用ChatGPT</p><p>提案：value 包展开的元组</p><p>Swift 论坛：讨论 Xcode 忽略 Package.resolved 文件</p><p>推荐博文：万字长文详解如何使用 Swift 提高代码质量</p><p><strong>话题讨论：</strong> </p><p>一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？</p></blockquote><p><strong>上期话题结果</strong></p><a id="more"></a><p><img src="https://files.mdnice.com/user/17787/c465cfe7-1b3a-49d3-820c-e7b06fd7738b.png" alt=""></p><p>上期话题讨论结果表明对于 AI 是否会取代软件工程师的问题，大家的观点存在分歧，而实际的结果可能<strong>取决于 AI 技术的发展和与人类工程师的协作方式的演变</strong>。让我们拭目以待。</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="担心泄密！外媒：苹果公司限制员工使用ChatGPT"><a href="#担心泄密！外媒：苹果公司限制员工使用ChatGPT" class="headerlink" title="担心泄密！外媒：苹果公司限制员工使用ChatGPT"></a>担心泄密！外媒：苹果公司限制员工使用ChatGPT</h3><p>中新经纬 5 月 19 日电 据华尔街日报中文网 19 日报道，其获悉的一份文件以及知情人士的消息显示，苹果公司已经限制使用 ChatGPT 和其他外部 AI 工具。</p><p>根据这份文件，苹果公司担心员工使用这类程序可能会泄露机密数据。该文件还称，苹果公司还告诉员工，不要使用微软所有的 GitHub 的产品 Copilot。Copilot 可以自动编写软件代码。</p><p>ChatGPT 是 AI 研究公司 OpenAI 开发的一款人工智能聊天机器人。该产品于 2022 年 11 月发布，可以进行从历史到哲学等话题的对话，并对计算机程序代码提供修改建议。</p><p>值得注意的是，在 ChatGPT 爆火的背后，也出现过商业泄密的重大事故。</p><p>今年 4 月，据多家媒体报道，三星电子引入聊天机器人 ChatGPT 不到 20 天，便曝出机密资料外泄，如半导体设备测量数据、产品良率等内容。为杜绝类似事故再发生，三星制定相关保护措施，该公司向员工表示，“若采取信息保护紧急措施后仍发生类似事故，公司内部网络可能会切断 ChatGPT 连接”。</p><p>此外，已经有国家监管机构注意到了数据安全风险。</p><p>当地时间 3 月 31 日，意大利个人数据保护局宣布，即日起禁止使用聊天机器人 ChatGPT ，限制其开发公司 OpenAI 处理意大利用户信息，并开始立案调查。意大利个人数据保护局认为，3 月 20 日 ChatGPT 平台出现了用户对话数据和付款服务支付信息丢失情况，而该平台没有就收集处理用户信息进行告知，且缺乏大量收集和存储个人信息的法律依据。(中新经纬APP)</p><h3 id="苹果公司大幅削减其MR头显销售预期，不足百万台"><a href="#苹果公司大幅削减其MR头显销售预期，不足百万台" class="headerlink" title="苹果公司大幅削减其MR头显销售预期，不足百万台"></a>苹果公司大幅削减其MR头显销售预期，不足百万台</h3><p>品玩 5 月 19 日讯，据界面新闻消息，苹果公司已将其期待已久的混合现实（MR）头显的销售预期下调约三分之二。报道指出，苹果最初希望每年销售约 300 万台，但现在已将销售预期削减至约 100 万台，随后又下调至 90 万台。该公司将于 6 月 5 日举行全球开发者大会，预计将在会上展示该产品。该设备的售价预计会高达 3000 美元左右，是 Meta Platforms 最昂贵的 Quest Pro 头显售价的三倍。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0396-never-codable.md" title="SE-0396" target="_blank" rel="noopener">SE-0396</a> <strong>Never 遵守 Codable</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>允许泛型类型对包进行抽象声明</strong> 提案通过审查。该提案已在 <strong>二十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>value 包展开的元组</strong> 提案正在审查。</p><p>之前的 SE-0393 引入了 Value 和 Type 参数包。该提案允许引用一个包含在重复模式中的 value 包的元组值。</p><h2 id="Swift-论坛"><a href="#Swift-论坛" class="headerlink" title="Swift 论坛"></a>Swift 论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/swiftui-charts-very-large-data-sets-and-chart-overlay/65054" title="SwiftUI 图表、超大数据集和图表叠加" target="_blank" rel="noopener">SwiftUI 图表、超大数据集和图表叠加</a></p><p>2) 讨论<a href="https://forums.swift.org/t/sendable-warning-with-thread-safe-property-wrapper/65053" title="带有线程安全属性包装器的可发送警告" target="_blank" rel="noopener">带有线程安全属性包装器的可发送警告</a></p><p>当使用有针对性的严格并发进行构建时，我收到一条警告，我想知道除了使我的类型“未经检查的可发送”之外，我是否可以做任何事情。</p><p>考虑一些线程安全的属性包装器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper <span class="class"><span class="keyword">struct</span> <span class="title">ThreadSafe</span>&lt;<span class="title">Value</span>: <span class="title">Sendable</span>&gt;: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock: <span class="type">Lock</span>&lt;<span class="type">Value</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; lock.withLock &#123; $<span class="number">0</span> &#125; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; lock.withLock &#123; $<span class="number">0</span> = newValue &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(lock: .<span class="keyword">init</span>(initialState: wrappedValue))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(lock: <span class="type">Lock</span>&lt;<span class="type">Value</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.lock = lock</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并考虑使用它来强制执行线程安全和可发送性的类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeSendable</span>: <span class="title">Sendable</span> </span>&#123;</span><br><span class="line">    @<span class="type">ThreadSafe</span></span><br><span class="line">    <span class="keyword">var</span> someBool: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使我的课程是线程安全的，我仍然收到此警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stored</span> property '_someBool' of '<span class="type">Sendable'</span>-conforming <span class="class"><span class="keyword">class</span> '<span class="title">SomeSendable</span>' <span class="title">is</span> <span class="title">mutable</span></span></span><br></pre></td></tr></table></figure><p>编译器诊断似乎没有检查属性包装器的可发送性。</p><p>有没有办法在不使我的类型“未选中”的情况下平息此警告？</p><p><strong>回答</strong></p><p>问题是任何带有 var 的类总是不可发送的，并且属性包装器不允许 let。</p><p>但对我来说，真正的问题是 SomeSendable 使用起来真的不是那么安全，特别是 <code>@ThreadSafe</code> 是不安全的。 它使得以易受竞争影响的方式使用可变状态变得太容易了。 由于数据被锁定，您肯定不会遇到运行时崩溃，但您很容易得到不正确的结果。</p><p>例如，像旋转 1,000 个任务来切换布尔值这样简单的事情在最后总是会产生一个真值，但有时你会得到假，有时你会得到真：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = <span class="type">SomeSendable</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">1000</span> &#123;</span><br><span class="line">  <span class="type">Task</span> &#123; object.toggle() &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(object.someBool)</span><br></pre></td></tr></table></figure><p>这是一个相当大的问题，它正在发生，因为 <code>@ThreadSafe</code> 允许直接写入底层值。 所以像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.someBool = !object.someBool</span><br></pre></td></tr></table></figure><p>…隐藏竞争条件。</p><p>实际上，您可能应该直接在类中保留 Lock 值，而不是使用 <code>@ThreadSafe</code> 属性包装器，然后仅通过它的 withValue 进行变异。 当然，如果可变数据的安全是最重要的问题，那么您真的应该使用 actor。</p><p>3) 讨论<a href="https://forums.swift.org/t/using-snippets-in-documentation-comments-not-possible/65046" title="无法在文档注释中使用片段？" target="_blank" rel="noopener">无法在文档注释中使用片段？</a></p><p>我阅读 SE-0356 的方式应该可以在 Swift 包的 Snippets 文件夹中创建一个片段文件，然后通过@Snippet 在我的文档评论中引用它。</p><p>但这似乎并不像我预期的那样工作（使用 Xcode 14.3 / Swift 5.8）：</p><p><code>@Snippet</code> 给我警告：“符号源文档不支持指令”<br>显示我记录的类型的快速帮助不包括片段。</p><p>使用菜单“产品”&gt;“构建文档”生成没有代码片段的文档。</p><p><strong>回答</strong></p><p>片段在 Swift 5.7 中实现，并可通过 <code>swift-docc-plugin</code> 与 SwiftPM 一起使用，但正如其他人指出的那样，没有与基于 Xcode 的文档工作流集成，因为它使用不同的构建系统。 我会更新提案。</p><p>4) 讨论<a href="https://forums.swift.org/t/xcode-ignoring-package-resolved-file/65031" title="Xcode 忽略 Package.resolved 文件" target="_blank" rel="noopener"> Xcode 忽略 Package.resolved 文件</a></p><p>我不确定这是 SPM 问题还是 Xcode 问题，但将 SPM 与 Xcode 一起使用时最令人沮丧的经历之一是它经常忽略我的 repo 中的 <code>Package.resolved</code> 文件，通常是在切换分支或不同机器之间时。</p><p><code>Package.resolved</code> 文件应该是我的依赖项的真实来源，它永远不应该被忽略——如果有问题，包解析失败，但永远不要改变我的依赖项。</p><p>似乎发生的情况是，Xcode 更愿意使用其源缓存中恰好满足包版本要求的库版本，而不是解析文件中的库版本。 例如，我有一个版本要求为“2.2.0 up to next minor”的库。 </p><p>Package.resolved 文件中有 2.2.3，所以这是我希望始终使用的版本，除非我进行一些会引入冲突的更改。 当我在另一台机器上打开同一个项目时，出于某种原因它坚持要更改为 2.2.2，大概这是它缓存中的版本。 为什么？ 如果可以忽略已解析文件的意义何在？</p><p><strong>回答</strong></p><p>我可能遗漏了一些细节，但在更新到 Xcode 14.3 并在我们的 CI 中面对这个问题时，我们意识到我们从未使用 <code>-onlyUsePackageVersionsFromResolvedFile</code> 标志调用 xcodebuild。 现在我们这样做了，而且 CI 似乎尊重我们的 Package.resolved 文件。</p><p>对于我们来说，这个问题只存在于 Xcode 的 GUI 中。 （与此同时，我同样感到困惑，为什么需要 <code>-onlyUsePackageVersionsFromResolvedFile</code> 而不是 CLI 和 GUI 的默认模式！）</p><p>5) 讨论<a href="https://forums.swift.org/t/without-objective-c-or-swift-how-can-a-display-name-be-retrieved-from-cgdirectdisplayid-in-c-or-c/65034" title="如果没有 Objective-C 或 Swift，如何在 C 或 C++ 中从 CGDirectDisplayID 检索显示名称？" target="_blank" rel="noopener">如果没有 Objective-C 或 Swift，如何在 C 或 C++ 中从 CGDirectDisplayID 检索显示名称？</a></p><p>我试图在纯 C++（或 C）中从 <code>CGDirectDisplayID</code> 获取显示名称</p><p>我可以在 Objective-C++ 中做到这一点，类似于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;CoreGraphics/CoreGraphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;IOKit/graphics/IOGraphicsLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> getDisplayNameForDispID(<span class="built_in">CGDirectDisplayID</span> dispID,</span><br><span class="line">                             std::string&amp; strOutName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> bRes = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    strOutName.clear();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *screens = [<span class="built_in">NSScreen</span> screens];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSScreen</span> *screen <span class="keyword">in</span> screens)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span>* screenDictionary = [screen deviceDescription];</span><br><span class="line">        <span class="keyword">if</span>(screenDictionary)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span>* screenID = [screenDictionary objectForKey:<span class="string">@"NSScreenNumber"</span>];</span><br><span class="line">            <span class="keyword">if</span>(screenID)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CGDirectDisplayID</span> aID = [screenID unsignedIntValue];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(aID == dispID)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Got it</span></span><br><span class="line">                    <span class="built_in">NSString</span>* pName = [screen localizedName];</span><br><span class="line">                    </span><br><span class="line">                    strOutName.assign([pName UTF8String], [pName lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line"></span><br><span class="line">                    bRes = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我不想仅仅为了完成这一项任务而将这个缓慢的 Objective-C 代码添加到我的项目中。 在低级 C 中，必须有一种方法可以做到这一点。</p><p>我知道有一个完整的主题专门讨论它。 由于 <code>CGDisplayIOServicePort</code> 已弃用并且仅返回 0 并且任何后续调用都会执行操作，因此请注意，没有任何解决方法为 macOS Ventura 提供工作。</p><p><strong>回答</strong></p><p>如果您坚持不直接使用任何 Objective C 代码，您仍然可以使用 Objective C 运行时 API 从 C 调用 Objective C API，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class nsScreen = objc_lookUpClass(<span class="string">"NSScreen"</span>);</span><br><span class="line">objc_object *screens = objc_msgSend(nsScreen, sel_getUid(<span class="string">"screens"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Desugaring "fast enumeration" is particularly knarly.</span></span><br><span class="line"><span class="comment">// for (NSScreen *screen in screens)</span></span><br><span class="line">objc_object *enumerator = objc_msgSend(screens, sel_getUid(<span class="string">"objectEnumerator"</span>));</span><br><span class="line">objc_object *screen;</span><br><span class="line"><span class="keyword">while</span> ((screen = objc_msgSend(enumerator, sel_getUid(<span class="string">"nextObject"</span>)) != <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>你会发现它比 Objective C 代码（实际上只是这类函数调用的语法糖）要“迟钝”得多，因为你需要一直转换所有内容。</p><p>我也完全忘记了手动添加内存管理。 你需要保留/释放一大堆东西。 真是一团糟。 如果你可以管理它，我强烈建议将其编译为 Objective C。</p><p>6) 讨论<a href="https://forums.swift.org/t/does-task-cancellation-propagate-to-urlsessiontasks/65041" title="任务取消是否传播到 URLSession 任务？" target="_blank" rel="noopener">任务取消是否传播到 URLSession 任务？</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task = <span class="type">Task</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> (data, response) = <span class="keyword">try</span> await <span class="type">URLSession</span>.shared.data(from: <span class="type">URL</span>(string: <span class="string">"https://some-image-url.com"</span>)!)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我执行 <code>task.cancel()</code>，URLSession 是否也会自动取消 <code>URLSessionTask？</code> 假设 URLSessionTask 也被取消似乎很粗心，但我找不到关于此事的任何文档。 但是，如果 URLSessionTask 没有自动取消，那么我不得不使用基于闭包的 <code>URLSession.dataTask(with:,completionHandler:)</code> 来获取对 URLSessionTask 的引用，然后还调用 <code>dataTask.cancel()</code> 在 <code>task.cancel()</code> 之上，这有点奇怪。</p><p><strong>回答</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task will start"</span>)</span><br><span class="line">            <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://postman-echo.com/delay/10"</span>)!</span><br><span class="line">            <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: <span class="number">60.0</span>)</span><br><span class="line">            <span class="keyword">let</span> (data, response) = <span class="keyword">try</span> await <span class="type">URLSession</span>.shared.data(<span class="keyword">for</span>: request)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task did complete, response: <span class="subst">\(response)</span>, data: <span class="subst">\(data)</span>"</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: task did error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: will cancel task"</span>)</span><br><span class="line">        t.cancel()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: did cancel task"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Date.now)</span>: waiting"</span>)</span><br><span class="line">    <span class="keyword">try</span>? await <span class="type">Task</span>.sleep(<span class="keyword">for</span>: .seconds(<span class="number">60</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await main()</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">52</span> +<span class="number">0000</span>: task will start</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: will cancel task</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: did cancel task</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: waiting</span><br><span class="line"><span class="number">2023</span>-<span class="number">05</span>-<span class="number">18</span> <span class="number">08</span>:<span class="number">18</span>:<span class="number">53</span> +<span class="number">0000</span>: task did error</span><br></pre></td></tr></table></figure><p>7) 讨论<a href="https://forums.swift.org/t/evolving-the-swift-workgroups/65052" title="发展 Swift 工作组" target="_blank" rel="noopener">发展 Swift 工作组</a></p><p>今天，Swift 核心团队宣布对 Swift 的结构、工作和周围的人进行前瞻性的改变。 这些更改包括新的组、名称、组织以及作为每个组的一流概念的包含。</p><p>链接：<a href="https://www.swift.org/blog/evolving-swift-project-workgroups/" target="_blank" rel="noopener">https://www.swift.org/blog/evolving-swift-project-workgroups/</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7231359714055077946/" title="万字长文详解如何使用 Swift 提高代码质量 | 京东云技术团队" target="_blank" rel="noopener">万字长文详解如何使用 Swift 提高代码质量 | 京东云技术团队</a></p><p><strong>摘要：</strong> 文章介绍了如何使用 Swift 提高代码质量。 Swift 的三个重要特性：富有表现力、安全性和快速。通过使用这些特性，可以提高代码质量并减少 Crash 的发生率。同时，本文还分享了一些实践技巧来提高使用 Swift 编写代码的效率和可读性，如利用编译检查、减少使用 Any/AnyObject 、不推荐大量使用 Dictionary 数据结构等。最后，从性能优化的角度，谈到了使用源代码打包，减少方法动态派发，使用 Slice 共享内存优化性能等来提高代码质量。</p><p><a href="https://swiftwithmajid.com/2023/05/03/the-power-of-overlays-in-swiftui/" title="swiftUI 中视图叠加的强大能力" target="_blank" rel="noopener">swiftUI 中视图叠加的强大能力</a></p><p><strong>摘要：</strong> 本博客文章讨论了 SwiftUI 中两个有趣的叠加使用案例。第一个案例涉及使用叠加来保持视图的结构标识，这对于防止性能问题和状态丢失至关重要。第二个用例是通过叠加视图修饰符构建自定义导航转换，使开发人员能够创建流畅的动画而不依赖 NavigationView 或 NavigationStack。提供示例以说明这些概念，并提供其他资源供进一步学习。总体而言，本文展示了 SwiftUI 中叠加功能的强大之处以及它们如何增强应用程序开发中用户体验。</p><p><a href="https://swiftwithmajid.com/2023/05/10/file-importing-and-exporting-in-swiftui/" title="SwiftUI 中的文件导入和导出" target="_blank" rel="noopener">SwiftUI 中的文件导入和导出</a></p><p><strong>摘要：</strong> 本篇博客讨论了如何使用 fileImporter 和 fileExporter 视图修饰符在 SwiftU I视图中导入和导出文件。文章包括两种操作的代码示例，以及一个额外部分介绍如何使用 fileMover 视图修改器进行文件移动。此外，还介绍了 TextDocument 类型，它符合 FileDocument 协议并允许从文件读取纯文本字符串，并将字符串数据导出到文件。总体而言，这篇文章强调了使用这些简单的视图修饰符可以轻松实现 SwiftUI 应用程序中的文件管理体验。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？</strong></p><p>1、社交隔阂：社交圈子的分隔和交流机会的减少<br>2、忙碌生活：现代社会的快节奏和高压力导致个人时间和精力有限<br>3、数字化社交：社交媒体和在线交友平台的兴起导致<br>4、个人选择标准的提高：个人对伴侣的要求变得更加苛刻，导致匹配的难度增加<br>5、社会观念的变化：个人对恋爱和婚姻的态度发生了变化，导致对寻找恋爱对象的需求减少</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第二十期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;最无情的永远不是环境，而是缺乏勇气的内心。&lt;strong&gt;Swift社区&lt;/strong&gt;与你一起，赤胆平乱世，长枪定江山！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：担心泄密！外媒：苹果公司限制员工使用ChatGPT&lt;/p&gt;
&lt;p&gt;提案：value 包展开的元组&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 Xcode 忽略 Package.resolved 文件&lt;/p&gt;
&lt;p&gt;推荐博文：万字长文详解如何使用 Swift 提高代码质量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;一群男的在找女朋友，一群女的在找男朋友，两群人互不干涉，什么原因引起的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;上期话题结果&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十八期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十八期/</id>
    <published>2023-07-04T07:20:04.000Z</published>
    <updated>2023-07-04T07:30:00.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十九期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>用鞭子抽打，陀螺才会旋转。览<strong>Swift社区</strong>，技能方可升华！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：外媒：iPhone 的平均售价直逼 1000 美元创历史新高</p><p>提案：<code>Never</code> 遵守 <code>Codable</code></p><p>Swift 论坛：讨论在函数参数列表中使用 $ 进行绑定</p><p>推荐博文：抖音 Swift 编译优化</p><p><strong>话题讨论：</strong> </p><p>你认为AI会取代软件工程师吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="外媒：iPhone-的平均售价直逼-1000-美元创历史新高"><a href="#外媒：iPhone-的平均售价直逼-1000-美元创历史新高" class="headerlink" title="外媒：iPhone 的平均售价直逼 1000 美元创历史新高"></a>外媒：iPhone 的平均售价直逼 1000 美元创历史新高</h3><p>近日根据调研公司公布的数据显示，全球智能手机市场表现整体下行，不过高端手机近三年同比都呈现增长趋势，尤其是 600 美元以上的机型。市场研究机构 CIRP 的数据报告显示在 2023 年第一季度 iPhone 的平均售价达到 988 美元 ( 约合人民币 6837 元 ) ，同比增长 12%，创历史新高，其中 iPhone 14 Pro 以及 iPhone 14 Pro Max 是 iPhone 系列最受欢迎的型号，虽然两款手机价格相对较高，但还是占据了总销量的近一半。去年同期 iPhone 的平均售价为 882 美元，2021 年的收尾价为 847 美元。</p><p><img src="http://zkres2.myzaker.com/202305/645351248e9f095a955c2015_1024.jpg" alt=""></p><p>相比之下 iPhone 14 的两款入门款机型的表现平平，而且跟上一代机型基本相同，大家宁愿买 iPhone 13 也不愿意买 iPhone 14。此外，用户对于手机存储空间的需求也在增加，导致更多人选择了更高容量的手机，这也进一步提升了平均售价。</p><h3 id="分析师：iPhone需求良好，苹果股价还能涨22"><a href="#分析师：iPhone需求良好，苹果股价还能涨22" class="headerlink" title="分析师：iPhone需求良好，苹果股价还能涨22%"></a>分析师：iPhone需求良好，苹果股价还能涨22%</h3><p>根据 Refinitiv 的预期，苹果最新财季的每股收益预计为 1.43 美元，营收为 929.7 亿美元，暗示将同比下滑 4.4%。另据 FactSet 的估计，苹果最新财季 iPhone 的收入预计将同比下滑 3.8% 至 486.6 亿美元，且预计包括 iPhone 在内的每条硬件产品线都会出现同比下滑。</p><p>不过，Wedbush 高级分析师 Daniel Ives 在发给《每日经济新闻》记者的置评邮件中称，根据他们最近对亚洲供应链的调查，他们认为苹果周四盘后发布的财报中，iPhone 的营收应该至少与预期一致。</p><p>“我们认为，尽管宏观形势不稳，但由于较高的平均售价和 iPhone14 Pro 的整体升级活动，以及 iPhone 本季度在关键的中国市场的需求明显上升，该产品线的营收可能会出现一些上升。随着本季度 App Store 营收的增长，我们认为苹果的服务收入应该是稳定的，结合起来应该转化为苹果的核心收入，至少应该符合市场预期，我们维持对苹果的‘跑赢大盘’评级和 205 美元的目标价。”这意味着，苹果较周三收盘价 167.45 美元还有 22% 的上涨空间。</p><p>“苹果在中国的市场份额正在增加，美国和欧洲的需求也保持良好，我们估计目前约有 25% 的 iPhone 用户在过去四年多的时间里没有换过新机。由于备受期待的周年纪念版iPhone 15 将于 9 月份发布，从 iPhone 14 到 iPhone 15 的过渡看起来将比过去的 iPhone 换代周期更加稳定。我们还认为，iPhone 的平均售价将升至 900 美元 ~ 925 美元左右，这将是下一个 iPhone 周期一个值得关注的趋势。”Daniel Ives补充道。</p><h3 id="准备好迎接即将在-5-月-9-日推出的增强全球定价机制"><a href="#准备好迎接即将在-5-月-9-日推出的增强全球定价机制" class="headerlink" title="准备好迎接即将在 5 月 9 日推出的增强全球定价机制"></a>准备好迎接即将在 5 月 9 日推出的增强全球定价机制</h3><p>借助 App Store 世界级的商务和支付系统，你能够便捷高效地为国际市场设定均衡的价格，根据外汇汇率或税费的变化进行调整，还可以管理每个店面的价格。上个月，我们推出了重大定价机制升级，其中包括将增强全球定价机制的适用范围扩展至所有购买类型。如今，更新后的价格点将跟随各个国家或地区最常见的定价方式，并且将根据金融数据机构提供的公开汇率信息做调整，在全球范围内与你为基准店面设定的价格保持平衡，因此更适用于当地顾客。</p><p>谨此提醒，自 2023 年 5 月 9 日起，App Store 各店面的现有 App 和一次性 App 内购买项目的价格都将以产品当前在美国店面的价格为基础进行更新，除非你在 2023 年 3 月 8 日后进行了相关更新。你随时可以使用 App Store Connect 或 App Store Connect API 更新基准店面的国家或地区。如果你选择进行更新，在 App Store 根据外汇变化或新的税费生成全球均衡价格时，你所选基准店面的价格将不会受到调整。你还可以选择手动调整多个所选店面中的价格，而不使用均衡的价格。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0391-package-registry-publish.md" title="SE-0391" target="_blank" rel="noopener">SE-0391</a> <strong>Package Registry 公开发布</strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0394-swiftpm-expression-macros.md" title="SE-0394" target="_blank" rel="noopener">SE-0394</a> <strong>Package Manager 支持自定义宏</strong> 提案通过审查。该提案已在 <strong>二十七期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0396-never-codable.md" title="SE-0396" target="_blank" rel="noopener">SE-0396</a> <strong>Never 遵守 Codable</strong> 提案正在审查。</p><p>该提案主要介绍 <code>Never</code> 扩展，使其符合 <code>Encodable</code> 和 <code>Decodable</code> 协议，一起称为 <code>Codable</code>。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0397-freestanding-declaration-macros.md" title="SE-0397" target="_blank" rel="noopener">SE-0397</a> <strong>独立声明 Macros</strong> 提案正在审查。</p><p>该提案概括了为 Expression Macros 引入的 <code>#</code> -prefixed 宏扩展语法，允许宏生成声明，支持许多其他用例，包括：</p><ul><li>从模板或其他数据格式（例如 JSON）生成数据结构。</li><li>将 SE-0196 中引入的 <code>#warning</code> 和 <code>#error</code> 指令作为宏。</li></ul><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0398-variadic-types.md" title="SE-0398" target="_blank" rel="noopener">SE-0398</a> <strong>允许泛型类型对包进行抽象声明</strong> 提案正在审查。</p><p>之前的 SE-0393 引入了 Value 和 Type 参数包和几个相关概念，允许泛型函数声明抽象出可变数量的类型。该提案将这些想法概括为泛型类型声明。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/avoiding-sendable-warning-for-unused-async-result/64633" title="避免未使用的异步结果的可发送警告" target="_blank" rel="noopener">避免未使用的异步结果的可发送警告</a></p><p><strong>内容大概</strong></p><p>有一个独立于专用 actor 的功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@globalActor</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeDedicatedActor</span> </span>&#123;</span><br><span class="line">    actor <span class="type">Actor</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Actor</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">SomeDedicatedActor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> async -&gt; [<span class="type">Any</span>] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常从与@SomeDedicatedActor 隔离的其他函数调用 f()，但我们有一个调用是我们想从不同的 actor 进行的。</p><p>我们做这个调用纯粹是为了 f 的副作用，根本不关心返回结果。 我希望以下构造是有效的，但是通过 Targeted/Complete Sendable 检查，我们会收到警告：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">MainActor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> async &#123;</span><br><span class="line">    <span class="comment">// Non-sendable type '[Any]' returned by implicitly asynchronous call</span></span><br><span class="line">    <span class="comment">// to global actor 'SomeDedicatedActor'-isolated function cannot cross</span></span><br><span class="line">    <span class="comment">// actor boundary</span></span><br><span class="line">    <span class="number">_</span> = await f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用 Swift 会忽略跨角色边界传输结果是否合理？</p><ul><li>如果是这样，那么这只是一个虚假的警告，还是这个构造现在实际上是不安全的（因为该值确实强行跨越参与者边界）？</li><li>如果不是，是否有理由必须跨界传输结果？</li></ul><p><strong>回答</strong></p><p>如果该值是不可发送的，它可能具有只允许在其原始 actor 中发生的 deinit 效果。 因此，忽略结果实际上必须“避免返回”actor 的结果，因为它必须在离开 actor 的隔离上下文之前销毁该值。 这对我来说似乎相当微妙，但也许它与编写一个返回非 Sendable 类型的隔离方法是一致的，因为您永远无法使用隔离之外的结果。</p><p>2) 讨论<a href="https://forums.swift.org/t/using-for-binding-in-function-parameter-list/64645" title="在函数参数列表中使用 $ 进行绑定" target="_blank" rel="noopener">在函数参数列表中使用 $ 进行绑定</a></p><p><strong>内容大概</strong></p><p>最近发现可以像这样在闭包参数中使用 $ 变量名：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bind</span>(<span class="string">"Title"</span>) &#123; $title <span class="keyword">in</span></span><br><span class="line">      <span class="type">TextField</span>(title, text: $title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，对于像这样的函数参数来说，同样的事情似乎是不可能的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(title $title: Binding&lt;String&gt;)</span></span> &#123;</span><br><span class="line">      <span class="type">TextField</span>(title, text: $title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是编译器在函数声明处给出了一个错误：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cannot</span> declare entity named '$title'; the '$' <span class="keyword">prefix</span> <span class="keyword">is</span> reserved <span class="keyword">for</span> implicitly-synthesized declarations</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>您需要在参数上使用属性包装器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(@Binding title: String)</span></span> &#123;</span><br><span class="line">  <span class="type">TextField</span>(title, text: $title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo($title: .constant(<span class="string">"R.I.P. Taylor Hawkins 🥁"</span>))</span><br></pre></td></tr></table></figure><p>3) 讨论<a href="https://forums.swift.org/t/task-awaiting-for-variable-change/64626" title="Task - 等待变量更改" target="_blank" rel="noopener">Task - 等待变量更改</a></p><p><strong>内容大概</strong></p><p>在使用 Task 时有一个如何解决问题的建议。<br>在等待 Task 内部的一些变量更改以进一步移动。</p><p>意思是说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">  ... <span class="keyword">for</span> example here comes some complex code that <span class="keyword">is</span> sending requests </span><br><span class="line">   through web socket to outer world, </span><br><span class="line">   response from websocket will change the variable result on this clas </span><br><span class="line">   but out of this scope</span><br><span class="line"></span><br><span class="line">   <span class="comment">// with this line we are waiting for variable change with reasonable timeout</span></span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> await @change(variable: <span class="keyword">self</span>.result, timeout:<span class="number">10</span> sec)</span><br><span class="line">   &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      ... timeout</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"we are waiting too long for server response"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回答</strong></p><p>您目前可以使用异步序列解决此问题。 现在的一个常见模式是执行以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> async &#123;</span><br><span class="line">  <span class="keyword">var</span> cont = <span class="type">AsyncStream</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Continuation</span>!  </span><br><span class="line">  <span class="keyword">let</span> stream = <span class="type">AsyncStream</span>&lt;<span class="type">Int</span>&gt; &#123; cont = $<span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> continuation = cont</span><br><span class="line">  </span><br><span class="line">  setupWebsocket(continuation)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> await element <span class="keyword">in</span> stream &#123;</span><br><span class="line">    <span class="comment">// process the result</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupWebsocket</span><span class="params">(continuation: AsyncStream&lt;Int&gt;.Continuation)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Setup the web socket and at some point call the following code</span></span><br><span class="line">  continuation.yield(<span class="number">2</span>) <span class="comment">// Yield your result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一件可能对这里有帮助的事情是当前正在发生的 Observation pitch，这将允许你观察类并让 Task 改变它； 然而，重要的是你需要确保一切都是线程安全的。</p><p>4) 更新 <a href="https://forums.swift.org/t/whats-next-for-foundation-april-2023-update/64637" title="Foundation 的下一步计划 - 2023 年 4 月更新" target="_blank" rel="noopener">Foundation 的下一步计划 - 2023 年 4 月更新</a></p><p>链接：<a href="https://www.swift.org/blog/future-of-foundation/" target="_blank" rel="noopener">https://www.swift.org/blog/future-of-foundation/</a></p><p>更多相关的详细信息链接：<a href="https://www.swift.org/blog/foundation-preview-now-available/" target="_blank" rel="noopener">https://www.swift.org/blog/foundation-preview-now-available/</a></p><p>5) 更新 <a href="https://forums.swift.org/t/swift-evolution-dashboard-support-for-upcoming-feature-flags/64617" title="Swift Evolution Dashboard 支持即将推出的 Feature Flags" target="_blank" rel="noopener">Swift Evolution Dashboard 支持即将推出的 Feature Flags</a></p><p>Swift Evolution Dashboard 现在包括对即将推出 Feature Flags 的支持。</p><p>Swift 5.8 引入了使用新编译器选项启用即将推出的功能的能力：-enable-upcoming-feature 后跟即将推出的功能的名称。</p><p>这些即将到来的特征标识符被称为即将到来的特征标志或简称 UFF。（详见 SE-0362 1）</p><p>随着 Dashboard 的更新，您现在可以轻松找到所有带有即将推出的功能标志的提案以及用于每个功能的标志名称。</p><p>您可以使用 Swift Evolution 仪表板来：</p><ul><li>查看提案的 UFF（如果有的话）</li><li>按名称搜索 UFF</li><li>过滤以查看所有带有 UFF 的提案</li><li>新的 UFF 过滤器按钮与现有的搜索字段和状态过滤器结合使用。</li></ul><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.avanderlee.com/swiftui/deeplink-url-handling/" title="SwiftUI 中的 Deeplink URL 处理" target="_blank" rel="noopener">SwiftUI 中的 Deeplink URL 处理</a></p><p><strong>摘要：</strong> 本文讨论深度链接（ deeplinks ）以及如何在 SwiftUI 中配置应用程序来处理它们。深度链接允许用户通过打开特定位置，在启动后深入进入您的应用程序，例如基于所点击的链接打开某个菜谱或电影等。本文提供了在 Xcode 中配置URL类型和使用视图修饰符或 AppDelegate/SceneDelegate 方法处理传入 URL 的步骤。此外，它建议使用深度链接进行其他场景，例如使用特定账户登录或在预发布和生产环境之间切换。该文章还强调了考虑安全性时定义支持 Deeplink URL 的重要性。</p><p><a href="https://juejin.cn/post/7221444501956886588" title="抖音 Swift 编译优化 - 基于自定义 Toolchain 编译提速 60%" target="_blank" rel="noopener">抖音 Swift 编译优化 - 基于自定义 Toolchain 编译提速 60%</a></p><p><strong>摘要：</strong> 本篇博客主要介绍了抖音团队基于自定义 Toolchain 提出的 Swift 编译优化方案，重点讨论在全部模块化后解决依赖瓶颈所采用的方法以及优化效果。通过裁剪 Clang Header 指定内容来降低 OC 头文件预编译耗时，并采用细粒度控制方案，实现编译提速 60%。文章还分享了方案拆解、快速验证、开发调试、验证上线等具体流程，对于有需要进行Swift编译优化的读者可以参考此文中给出的思路和方法。</p><p><a href="https://juejin.cn/post/7222189908429275173" title="Swift 最佳实践之 Property Wrapper" target="_blank" rel="noopener">Swift 最佳实践之 Property Wrapper</a></p><p><strong>摘要：</strong>  本文介绍了 Swift 5.1 中引入的 Property Wrapper，它是对属性的一层封装，隐藏与属性相关的逻辑细节从而提高代码复用性。文章详细讲解了 Property Wrapper 的定义、使用、初始化以及 Projected Value 等概念，并通过示例展示了在 SwiftUI、线程安全保护、Codable 和 User Defaults 存储等方面应用 Property Wrapper 的方法和好处。最后还指出了使用 Property Wrapper 标记属性时需要注意的限制。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>你认为AI会取代软件工程师吗？</strong></p><p>1、会<br>2、不会</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十九期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;用鞭子抽打，陀螺才会旋转。览&lt;strong&gt;Swift社区&lt;/strong&gt;，技能方可升华！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：外媒：iPhone 的平均售价直逼 1000 美元创历史新高&lt;/p&gt;
&lt;p&gt;提案：&lt;code&gt;Never&lt;/code&gt; 遵守 &lt;code&gt;Codable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论在函数参数列表中使用 $ 进行绑定&lt;/p&gt;
&lt;p&gt;推荐博文：抖音 Swift 编译优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你认为AI会取代软件工程师吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十七期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十七期/</id>
    <published>2023-07-04T07:19:58.000Z</published>
    <updated>2023-07-04T07:29:17.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十八期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>再暗的黑夜也会迎来黎明，再长的坎坷也会连接平川。怀抱<strong>Swift社区</strong>，一颗永不放弃的希望之心，明天将会是温暖的阳光雨露！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：因增速放缓 苹果公司将开启大规模收购</p><p>提案：Package Manager 支持自定义宏</p><p>Swift 论坛：讨论为什么 didSet 观察者在使用中会触发 Set 类型的属性</p><p>推荐博文：在 SwiftUI 中掌握 Canvas 的使用</p><p><strong>话题讨论：</strong> </p><p>你存钱了吗？你存钱的目的是什么呢？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果公司向“恢复基金”再投2亿美元，推进碳移除项目"><a href="#苹果公司向“恢复基金”再投2亿美元，推进碳移除项目" class="headerlink" title="苹果公司向“恢复基金”再投2亿美元，推进碳移除项目"></a>苹果公司向“恢复基金”再投2亿美元，推进碳移除项目</h3><p><img src="https://jg-app.obs.cn-north-4.myhuaweicloud.com/prod/upload/jpg/0a52d53f56fb4270855286d10f80f239.jpg" alt=""></p><p>据界面新闻消息，苹果公司 4 月 12 日宣布，在最初 2 亿美元的投资基础上，将向 2021 年设立的“恢复基金”（Restore Fund）再投多达 2 亿美元。该基金旨在为高质量的自然碳移除项目提供资金，激励全球投资保护和恢复“关键生态系统”。苹果公司还希望帮助无法通过现有技术避免或减少碳排放的企业，推广可行的碳移除解决方案。</p><p>加码后的基金将由汇丰资产管理部门和 Polliation 合资成立的 Climate Asset Management 管理，额外投资预计将使苹果此前提出的每年从大气中清除 100 万公吨二氧化碳目标翻倍，同时为投资者带来经济回报。</p><p>该基金期望把重点放在面向自然的农业项目以及保护和恢复关键生态系统的项目上，前者将帮助公司从可持续管理的农业实践中获得收入，后者则能从大气中移除并储存二氧化碳。苹果公司表示，“恢复基金”的投资将遵循“严格的社会和环境标准”。</p><h3 id="因增速放缓-苹果公司将开启大规模收购"><a href="#因增速放缓-苹果公司将开启大规模收购" class="headerlink" title="因增速放缓 苹果公司将开启大规模收购"></a>因增速放缓 苹果公司将开启大规模收购</h3><p>【环球网科技综合报道】4 月 7 日消息，据外媒报道称，苹果公司目前拥有超过 1650 亿美元的现金储备，鉴于苹果公司当前增速放缓，这家公司未来会开启大规模的收购。</p><p>不过，和微软、亚马逊等大手笔收购类型不同，苹果公司更倾向于收购小型初创公司。</p><p>外媒称，苹果喜欢以培养、孵化的方式开展收购，并耐心等待这些初创公司成长，来撬动新的市场。</p><p>据此前报道，今年 2 月，苹果收购了位于加州的 AI 算法公司 WaveOne 。今年 3 月，苹果公司已经收购了英国开放银行初创公司 CreditKudos 。</p><p>据了解，苹果经常收购小型企业，以加强其技术和专业知识，但显然没有或立即将其推广到产品或服务中。另一方面，许多收购确实成为苹果生态系统的关键部分。近年来，苹果已经收购了音乐识别服务 Shazam 和自动驾驶汽车公司 Drive.ai 等企业。</p><h3 id="Swift-Student-Challenge-现已开放申请"><a href="#Swift-Student-Challenge-现已开放申请" class="headerlink" title="Swift Student Challenge 现已开放申请"></a>Swift Student Challenge 现已开放申请</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/1FFB9751-9FB2-4171-B6E2-14CF821F6887/2048.jpeg" alt=""></p><p>我们很高兴能一如既往地为世界各地热爱编程的学生提供长期支持。欢迎使用 Swift Playgrounds 或 Xcode 编写 App Playground (主题自选) 并提交你的杰作，向我们展现你对于编程的热爱。优胜者将获得奖项和表彰，以及额外奖励。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md" title="SE-0393" target="_blank" rel="noopener">SE-0393</a> <strong>Value 和 Type 参数包</strong> 提案通过审查。该提案已在 <strong>二十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0394-swiftpm-expression-macros.md" title="SE-0394" target="_blank" rel="noopener">SE-0394</a> <strong>Package Manager 支持自定义宏</strong> 提案正在审查。</p><p>宏提供了一种扩展 Swift 的方法，通过对输入源代码执行任意语法转换来生成新代码。该提案涵盖了如何将自定义宏作为 Swift 软件包的一部分进行定义、构建和分发。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0395-observability.md" title="SE-0395" target="_blank" rel="noopener">SE-0395</a> <strong>Observation</strong> 提案正在审查。</p><p>该提案定义了什么是可观察的引用，观察者需要遵守什么，以及类型与其观察者之间的联系。这种设计模式是许多语言都支持的，Swift 引入之后，无疑将更加强大、安全和高性能。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-variadic-generic-types-abstracting-over-packs/64377" title="可变泛型类型抽象包" target="_blank" rel="noopener">可变泛型类型抽象包</a></p><p><strong>介绍</strong></p><p>之前的 SE-0393 引入了类型参数包和几个相关概念，允许泛型函数声明抽象出可变数量的类型。 该提案将这些想法概括为泛型类型声明。</p><p><strong>动机</strong></p><p>当试图在集合上概括通用算法时，自然会出现对可变数量的类型进行抽象的通用类型声明。 例如，惰性 ZipSequence 可能在两个序列上是通用的。 可以声明一个 ZipSequence 类型，它将固定序列列表的元素表示为元组序列：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZipSequence</span>&lt;<span class="title">each</span> <span class="title">S</span>: <span class="title">Sequence</span>&gt;: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Element</span> = (<span class="keyword">repeat</span> each <span class="type">S</span>.<span class="type">Element</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> seq: (<span class="keyword">repeat</span> each <span class="type">S</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Iterator</span>(iter: (<span class="keyword">repeat</span> (each seq).makeIterator()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = (<span class="keyword">repeat</span> each <span class="type">S</span>.<span class="type">Element</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iter: (<span class="keyword">repeat</span> each <span class="type">S</span>.<span class="type">Iterator</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">      <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议的解决方案</strong></p><p>在泛型类型的泛型参数列表中，each 关键字声明了一个泛型参数包，就像它在泛型函数的泛型参数列表中所做的那样。 存储属性的类型可以包含包扩展类型，如上面的 let seq 和 var iter。</p><p>2) 讨论<a href="https://forums.swift.org/t/dot-prefixing-considered-ugly/64376" title="点前缀被认为是丑陋的" target="_blank" rel="noopener">点前缀被认为是丑陋的</a></p><p>虽然我们已经习惯了，但在静态成员和枚举常量前加上点会引入视觉噪音，看起来太聪明了，总是让我的其他语言背景的同事感到惊讶：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> v: Color)</span></span> &#123;...&#125;</span><br><span class="line">object.foo(.red) <span class="comment">// 🤔</span></span><br></pre></td></tr></table></figure><p>在声明中缺少点前缀之间也存在这种令人不安的不对称性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> red</span><br><span class="line">    <span class="keyword">case</span> green</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> blue = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在其他地方使用这些前缀：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line">    <span class="keyword">case</span> .red: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .green: <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">foo(.red)</span><br><span class="line">foo(.blue)</span><br></pre></td></tr></table></figure><p>有趣的是，我已经可以在某些上下文中使用“object.foo(red)”（例如，在 Color 的静态方法中），但不能在其他上下文中使用。</p><p>我很欣赏这将是一个突破性的变化，我们不可能在现阶段迅速适应这一变化。 暂时忘记这一点，你认为 Swift 通过以下更改会变得更好还是更糟？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> v: Color)</span></span> &#123;...&#125;</span><br><span class="line">...</span><br><span class="line">object.foo(<span class="type">Color</span>.red) <span class="comment">// ok</span></span><br><span class="line">object.foo(.red)      <span class="comment">// 🛑 prohibited</span></span><br><span class="line">object.foo(red)       <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line">    <span class="keyword">case</span> .red: <span class="keyword">break</span>  <span class="comment">// 🛑 prohibited</span></span><br><span class="line">    <span class="keyword">case</span> red: <span class="keyword">break</span>   <span class="comment">// ✅</span></span><br><span class="line">&#125;</span><br><span class="line">dispatchPrecondition(condition: .onQueue(.main)) <span class="comment">// 🛑</span></span><br><span class="line">dispatchPrecondition(condition: onQueue(main))   <span class="comment">// ✅</span></span><br><span class="line">bar(.<span class="keyword">init</span>()) <span class="comment">// 🛑</span></span><br><span class="line">bar(<span class="keyword">init</span>())  <span class="comment">// ✅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// While choosing what "red" to use – follow these new resolution rules:</span></span><br><span class="line"><span class="comment">// - use local variable if exists</span></span><br><span class="line"><span class="comment">// - or use instance variable if exists (in which case self should be captured strongly explicitly or implicitly)</span></span><br><span class="line"><span class="comment">// - or use static variable if exists (in case of enum could be an enumeration constant)</span></span><br><span class="line"><span class="comment">// - or use global variable if exists</span></span><br><span class="line"><span class="comment">// - otherwise emit an error</span></span><br></pre></td></tr></table></figure><p>3) 讨论<a href="https://forums.swift.org/t/can-non-sendable-types-be-captured-in-tasks/64372" title="非 Sendable 类型可以在 Tasks 中捕获吗？" target="_blank" rel="noopener">非 Sendable 类型可以在 Tasks 中捕获吗？</a></p><p>现在，我猜想下面的代码应该会出现任何错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="built_in">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="built_in">count</span> = <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someClass = <span class="type">SomeClass</span>(<span class="built_in">count</span>: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init(priority: TaskPriority? = nil, operation: @escaping @Sendable () async -&gt; Success)</span></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    someClass.<span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public init(priority: TaskPriority? = nil, operation: @escaping @Sendable () async -&gt; Success)</span></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    someClass.<span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在 Swift（5.8 版）中，此代码片段可以编译。 在 Swift6 中，这段代码有没有出现错误？</p><p><strong>回答：</strong></p><p>在 Swift v.Future 中，全局 someClass 必须与全局 actor 隔离，因此行 someClass.count += 1 将需要：</p><p>整个 Task 闭包被隔离到同一个global actor，或者您为该操作切换到适当的global actor<br>（例如：await MainActor.run { someClass.count += 1 }）很难准确地说出在 Swift 6 中什么会/不会是错误。您可以使用一些编译器标志来尝试一些事情，但它们是不一致的。</p><p>4) 讨论<a href="https://forums.swift.org/t/why-does-didset-observer-fire-for-property-of-type-set-after-calling-insert-with-value-already-in-the-set/64350" title="为什么 didSet 观察者在使用集合中已有的值调用插入后会触发 Set 类型的属性？" target="_blank" rel="noopener">为什么 didSet 观察者在使用集合中已有的值调用插入后会触发 Set 类型的属性？</a></p><p>Xcode Playground 中的以下代码片段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> collection = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"didSet"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.insert(<span class="string">"Test1"</span>)</span><br><span class="line">collection.insert(<span class="string">"Test2"</span>)</span><br><span class="line">collection.insert(<span class="string">"Test1"</span>)</span><br><span class="line">collection.insert(<span class="string">"Test3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done"</span>)</span><br></pre></td></tr></table></figure><p>为什么是输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="type">Done</span></span><br></pre></td></tr></table></figure><p>而不是:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="keyword">didSet</span></span><br><span class="line"><span class="type">Done</span></span><br></pre></td></tr></table></figure><p>为什么当集合未更改时它会触发，因为该值已经在集合中？</p><p><strong>回答：</strong></p><p>每个mutating函数都会像这样。<br>没有特殊的机制可以让属性知道 Set 没有在内部被修改。</p><p>5) 讨论<a href="https://forums.swift.org/t/a-simultaneously-simple-yet-probably-fatally-complex-use-of-variadic-generics/64347" title="可变参数泛型的同时简单但可能致命复杂的使用" target="_blank" rel="noopener">可变参数泛型的同时简单但可能致命复杂的使用</a></p><p>我很好奇即将到来的可变参数泛型特性是否能让我们实现像 transform(<em>:</em>:) 这样的函数，你可以在下面看到它的使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasPrimeNumberOfCharacters: <span class="type">Bool</span> &#123;</span><br><span class="line">        transform(</span><br><span class="line">            <span class="keyword">self</span>,</span><br><span class="line">            &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;,</span><br><span class="line">            &#123; $<span class="number">0</span>.isPrime &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数采用一个强制性的第一个参数，即要转换的值，然后是一个可变的转换闭包列表，每个闭包都对它之前的闭包的输出类型进行操作，第一个对初始值进行操作。 在上面的例子中，参数是：String, (String)-&gt;Int, (Int)-&gt;Bool。</p><p>我已经阅读了大量的可变参数泛型文档，如果我现在必须给出我最好的猜测，我会说我的 transform(<em>:</em>:) 函数在可变参数泛型的第一次迭代中是不可能的。</p><p>下面是一个非常粗略的草图，它是我能想象到的最接近如何编写这样一个函数签名的草图。 我发现有必要发明许多新的语法，这支持了我的猜测，即这是不可能的，至少在最初是不可能的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transform</span></span></span><br><span class="line"><span class="function">    &lt;InitialValue,</span></span><br><span class="line"><span class="function">     each (T, U)&gt;</span></span><br><span class="line"><span class="function">    <span class="params">(<span class="number">_</span> initialValue: InitialValue,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="number">_</span> transform: <span class="keyword">repeat</span> each <span class="params">(T)</span></span></span>-&gt;<span class="type">U</span>)</span><br><span class="line">-&gt; last <span class="type">U</span> or <span class="type">InitialValue</span></span><br><span class="line"><span class="keyword">where</span> first <span class="type">T</span> == <span class="type">InitialValue</span> &#123;</span><br><span class="line">    <span class="comment">// How would one even implement this if the above syntax were valid?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6) 讨论<a href="https://forums.swift.org/t/building-distros-for-debian-ubuntu/64367" title="为 Debian/Ubuntu 构建发行版？" target="_blank" rel="noopener">为 Debian/Ubuntu 构建发行版？</a></p><p>现在我希望在 Jetson Nano（它有一个 ARM Cortex-A57 CPU）上用 Swift 做一个机器人项目，它只能使用 Ubuntu 18.04。 18.04 没有预构建的 5.8 .deb 包，这有点痛苦，因为这意味着我必须从源代码构建，并且一些构建依赖项（例如 cmake）必须从源代码构建才能获得最新的 足够的版本。 我以前构建过工具链，现在我正在 Jetson Nano 上构建它，但它花费了很长时间，尽管构建在连接的 SSD 上（操作系统运行在 SD 卡上）。</p><p>我想知道在我的 M1 Max MacBook Pro 上的 Ubuntu 18.04 Docker 容器（或者可能是 Parallels VM）中构建工具链是否有意义，然后构建将正确安装在任何 18.04 ARM 机器上的工具链的 .deb。</p><p>你认为那会建造得更快吗？</p><p>是否存在对构建 .deb 包的支持？ 20.04 和 22.04 包是如何构建的？</p><p><strong>回答：</strong></p><p>另一种选择是构建 MacOS -&gt; 18.04 交叉编译工具链。 不久前，我将 x-compiler 配置移到了 focus，但要翻转回 bionic 配置应该很容易。</p><p>7) 发布<a href="https://forums.swift.org/t/swift-5-8-released/64346" title="Swift 5.8 发布！" target="_blank" rel="noopener">Swift 5.8 发布！</a></p><p><strong>链接：</strong> <a href="https://www.swift.org/blog/swift-5.8-released/" target="_blank" rel="noopener">https://www.swift.org/blog/swift-5.8-released/</a></p><p>您可能已经看到，Swift 5.8 现已正式发布！ :tada: 此版本包括对语言和标准库的主要补充，包括支持逐步采用即将推出的功能的 hasFeature、改进的开发人员体验、改进 Swift 生态系统中的工具，包括 Swift-DocC、Swift Package Manager 和 SwiftSyntax，经过改进 Windows 支持等。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/04/11/mastering-canvas-in-swiftui/" title="在 SwiftUI 中掌握 Canvas 的使用" target="_blank" rel="noopener">在 SwiftUI 中掌握 Canvas 的使用</a></p><p><strong>摘要：</strong> 文章介绍了如何使用 Canvas 视图在 SwiftUI 中绘制 2D 图形，而无需使用 Shape API 。在 Canvas 视图中，我们可以使用 GraphicsContext 实例进行绘图，调整透明度、缩放和混合模式等参数，并添加不同的滤镜。 Canvas 还提供了 stroke、 fill 和 clip 函数，允许我们绘制任何我们需要的路径，同时也提供了draw函数，允许我们绘制文本和图像。我们可以使用 Canvas 类型绘制任何 SwiftUI 视图，但需要在创建 Canvas 时使用 symbols 闭包中注册它们。虽然 Canvas 视图不支持动画，但可以通过将其嵌入到带有动画调度程序的 TimelineView 中来实现动画效果。 Canvas 视图没有辅助功能树，但可以附加一组辅助视图修饰符，以使每个人都可以访问其内容。</p><p><a href="https://www.swiftbysundell.com/articles/observing-swiftui-scrollview-content-offset/#resolving-frames-using-geometryreader" title="监听 SwiftUI ScrollView 的内容偏移量" target="_blank" rel="noopener">监听 SwiftUI ScrollView 的内容偏移量</a></p><p><strong>摘要：</strong> 文章介绍了如何监听 SwiftUI ScrollView 的内容偏移量。在构建可滚动的 UI 时，通常需要观察当前滚动位置以便进行操作，但目前（在撰写本文时）SwiftUI 的 ScrollView 没有内置的方式来执行此类滚动观察。作者提供了一种利用 GeometryReader 解析器并使用 PreferenceKey 类型来实现的方法，使我们能够观察当前的内容偏移。最终作者实现了一个名为 OffsetObservingScrollView 的自定义滚动视图，可以实现监听当前内容偏移量的功能。</p><p><a href="https://www.swiftbysundell.com/articles/opaque-return-types-primary-associated-types/" title="Swift 中如何将不透明返回类型与主要关联类型相结合" target="_blank" rel="noopener">Swift 中如何将不透明返回类型与主要关联类型相结合</a></p><p><strong>摘要：</strong>  文章介绍了 Swift 5.7 引入的主关联类型和不透明返回类型相结合的使用方式。通过声明主关联类型，我们可以在使用 some 关键字时避免类型擦除，并使代码更加类型安全。该功能不仅适用于 Combine 框架，还可以在处理自己的泛型协议时使用。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p>4月11日，央行公布了2023年一季度的金融数据，居民超额存款三年10.8万亿：北京人均存款已接近27万，上海人均超21万。<strong>你存钱了吗？你存钱的目的是什么呢？</strong></p><ol><li>有安全感：为了应对失业、突发疾病等，避免因意外事件而出现经济困难。</li><li>实现个人目标：买房、买车、旅行等，通过积累资金来实现自己的愿望。</li><li>投资理财：通过投资股票、基金、房地产等资产来增加财富，实现长期的财务目标。</li><li>应对退休生活：通过积累养老金和退休金来保障自己的生活质量和经济安全。</li><li>没有存款：支出基本等于收入，实在是存不了钱。</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十八期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;再暗的黑夜也会迎来黎明，再长的坎坷也会连接平川。怀抱&lt;strong&gt;Swift社区&lt;/strong&gt;，一颗永不放弃的希望之心，明天将会是温暖的阳光雨露！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：因增速放缓 苹果公司将开启大规模收购&lt;/p&gt;
&lt;p&gt;提案：Package Manager 支持自定义宏&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论为什么 didSet 观察者在使用中会触发 Set 类型的属性&lt;/p&gt;
&lt;p&gt;推荐博文：在 SwiftUI 中掌握 Canvas 的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;你存钱了吗？你存钱的目的是什么呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十六期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十六期/</id>
    <published>2023-07-04T07:19:52.000Z</published>
    <updated>2023-07-04T07:28:35.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十七期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>考验人的才能不在于他是否拿到一副好牌，而在于他能打好一副坏牌。选择<strong>Swift社区</strong>，教你打好人生的每一张卡牌！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：WWDC23 将于北京时间 6 月 6 日举行</p><p>提案：提出添加 Value 和 Type 参数包</p><p>Swift 论坛：讨论 KeyPath 会产生内存泄漏吗？</p><p>推荐博文：使用 Hummingbird framework 对数据进行编码和解码</p><p><strong>话题讨论：</strong> </p><p>当代大学生脱掉孔乙己长衫，选择普通的非技术岗位就业，这算是一种思想的进步吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="WWDC23-将于北京时间-6-月-6-日举行"><a href="#WWDC23-将于北京时间-6-月-6-日举行" class="headerlink" title="WWDC23 将于北京时间 6 月 6 日举行"></a>WWDC23 将于北京时间 6 月 6 日举行</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/4508744A-29D9-43A0-9B71-E245065F041C/2048.jpeg" alt=""></p><p>万勿错过北京时间 6 月 6 日至 10 日为期一周丰富多彩的技术和社区活动，现在就添加到你的日历吧。你将能抢先了解 Apple 平台、技术和工具的最新动态，还有机会与 Apple 专家和其他开发者互动。以上活动均免费在线举行。</p><p>此外，Apple 将于太平洋夏令时间 6 月 5 日在 Apple Park 举办面向开发者和学生的全天特别活动。我们将一起观看主题演讲和 State of the Union 视频，与部分 Apple 团队会面交流，在 Apple 设计大奖颁奖典礼上为卓越的 App 欢呼庆祝，还能一起乐享当晚的活动。</p><p>另外，富有才华的学生们还可通过展现自己的创造力，角逐 Swift Student Challenge 并获得奖励。</p><h3 id="4-月-25-日起将实行以下-App-Store-内容提交要求"><a href="#4-月-25-日起将实行以下-App-Store-内容提交要求" class="headerlink" title="4 月 25 日起将实行以下 App Store 内容提交要求"></a>4 月 25 日起将实行以下 App Store 内容提交要求</h3><p>自 2023 年 4 月 25 日起，提交至 App Store 的 iOS、iPadOS 和 watchOS App 必须使用 Xcode 14.1 或更高版本构建。你可以从 Mac App Store 中免费获得最新版本的 Xcode 14，其中包含适用于 iOS 16、iPadOS 16 和 watchOS 9 的最新 SDK。</p><p>当你构建 App 时，我们强烈建议你利用 iOS 16、iPadOS 16 和 watchOS 9 中的最新改进。</p><p>iOS 16 满载全新的个性化功能、更具深度的智能技术，以及更多无缝式的沟通与共享方式，让 iPhone 的体验更进一步。利用“实时活动”帮助用户通过 iPhone 14 Pro 上的锁定屏幕和灵动岛，直接了解你的 App 中正在发生的事情。借助 App Intents，用户可以通过语音或轻点方式快速完成与你的 App 相关的任务。此外，你还可以充分利用 MapKit、ARKit 和 Core ML 等技术中的最新增强功能。</p><p>iPadOS 16 引入了新的效率功能，让你能够在 iPad 上提供引人入胜的协作体验，构建更丰富、更直观的 App 和强大的专业工作流程。你可以为 iPad App 带来桌面级功能，如编辑器风格的导航栏、增强的文本编辑菜单和外置显示器支持。同时，Metal 3 也引入了多项强大功能，可协助你的游戏和专业 App 在最新一代的 iPad Pro 和 iPad Air 上充分发掘 Apple 芯片的潜能。</p><p>watchOS 9 为 watchOS App 提供了强大的新通信功能。你可以在更多 Apple Watch 表盘上通过丰富的复杂功能提供及时资讯，支持用户从你的 App 中分享内容，让用户直接通过 Apple Watch 进行 VoIP 通话等。此外，watchOS App 的结构经过简化，更是让管理项目变得前所未有的简单。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0385-custom-reflection-metadata.md" title="SE-0385" target="_blank" rel="noopener">SE-0385</a> <strong>自定义反射元数据</strong> 提案被驳回。该提案已在 <strong>二十二期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0393-parameter-packs.md" title="SE-0393" target="_blank" rel="noopener">SE-0393</a> <strong>Value 和 Type 参数包</strong> 提案正在审查。</p><p>该提案添加了类型参数包和值参数包，方便对 Value 和 Type进行抽象实现。这是 Swift 向可变泛型迈出的关键一步。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-conform-never-to-codable/64056" title="使 Never 符合 Codable" target="_blank" rel="noopener">使 Never 符合 Codable</a></p><p><strong>介绍</strong></p><p>扩展 Never 使其符合 Encodable 和 Decodable 协议，统称为 Codable。</p><p><strong>动机</strong></p><p>Swift 可以为任何具有 Codable 成员的类型综合 Codable 一致性。 泛型类型通常通过约束它们的泛型参数来参与这种综合一致性，例如 Either 类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Either</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">left</span>(<span class="type">A</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">right</span>(<span class="type">B</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Either</span>: <span class="title">Codable</span> <span class="title">where</span> <span class="title">A</span>: <span class="title">Codable</span>, <span class="title">B</span>: <span class="title">Codable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样，两个泛型参数都是 Codable 的 Either 实例本身就是 Codable，例如 Either<int, double="">。 但是，由于 Never 不可编码，因此使用 Never 作为参数之一会阻止条件一致性，即使编码或解码像 Either<int, never=""> 这样的类型是完全没问题的。</int,></int,></p><p><strong>建议的解决方案</strong></p><p>标准库应该向 Never 类型添加 Encodable 和 Decodable 一致性。</p><p><strong>详细设计</strong></p><p>Encodable 一致性很简单——因为不可能有 Never 实例，encode(to:) 方法可以简单地为空。<br>Decodable 协议需要 init(from:) 初始化器，它显然不能创建 Never 实例。 如果尝试解码，该实现会抛出 DecodingError。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-import-c-structs-with-arc-pointer-members/64059#introduction-1" title="导入带有 ARC 指针成员的 C 结构体" target="_blank" rel="noopener">导入带有 ARC 指针成员的 C 结构体</a></p><p><strong>介绍：</strong></p><p>目前，Swift 可以导入 C 结构，其成员是 Swift 可导入的值类型，例如 int、BOOL 和 <code>__unsafe_unretained ARC</code> 指针，它们都是简单的构造和可析构的。 基于 Akira 在 LLVM 中启用强引用和弱引用的工作，我们应该能够导入这些类型和声明。</p><p><strong>动机：</strong></p><p>自 2018 年以来，这些指针类型已可用于 Objective-C/Objective-C++（以及之前的 Objective-C++），而 Swift 迄今为止尚未扩展以导入它们。 这是 Swift &lt;&gt; C++ 互操作的必要部分，我们应该能够移植值类型的引用类型成员的默认和成员构造和销毁，包括 Objective-C 语言模式中结构中的 ARC 指针。 Puyan 已经在此处合并了一些使用 C++ interop 构建这些类型的代码。</p><p><strong>建议的解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct WithArcPointers &#123;</span><br><span class="line">    __unsafe_unretained NSString *usUR;</span><br><span class="line">    __strong _Nonnull NSString *sStr;</span><br><span class="line">    __weak _Nullable NSString *wStr;</span><br><span class="line">    NSInteger count;</span><br><span class="line">&#125; WithArcPointers;</span><br></pre></td></tr></table></figure><p>应该导入到 Swift 作为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WithArcPointers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(usUR: <span class="type">String</span>!, sStr: <span class="type">String</span>, wStr: <span class="type">String</span>?, <span class="built_in">count</span>: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">var</span> usUR: <span class="type">Unmanaged</span>&lt;<span class="type">NSString</span>&gt;!</span><br><span class="line">  <span class="keyword">var</span> sStr: <span class="type">String</span></span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> wStr: <span class="type">NSString</span>?</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应保留各种 arc 存储类型，并在可能的情况下尊重预期的类型桥接和可空性注释。 弱成员在 Swift 端必须是 Optional，并且 <code>__unsafe_unretained</code> 必须是非桥接类型的 Unmanaged。 这些结构应该是成员可构造的，如果它们不包含非空成员，那么也可以通过可用的 init() 轻松构造。</p><p>结构中的非空弱引用虽然在 Clang 中是合法的，但不会被导入并且编译器将发出适当的诊断，因为 Swift 要求弱引用是可选的。 C 声明可能也应该有一个诊断，与适当错误的 ObjC 类一致，但这超出了本提案的范围。</p><p>3) 提议<a href="https://forums.swift.org/t/pitch-variadic-sequences/64072" title="可变序列" target="_blank" rel="noopener">可变序列</a></p><p>Swift 可以通过在方法定义中允许重复的参数序列来使可变参数表达式更强大。</p><p>这是在 Swift 5.7 语法中有效的可变参数函数定义和调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> value: <span class="params">(name: String, age: Int)</span></span></span>..., and otherName: <span class="type">String</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction((name: <span class="string">"Ada"</span>, age: <span class="number">26</span>), (name: <span class="string">"Bob"</span>, age: <span class="number">21</span>), and: <span class="string">"Carl"</span>)</span><br></pre></td></tr></table></figure><p>但是，我相信相同的定义/调用应该具有如下所示的能力：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(name: String..., age: ...Int, and anotherParameter: String)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction(name: <span class="string">"Ada"</span>, age: <span class="number">26</span>, name: <span class="string">"Bob"</span>, age: <span class="number">21</span>, and: <span class="string">"Carl"</span>)</span><br></pre></td></tr></table></figure><p>这可能是一种称为可变序列的新语言功能，其中可以在方法定义中包含任意数量的序列参数。 请注意新的 …Int 语法：这表示可变序列的结尾。 此功能为开发人员在编写方法调用时提供了更友好的体验。</p><p>至于在函数实现中获取可变参数序列，可以使用美元符号语法。 或者，每个可变序列元素都可以通过参数名称作为元组数组获得。 最后，可以通过使用 for in 循环 [1] 来迭代可变序列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(a: String..., b: ...Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> allSequences: [(a: <span class="type">String</span>, b: <span class="type">Int</span>)] = $<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> allValuesOfA: [<span class="type">String</span>] = a</span><br><span class="line">  <span class="keyword">let</span> allValuesOfB: [<span class="type">Int</span>] = b</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> myA, myB <span class="keyword">in</span> $<span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> aValue: <span class="type">String</span> = myA</span><br><span class="line">    <span class="keyword">let</span> bValue: <span class="type">Int</span> = myB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提议的细节：</p><p>每个可变参数序列都以打开和关闭参数开始和结束。 开放参数使用 Type… 语法。 关闭参数使用新的 …Type 语法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> <span class="keyword">open</span>: String..., <span class="number">_</span> close: ...String)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可变序列可以包含中间参数。 中间参数的类型使用普通语法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Variadic sequence with 3 elements</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> <span class="keyword">open</span>: String..., <span class="number">_</span> middle: String, <span class="number">_</span> close: ...String)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variadic sequence with 4 elements</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: String, <span class="number">_</span> <span class="built_in">c</span>: String, <span class="number">_</span> d: ...String)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可变参数序列可以使用任何需要的类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: Double, <span class="number">_</span> <span class="built_in">c</span>: ...T, <span class="number">_</span> d: Int)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction(<span class="string">"Swift"</span>, <span class="number">5.7</span>, objectA, <span class="string">"Objective-C"</span>, <span class="number">2.0</span>, objectB, <span class="number">1234</span>)</span><br></pre></td></tr></table></figure><p>对具有可变序列参数的函数的调用可以根据需要包含尽可能多的重复：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunction(<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"B"</span>, <span class="number">2</span>, <span class="string">"C"</span>, <span class="number">3</span>, <span class="string">"D"</span>, <span class="number">4</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>Varadic 序列元素可以命名为 [2]：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span>&lt;A, B&gt;<span class="params">(property path: KeyPath&lt;A, B&gt;..., <span class="number">_</span> middle: Comparison, value: ...B)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">myFunction(property: \.name, .equals, value: <span class="string">"Ada"</span>, property: \.age, .greaterThan, value: <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>方法定义中可能存在多个不同长度的可变序列。 在这种情况下，每个相应的序列都是使用 $0、$1、$2 等获得的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: ...Int, <span class="number">_</span> <span class="built_in">c</span>: Double..., _d: Date, <span class="number">_</span> e: ...Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> abValues: [(<span class="type">String</span>, <span class="type">Int</span>)] = $<span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> cdeValues: [(<span class="type">Double</span>, <span class="type">Date</span>, <span class="type">Int</span>)] = $<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数序列可以与常规参数和现有的可变参数一起使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">(<span class="number">_</span> a: String..., <span class="number">_</span> b: ...Int, _c: Double, <span class="number">_</span> d: Int...)</span></span></span><br><span class="line">myFunction(<span class="string">"Ada"</span>, <span class="number">26</span>, <span class="string">"Bob"</span>, <span class="number">21</span>, <span class="number">5.7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>4) 讨论<a href="https://forums.swift.org/t/pitch-observation-revised/63757" title="有没有办法从字符串中验证 URL" target="_blank" rel="noopener">有没有办法从字符串中验证 URL</a></p><p>可以用第三方库：GitHub：<a href="https://github.com/vapor/validation/blob/master/Sources/Validation/Validators/URLValidator.swift" title="vapor/validation" target="_blank" rel="noopener">vapor/validation</a></p><p>5) 讨论<a href="https://forums.swift.org/t/does-keypath-produce-memory-leaks/64050" title="KeyPath 会产生内存泄漏吗？" target="_blank" rel="noopener"> KeyPath 会产生内存泄漏吗？</a></p><p>回答：是的，KeyPath 实例在第一次使用时被缓存并保留在内存中直到程序结束。</p><p>6) 讨论<a href="https://forums.swift.org/t/for-in-vs-foreach-when-sequence-element-is-dictionary-key/64053" title="当序列元素为 Dictionary.Key 时，For-in 与 forEach()" target="_blank" rel="noopener">当序列元素为 Dictionary.Key 时，For-in 与 forEach()</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(keys: any Sequence&lt;Key&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys &#123;</span><br><span class="line">            <span class="keyword">let</span> value = <span class="keyword">self</span>[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(keys: any Sequence&lt;Key&gt;)</span></span> &#123;</span><br><span class="line">        keys.forEach &#123; key <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> value = <span class="keyword">self</span>[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for-in 中，key 的类型被推断为 Any，而在 forEach() 中，其类型为 Key。 这是设计使然还是错误？</p><p><strong>回答：</strong></p><p>首先，要知道这一点，但 f1 和 f2 实际上应该采用一些 Sequence<key> 类型的参数，而不是任何类型的参数，这将使错误消失。<br>这是一个已知的限制，将来可能会被取消。 让我试着分解一下。</key></p><p>从 f2: forEach 开始可以保留具体的 Key 类型，这要归功于 SE-0353：受限存在类型中的 Covariant Erasure with Constrained Existentials 1。 所以这是相对简单的。</p><p>对于 f1，编译器基本上将 for 循环重写为 while 循环，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = keys.makeIterator()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> key = iterator.next() &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们手动编写这个 while 循环，我们会在第一行的 makeIterator() 调用中遇到错误：</p><p>错误：推断结果类型“any IteratorProtocol”需要显式<br>由于通用要求的丢失而导致的强制编译器强制我们将 keys.makeIterator() 编写为任何 IteratorProtocol，以确认迭代器变量失去了其 Element == Key 的知识，这就是为什么 for 循环中的元素类型为 Any 的原因。</p><p>在 SE-0352: Implicitly Opened Existentials 中类型擦除结果值时“丢失”约束中描述了几乎这种情况：</p><p>当涉及打开的存在类型的调用结果被类型擦除时，可能一些关于返回类型的信息无法用存在类型表示，因此上述“上界”将丢失信息。</p><p>该部分还提到，未来的编译器版本可以通过恢复现在更多的类型信息来提高语言的表达能力。 它甚至明确提到了可能有助于解决此问题的主要关联类型 SE-0353。</p><p>总而言之，当从任何 Sequence<t> 生成迭代器时，编译器似乎可以（并且最终应该）保留元素类型信息，但这尚未实现（如果实现，它可能也会有 经历 Swift Evolution）。</t></p><p>7) 讨论<a href="https://forums.swift.org/t/void-as-an-associated-type/64043" title="Void 作为关联类型？" target="_blank" rel="noopener">Void 作为关联类型？</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://www.avanderlee.com/swift/operation-couldnt-completed-error-code/" title="在 Swift 中解决 The operation couldn’t be completed 错误" target="_blank" rel="noopener">在 Swift 中解决 The operation couldn’t be completed 错误</a></p><p><strong>摘要：</strong> 本篇博客讨论如何解决 Swift 中出现 “The operation couldn’t be completed” 的错误，当收到 “The operation couldn’t be completed” 错误消息时该如何处理。作者解释说，这些错误通常会附带错误代码，但没有描述，因此很难确定如何解决问题。该文章建议在GitHub上搜索错误域以查找错误代码的描述，然后在Google上搜索相关信息并找到带有描述的苹果文档。作者还介绍了 What The Error Code ，这是一个提供即时错误代码描述的简单工具的使用。最后，作者解释说他们已经将 What The Error Code 添加到 RocketSim 上，以简化其使用。</p><p><a href="https://juejin.cn/post/7216130963277332535" title="Swift 之 struct 二进制大小分析" target="_blank" rel="noopener">Swift 之 struct 二进制大小分析</a></p><p><strong>摘要：</strong> 文章讨论了 struct 对比 class 的一些优劣势，重点分析了 struct 和 class 对包体积带来的影响及规避措施，并分别比较了使用 let 和 var 修饰下二者二进制大小的区别，为我们在日常开发中 struct 和 class 选择上提供了包大小维度的衡量。</p><p><a href="https://theswiftdev.com/encoding-and-decoding-data-using-the-hummingbird-framework/" title="使用 Hummingbird framework 对数据进行编码和解码" target="_blank" rel="noopener">使用 Hummingbird framework 对数据进行编码和解码</a></p><p><strong>摘要：</strong>  这篇博文介绍了 <code>HummingbirdFoundation</code> 框架对数据进行编解码，它支持 HTML、JSON 和 plain text 等多种数据类型。该框架还允许将传入的 HTTP 请求体对象轻松转换为 Swift 数据结构并返回它们。作者展示了框架通过 Codable 协议和使用 <code>HBResponseCodable</code> 协议、 <code>HBResponseEncodable</code> 协议、 <code>HBRequestDecoder</code> 和 <code>HBResponseEncoder</code> 实现的 JSON 对象内置编码和解码支持。此外，文章还解释了使用  <code>HummingbirdFoundation</code> 支持的两种编码类型—— <code>application/x-www-form-urlencoded</code> 和 <code>multipart/form-data——</code> 对 HTML 表单进行编码和解码。</p><p><a href="https://swdevnotes.com/swift/2023/how-to-cancel-a-background-task-in-swift//" title="在 Swift 中如何取消后台任务" target="_blank" rel="noopener">在 Swift 中如何取消后台任务</a></p><p><strong>摘要：</strong>  本文演示了在 Swift 5.5 中使用 async/await 异步编程时取消后台任务的不同方法。文章强调了取消不必要的任务的重要性，以防止不需要的后台任务干扰应用程序的性能。文章提供了各种取消任务的方法，包括使用取消标志、使用 <code>Task.checkCancellation()</code> 检查任务取消情况以及使用 <code>Task.isCancelled</code> 来将取消传播到子任务。文章为每种方法提供了示例代码，并解释了每种方法的优点和缺点。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>当代大学生脱掉孔乙己长衫，选择普通的非技术岗位就业，这算是一种思想的进步吗？</strong></p><ol><li>必须算啊，勇于突破陈旧观念，值得尊敬。</li><li>不能算的，选择了普通非技术岗位，意味着自己的大学生涯毫无价值体现。</li><li>无所谓进步与否，只不过是当今经济环境下的无奈选择罢了。</li></ol><p><img src="https://files.mdnice.com/user/17787/6cdea255-542f-4168-93f8-31cf18c17ce5.png" alt="本图来源于网络"></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十七期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;考验人的才能不在于他是否拿到一副好牌，而在于他能打好一副坏牌。选择&lt;strong&gt;Swift社区&lt;/strong&gt;，教你打好人生的每一张卡牌！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：WWDC23 将于北京时间 6 月 6 日举行&lt;/p&gt;
&lt;p&gt;提案：提出添加 Value 和 Type 参数包&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论 KeyPath 会产生内存泄漏吗？&lt;/p&gt;
&lt;p&gt;推荐博文：使用 Hummingbird framework 对数据进行编码和解码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;当代大学生脱掉孔乙己长衫，选择普通的非技术岗位就业，这算是一种思想的进步吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十五期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十五期/</id>
    <published>2023-07-04T07:19:48.000Z</published>
    <updated>2023-07-04T07:27:45.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十六期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>选择与放弃，是生活与人生处处需要面对的关口。选择了<strong>Swift社区</strong>，就拥有了一道最靓丽的风景！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：印度将首次成为苹果公司自有销售地区</p><p>提案：提案 SE-0382、SE-0388、SE-0389 通过审查</p><p>Swift 论坛：提议 Observation 修订</p><p>推荐博文：两个新的开源 Swift 库：<code>Swift Certificates</code> 和 <code>Swift ASN.1</code></p><p><strong>话题讨论：</strong> </p><p>文心一言挑战 ChatGPT，谁更胜一筹？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="印度将首次成为苹果公司自有销售地区"><a href="#印度将首次成为苹果公司自有销售地区" class="headerlink" title="印度将首次成为苹果公司自有销售地区"></a>印度将首次成为苹果公司自有销售地区</h3><p>【环球网科技综合报道】3 月 9 日消息，据外媒报道，苹果公司正在改变国际业务的管理方式，推动印度首次成为其自有销售区。</p><p>据悉，负责苹果印度、中东、地中海、东欧和非洲地区业务的副总裁休斯·阿斯曼（HuguesAsseman）退休后，苹果计划将印度调整成自有销售区域。而阿希什·乔杜里（AshishChowdhary）将升职，成为印度地区的负责人，直接向苹果的产品销售负责人汇报。</p><p>外媒分析称，作为世界第二大智能手机市场，印度市场对于苹果而言越来越重要。2022 年第 四 季度，苹果在印度市场的销售额创新高。</p><p>目前，苹果已开始在印度生产一些 iPhone 型号，包括 iPhone14 。此外，苹果计划于今年晚些时候在该国开设第一家零售店。</p><h3 id="Meta第二轮裁员波及万人，苹果推迟发放奖金"><a href="#Meta第二轮裁员波及万人，苹果推迟发放奖金" class="headerlink" title="Meta第二轮裁员波及万人，苹果推迟发放奖金"></a>Meta第二轮裁员波及万人，苹果推迟发放奖金</h3><p>硅谷的裁员、降薪潮远未结束。</p><p>3 月 14 日周二，Meta 和苹果纷纷宣布最新的人事政策。</p><p>周二，Meta 的第二轮裁员终于确定，将裁员大约一万人，同时还将关闭 5000 个额外空缺职位，以求节省开支、提高效率。这是 Meta 在六个月时间里的第二轮重大裁员行动。</p><p>Meta 的首席执行官马克·扎克伯格周二在声明中表示，该公司的目标是通过取消管理层的多层级结构来让公司变得更加扁平化。</p><p>周二，Meta 高开高走，当前股价上涨 5.93% ，报 191.62 美元。</p><p><img src="https://files.mdnice.com/user/17787/aa91dde5-2de2-465a-8eb9-ae37aeb84cdd.png" alt=""></p><p>上个月，有媒体报道称，Meta 还一直致力于扁平化其组织，向管理人员提供买断方案，并裁减其认为不必要的整个团队，此举仍在最后敲定中，可能会影响数千名员工。</p><p>知情人士称，Meta 即将到来的新一轮裁员是由财务目标推动的，与公司“扁平化”没有直接关系。知情人士说，Meta 已经看到广告收入放缓，并将重点转移到元宇宙平台，公司高层一直在要求董事和副总裁列出可以解雇的员工名单。</p><p>据知情人士透露，这一阶段的裁员最快可能会在本周完成。一位知情人士说，那些正在制定裁员计划的人希望在首席执行官扎克伯格为他的第三个孩子休育儿假之前准备好，因此这次裁员的速度可能会非常快。</p><h3 id="App-Store-的定价机制升级现已扩展至所有购买类型"><a href="#App-Store-的定价机制升级现已扩展至所有购买类型" class="headerlink" title="App Store 的定价机制升级现已扩展至所有购买类型"></a>App Store 的定价机制升级现已扩展至所有购买类型</h3><p>在 12 月，我们宣布对 App Store 进行问世至今最全面的定价机制升级，其中包括新增价格点和按店面管理定价的全新工具。即日起，这些升级和新价格适用于所有类型的 App 和 App 内购买项目，包括付费 App 和一次性 App 内购买项目。</p><p>更为灵活的价格点。可在 900 个价格点中选择定价 — 比此前付费 App 和一次性 App 内购买项目的可选价格点数量增加了近 9 倍。这些选项也提供了更高的定价灵活度，价格点按价格区间逐渐递增 (如在 RMB 10 以下每档相差 RMB 0.5；RMB 10 到 RMB 200 之间每档相差 RMB 1 等)。</p><p>增强的全球定价机制。全球均衡价格遵循了各个国家或地区最常见的定价方式。采用全球均衡价格，你可以提供更适用于当地顾客的定价。</p><p>根据基准价格提供全球定价形式。针对付费 App 和一次性 App 内购买项目，指定你熟悉的国家或地区，以之为基础为其他 174 个国家或地区的店面以及 43 种货币生成全球均衡价格。你为这个基准店面设定的价格，Apple 不会根据税款或外汇变化进行调整。此外，你也可以按个人喜好为每个店面自行设定价格。</p><p>为上架产品提供地区性定价方案。针对不同国家和地区的店面决定 App 内购买项目 (包括订阅) 的销售范围，因此你可以为各个市场分发定制的内容和服务。</p><p>准备好迎接即将在 5 月推出的增强全球定价机制<br>App Store 的全球均衡价格工具为你提供了一种简单便捷的方式来管理国际市场的定价。在 2023 年 5 月 9 日，在所有 175 个 App Store 店面中的现有 App 和一次性 App 内购买项目的价格都将更新，以充分利用此次全新的增强全球定价机制。更新后的价格将根据金融数据机构提供的公开汇率信息做调整，在全球范围内与你为基准店面设定的价格保持平衡。这些价格点将跟随各个国家或地区最常见的定价方式，让价格更适用于当地顾客。</p><p>你即刻就能使用 App Store Connect 或 App Store Connect API 更新你的当前定价，以充分利用此次全新升级。在 5 月 9 日，如果你的现有 App 和一次性 App 内购买项目还没有完成价格更新，Apple 将以产品当前在美国店面的价格为基础，为它们生成相应的更新价格。如果你希望以其他价格作为基础，现在可通过更新基准店面的国家或地区，为 App 或 App 内购买项目选择新的基准店面。你还可以选择手动管理所选店面中的价格，而不使用均衡的价格。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过审查的提案"><a href="#通过审查的提案" class="headerlink" title="通过审查的提案"></a>通过审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案通过审查。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md" title="SE-0388" target="_blank" rel="noopener">SE-0388</a> <strong>增加 Async[Throwing]Stream.makeStream 方法</strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0389-attached-macros.md" title="SE-0389" target="_blank" rel="noopener">SE-0389</a> <strong>Attached Macros</strong> 提案通过审查。该提案已在 <strong>二十四期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0392-custom-actor-executors.md" title="SE-0392" target="_blank" rel="noopener">SE-0392</a> <strong>自定义 Actor 执行器</strong> 提案正在审查。</p><p>该提案介绍了一种用于自定义 actor 执行程序的基本机制。通过提供执行者的实例，参与者可以影响他们将在什么地方执行正在运行的一些任务。</p><blockquote><p><strong>注意：</strong> 该提案仅定义了一组 API 来自定义 actor 执行器，其他类型的执行器控制超出了该特定提案的范围。</p></blockquote><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/pitch-observation-revised/63757" title="Observation（修订）" target="_blank" rel="noopener">Observation（修订）</a></p><p><strong>介绍</strong></p><p>制作响应式应用程序通常需要能够在基础数据发生变化时更新演示文稿。 观察者模式允许一个主题维护一个观察者列表，并通知他们特定的或一般的状态变化。 这具有不直接将对象耦合在一起并允许在潜在的多个观察者之间隐式分布更新的优点。 可观察对象不需要关于其观察者的特定信息。</p><p>这种设计模式是许多语言都走过的一条很好的道路，Swift 有机会提供一个健壮的、类型安全的和高性能的实现。 该提议定义了什么是可观察引用、观察者需要遵守什么以及类型与其观察者之间的联系。</p><p><strong>动机</strong></p><p>Swift 中已经有一些观察机制。 其中包括键值观察 (KVO) 和 <code>ObservableObject</code>，但它们中的每一个都有局限性。 KVO 只能与 NSObject 后代一起使用，而 <code>ObservableObject</code> 需要使用 Combine，它仅限于 Darwin 平台并且不使用当前的 Swift 并发功能。 通过从这些现有系统中吸取经验，我们可以构建一个更普遍有用的功能，适用于所有 Swift 引用类型，而不仅仅是那些继承自 NSObject 的引用类型，并使其跨平台工作，并具有 <code>async/await</code> 等语言功能的优势。</p><p>现有系统获得了许多正确的行为和特征。 但是，有许多领域可以在安全性、性能和表现力之间提供更好的平衡。 例如，将相关的更改分组到一个独立的事务中是一项常见的任务，但是这在使用 Combine 时很复杂并且在使用 KVO 时不受支持。 在实践中，观察者想要访问交易，并能够指定如何解释交易。</p><p>注释阐明了可观察的内容，但也可能很麻烦。 例如，Combine 不仅要求类型符合 <code>ObservableObject</code>，还要求被观察的每个属性都标记为 <code>@Published</code>。 此外，无法直接观察计算出的属性。 实际上，在可观察的类型中具有非观察字段并不常见。</p><p>在整个文档中，对 KVO 和 Combine 的引用将说明哪些功能是有益的并且可以合并到新方法中，以及可以以更稳健的方式解决哪些缺点。</p><p><strong>现有技术</strong></p><p><strong>KVO</strong></p><p>Objective-C 中的键值观察很好地服务于该模型，但仅限于从 NSObject 继承的类层次结构。 API 仅提供事件拦截，这意味着更改通知位于 willSet 和 didSet 事件之间。 KVO 在事件粒度方面具有很大的灵活性，但缺乏可组合性。 KVO 观察者还必须继承自 NSObject，并依赖 Objective-C 运行时来跟踪发生的变化。 尽管 KVO 的接口已经更新为使用更现代的 Swift 强类型键路径，但在底层它的事件仍然是字符串类型的。</p><p><strong>Combine</strong></p><p>Combine 的 <code>ObservableObject</code> 在 <code>willSet/didSet</code> 事件的前缘产生变化，所有的值都在值被设置之前传递。 虽然这很好地服务于 SwiftUI，但它对非 SwiftUI 的使用有限制，并且对于第一次遇到该限制的开发人员来说可能会感到惊讶。 <code>ObservableObject</code> 还要求将所有观察到的属性标记为 <code>@Published</code>  以与更改事件进行交互。 在大多数情况下，这一要求适用于每一个单独的属性，对开发者来说变得多余； 编写符合 <code>ObservableObject</code> 类型的人必须重复（几乎没有真正获得清晰度）注释每个属性。 最后，这会导致对参与项目或不参与项目的意义疲劳。</p><p>我们提出了一个名为 <code>Observation</code> 的新标准库模块，其中包括实现这种模式的协议、类型和宏。<br>基本上，一个类型可以简单地通过使用 <code>@Observable</code> 宏注解将自己声明为可观察的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Observable</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> someProperty: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> someOtherProperty = <span class="number">0</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> somePrivateProperty = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Observable</code> 宏声明并实现与 <code>Observable</code> 协议的一致性，该协议包括一组处理观察的扩展方法。 在最简单的情况下，客户端可以使用 <code>changes(for:)</code> 方法来观察给定实例的特定属性的变化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processChanges</span><span class="params">(<span class="number">_</span> object: MyObject)</span></span> async &#123;</span><br><span class="line">    <span class="keyword">for</span> await value <span class="keyword">in</span> object.values(<span class="keyword">for</span>: \.someProperty) &#123;</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这允许 <code>Observable</code> 类型的用户将特定值的更改或整个实例作为更改事件的异步序列进行观察。 <code>changes(for:)</code> 方法提供类型安全，因为它只提供对一个特定属性的更改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object.someProperty = <span class="string">"hello"</span> </span><br><span class="line"><span class="comment">// prints "hello" in the awaiting loop</span></span><br><span class="line">object.someOtherProperty += <span class="number">1</span></span><br><span class="line"><span class="comment">// nothing is printed</span></span><br></pre></td></tr></table></figure><p>可观察对象还可以提供分组到事务中的更改，这些事务合并了在暂停点之间进行的任何更改。 默认情况下，交易会单独交付给您提供的参与者或主要参与者。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processTransactions</span><span class="params">(<span class="number">_</span> object: MyObject)</span></span> async &#123;</span><br><span class="line">    <span class="keyword">for</span> await change <span class="keyword">in</span> objects.changes(<span class="keyword">for</span>: [\.someProperty, \.someOtherProperty]) &#123;</span><br><span class="line">        <span class="built_in">print</span>(myObject.someProperty, myObject.someOtherProperty)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>ObservableObject</code> 和 <code>@Published</code> 不同，<code>@Observable</code> 类型的属性不需要单独标记为可观察。 相反，所有存储的属性都是隐式可观察的。<br>对于只读计算属性，作者可以添加 <code>static dependencies(of:)</code> 方法来声明额外的关键路径作为他们观察的一部分。 这类似于 KVO 用来提供对键路径有影响的附加键路径的机制。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> someComputedProperty: <span class="type">Int</span> &#123; </span><br><span class="line">        somePrivateProperty + someOtherProperty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nonisolated <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">dependencies</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        of keyPath: PartialKeyPath&lt;<span class="keyword">Self</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> -&gt; <span class="type">TrackedProperties</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> keyPath &#123;</span><br><span class="line">        <span class="keyword">case</span> \.someComputedProperty:</span><br><span class="line">            <span class="keyword">return</span> [\.somePrivateProperty, \.someOtherProperty]</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> [keyPath]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于所有对观察变化的访问都是通过关键路径进行的，因此 public 和 private 等可见性关键字决定了可以观察到什么，不能观察到什么。 与 KVO 不同，这意味着只能观察到在特定范围内可访问的成员。 这一事实反映在设计中，其中事务表示为 <code>TrackedProperties</code> 实例，它允许查询更改的键路径，但不能查询它们的迭代。</p><p>2) 提议<a href="https://forums.swift.org/t/pitch-elide-some-in-swift-6/63737" title="在 Swift 6 中省略 some" target="_blank" rel="noopener">在 Swift 6 中省略 some</a></p><p><strong>介绍</strong></p><p>目前，在类型位置中编写普通协议名称的默认值是 any，但其中许多隐含的 any 用法可以替换为 some，从而为它们提供更多类型信息，同时仍能正确运行。 该提议翻转了默认值，以便在编写普通协议时，类型将默认为 some 而不是 any。 使默认值 some 保证固定的底层类型，它保留与底层类型的静态类型关系，使您可以完全访问使用 Self 和关联类型的协议要求和扩展方法。</p><p><strong>动机</strong></p><p>一段时间以来，Swift 一直致力于改进泛型的 UI，在 Swift 5.1 中引入了 some 关键字来表示不透明类型——特定具体类型的抽象类型占位符——它在 Swift 5.7 类型中扩展到参数，这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>&lt;T&gt;<span class="params">(<span class="number">_</span> bar: T)</span></span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Equatable</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is equivalent to </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> bar: some T)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>Swift 5.6 引入了 explicit any，这在 Swift 6 语言模式中是必需的，以确保选择类型擦除而不是使用类型参数是明确和深思熟虑的。 引入使用显式 any 的要求并鼓励默认编写一些，这为将一些作为普通协议名称的默认值提供了机会。</p><p>通用代码已经在比您想象的更多的地方得到了简化。 以协议扩展为例。 要编写适用于任何符合协议的具体类型的通用代码，您只需编写扩展关键字和普通协议名称。 在此示例中，我们使用 Collection 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What you write to extend all concrete types conforming to 'Collection':</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>在通用代码中，通用签名表示通用参数和对这些参数的任何要求。 在协议扩展的情况下，有一个名为 Self 的隐式类型参数和单一一致性要求 <code>Self: Collection</code> 由编译器添加，而不需要您编写。 这允许您从符合要求的 Self 类型上的 Collection 协议访问所有协议要求、关联类型和其他扩展方法。</p><p>当存在不需要使用 where 子句内化泛型签名的垫脚石时，程序员学习泛型编程会容易得多。 程序员可以使用更直接、更直观的语法来表达同一事物。 Swift 6 可以将同样的原则应用于其他上下文中的普通协议名称。 这种做法对于学习 Swift 的初学者来说可能是无价的，它消除了在向代码中添加协议时比较某些和任何之间的权衡的心理负担。 初学者不需要在使用 some 还是 any 之间做出决定，推迟完全理解语义差异的需要，直到绝对有必要在两者之间进行选择。 即使您不是初学者，一些默认设置仍然可以通过使代码更简洁来提高代码的可读性。</p><p>3) 讨论<a href="https://forums.swift.org/t/really-bad-performance-with-concurrecny-and-how-to-optimize-the-code/63732/1" title="并发性能真的很差以及如何优化代码" target="_blank" rel="noopener">并发性能真的很差以及如何优化代码</a></p><p><strong>内容大概：</strong></p><p>我们正在对各种编程语言的并发性进行比较，并使用 Swift 实现一维热方程求解器。 与 Python、Rust 和 C++ 相比，swift 的性能看起来不是很好。<br>首先，代码最多只能扩展到三个内核，见下文</p><p>核心，总时间</p><p>10,2111.423936009407<br>8,2189.256893992424<br>5,1967.6182420253754<br>4,1929.6173659563065<br>2,3097.796007990837<br>1,4388.57520699501</p><p>然而，每秒的浮点运算相当低，例如在三个内核上我们每秒可以进行 500 次浮点运算。 与其他语言相比，这并不多。</p><p>所以，既然我们想发布结果，我想寻求一些帮助，因为我认为我们在 Swift 中的实现并不好。</p><p><strong>Vote最多的回答：</strong></p><p>这种问题对于简单的并发或多线程来说通常是一个非常糟糕的情况：</p><p>您的工作集太大。 在 <code>2 * 10000000 * MemoryLayout(Double).size</code>，你有一个 160MB 的工作集，它不适合缓存，所以你实际上受到内存速度的限制，而不是计算速度，这 与额外资源的扩展几乎不一样。</p><p>如果你用较小的工作集解决了这个问题，你就会被数据局部性所困扰。 您确实希望将每个 worker 固定到数据的固定部分，因此它会在下一个时间步位于与 worker 关联的缓存中。</p><p>4) 讨论<a href="https://forums.swift.org/t/state-not-initializing-correctly/63726" title="@State 没有正确初始化" target="_blank" rel="noopener">@State 没有正确初始化</a></p><p>5) 讨论<a href="https://forums.swift.org/t/a-light-weight-mvvmlight-architecture-pattern-in-swift/63722" title="Swift 中的轻量级 MVVMLight 架构模式" target="_blank" rel="noopener">Swift 中的轻量级 MVVMLight 架构模式</a></p><p>6) 讨论<a href="https://forums.swift.org/t/generic-where-fails-for-protocol-types/63729/1" title="协议类型里的Generic“where”失效" target="_blank" rel="noopener">协议类型里的 Generic“where” 失效</a></p><p>7) 讨论<a href="https://forums.swift.org/t/how-to-kind-of-emulate-raii-using-defer/63719" title="如何使用 `defer` 模拟 RAII" target="_blank" rel="noopener">如何使用 <code>defer</code> 模拟 RAII</a></p><p><strong>内容大概</strong></p><p>Swift 的 defer 语句具有很好的模拟 C++ 的资源获取即初始化行为的能力，由于 ARC，我们无法做到这一点。 如果您正在使用 <code>UnsafeMutablePointer</code> 通过确保在退出范围时正确清理资源来执行某些操作，这可能会很方便：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> file: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">FILE</span>&gt;?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(filePath: <span class="type">String</span>) &#123;</span><br><span class="line">        file = fopen(filePath, <span class="string">"r"</span>)</span><br><span class="line">        <span class="keyword">guard</span> file != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Error: Unable to open the file."</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> file != <span class="literal">nil</span> &#123;</span><br><span class="line">            fclose(file)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">readAndProcessFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> file != <span class="literal">nil</span> &#123;</span><br><span class="line">                fclose(file)</span><br><span class="line">                file = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read and process the file</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fileHandler = <span class="type">FileHandler</span>(filePath: <span class="string">"path/to/your/file.txt"</span>) &#123;</span><br><span class="line">    fileHandler.readAndProcessFile()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们有一个管理文件的 <code>FileHandler</code> 类。 当调用 <code>readAndProcessFile</code> 方法时，我们使用 defer 块来确保在方法退出时关闭文件，无论它是正常退出还是由于错误退出。 这类似于 C++ 中的 RAII 概念，其中在对象超出范围时执行资源清理。</p><p>当然，这不是 RAII 的 1:1，但它显示了一种可以使用 defer 来实现类似效果的方法。</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swiftwithmajid.com/2023/03/15/performance-testing-in-swift-using-xctest-framework" title="Swift 中如何使用 XCTest 框架进行性能测试" target="_blank" rel="noopener">Swift 中如何使用 XCTest 框架进行性能测试</a></p><p><strong>摘要：</strong> 本文介绍了如何在 Swift 中使用 XCTest 框架进行性能测试，并通过 measure 函数来测量应用程序中特定代码路径的性能。</p><p><a href="https://www.swift.org/blog/swift-certificates-and-asn1" title="两个新的开源 Swift 库：Swift Certificates 和 Swift ASN.1" target="_blank" rel="noopener">两个新的开源 Swift 库：Swift Certificates 和 Swift ASN.1</a></p><p><strong>摘要：</strong> 这篇文章介绍了两个新的开源 Swift 库：Swift Certificates 和 Swift ASN.1。这两个库共同提供了更快、更安全的 X.509 证书实现，X.509 证书是支持 TLS 安全的关键技术之一。文章解释了X.509 证书和 ASN.1 格式的概念，和为什么需要构建一个 ASN.1 库以支持完整的 X.509 库，并介绍了 Swift ASN.1 和 Swift Certificates 的功能和目标。 Swift Certificates 目前可以解析大多数符合 RFC 5280 标准和 Web PKI 中使用的 X.509 证书，支持插件式 X.509 验证策略和 OCSP 分辨率。短期目标是使用 Swift Certificates 替换 swift-nio-ssl 中的 BoringSSL 实现，以提供更高性能和更好的内存安全性。</p><p><a href="https://juejin.cn/post/7207269389474037817" title="云音乐 Swift 混编 Module 化实践" target="_blank" rel="noopener">云音乐 Swift 混编 Module 化实践</a></p><p><strong>摘要：</strong>  文章介绍了网易云音乐 iOS App 在支持 Swift 混编过程中，Module 化阶段的分析与实践以及在实践过程中可能会遇到各种未知问题。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>文心一言挑战ChatGPT，谁更胜一筹？</strong></p><ol><li>文心一言</li><li>ChatGPT</li><li>不分伯仲</li></ol><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十六期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;选择与放弃，是生活与人生处处需要面对的关口。选择了&lt;strong&gt;Swift社区&lt;/strong&gt;，就拥有了一道最靓丽的风景！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：印度将首次成为苹果公司自有销售地区&lt;/p&gt;
&lt;p&gt;提案：提案 SE-0382、SE-0388、SE-0389 通过审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：提议 Observation 修订&lt;/p&gt;
&lt;p&gt;推荐博文：两个新的开源 Swift 库：&lt;code&gt;Swift Certificates&lt;/code&gt; 和 &lt;code&gt;Swift ASN.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;文心一言挑战 ChatGPT，谁更胜一筹？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十四期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十四期/</id>
    <published>2023-07-04T07:19:43.000Z</published>
    <updated>2023-07-04T07:27:10.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十五期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>一个人真正觉悟的时候，就会去追寻内心世界真正的财富。<strong>Swift社区</strong>渴望走进你的内心，与你一起拥抱财富！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果高管确认，新品即将上市</p><p>提案：围绕 <code>Macros</code> 提出多个提案</p><p>Swift 论坛：新发布 VSCode devContainers 的新功能</p><p>推荐博文：使用 <code>async/await</code> 完成后台任务管理</p><p><strong>话题讨论：</strong> </p><p>程序员养生喝什么？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果高管确认，新品即将上市"><a href="#苹果高管确认，新品即将上市" class="headerlink" title="苹果高管确认，新品即将上市"></a>苹果高管确认，新品即将上市</h3><p>众所周知，苹果对待还未正式发布的产品，向来采取较为严格的保密政策。<br>不过，在去年 3 月举办的苹果春季发布会上，苹果对新品的一波预告，似乎成了近些年来罕有的例外。</p><p><img src="https://pics0.baidu.com/feed/58ee3d6d55fbb2fbd4417ebff105eeaf4723dc94.jpeg@f_auto?token=aac9eaa5fbccbd32593233adc298b6cf" alt=""></p><p>苹果硬件工程高级副总裁 John Ternus 在发布会结尾，暗示了即将要推出新款 Mac Pro 的消息。</p><p>实际上这也并不稀奇，苹果早在 2020 年就曾宣布了一项「两年计划」，预计在两年时间内将旗下所有 Mac 产品都转向自研芯片，彻底抛弃英特尔。</p><p>而如今两年之期已到，Mac 产品线中，也仅剩 Mac Pro 一款产品还未搭载 M 系芯片。</p><p>就在许多期待这款新 Mac 的小伙伴望眼欲穿之际，另一位苹果高管为我们带来了与之相关的最新消息。</p><p>近期，苹果全球产品营销副总裁 Bob Borchers 接受了 India Today 的采访，并针对一些产品问题进行了回复。</p><p><img src="https://pics0.baidu.com/feed/8435e5dde71190ef286707907054531dfcfa60b8.jpeg@f_auto?token=3c29a4745197240d1fc4ebb55a85bd89" alt=""></p><p>Bob Borchers 表示，在将大部分 Mac 产品都搭载 M 系芯片后，现阶段苹果的「两年计划」还在进行中。</p><p>也就是说，苹果的终极目标是将 Mac 产品线完成全系自研后，将自研芯片扩展至所有苹果产品中，其中自然也包括新款 Mac Pro。</p><p>从这两年的苹果的一系列动作来看，推动 Mac 全面自研化的进程已经接近收官，目前只差 Mac Pro。</p><h3 id="对等组基准指标现已在“App-分析”中发布"><a href="#对等组基准指标现已在“App-分析”中发布" class="headerlink" title="对等组基准指标现已在“App 分析”中发布"></a>对等组基准指标现已在“App 分析”中发布</h3><p>App Store Connect 中的“App 分析”是一款实用的工具，它具备丰富的功能，可帮助你了解和改进你的 App 在 App Store 中的表现。借助与获客率、使用和盈利策略相关的指标，你可以通过“App 分析”监控客户生命周期 (从认知到转化再到留存) 中各个阶段的结果。对等组基准指标会将你 App 的表现与 App Store 中类似的 App 进行比较，从今天开始，你可以使用此功能在有效情境中衡量 App 的表现。现在，你将获得更多见解，更有效地发现业务增长机会。</p><p>对等组基准指标会在整个客户旅程中提供独到且实用的新见解，帮助你更准确地了解 App 在哪些方面表现出色，并找到改进的方向。系统会根据 App 的 App Store 类别、商业模式和下载量将 App 归入不同的对等组中，以确保比较数据的相关性。此外，对等组基准指标使用行业领先的差分隐私技术，提供相关且切实可行的见解，同时确保单个 App 表现的私密性。</p><p>查看新的基准指标数据，然后利用 App Store Connect 中的其他工具来改善转化率、收益、崩溃率和用户留存率。你可以测试产品页上的不同元素以找出最能引起用户共鸣的部分，创建出额外的产品页版本以重点推介特定功能或内容，获得有关 Beta 版 App 的反馈，提供 App 内活动以鼓励参与，等等。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案重新恢复审查。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md" title="SE-0388" target="_blank" rel="noopener">SE-0388</a> <strong>增加 Async[Throwing]Stream.makeStream 方法</strong> 提案正在审查。</p><p>改天建议引入辅助方法来创建 <code>AsyncStream</code> 和 <code>AsyncThrowingStream</code> 实例，使开发者使用起来更加方便。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0389-attached-macros.md" title="SE-0389" target="_blank" rel="noopener">SE-0389</a> <strong>Attached Macros</strong> 提案正在审查。</p><p><code>Attached Macros</code> 是 Swift 中 <code>Macros</code> 愿景的一部分，该提案以 SE-0382 <code>Expression Macros</code> 的思想和动机为基础，涵盖了大量新的用例，将参考该提案以了解 <code>Macros</code> 如何集成到语言中的基本模型。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md" title="SE-0390" target="_blank" rel="noopener">SE-0390</a> <strong>引入 @noncopyable </strong> 提案正在审查。</p><p>该提案引入了 <code>@noncopyable</code> 类型（也称为 <code>move-only</code> 类型）的概念。 <code>@noncopyable</code> 类型的实例始终具有唯一所有权，这与可以自由复制的普通 Swift 类型不同。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0391-package-registry-publish.md" title="SE-0391" target="_blank" rel="noopener">SE-0391</a> <strong>Package Registry 公开发布</strong> 提案正在审查。</p><p><code>Package Registry</code> 公开发布后，可以对外公开可用。 从 Swift 5.7 开始，SwiftPM 支持使用任何实现与 SE-0292 一起提出的服务规范的注册表的依赖项解析和包下载。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 提议<a href="https://forums.swift.org/t/weburl-keyvaluepairs-api/63164" title="包管理器支持自定义宏" target="_blank" rel="noopener">包管理器支持自定义宏</a><br><strong>介绍</strong><br>宏提供了一种通过对输入源代码执行任意句法转换来生成新代码来扩展 Swift 的方法。 一个例子是之前在<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" target="_blank" rel="noopener">SE-0382</a> 中提出的表达式宏。该提案涵盖了如何定义、构建和分发自定义宏作为 Swift 包的一部分。<br><strong>动机</strong><br><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" target="_blank" rel="noopener">SE-0382</a> 和 <a href="https://gist.github.com/DougGregor/4f3ba5f4eadac474ae62eae836328b71" target="_blank" rel="noopener">A Possible Vision for Macros in Swift</a> 涵盖了宏本身的动机，将它们定义为包的一部分将提供一种直接的方式来重用和分发宏作为源代码。<br><strong>提议的解决方案</strong><br>在外部程序中实现的宏可以通过新的宏目标类型声明为包的一部分，定义在 CompilerPluginSupport 库：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Creates a macro target.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///     - name: The name of the macro.</span></span><br><span class="line">    <span class="comment">///     - dependencies: The macro's dependencies.</span></span><br><span class="line">    <span class="comment">///     - path: The path of the macro, relative to the package root.</span></span><br><span class="line">    <span class="comment">///     - exclude: The paths to source and resource files you want to exclude from the macro.</span></span><br><span class="line">    <span class="comment">///     - sources: The source files in the macro.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">macro</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        name: String,</span></span></span><br><span class="line"><span class="function"><span class="params">        dependencies: [Dependency] = [],</span></span></span><br><span class="line"><span class="function"><span class="params">        path: String? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        exclude: [String] = [],</span></span></span><br><span class="line"><span class="function"><span class="params">        sources: [String]? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> -&gt; <span class="type">Target</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似于包插件（SE-0303“包管理器可扩展构建工具”），宏插件被构建为主机的可执行文件（即，运行编译器的地方）。 编译器从构建系统接收到这些可执行文件的路径，并将作为编译过程的一部分按需运行它们。 宏可执行文件可自动用于任何通过包清单传递依赖于它们的目标。<br>包含宏的实现、定义和客户端的最小包如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"><span class="keyword">import</span> CompilerPluginSupport</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">"MacroPackage"</span>,</span><br><span class="line">    targets: [</span><br><span class="line">        .macro(name: <span class="string">"MacroImpl"</span>),</span><br><span class="line">        .target(name: <span class="string">"MacroDef"</span>, dependencies: [<span class="string">"MacroImpl"</span>]),</span><br><span class="line">        .executableTarget(name: <span class="string">"MacroClient"</span>, dependencies: [<span class="string">"MacroDef"</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>宏实现将在类似于 package plugins 的沙盒中执行，防止文件系统和网络访问。 这是一种鼓励宏不依赖于任何状态的实用方法，除了它们被赋予扩展的特定宏扩展节点及其子节点（但不是其父节点），以及宏扩展上下文专门提供的信息。 如果将来宏需要访问其他信息，这将通过扩展宏扩展上下文来实现，这也为编译器提供了一种机制来跟踪宏实际查询的信息。</p><p>2) 新发布<a href="https://forums.swift.org/t/a-few-features-for-vscode-devcontainers-now-available/63485" title="VSCode devContainers 的新功能" target="_blank" rel="noopener">VSCode devContainers 的新功能</a><br>这些新功能它们让我的生活更轻松，所以我将它们添加到可用容器的通用目录中，以支持在 Swift:5.7 及更高版本中使用 .devContainer 设置。 具有三个独立的功能：</p><ul><li>jemalloc - 安装 jemalloc 库（如果你正在探索使用 package-benchmark 1 会很有帮助）</li><li>swiftpm - 安装构建 SwiftPM 所需的 sqlite 和 libsqlite 库</li><li>foundationnetworking - 安装 libcurl-openssl 以支持基础网络</li></ul><p>3) 提问<a href="https://forums.swift.org/t/how-to-measure-the-actual-memory-footprint-of-an-instance-of-a-struct/63474" title="如何测量结构实例的实际内存占用量？" target="_blank" rel="noopener">如何测量结构实例的实际内存占用量？</a><br>MemoryLayout.size(ofValue: theInstance) 但它只返回错误的大小（可能是指针的大小）。<br>将这个问题的范围缩小到仅结构体。例如：测量仅包含结构体的字典结构占用了多少内存。<br>回答：<br>一旦部分“值”没有存储在堆栈中，这个问题也变得没有意义。 如果我说 let newDict = existingDict，占用空间估计函数可能会说它们每个总共有 1024 个字节，因此您可能会得出结论，它们加起来是 2048 个字节。 但事实并非如此，因为 Dictionary 被记录为像这样的简单副本共享存储，直到一个值或另一个值发生变化； 实际总数大约是 1032 字节。 同样，您可以想象在这些字典中还嵌套了其他字典； 如果您修改其中一个顶级词典，将分配新的存储空间，但仍将共享嵌套词典。<br>说“这个值能保持多少内存”绝对是有价值的，但在一种具有无处不在的引用计数（或垃圾收集，就此而言）的语言中，它没有一个简单的答案。</p><p>4) 讨论<a href="https://forums.swift.org/t/why-so-many-expressions/63461" title="为什么有这么多“@”表达式？" target="_blank" rel="noopener">为什么有这么多“@”表达式？</a><br>我不是每天都使用 Swift，因为它实际上是 Apple 专用的语言。<br>所以当我最近回到它时，我发现了两个新问题。<br>使用 Swift 5 编译器编译后运行良好的代码在使用 5.9-dev 编译器构建时无法正确运行。 后者会产生以前不存在的运行时错误。<br>查看一些示例代码，我看到比以前更多的 @ 表达式，例如 @frozen、@State、@stateobject 等。 有没有完整的列表？ 这些都有什么用？ 文档（在其存在的范围内）含糊不清。 这些表达式不会降低代码的可读性吗？<br>回答：<br>一些“@表达式”内置于编译器中，如@available、@propertyWrapper、@dynamicMemberLookup。<br>大多数由 SwiftUI 等库以 Property Wrappers 的形式提供<br>这些表达式不会降低代码的可读性吗？相反，与手卷替代方案相比，它们大大提高了可读性。<br>属性包装器让您可以提取自动应用于获取或设置值的可重用行为（如 JS 2 中的处理程序方法或 Python 1 中的描述符）。<br>例如，每次写入标记为@Published 的属性时，您的 ObservedObject 都会自动发出一个 objectWillChange 事件。 如果 @Published 属性包装器不存在，代码中的 @ 符号就会减少，但您还需要在每次写入属性时执行类似 objectWillChangePublisher.send() 的操作。 这很费力，引入了疯狂的重复和忘记这样做的机会。 在不知不觉中，您会在论坛上看到类似以下的问题：<br>提问者：“为什么当我更改此属性时我的视图没有更新？”<br>回答者：“因为你忘记了 objectWillChangePublisher.send()。”<br>提问者：“为什么框架不能自动为我调用它？”<br>因此，出现了属性包装器。</p><p>5) 提问<a href="https://forums.swift.org/t/how-to-launch-effect-onapper-only-once/63455" title="SwiftUI 如何只启动一次 onApper？" target="_blank" rel="noopener">SwiftUI 如何只启动一次 onApper？</a></p><p>6) 提问<a href="https://forums.swift.org/t/opting-out-of-automatic-foundation-linking-on-macos/63430" title="选择取消 macOS 上的自动 Foundation 链接？" target="_blank" rel="noopener">选择取消 macOS 上的自动 Foundation 链接？</a></p><p>7) GSoC<a href="https://forums.swift.org/t/swift-to-participate-in-gsoc-2023/63441" title="Swift参加GSoC 2023！" target="_blank" rel="noopener">Swift参加GSoC 2023！</a><br>很高兴与大家分享，Swift 将再次参加 Google Summer of Code 3！ 到现在为止，也许您已经看到潜在的参与者开始了一些话题<br>去年，我们设法运行了 5 个很棒且成功的项目。 如果您对它们是什么感到好奇，您可以直接在 Swift 博客 10 上从他们的参与者和导师那里了解相关信息。<br>今年，我们已经收集了一些潜在的项目想法以及他们自愿参与 Swift 网站的导师：Swift.org - GSoC 2023 的项目想法 23。<br>今年我们准备了一个专门针对 GSoC 6 的新论坛类别，因为我们发现虽然有些项目有很好的空间来讨论它（比如服务器类别），但有些项目以前并没有真正的讨论空间（ 之后）他们开始了。 我们仍然鼓励使用 gsoc-2023 标签 2 来标记所有与 gsoc 相关的线程，并且并非所有线程都需要属于这个新类别。 然而，这个类别应该有助于引导讨论，否则没有一个很好的归宿。<br>与往常一样，我们期待听到您的项目想法，并建议在新论坛类别中打开一个主题，描述您的项目想法以及您需要帮助以使其成为现实的领域。 如果某个项目看起来很有吸引力并且有可能在 GSoC 时间框架内实现，我们将尽最大努力为其寻找导师。<br>我们对有助于“Swift 项目”的项目感兴趣，其中包括各个重点领域的各种项目。 以下是一些可能成为 GSoC 项目创意候选者的项目示例：<br>Swift 编译器 2 本身（类型检查器、前端、后端、标准库），项目可以包括改进调试、性能、添加一个小功能，<br>相关包，如 Collections、Async Algorithms、SwiftSyntax、SourceKit-LSP、DocC、Distributed Actor Cluster 等 1，<br>主要由服务器生态系统使用的包，包括为尚未支持的数据库、队列或其他 API 提议新的库，<br>Swift Package Manager 2、Swift 网站、文档或 Swift 的其他部分。<br>您可以在我们的 Swift 博客上回顾去年的成功项目 10 ，了解接受了哪些类型的项目。<br>今年我们还为非 Apple 员工开放了导师角色。 如果您是一位经验丰富的 Swift 贡献者，并且有兴趣作为 GSoC 导师为我们的参与者提供指导，请留意进一步的公告，或使用下面的联系方式与我联系。 这对我们来说是一个新流程，所以我们将看看它是如何运作的，但我们有兴趣向更广泛的 Swift 项目贡献者开放指导。<br>作为 GSoC 体验的一部分，我们也在考虑提供更多机会与其他 Swift 贡献者会面。</p><p>8) GSoC<a href="https://forums.swift.org/t/interested-in-improving-user-experience-with-scripting-in-swift/63478" title="有兴趣使用 Swift 中的脚本来改善用户体验" target="_blank" rel="noopener">有兴趣使用 Swift 中的脚本来改善用户体验</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://swdevnotes.com/swift/2023/use-async-let-to-run-background-tasks-in-parallel-in-swift/" title="Use async let to run background tasks in parallel in Swift" target="_blank" rel="noopener">使用 async let 在 Swift 中并行运行后台任务</a></p><p><strong>摘要：</strong> 本文介绍了如何在后台执行长期运行的任务并保持 UI 响应。<code>async/await</code> 提供了执行异步任务的干净机制。允许并行执行多个后台任务。</p><p><a href="https://swdevnotes.com/swift/2023/how-to-cancel-a-background-task-in-swift/" title="How to cancel a background task in Swift" target="_blank" rel="noopener">如何在 Swift 中取消后台任务</a></p><p><strong>摘要：</strong> Swift 5.5 中引入的 <code>async/await</code> 语法允许以可读的方式编写异步代码。异步编程可以提高应用程序的性能，同时很重要的一点是要取消不需要的任务，以确保暂时不需要的后台任务不会干扰应用程序。本文演示了如何取消任务，并解释了如何自动取消子任务。</p><p><a href="https://sarunw.com/posts/how-to-use-async-await-in-flutter/" title="How to use async/await in Flutter" target="_blank" rel="noopener">如何在 Flutter 中使用 async/await</a></p><p><strong>摘要：</strong> 在本文中展示了一系列异步实现示例，并在最后给出三个组件（<code>Future</code>，<code>async</code> 和 <code>await</code>）的使用说明。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>程序员养生喝什么？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十五期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;一个人真正觉悟的时候，就会去追寻内心世界真正的财富。&lt;strong&gt;Swift社区&lt;/strong&gt;渴望走进你的内心，与你一起拥抱财富！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果高管确认，新品即将上市&lt;/p&gt;
&lt;p&gt;提案：围绕 &lt;code&gt;Macros&lt;/code&gt; 提出多个提案&lt;/p&gt;
&lt;p&gt;Swift 论坛：新发布 VSCode devContainers 的新功能&lt;/p&gt;
&lt;p&gt;推荐博文：使用 &lt;code&gt;async/await&lt;/code&gt; 完成后台任务管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;程序员养生喝什么？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十三期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十三期/</id>
    <published>2023-07-04T07:19:38.000Z</published>
    <updated>2023-07-04T07:26:28.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十四期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>勇敢是即便知道好结局不会每每降临在我们身上，但也依然选择热爱和坚持。<strong>Swift社区</strong>会伴你一起，见证每一刻勇敢的光亮！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及</p><p>Swift 论坛：讨论嵌套泛型的问题</p><p>推荐博文：iOS App 项目优化</p><p><strong>话题讨论：</strong> </p><p>生活中遇到的问题你会使用 chatGTP 寻找答案吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果iPhone-15-Pro硬件细节曝光，广大网友期待USB-C接口迎来普及"><a href="#苹果iPhone-15-Pro硬件细节曝光，广大网友期待USB-C接口迎来普及" class="headerlink" title="苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及"></a>苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及</h3><p>苹果在欧美市场已被多个监管施压放弃Lighting接口改为USB-C接口，最新关于苹果 iPhone 15 Pro硬件细节爆料消息，似乎透露着苹果公司将将在自家产品正式放弃Lighting接口改为 USB-C 接口。从苹果 iPhone 15 Pro 真机图片来看，苹果 iPhone 15 Pro 开始使用USB-C接口。随着安卓手机厂商普遍采用 USB-C 接口，目前来看苹果公司在自家新品上采用 USB-C 接口，也是整个手机行业的大势所趋。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0218%2F2eca6bd0j00rqa52w001id000u000gvm.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt=""></p><p>除此之外，苹果 iPhone 15 Pro 硬件外观部分也更加圆润，同时音量键设计也改为电容式设计，后置摄像头的镜头模组也变得更加凸起，意味着苹果公司在新的 iPhone 15 Pro 机型镜头模组进行了升级。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0218%2Fe1795fd6j00rqa52l000ad000sg00e8m.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt=""></p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0218%2F6f5d7cdaj00rqa52n000sd000sg00e8m.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" alt=""></p><p>总体来说，iPhone 15 Pro 大概率也将是 iPhone 14Pro 升级产品，相较前代机型，在细节部分进行了进一步的优化完善。来源: IT极客世界。</p><h3 id="苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工"><a href="#苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工" class="headerlink" title="苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工"></a>苹果也要“降本增效”？步亚马逊、Meta等公司后尘，大刀砍向员工</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/down/d572ac3a4cab7954fc5bacdf5e12aa1f.jpeg" alt=""></p><p>在亚马逊、微软、谷歌等国际科技巨头们裁员后，苹果也被曝出裁员消息。2 月 17 日，《纽约邮报》援引知情人士报道，苹果公司在过去几天裁减了数百名合同未到期的外包合同工。</p><p>作为全世界最赚钱的公司之一，苹果公司曾在 2022 年公开宣称不会裁员，但将停止招聘。但随着 2022 年四季度不及预期的财报发布后，苹果还是动了裁员的念头。</p><p>据苹果公司发布 10-12 月份的季度业绩显示，其实现总净销售额 1171.54 亿美元，同比下滑 5% ，不仅低于市场预期的 1211.04 亿元，还创造了 2019 财年来首次营收同比下滑。iPhone、Mac、可穿戴设备等业务营收均出现不同程度的下滑，仅iPad业务的营收实现了同比增长。</p><p>为挽救业务，苹果一方面加大促销力度，于 2022 年 9 月开始在中国销售的 iPhone 14 系列，在上市不到半年后即推出“全系降价 600 元- 800 元”的促销活动。搁往年，苹果最新款降价一般都在六七月份。如今，裁员也成为“降本增效”的新选择。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/weburl-keyvaluepairs-api/63164" title="WebURL KeyValuePairs API" target="_blank" rel="noopener">WebURL KeyValuePairs API</a></p><p>为了更容易地从 URL 组件读取/写入键值对，WebURL 0.5.0 将包含一个新的 KeyValuePairs 类型。 当前的 formParams 视图将在下一个次要版本中弃用和删除。</p><p>2) 讨论<a href="https://forums.swift.org/t/partition-the-reflection-metadata-to-runtime-and-debug-categories/63163/1" title="将反射元数据划分为运行时和调试类别" target="_blank" rel="noopener">将反射元数据划分为运行时和调试类别</a></p><p>目前的情况：</p><ul><li>可以完全启用或禁用反射功能。 （中间没有选项）</li><li>当使用 <code>-disable-reflection-metadata</code> 标志禁用时，LLDB 将无法使用反射元数据，从而导致调试功能显着降低。</li><li>启用后，dsymutil 将反射信息从 TEXT 复制到 dSYM 的 DWARF 段，这允许 lldb 稍后发现它。</li><li>通过使用 <code>-enable-reflection-for-debugger-only</code> 标志，LLDB 可以使用反射，但是，它不会链接到 NTD，这将允许链接器通过 dead-stripping 消除它。</li></ul><p>设计：</p><p>快速编译器：</p><ul><li><p>扩展 FieldTypeMetadataBuilder（可能还有其他构建器）并使其可从外部进行配置。</p></li><li><p>在 emitFieldDescriptor 中实例化两个 FieldTypeMetadataBuilder，一个将直接在 _DWARF 中发射全反射，另一个将像往常一样发射反射到 _TEXT 段。 前者将由 -g 系列标志控制，而后者将由反射标志控制。</p></li></ul><p>DSYMUTIL：</p><ul><li>更改 dsymutil，而不是从 TEXT 复制反射，而是将其复制到 DWRAF 段。</li></ul><p>LLDB：</p><ul><li>可能需要更改 LLDB，以教会它在没有提供 DSYM 的情况下进行调试时发现 DWARF 段中的反射。</li></ul><p>3) 讨论<a href="https://forums.swift.org/t/prevent-optimizing-away-public-interfaces-needed-by-an-xcframework-aka-dyld-symbol-not-found/63162" title="防止优化 XCFramework 所需的公共接口（又名 dyld：未找到符号）" target="_blank" rel="noopener">防止优化 XCFramework 所需的公共接口（又名 dyld：未找到符号）</a></p><p>4) 提议<a href="https://forums.swift.org/t/se-0388-convenience-async-throwing-stream-makestream-methods/63139" title="SE-0388：便捷 Async[Throwing]Stream.makeStream 方法" target="_blank" rel="noopener">SE-0388：便捷 Async[Throwing]Stream.makeStream 方法</a></p><p>便捷 Async[Throwing]Stream.makeStream 方法”的审查现在开始，一直持续到 2023 年 2 月 26 日。</p><p>该提案可在此处获得：<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md" target="_blank" rel="noopener">https://github.com/apple/swift-evolution/blob/main/proposals/0388-async-stream-factory.md</a></p><p>5) 讨论<a href="https://forums.swift.org/t/swift-devcontainer-template/63161" title="Swift 开发容器模板" target="_blank" rel="noopener">Swift 开发容器模板</a></p><p><strong>内容大概：</strong></p><p>Visual Studio Code 的优势之一是您可以在 docker 容器内开发项目。 如果你在 macOS 上开发但部署到 Linux，你不再需要在 Linux 上运行你的代码来验证它是否工作，你可以在你的 Mac 上编辑、编译、运行和调试你的项目，在 VS Code 中运行的 docker 容器中。</p><p>到目前为止，您可以通过手动编辑 devcontainer.json 文件或下载由 Microsoft 管理的快速开发模板来定义容器环境。</p><p>由 Microsoft 管理模板意味着在需要对模板进行更改时需要他们的输入（通过 PR 审查），例如添加新版本的 swift。</p><p>最近这种情况发生了变化，Swift devcontainer 模板的责任已转移到 SSWG。 devcontainer 现在存储在 swift-server GitHub 组织中。</p><p>我们做的第一件事是使模板现代化。 我们用等效的 devcontainer common-utils 功能替换了原始模板具有的 shell 脚本。 您可以在此处找到有关 <code>devcontainer</code> 功能的更多信息。原始模板有一个安装 Node.js 的选项（在大多数模板中实现的标准 MS）。 这已被删除，因为现在可以通过 devcontainer 功能完成。</p><p><strong>新的 devcontainer GitHub链接</strong>：<a href="https://github.com/swift-server/swift-devcontainer-template" target="_blank" rel="noopener">https://github.com/swift-server/swift-devcontainer-template</a></p><p>6) 提问<a href="https://forums.swift.org/t/nested-generic-trouble/63152" title="嵌套泛型的问题" target="_blank" rel="noopener">嵌套泛型的问题</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>: <span class="title">P</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>&lt;T: P&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(type(of: value)) <span class="comment">// S</span></span><br><span class="line">    <span class="built_in">print</span>(value) <span class="comment">// S()</span></span><br><span class="line">    bar(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">(<span class="number">_</span> value: S)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"S call"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span>&lt;T: P&gt;<span class="params">(<span class="number">_</span> value: T)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"P call"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="type">S</span>()</span><br><span class="line">    bar(s) <span class="comment">// S call</span></span><br><span class="line">    foo(s) <span class="comment">// P call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calling bar 直接打印出预期的“S call”，但通过“foo”调用它会打印出意外的“P call”。我的期望是错误的？<br>有趣的是它在 C++ 中按预期工作。</p><p>7) 提议<a href="https://forums.swift.org/t/swift-async-algorithms-proposal-buffer/63155" title="Swift 异步算法提案：缓冲区" target="_blank" rel="noopener">Swift 异步算法提案：缓冲区</a></p><p><strong>介绍：</strong></p><p>缓冲是一种通过临时存储元素来平衡生产和消耗率波动来平衡供需的技术。 <code>AsyncStream</code> 通过允许您控制缓冲区的大小和处理超过该大小的元素的策略来促进此过程。 但是，这种方法可能并不适合所有情况，并且它不提供一种方法来调整其他 <code>AsyncSequence</code> 类型以合并缓冲。</p><p>该提案提出了一种新类型，可以满足这些更高级的要求，并为异步序列中的缓冲提供全面的解决方案。</p><p>8) 提议<a href="https://forums.swift.org/t/pitch-custom-actor-executors/63135" title="自定义 Actor 执行器" target="_blank" rel="noopener">自定义 Actor 执行器</a></p><p><strong>介绍：</strong></p><p>该提案侧重于使 actor 执行程序可由库作者或最终用户配置的最小可行部分。 它基于 <code>@John_McCall</code> 的自定义执行器 16 的早期草案，我们在 Swift 并发性首次引入时分享了该草案，但我们从未正式确定它引入的想法。</p><p>在过去的几年里，我们发现了什么有效，什么需要更多的思考。 该提案侧重于标准化基本的 <code>SerialExecutor</code> 机制以及参与者如何自定义他们想要运行任务的位置。 我们也承认之前提出的未来工作领域，我们不打算在本提案中一次解决所有这些问题； 请参阅“未来方向”部分以了解更多信息。 有趣的是，这个 API 的某些部分被默默地引入并融入了 Swift 并发的 ABI——在适用的情况下，我们解释了这些关系以及我们如何使提议的 API 满足那些现有的要求。</p><p>这个推介也与最近推介的 <code>unsafeAssumeMainActor</code> 想法有一点关系，因为它打开了共享同一个串行执行器的各种参与者的领域，并引入了基于此的断言。</p><p><strong>附上 GitHub 链接</strong>：<a href="https://github.com/ktoso/swift-evolution/blob/wip-custom-executors/proposals/nnnn-custom-actor-executors.md" target="_blank" rel="noopener">https://github.com/ktoso/swift-evolution/blob/wip-custom-executors/proposals/nnnn-custom-actor-executors.md</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7197970175478464571" title="百度 APP iOS 端内存优化-原理篇" target="_blank" rel="noopener">百度 APP iOS 端内存优化-原理篇</a></p><p><strong>摘要：</strong> 本文介绍了 Mach 虚拟内存的特点、内存管理的数据结构以及 Mach 内核提供的内存操作接口，同时对 OC 内存分配核心函数 alloc 做了源码分析。</p><p><a href="https://juejin.cn/post/7185083491061596219/" title="iOS 包体积优化3 - 代码管理" target="_blank" rel="noopener">iOS 包体积优化3 - 代码管理</a></p><p><strong>摘要：</strong> 本文是 iOS 包体积优化的系列文章中代码管理模块，主要讲述了如何做好项目中的代码管理工作。</p><p><a href="https://juejin.cn/post/7185101900303728695" title="iOS 包体积优化5 - 编译优化" target="_blank" rel="noopener">iOS 包体积优化5 - 编译优化</a></p><p><strong>摘要：</strong> 本文是 iOS 包体积优化的系列文章中编译优化模块，介绍了多种项目实战所用到的编译优化方法。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>生活中遇到的问题你会使用 chatGTP 寻找答案吗？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十四期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;勇敢是即便知道好结局不会每每降临在我们身上，但也依然选择热爱和坚持。&lt;strong&gt;Swift社区&lt;/strong&gt;会伴你一起，见证每一刻勇敢的光亮！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果iPhone 15 Pro硬件细节曝光，广大网友期待USB-C接口迎来普及&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论嵌套泛型的问题&lt;/p&gt;
&lt;p&gt;推荐博文：iOS App 项目优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;生活中遇到的问题你会使用 chatGTP 寻找答案吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十二期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十二期/</id>
    <published>2023-07-04T07:19:30.000Z</published>
    <updated>2023-07-04T07:25:41.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十三期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>渺小不可怕，可怕的是比你优秀的强者还比你更加努力。<strong>Swift社区</strong>不会辜负每一位努力的勇士，优秀终将与你不期而遇！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：因iPhone销量下降 苹果利润2016年以来首次低于预期</p><p>提案：新年开始多个提案状态发生变化</p><p>Swift 论坛：讨论如何设置需要异步初始化的静态变量</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="因-iPhone-销量下降，苹果利润-2016-年以来首次低于预期"><a href="#因-iPhone-销量下降，苹果利润-2016-年以来首次低于预期" class="headerlink" title="因 iPhone 销量下降，苹果利润 2016 年以来首次低于预期"></a>因 iPhone 销量下降，苹果利润 2016 年以来首次低于预期</h3><p>2 月 3 日凌晨，多家美股科技巨头公布财报。苹果 2023 财年 Q1 净利润录得 299 亿美元，低于市场预期，原因是 iPhone 的供应出现问题，导致销售疲软。苹果当季销售额下降 5% ，至 1172 亿美元，全球各地的销售额均出现下滑。除服务和 ipad 以外，所有产品类别的销售额都有所下降。这是自 2016 年以来苹果首次未能达到华尔街的利润预期。不过，苹果CEO库克在最新业绩会上表示，中国市场的需求已经有非常好的复苏，去年 12 月和 11 月相比市场确实发生了很大变化。库克还表示，苹果将很快在印度开设第一批零售店。</p><h3 id="App-和-App-内购买项目即将实行税率和价格调整"><a href="#App-和-App-内购买项目即将实行税率和价格调整" class="headerlink" title="App 和 App 内购买项目即将实行税率和价格调整"></a>App 和 App 内购买项目即将实行税率和价格调整</h3><p>App Store 的交易和支付机制旨在帮助您在覆盖全球的 175 个国家和地区的商店中，以 45 种货币为您的产品和服务便捷地进行定价与销售。我们会根据税款和外币汇率变化，定期在相关地区的 App Store 更新定价。相关调整将根据金融数据机构提供的公开汇率信息进行，以此确保 App 和 App 内购买内容的定价在所有商店中保持平衡。</p><p>2023 年 2 月 13 日起，哥伦比亚、埃及、匈牙利、尼日利亚、挪威、南非和英国 App Store 的 App 及 App 内购买项目 (自动续期订阅除外) 的价格将上调。由于乌兹别克斯坦的增值税率从 15% 下调至 12%，该地区的价格亦将相应下调。您的收益将随之进行调整，并会根据不含税的价格来进行计算。</p><p>虽然爱尔兰、卢森堡、新加坡和津巴布韦 App Store 的价格不会改变，但您的收益将进行调整以反映以下税率调整：</p><p>爱尔兰：电子报纸和期刊的增值税率从 9% 下调至 0%<br>卢森堡：增值税率从 17% 下调至 16%<br>新加坡：商品和服务税率从 7% 上调至 8%<br>津巴布韦：增值税率从 14.5% 上调至 15%<br>此外，在柬埔寨、吉尔吉斯斯坦、印度尼西亚、新加坡、韩国、塔吉克斯坦、泰国和乌兹别克斯坦销售产品和服务的当地开发者的收益将在一月底前相应增加。</p><p>Apple 在计算抽成之前会根据您提供的税务类别信息估算并移除相关税费。《付费 App 协议》的附录 B 亦将更新以反映此调整。</p><p>以上调整生效后，在“我的 App”中“价格与销售范围”部分会随即更新。一如既往，您可以随时在 App Store Connect 中更改您的 App 和 App 内购买项目的价格 (包括自动续期订阅)。如果您有提供订阅项目，您可以选择为现有订阅者保留当前价格。</p><p>正如我们此前所宣布，从 2023 年春季起，App 和 App 内购买项目的定价功能升级将带来 700 个新增的价格点；我们还将提供针对全球不同地区更加灵活的价格设定，您将能够不受全球均衡价格的影响，自由管理外币汇率变化。</p><h3 id="Ask-Apple-Q-amp-A-和调查表"><a href="#Ask-Apple-Q-amp-A-和调查表" class="headerlink" title="Ask Apple Q&amp;A 和调查表"></a>Ask Apple Q&amp;A 和调查表</h3><p><img src="https://devimages-cdn.apple.com/wwdc-services/articles/images/5A13BEF0-31D6-466B-B88B-8484635BEA2A/2048.jpeg" alt=""></p><p>感谢大家参与 10 月、11 月和 12 月举办的三场精彩的 Ask Apple 活动周。Ask Apple 参与者仍可以根据需要访问并查阅 Slack 中的 Q&amp;A。</p><p>我们非常希望获得您的反馈，如果您尚未与我们分享您的 Q&amp;A 体验，恳请完成我们的简短调查表。只需几分钟时间即可完成，并且您的回答将被匿名处理。</p><p>我们期待不久之后能再次与您沟通交流。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过审查的提案"><a href="#通过审查的提案" class="headerlink" title="通过审查的提案"></a>通过审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0384-importing-forward-declared-objc-interfaces-and-protocols.md" title="SE-0384" target="_blank" rel="noopener">SE-0384</a> <strong>导入已声明的 Objective-C 接口和协议</strong> 提案通过审查。该提案已在 <strong>二十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0383-deprecate-uiapplicationmain-and-nsapplicationmain.md" title="SE-0383" target="_blank" rel="noopener">SE-0383</a> <strong>弃用 @UIApplicationMain 和 @NSApplicationMain</strong> 提案通过审查。该提案已在 <strong>二十一期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0381-task-group-discard-results.md" title="SE-0381" target="_blank" rel="noopener">SE-0381</a> <strong>DiscardingTaskGroups</strong> 提案通过审查。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0380-if-switch-expressions.md" title="SE-0380" target="_blank" rel="noopener">SE-0380</a> <strong>if 和 switch 表达式</strong> 提案通过审查。该提案已在 <strong>十九期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0378-package-registry-auth.md" title="SE-0378" target="_blank" rel="noopener">SE-0378</a> <strong>Package 注册表认证</strong> 提案通过审查。该提案已在 <strong>十八期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0377-parameter-ownership-modifiers.md" title="SE-0377" target="_blank" rel="noopener">SE-0377</a> <strong>提出了新的 <code>borrow</code> 和 <code>take</code> 参数修饰符</strong> 提案通过审查。该提案已在 <strong>十六期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="驳回的提案"><a href="#驳回的提案" class="headerlink" title="驳回的提案"></a>驳回的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案被驳回。该提案已在 <strong>二十期周报</strong> 正在审查的提案模块做了详细介绍。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0379-opt-in-reflection-metadata.md" title="SE-0379" target="_blank" rel="noopener">SE-0379</a> <strong>Swift 选择加入 Reflection 元数据</strong> 提案被驳回。该提案已在 <strong>十九期周报</strong> 正在审查的提案模块做了详细介绍。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0387-cross-compilation-destinations.md" title="SE-0387" target="_blank" rel="noopener">SE-0387</a> <strong>交叉编译项目</strong> 提案正在审查。</p><p><code>Cross-compilation</code> 是一个常见的开发用例。该提案的作者知道已建立的“构建/主机/目标平台”命名惯例，但认为“目标”在构建系统命名中已经具有不同的含义。此外，“平台”本身的定义相当松散。为了避免可能的混淆，我们在这个建议中使用“构建时三元组”和“运行时三元组”术语。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0386-package-access-modifier.md" title="SE-0386" target="_blank" rel="noopener">SE-0386</a> <strong>新的访问修饰符:package</strong> 提案正在审查。</p><p>该提案引入了 <code>package</code> 作为一个新的访问修饰符。目前，要访问另一个模块中的符号，该符号需要声明为 <code>public</code>。但是，<code>public</code> 符号允许从任何模块访问它，无论是在包内还是从包外，有时候这样做不能满足需求。需要一个新的访问修饰符来更好地控制此类符号的可见范围。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0385-custom-reflection-metadata.md" title="SE-0385" target="_blank" rel="noopener">SE-0385</a> <strong>自定义反射元数据</strong> 提案正在审查。</p><p>该提案引入了使用自定义属性将库定义的反射元数据附加到声明中的功能，然后库可以查询这些元数据，以便于将客户端代码选择到库功能中。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论<a href="https://forums.swift.org/t/how-to-set-static-variable-that-requires-async-initialization/62661" title="如何设置需要异步初始化的静态变量" target="_blank" rel="noopener">如何设置需要异步初始化的静态变量</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@globalActor <span class="keyword">public</span> actor <span class="type">ImageDatabase</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="type">ImageDatabase</span> = <span class="type">ImageDatabase</span>() </span><br><span class="line">    <span class="comment">// 'async' call cannot occur in a global variable initializer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> transport : <span class="type">ImageTransportLayer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() async &#123;</span><br><span class="line">           <span class="keyword">self</span>.transport = await <span class="type">ImageTransportLayer</span>()</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">ImageDatabase</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageTransportLayer</span> </span>&#123; &#125; <span class="comment">// CRUD</span></span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong> 可以稍后在应用程序启动序列中手动初始化 <code>ImageTransportLayer</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@globalActor <span class="keyword">public</span> actor <span class="type">ImageDatabase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> shared: <span class="type">ImageDatabase</span> = <span class="type">ImageDatabase</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> transport: <span class="type">ImageTransportLayer</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">initTransport</span><span class="params">()</span></span> async &#123;</span><br><span class="line">        transport = await <span class="type">ImageTransportLayer</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="type">ImageDatabase</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageTransportLayer</span> </span>&#123;&#125; <span class="comment">// CRUD</span></span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    await <span class="type">ImageDatabase</span>.shared.initTransport()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Continue using ImageDatabase.shared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 讨论<a href="https://forums.swift.org/t/swift-5-7-on-macos-catalina-and-a-toolchain-for-macos/62656" title="macOS Catalina 上的 Swift 5.7 和适用于 macOS 的工具链" target="_blank" rel="noopener"> macOS Catalina 上的 Swift 5.7 和适用于 macOS 的工具链</a></p><p>3) 发布<a href="https://forums.swift.org/t/vscode-swift-v1-0-0/62668" title="VSCode Swift v1.0.0" target="_blank" rel="noopener"> VSCode Swift v1.0.0</a></p><p>Swift Visual Studio Code 扩展的 1.0 版已经发布。 它不再处于预览状态。<br>此版本对 v0.10.0 进行了一些小的添加，并修复了一些错误。 更新日志链接：<a href="https://marketplace.visualstudio.com/items/sswg.swift-lang/changelog" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items/sswg.swift-lang/changelog</a></p><p>4) 讨论<a href="https://forums.swift.org/t/asyncsequences-and-cooperative-task-cancellation/62657" title="AsyncSequences 和 cooperative 任务取消" target="_blank" rel="noopener"> AsyncSequences 和 cooperative 任务取消</a></p><p>5) 讨论<a href="https://forums.swift.org/t/property-wrapper-on-a-functions-signature/62660" title="函数签名的属性包装器" target="_blank" rel="noopener">函数签名的属性包装器</a></p><p>6) 提问<a href="https://forums.swift.org/t/integrating-a-function-into-a-struct/62634" title="将函数集成到结构中" target="_blank" rel="noopener">将函数集成到结构中</a></p><p>目标是有一个接受字符串的字段，它下面的文本将打印一条消息，其中包含输入的单词和它包含的字母数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> newWord = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">VStack</span> &#123;</span><br><span class="line">          <span class="type">TextField</span>(<span class="string">"Enter a word"</span>, text: $newWord)</span><br><span class="line">              .frame(height: <span class="number">50</span>)</span><br><span class="line">              .cornerRadius(<span class="number">10</span>)</span><br><span class="line">              .background(.gray.opacity(<span class="number">0.1</span>))</span><br><span class="line">              .padding(.horizontal, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//Text(countLetters(myWord: newWord))</span></span><br><span class="line">          <span class="type">Text</span>(myMessage)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLetters</span><span class="params">(myWord: String)</span></span> -&gt; (<span class="type">String</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myCounter = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> characters = <span class="string">""</span></span><br><span class="line">  <span class="keyword">for</span> letter <span class="keyword">in</span> myWord &#123;</span><br><span class="line">      characters += <span class="string">"<span class="subst">\(letter)</span>"</span></span><br><span class="line">      myCounter += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (characters, myCounter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myWordCount = countLetters(myWord: <span class="string">"Gregory"</span>)</span><br><span class="line"><span class="keyword">var</span> myMessage = <span class="string">"There are <span class="subst">\(myWordCount)</span> letters in the"</span></span><br></pre></td></tr></table></figure><p><strong>解决：</strong> 字符串有一个 <code>.count</code> 属性，可以直接使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  @<span class="type">State</span> <span class="keyword">var</span> text = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      <span class="type">VStack</span> &#123;</span><br><span class="line">          <span class="type">TextField</span>(<span class="string">"Enter a word"</span>, text: $text)</span><br><span class="line">          <span class="type">Text</span>(<span class="string">"There are <span class="subst">\(text.<span class="built_in">count</span>)</span> letters in your word"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7) 发布<a href="https://forums.swift.org/t/released-asyncobjects-2-0/62664" title="AsyncObjects 2.0" target="_blank" rel="noopener"> AsyncObjects 2.0</a></p><p>8) 提议<a href="https://forums.swift.org/t/pitch-add-keypaths-boolean-custom-operators/62626" title="添加 KeyPaths Boolean自定义运算符" target="_blank" rel="noopener">添加 KeyPaths Boolean 自定义运算符</a></p><p><strong>内容大概：</strong></p><p>在<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0249-key-path-literal-function-expressions.md" target="_blank" rel="noopener">SE-0249</a> 引入了在允许 (Root) -&gt; Value 函数的任何地方使用关键路径表达式 \Root.value 的能力。</p><p>现在在各个项目中得到了广泛的使用。<br>在这里试图提议的是为关键路径添加一些新的运算符，以便在尝试对其应用任何逻辑时更容易使用它。</p><p>这里有几个例子：</p><p>假设我们想过滤字典并获取所有为真的值。<br>我们现在可以通过以下方式使用关键路径轻松完成此操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = [<span class="string">"a"</span>: <span class="literal">true</span>, <span class="string">"b"</span>: <span class="literal">true</span>, <span class="string">"c"</span>: <span class="literal">false</span>]</span><br><span class="line"><span class="keyword">let</span> filtered = dict.<span class="built_in">filter</span>(\.value) <span class="comment">// returns ["a": true, "b": true]</span></span><br></pre></td></tr></table></figure><p>但是如果我们想过滤字典中的错误值怎么办？那么现在我们不能使用关键路径，我们需要依赖闭包：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered = dict.<span class="built_in">filter</span> &#123; !$<span class="number">0</span>.value &#125; <span class="comment">// returns ["c": false]</span></span><br></pre></td></tr></table></figure><p>这里的建议是添加以下运算符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> !&lt;V&gt;<span class="params">(keyPath: KeyPath&lt;V, Bool&gt;)</span></span> -&gt; (<span class="type">V</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    &#123; !$<span class="number">0</span>[keyPath: keyPath]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ==&lt;T, V: Equatable&gt;<span class="params">(lhs: KeyPath&lt;T, V&gt;, rhs: V)</span></span> -&gt; (<span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; $<span class="number">0</span>[keyPath: lhs] == rhs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> !=&lt;T, V: Equatable&gt;<span class="params">(lhs: KeyPath&lt;T, V&gt;, rhs: V)</span></span> -&gt; (<span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; $<span class="number">0</span>[keyPath: lhs] != rhs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将使我们能够按如下方式使用关键路径：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = [<span class="string">"a"</span>: <span class="literal">true</span>, <span class="string">"b"</span>: <span class="literal">true</span>, <span class="string">"c"</span>: <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filtered = dict.<span class="built_in">filter</span>(!\.value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filtered2 = dict.<span class="built_in">filter</span>(\.value == <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十三期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;渺小不可怕，可怕的是比你优秀的强者还比你更加努力。&lt;strong&gt;Swift社区&lt;/strong&gt;不会辜负每一位努力的勇士，优秀终将与你不期而遇！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：因iPhone销量下降 苹果利润2016年以来首次低于预期&lt;/p&gt;
&lt;p&gt;提案：新年开始多个提案状态发生变化&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论如何设置需要异步初始化的静态变量&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十一期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十一期/</id>
    <published>2023-07-04T07:19:17.000Z</published>
    <updated>2023-07-04T07:24:11.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十二期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><p>烟花，如此短暂，却如此的奔放热烈。<strong>Swift社区</strong>，积聚无数力量，却只为给你展现一刹那辉煌！👊👊👊</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：苹果市值两年来首次跌破2万亿美元</p><p>提案：弃用 <code>@UIApplicationMain</code> 和 <code>@NSApplicationMain</code></p><p>Swift 论坛：改变一个属性包装器</p><p>推荐博文：iOS 应用卡顿监控与治理</p><p><strong>话题讨论：</strong> </p><p>您觉得烟花应该被禁止吗？</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果市值两年来首次跌破2万亿美元"><a href="#苹果市值两年来首次跌破2万亿美元" class="headerlink" title="苹果市值两年来首次跌破2万亿美元"></a>苹果市值两年来首次跌破2万亿美元</h3><p>鞭牛士 1 月 4 日消息，据报道，当地时间 1 月 3 日，苹果（AAPL）收报 125.07 美元，跌幅 3.74% ，市值 1.99 万亿美元。市值一夜蒸发 773 亿美元（约 5345 亿元人民币）。</p><p><img src="https://files.mdnice.com/user/17787/2f40682e-f405-4394-9578-ce298cae2821.png" alt=""></p><p>Tech 星球 1 月 4 日消息，据凤凰网科技，在遭遇了去年的大幅下跌后，苹果公司市值本周二继续大幅缩水，自 2021 年 3 月以来首次跌破 2 万亿美元，面临被微软公司超越的风险。而就在一年前，苹果曾成为首家市值触及 3 万亿美元的公司。</p><p>截至周二收盘，苹果股价下跌 3.7% ，至 125.07 美元。此前，法国巴黎银行分析师杰罗姆·拉梅尔(Jerome Ramel)将苹果股票评级从“跑赢大盘”下调至“中性”，并将其目标价从 180 美元下调至 140 美元。拉梅尔还将 iPhone 2023 财年的出货量预期从 2.45 亿部下调至 2.24 亿部，以反映代工商富士康的供应链问题以及消费者削减在高端手机上的支出。</p><p>与此同时，投资者还担心，全球经济放缓和高通胀可能会损害消费者对苹果设备的需求。日本媒体报道称，苹果已经要求供应商减少为其耳机、手表和笔记本电脑生产零部件。</p><p>在经历了周二的下跌后，苹果目前的市值为 1.99 万亿美元，稍稍领先微软，后者的市值约为 1.8 万亿美元。苹果、微软、亚马逊、谷歌母公司 Alphabet 、脸书母公司 Meta 目前在标普 500 指数中的市值占比约为 18% ， 低于 2020 年一度达到的 24% 。</p><h3 id="TrendForce-集邦咨询：疫情影响，2022-年-iPhone-14-系列出货量滑至-7-810-万支"><a href="#TrendForce-集邦咨询：疫情影响，2022-年-iPhone-14-系列出货量滑至-7-810-万支" class="headerlink" title="TrendForce 集邦咨询：疫情影响，2022 年 iPhone 14 系列出货量滑至 7,810 万支"></a>TrendForce 集邦咨询：疫情影响，2022 年 iPhone 14 系列出货量滑至 7,810 万支</h3><p>富士康（Foxconn）郑州厂自 10 月起至今持续受疫情影响，稼动率仍难突破七成，而 10 月底正值苹果（Apple）新机销售的冲刺期，其中 Pro 系列因受市场青睐而持续调升生产比重，使得作为 Apple Pro 系列主力组装厂的富士康备感压力，即便有富士康深圳厂支持生产，但仍缓不济急，故 TrendForce 集邦咨询下调 2022 年 iPhone 14 系列出货量至 7,810 万支。</p><h3 id="富士康独供地位不再，立讯确定将加入-iPhone-15-Pro-Max-生产行列"><a href="#富士康独供地位不再，立讯确定将加入-iPhone-15-Pro-Max-生产行列" class="headerlink" title="富士康独供地位不再，立讯确定将加入 iPhone 15 Pro Max 生产行列"></a>富士康独供地位不再，立讯确定将加入 iPhone 15 Pro Max 生产行列</h3><p>富士康长年稳站 Pro 系列的独家组装，但苹果基于风险控管，原本即有意找寻其他业者加入生产组装行列，并且在 iPhone 14 Pro 系列上试行，富士康由于疫情影响稼动率，这也让立讯精密（Luxshare）成为 iPhone 15 Pro Max 组装供应链行列之一，目前其 iPhone 代工厂仍坐落中国，越南厂则是以苹果周边为主，目前尚无 iPhone 产线规划。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0383-deprecate-uiapplicationmain-and-nsapplicationmain.md" title="SE-0383" target="_blank" rel="noopener">SE-0383</a> <strong>弃用 @UIApplicationMain 和 @NSApplicationMain</strong> 提案正在审查。</p><p><code>@UIApplicationMain</code> 和 <code>@NSApplicationMain</code> 曾经是 iOS 和 macOS 应用程序分别为应用程序声明合成平台特定入口点的标准方式。 这些函数已经被 SE-0281 引入的 <code>@main</code> 属性淘汰了。 这个提议试图在 Swift 6 之前弃用这些可选的入口点属性，从而支持 @main。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0384-importing-forward-declared-objc-interfaces-and-protocols.md" title="SE-0384" target="_blank" rel="noopener">SE-0384</a> <strong>导入已声明的 Objective-C 接口和协议</strong> 提案正在审查。</p><p>该提案主要目的是通过减少对已声明的 Swift API 可见性的负面影响，来提高 Swift 中现有 Objective-C 库的可用性。希望可以用合成占位符类型来表示 Swift 中已声明的 Objective-C 接口和协议。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) 讨论 <a href="https://forums.swift.org/t/se-0384-importing-forward-declared-objective-c-interfaces-and-protocols/62392" title="SE-0384：导入前向声明的 Objective-C 接口和协议" target="_blank" rel="noopener">SE-0384：导入前向声明的 Objective-C 接口和协议</a></p><p>2) 讨论 <a href="https://forums.swift.org/t/design-priorities-for-the-swift-6-language-mode/62408" title="Swift 6 语言模式的设计优先级" target="_blank" rel="noopener">Swift 6 语言模式的设计优先级</a></p><p>Swift 6 重点领域</p><p>Swift 语言工作组确定了三个重点领域，Swift 的系统改进将取决于源代码不兼容的更改。 涉及 Swift 6 源代码不兼容更改的提案应解决以下多个领域之一：</p><p>默认情况下的数据竞争安全性：默认情况下的数据竞争安全性是对只能在新语言版本中上演的模型的重大转变，但它有很大的回报，因为它使并发程序更容易正确编写。 Swift 6 将需要加强围绕 Sendable 和 actor-isolation 检查的语义，但可能还需要额外的更改或功能来使在该安全模型中工作更容易。</p><p>性能可预测性：Swift 提供了一种富有表现力的相当高级的编程模型，可以抽象掉不必要的细节。 然而，Swift 开发可能会遇到性能“悬崖”，其中一个小的变化可能会导致程序运行时性能意外下降（例如，由于写时复制数据类型的过度复制）或 Swift 工具的性能（ 例如，“表达式太复杂”错误）。Swift 6 可以考虑更改默认语言语义以提高性能可预测性，例如通过调整有关变量生命周期的规则，使某些带有运行时成本的功能选择加入而不是选择退出，或调整类型推断规则以启用 一个性能更好的类型检查器实现。</p><p>包生态系统的可扩展性：Swift 语言和社区的长期健康取决于拥有一个强大的包生态系统。 Swift 语言和包管理器可能需要进行调整，以便更轻松地扩展包生态系统。 例如，Swift 的模块系统可能会得到改进，以限制模块的实现依赖性对其客户端模块的影响，从而使模块和包更能适应变化。</p><p>3) 讨论 <a href="https://forums.swift.org/t/vapor-how-to-get-response-url-using-async-http-vapor-client/62418" title="Vapor：如何使用 async-http / Vapor 客户端获取响应 URL" target="_blank" rel="noopener">Vapor：如何使用 async-http / Vapor 客户端获取响应 URL</a></p><p>4) 讨论 <a href="https://forums.swift.org/t/how-can-i-use-return-values-from-functions-instead-of-using-binding-to-pass-data-between-views/62413" title="如何使用函数的返回值而不是使用@Binding 在视图之间传递数据？" target="_blank" rel="noopener">如何使用函数的返回值而不是使用@Binding 在视图之间传递数据？</a></p><p>5) 提议 <a href="https://forums.swift.org/t/implicit-guarding-self-in-closures/62386" title="在闭包中隐式使用guard self" target="_blank" rel="noopener">在闭包中隐式使用guard self</a></p><p>受 SE-0365 的启发：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [guarded <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    dismiss()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里 guard self 以确保 self（否则返回），这通常在这种情况下使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    dismiss()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6) 讨论 <a href="https://forums.swift.org/t/mutating-a-property-wrapper/62403" title="改变一个属性包装器" target="_blank" rel="noopener">改变一个属性包装器</a></p><p>Property wrapper 一个栗子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">PropertyWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> projectedValue: <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">        _modify &#123; yield &amp;<span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; box.value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; box.value = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> box: <span class="type">Box</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(wrappedValue: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.box = <span class="type">Box</span>(value: wrappedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">needsCopyOnWrite</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        !isKnownUniquelyReferenced(&amp;box)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(value: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span> </span>&#123;</span><br><span class="line">    @<span class="type">PropertyWrapper</span></span><br><span class="line">    <span class="keyword">var</span> property: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> propertyWrapper: <span class="type">PropertyWrapper</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; _property.projectedValue &#125;</span><br><span class="line">        _modify &#123; yield &amp;_property.projectedValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Struct</span>(property: <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.$property.needsCopyOnWrite()) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(s.propertyWrapper.needsCopyOnWrite()) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>7) 讨论 <a href="https://forums.swift.org/t/caveats-of-keeping-task-instance-beyond-its-bodys-execution/62400" title="保持任务实例超出其主体执行的警告？" target="_blank" rel="noopener">保持任务实例超出其主体执行的警告？</a></p><p>8) 讨论 <a href="https://forums.swift.org/t/returned-for-revision-se-0379-opt-in-reflection-metadata/62390" title="SE-0379: Opt-in Reflection Metadata" target="_blank" rel="noopener">SE-0379: Opt-in Reflection Metadata</a></p><p>更改反射生成的默认行为:</p><p>该提案规定，在 Swift 6 语言模式下，反射的默认行为应该成为选择加入。 社区对提案的这一方面反应不一，许多开发人员担心这会对现有代码中普遍使用打印、镜像和其他基于反射的 API 产生影响。 关于支持“按使用量付费”模型和提供丰富的运行时设施之间的紧张关系，有很好的哲学讨论。 该提案建议通过使依赖反射的 API 在其参数中添加 Reflectable 约束来解决这种紧张关系。 然而，对于许多 API 来说，这是一个问题，特别是标准库设施，如打印和相关的字符串化功能，旨在尽最大努力处理任何值。 要求通过潜在的许多 API 层线程化通用约束只是为了添加一些日志记录或 printf 调试将是一个严重的强加。 但是，消除对这些约束的需求会使编译器没有面包屑来帮助开发人员制作所有需要的类型 Reflectable 或 Custom * StringConvertible；开发人员必须通过大量专门测试来发现和修复运行时影响。</p><p>Language Workgroup 还注意到 Swift 项目先前尝试追溯更改运行时行为，特别是 SE-0083，它通过从运行时中删除 Foundation 类型桥接来简化动态转换行为。 当时的核心团队最终拒绝了该提议，因为考虑到该提议的动态性质，他们无法想出一种方法来评估对 Swift 生态系统的影响，并有足够的把握认为该变化不会造成过度破坏。 语言工作组对更改默认反射行为也有类似的担忧； 即使默认更改受语言版本限制，我们希望开发人员采用 Swift 6 以获得静态并发安全和其他更改的好处，并期望他们也审计项目的动态行为以防止意外的反射依赖项将是一个障碍 更新他们的语言版本模式。 如果没有评估更改默认设置对现实世界影响的计划，我们就不会接受这种更改。</p><p>Reflectable 的本质和动态投射支持:</p><p>提案规定 Reflectable 和 Sendable 一样是一个标记协议； 然而，与真正的标记协议不同，约束的存在对运行程序可用的元数据类型具有真正的运行时影响。 此外，与遵循协议不同，反射元数据不能通过其定义模块之外的扩展追溯添加到类型中。 因此，尽管将其作为通用约束是一种很好的语言设计，但将其称为标记协议或协议似乎不太正确。</p><p>该提案还规定，程序员可以通过动态转换查询一个类型是否携带全反射元数据？ 可反射。 如果 Reflectable 是一个标记协议，那么它如何在完全通用的情况下工作还不清楚，因为尽管我们可能静态地将表达式 x 识别为？ 可反射的，不可能将 x 处理为？ T 表示在运行时绑定到 Reflectable 存在类型的泛型类型参数 T。 但是，语言工作组还认为，在新的 Reflection 库中将此功能表达为独立的查询功能可能会更好，这样可以降低它必须与整个动态转换基础结构进行交互的复杂性。</p><p>现在的语言中存在一个非协议泛型约束——AnyObject 约束，只有类和没有见证表的类存在性才能满足。 编译器在内部将其归类为“布局约束”，因为它不需要明确的一致性，但其布局本质上满足约束要求的类型会隐式满足它。 目前还有一些其他布局约束只为优化器实现以允许部分专门化，但其中一些，特别是按位可复制类型的约束，在 C++ 行话中称为“平凡”或“POD”，也可以浮出水面 在语言中。 Reflectable 可能也适合这个系列，因为当编译器设置为发出所有反射元数据时，它不需要明确的“一致性”； 虽然它不是专门针对类型值的布局的约束，但它确实对该类型的元数据布局施加了约束。</p><p>调试器支持:</p><p>需要进一步考虑的实现的一个方面是它与调试器的交互。 LLDB 的 Swift 支持目前严重依赖全反射元数据来提供完整的功能，语言工作组希望看到一个计划来确保调试支持可用</p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7176823567059779639" title="出行iOS用户端卡顿治理实践" target="_blank" rel="noopener">出行iOS用户端卡顿治理实践</a></p><p><strong>摘要：</strong> 这篇文章主要讲解该如何去做好卡顿治理。我们使用APP有时会遇到点击响应迟钝、页面跳转缓慢、滑动列表不流畅、卡死无响应，这些就是卡顿问题，它会影响用户体验，严重时会导致用户的流失，因此卡顿治理是非常重要的。</p><p><a href="https://juejin.cn/post/7176441132447399993" title="58同城iOS包大小治理工具解密" target="_blank" rel="noopener">58同城iOS包大小治理工具解密</a></p><p><strong>摘要：</strong> 本文通过58同城包大小治理的实践经验，来讲解如何解决混编环境下OC/Swift无用类、无用资源、重复资源等检测问题，同时结合业内常见的段迁移、链接时优化(LTO)等多种技术手段，来辅助App进行瘦身。</p><p><a href="https://juejin.cn/post/7181352292673650746" title="iOS卡顿监控探索与实践" target="_blank" rel="noopener">iOS卡顿监控探索与实践</a></p><p><strong>摘要：</strong> 这篇文章主要讲解如何监控卡顿，帮助开发者进一步解决卡顿问题。与用户交互的事件都是在主线程里处理的，但如果主线程无法响应用户的交互就会造成卡顿，卡顿时间比较长是非常影响App的功能和用户体验的，所以这也是一个非常值得重视的问题。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>您觉得烟花应该被禁止吗？</strong></p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十二期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;p&gt;烟花，如此短暂，却如此的奔放热烈。&lt;strong&gt;Swift社区&lt;/strong&gt;，积聚无数力量，却只为给你展现一刹那辉煌！👊👊👊&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：苹果市值两年来首次跌破2万亿美元&lt;/p&gt;
&lt;p&gt;提案：弃用 &lt;code&gt;@UIApplicationMain&lt;/code&gt; 和 &lt;code&gt;@NSApplicationMain&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Swift 论坛：改变一个属性包装器&lt;/p&gt;
&lt;p&gt;推荐博文：iOS 应用卡顿监控与治理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;您觉得烟花应该被禁止吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 第二十期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第二十期/</id>
    <published>2023-07-04T07:18:55.000Z</published>
    <updated>2023-07-04T07:23:12.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本期是 Swift 编辑组自主整理周报的第十一期</strong>，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。</p><p>Swift 周报在 <a href="https://github.com/SwiftCommunityRes/SwiftWeekly" title="SwiftWeekly" target="_blank" rel="noopener">GitHub 开源</a>，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。</p><blockquote><p><strong>周报精选</strong></p><p>新闻和社区：部分 iPhone 14 Pro / Max 被爆开机闪现水平线</p><p>提案：<code>DiscardingTaskGroups</code> 提案正在审查</p><p>Swift 论坛：讨论修改 SE-0368 以删除前缀 <code>+</code> 运算符</p><p>推荐博文：SwiftUI 的优势、劣势和缺陷</p><p><strong>话题讨论：</strong> </p><p>疫情放开，你处于什么阶段</p></blockquote><a id="more"></a><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="部分-iPhone-14-Pro-Max-被爆开机闪现水平线"><a href="#部分-iPhone-14-Pro-Max-被爆开机闪现水平线" class="headerlink" title="部分 iPhone 14 Pro / Max 被爆开机闪现水平线"></a>部分 iPhone 14 Pro / Max 被爆开机闪现水平线</h3><p>一些 iPhone 14 Pro 和 iPhone 14 Pro Max 用户报告说，当设备被打开时，iPhone 显示屏上闪烁着水平线，但没有明确的原因或如何修复它。</p><p>在 Reddit 的主题帖子中，数十名 iPhone 14 Pro 用户报告说，当设备被打开时，一条或多条绿色和黄色的线条可能会在屏幕上闪烁，几秒钟后消失。根据这些用户的说法，苹果支持部门已经通知他们，该问题不是硬件缺陷造成的，而是 iOS 16 的错误 Bug。</p><p><img src="https://files.mdnice.com/user/17787/ce2b2a90-fc9c-4b44-8a32-13231e4e9198.png" alt=""></p><h3 id="iOS-16-2-不能升级-Home-应用架构"><a href="#iOS-16-2-不能升级-Home-应用架构" class="headerlink" title="iOS 16.2 不能升级 Home 应用架构"></a>iOS 16.2 不能升级 Home 应用架构</h3><p>苹果已取消 iOS 16.2 升级到新 Home 家庭架构的选项，iOS 16.2 和 macOS Ventura 13.1 的主要新功能之一是能够升级到新的 Home 家庭应用架构。虽然苹果没有分享具体的变化细节，但表示，该升级为 HomeKit 配件提供了“更好的性能和可靠性”。</p><p><img src="https://files.mdnice.com/user/17787/b9c275dc-da92-405e-b108-cdd13178785e.png" alt=""></p><h3 id="AppleWatch-或可无创测血压"><a href="#AppleWatch-或可无创测血压" class="headerlink" title="AppleWatch 或可无创测血压"></a>AppleWatch 或可无创测血压</h3><p>Apple Watch 无创测血压功能即将到来，苹果正积极积累相关技术。IT 之家 12 月 23 日消息，知情人士在今年 4 月透露，苹果计划在 Apple Watch 中添加血压监测功能，但由于遇到障碍，该项技术预计最早要到 2024 年才能推出。苹果目前也在积极地积累技术支持，美国商标和专利局（USPTO）公示了一项新的苹果专利（专利号 US 20220400959），涉及获取和分析无创血压测量数据的系统和方法。</p><p><img src="https://files.mdnice.com/user/17787/3edae191-378a-48a6-9031-ff6b8ad169d7.png" alt=""></p><h3 id="iPhone15-系列将继续采用高通5G基带芯片"><a href="#iPhone15-系列将继续采用高通5G基带芯片" class="headerlink" title="iPhone15 系列将继续采用高通5G基带芯片"></a>iPhone15 系列将继续采用高通5G基带芯片</h3><p>苹果 iPhone 15 系列将采用高通骁龙 X70 5G 基带芯，根据 DigiTimes 报道，苹果 iPhone 15 系列将继续采用高通 5G 调制解调器（基带芯片），因为苹果公司仍在继续开发自有的 5G 定制芯片。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0381-task-group-discard-results.md" title="SE-0381" target="_blank" rel="noopener">SE-0381</a> <strong>DiscardingTaskGroups</strong> 提案正在审查。</p><p>该提案建议为 <code>TaskGroup</code> 和 <code>ThrowingTaskGroup</code> 引入一个新的布尔参数 <code>discardResults</code>。此参数将控制 <code>TaskGroup</code> 是保留其已完成子任务的结果，然后确定是传递给 <code>next()</code>，还是立即丢弃。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md" title="SE-0382" target="_blank" rel="noopener">SE-0382</a> <strong>Expression Macros</strong> 提案正在审查。</p><p><code>Expression Macros</code> 提供了一种用新型表达式扩展 Swift 的方法，这些表达式可以对其参数执行任意语法转换以生成新代码。 <code>Expression Macros</code> 使得用以前只有引入新的语言特性才能实现的方式扩展 Swift 成为可能，帮助开发人员构建更具表现力的库并消除无关的样板。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><p>1) Swift to C++ <a href="https://forums.swift.org/t/swift-to-c-incorporating-swift-argument-labels-into-generated-c-function-name/62195" title="将 Swift 参数标签合并到生成的 C++ 函数名中" target="_blank" rel="noopener">将 Swift 参数标签合并到生成的 C++ 函数名中</a></p><p>2) 讨论<a href="https://forums.swift.org/t/how-to-test-long-running-effect-that-sends-actions/62201" title="如何测试发送动作的长时间运行效果？" target="_blank" rel="noopener">如何测试发送动作的长时间运行效果？</a></p><p>3) 议案 <a href="https://forums.swift.org/t/pitch-result-builder-scoped-unqualified-lookup/62190" title="[Pitch] 结果构建器范围内的不合格查找" target="_blank" rel="noopener">[Pitch] 结果构建器范围内的不合格查找</a></p><p><strong>介绍:</strong></p><p>结果构建器为定义声明式 DSL 提供了基础——特定领域的语言提供了在特定领域工作的定制语法，例如生成图表或文本处理。 利用结果构建器的复杂 DSL API 遇到了设计可扩展性和类型检查性能方面的问题，引入了需要解决的关键挑战。 </p><p>扩展结果构建器以支持在其主体内进行范围内的非限定名称查找，即特定于构建器类型的范围内名称间距，将启用新的 API 模式，显着降低类型检查的复杂性，同时改善调用站点的美感。</p><p>4) 议案<a href="https://forums.swift.org/t/pitch-amend-se-0368-to-remove-prefix-operator/62173" title="修改 SE-0368 以删除前缀 + 运算符" target="_blank" rel="noopener">修改 SE-0368 以删除前缀 + 运算符</a></p><p>内容:<a href="https://forums.swift.org/t/se-0368-staticbigint/59421" title="SE-0368" target="_blank" rel="noopener">SE-0368</a>包括对 <code>StaticBigInt</code> 的以下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns the given value unchanged.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="number">_</span> rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br></pre></td></tr></table></figure><p>这被包括在内，以便前缀 + 可以作为文字前缀包含在上下文中，在这些上下文中，值需要是 <code>StaticBigInt</code> 类型，而不是另一种类型的文字，以便与 - 对称：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signs: [<span class="type">StaticBigInt</span>] = [-<span class="number">1</span>, <span class="number">0</span>, +<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>事实证明，这是一个源代码的突破性变化，因为有如下示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Int</span> = <span class="number">7</span></span><br><span class="line"><span class="keyword">let</span> b = +<span class="number">1</span>     <span class="comment">// Inferred as `StaticBigInt` because concrete `+` beats</span></span><br><span class="line">               <span class="comment">// the generic one on `AdditiveArithmetic`</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a + b  <span class="comment">// Error: Cannot convert `b` from `StaticBigInt` to `Int`</span></span><br></pre></td></tr></table></figure><p>之前，<code>b</code> 被赋予了 <code>Int</code> 类型，这个例子编译正确。建议修改 <code>SE-0368</code> 以删除此运算符。 这对于想要使用 <code>StaticBigInt</code> 值的代码来说是一个小小的不便，但是不存在这样的代码，因为 5.7 中不存在该类型。</p><p>这样的代码可以省略前导 + 作为解决方法。</p><p>一旦解决了源中断问题，我们就可以调查其他选项以在空闲时恢复所需的语法。</p><p>5) 讨论 <a href="https://forums.swift.org/t/no-such-file-errors-with-argumentparser-package/62183" title="ArgumentParser 包出现 no such file 错误" target="_blank" rel="noopener">ArgumentParser 包出现 no such file 错误</a></p><p>6) 讨论<a href="https://forums.swift.org/t/how-can-i-print-https-url-params-and-body/62153" title="如何打印 HTTPS URL 参数和正文" target="_blank" rel="noopener">如何打印 HTTPS URL 参数和正文</a></p><p>7) 提议 <a href="https://forums.swift.org/t/pitch-better-result-success-failure-guard-evaluation/62158" title="&lt;Success, Failure&gt; Guard Evaluation 会更好" target="_blank" rel="noopener"><success, failure=""> Guard Evaluation 会更好</success,></a></p><p>内容:</p><p>在 <code>SE-0235</code> 中将结果类型引入标准语言是我在构建库时最喜欢的功能之一。 当返回的 Result 用户想要评估时，通常看起来有点像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result:  <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getResult()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">  <span class="comment">// Do something with the data here</span></span><br><span class="line"><span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">  <span class="comment">// Handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这对大多数情况都很好。 然而，如果我们需要级联多个结果，它会变得有点难看。</p><p><strong>例如：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstResult:  <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getFirstResult()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> firstResult &#123;</span><br><span class="line"><span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">  <span class="keyword">let</span> secondResult: <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getSecondResult(using: data)</span><br><span class="line">  <span class="keyword">switch</span> secondResult &#123;</span><br><span class="line">  <span class="keyword">case</span> .success(<span class="keyword">let</span> secondData):</span><br><span class="line">    <span class="comment">// Do something with secondData</span></span><br><span class="line">  <span class="keyword">case</span> .failure(<span class="keyword">let</span> secondError):</span><br><span class="line">    <span class="comment">// Handle secondError</span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">case</span> .failure(<span class="keyword">let</span> firstError):</span><br><span class="line">  <span class="comment">// Handle firstError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，嵌套切换变得有点沉重。 这常常让我想起嵌套的 if 语句，作为一个“从不嵌套”的人，我通常会在这里求助于 <code>guard</code> 关键字。 我认为 guard 关键字对于评估 Result 类型也非常有用，但是因为它现在有效，但 gaurd 关键字对于 Result type 用起来有问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstResult:  <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getFirstResult()</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">case</span> .success(<span class="keyword">let</span> data) = firstResult <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Handle first error - But no reference to firstError! </span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> secondResult: <span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">MyCustomError</span>&gt; = getSecondResult(using: data)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">case</span> .success(<span class="keyword">let</span> secondData) = secondResult <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Handle second error - But no reference to secondError! </span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如评论所暗示的那样，我没有引用 <code>guard</code> 语句的 <code>else</code> 部分中的错误类型。 据我所知，没有办法使用这种语法并访问返回的错误类型。</p><p>也许有一些方法可以通过扩展 <code>guard</code> 语句或更新 <code>Result</code> 类型来实现此功能？</p><p>所以这就是为什么我要提出这个建议。我不是确定能百分百修复。甚至不确定这是对语言的有用更改还是其他 Swift 用户想要的东西。让我们在这里讨论一下！</p><p>8) 讨论 <a href="https://forums.swift.org/t/are-we-allowed-to-overload-a-property-or-not/62167" title="Swift 是否允许重载属性" target="_blank" rel="noopener">Swift 是否允许重载属性</a></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><a href="https://juejin.cn/post/7140825514108780580" title="2021 年的 SwiftUI: 优势、劣势和缺陷" target="_blank" rel="noopener">2021 年的 SwiftUI: 优势、劣势和缺陷</a></p><p><strong>摘要：</strong> 这篇文章主要目的是帮助你理解 SwiftUI 的利弊，这样你可以就 SwiftUI 是否适合下一个项目做出更明智的决定。</p><p><a href="https://juejin.cn/post/7175051294808211512" title="用 SwiftUI 实现 AI 聊天对话 app - iChatGPT" target="_blank" rel="noopener">用 SwiftUI 实现 AI 聊天对话 app - iChatGPT</a></p><p><strong>摘要：</strong> 关于 ChatGPT 的话题，大家都不陌生，我们直入话题，因为 ChatGPT 目前限制中国访问服务，所以如果直接使用 ChatGPT 网页进行对话，还是不太方便。通过 ChatGPT SessionToken 就可以不限制网络访问，所以大家发挥想象力实现各种的聊天机器人、小程序，而原生 app 可能体验更好</p><p><a href="https://mp.weixin.qq.com/s/fgHkd_EFPkNwG3G3KPq92w" target="_blank" rel="noopener">SwiftUI 布局协议 - Part 2</a></p><p><strong>摘要：</strong> 在 Part 1 我们探索了布局协议的基础知识，为理解布局是如何工作的打下了坚实的基础。现在，是时候深入研究那些更少提及的功能了，以及如何使用它们来为我们带来便利。</p><h2 id="话题讨论"><a href="#话题讨论" class="headerlink" title="话题讨论"></a>话题讨论</h2><p><strong>疫情放开，你处于什么阶段</strong></p><p>123</p><p>欢迎在文末留言参与讨论。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的各种交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a> 文章中外引链接较多，可以点击 <strong>阅读原文</strong> 更加方便阅读。</p><h2 id="关于我们-1"><a href="#关于我们-1" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本期是 Swift 编辑组自主整理周报的第十一期&lt;/strong&gt;，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。&lt;/p&gt;
&lt;p&gt;Swift 周报在 &lt;a href=&quot;https://github.com/SwiftCommunityRes/SwiftWeekly&quot; title=&quot;SwiftWeekly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 开源&lt;/a&gt;，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;周报精选&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新闻和社区：部分 iPhone 14 Pro / Max 被爆开机闪现水平线&lt;/p&gt;
&lt;p&gt;提案：&lt;code&gt;DiscardingTaskGroups&lt;/code&gt; 提案正在审查&lt;/p&gt;
&lt;p&gt;Swift 论坛：讨论修改 SE-0368 以删除前缀 &lt;code&gt;+&lt;/code&gt; 运算符&lt;/p&gt;
&lt;p&gt;推荐博文：SwiftUI 的优势、劣势和缺陷&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题讨论：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;疫情放开，你处于什么阶段&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
