<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2022-05-30T07:14:29.036Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决使用 AVAudioRecorder 录音保存 .WAV 文件遇到的问题</title>
    <link href="https://fanbaoying.github.io/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8-AVAudioRecorder-%E5%BD%95%E9%9F%B3%E4%BF%9D%E5%AD%98-WAV-%E6%96%87%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://fanbaoying.github.io/解决使用-AVAudioRecorder-录音保存-WAV-文件遇到的问题/</id>
    <published>2022-05-30T07:13:57.000Z</published>
    <updated>2022-05-30T07:14:29.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>App 实现录音保存音频文件，并实现本地语音识别匹配功能。</p><p>通过网络请求上传通过语音匹配的音频文件。</p><p>服务器接收到文件并进行语音识别，使用的是第三方微软语音识别，只支持 <code>PCM</code> 数据源的 <code>WAV</code> 格式。</p><p>本地识别没有任何问题，上传到服务器的文件无法识别，微软库直接报错。猜测上传的音频个是问题，导致的问题。</p><h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> *)getAudioSetting &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dicM=[<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//设置录音格式</span></span><br><span class="line">    [dicM setObject:@(kAudioFormatLinearPCM) forKey:<span class="built_in">AVFormatIDKey</span>];</span><br><span class="line">    <span class="comment">//设置录音采样率，8000是电话采样率，对于一般录音已经够了</span></span><br><span class="line">    [dicM setObject:@(<span class="number">16000</span>) forKey:<span class="built_in">AVSampleRateKey</span>];</span><br><span class="line">    <span class="comment">//设置通道,这里采用单声道 1 2</span></span><br><span class="line">    [dicM setObject:@(<span class="number">2</span>) forKey:<span class="built_in">AVNumberOfChannelsKey</span>];</span><br><span class="line">    <span class="comment">//每个采样点位数,分为8、16、24、32</span></span><br><span class="line">    [dicM setObject:@(<span class="number">16</span>) forKey:<span class="built_in">AVLinearPCMBitDepthKey</span>];</span><br><span class="line">    <span class="comment">//是否使用浮点数采样</span></span><br><span class="line">    [dicM setObject:@(<span class="literal">NO</span>) forKey:<span class="built_in">AVLinearPCMIsFloatKey</span>];</span><br><span class="line">    <span class="comment">//....其他设置等</span></span><br><span class="line">    <span class="keyword">return</span> dicM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有使用微软语音识别库之前，使用上面的代码没有任何问题。识别库更新之后，不识别上传的的音频文件。</p><p>一开始以为是因为没有使用浮点数采样导致音频文件被压缩。修改后依然没有解决问题。</p><p>经过和服务器的联调，发现 .wav 音频文件的头不信息服务区无法识别。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>当音频文件保存为 <code>.wav</code> 格式的时候，<code>iOS11</code> 以下的系统，<code>.wav</code> 文件的头部信息是没问题，但是在 <code>iOS11+</code> <code>.wav</code> 文件的头部信息服务区识别不了。</p><p>需要设置 <code>AVAudioFileTypeKey</code> 来解决这个问题。代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> *)getAudioSetting &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dicM=[<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//设置录音格式</span></span><br><span class="line">    [dicM setObject:@(kAudioFormatLinearPCM) forKey:<span class="built_in">AVFormatIDKey</span>];</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        [dicM setObject:@(kAudioFileWAVEType) forKey:<span class="built_in">AVAudioFileTypeKey</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置录音采样率，8000是电话采样率，对于一般录音已经够了</span></span><br><span class="line">    [dicM setObject:@(<span class="number">16000</span>) forKey:<span class="built_in">AVSampleRateKey</span>];</span><br><span class="line">    <span class="comment">//设置通道,这里采用单声道 1 2</span></span><br><span class="line">    [dicM setObject:@(<span class="number">2</span>) forKey:<span class="built_in">AVNumberOfChannelsKey</span>];</span><br><span class="line">    <span class="comment">//每个采样点位数,分为8、16、24、32</span></span><br><span class="line">    [dicM setObject:@(<span class="number">16</span>) forKey:<span class="built_in">AVLinearPCMBitDepthKey</span>];</span><br><span class="line">    <span class="comment">//是否使用浮点数采样</span></span><br><span class="line">    [dicM setObject:@(<span class="literal">NO</span>) forKey:<span class="built_in">AVLinearPCMIsFloatKey</span>];</span><br><span class="line">    <span class="comment">//....其他设置等</span></span><br><span class="line">    <span class="keyword">return</span> dicM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;App 实现录音保存音频文件，并实现本地语音识别匹配功能。&lt;/p&gt;
&lt;p&gt;通过网络请求上传通过语音匹配的音频文件。&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 40 组合总和 II</title>
    <link href="https://fanbaoying.github.io/LeetCode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II/"/>
    <id>https://fanbaoying.github.io/LeetCode-40-组合总和-II/</id>
    <published>2022-05-25T03:36:53.000Z</published>
    <updated>2022-05-25T03:53:10.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 39 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong> 解集不能包含重复的组合。 </p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinationSumII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combinationSum2</span><span class="params">(candidates: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]](), path = [<span class="type">Int</span>]()</span><br><span class="line">        </span><br><span class="line">        dfs(&amp;res, &amp;path, target, candidates.sorted(), <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> res: <span class="keyword">inout</span> [[Int]], <span class="number">_</span> path: <span class="keyword">inout</span> [Int], <span class="number">_</span> target: Int, <span class="number">_</span> candidates: [Int], <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            res.append(<span class="type">Array</span>(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> index..&lt;candidates.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> candidates[i] &lt;= target <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; i != index &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            _dfs(&amp;res, &amp;path, target - candidates[i], candidates, i + <span class="number">1</span>)</span><br><span class="line">            path.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索。</li><li>时间复杂度： O(n^n)</li><li>空间复杂度： O(2^n - 2)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/combination-sum-ii/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 39 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 39 组合总和（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-39-组合总和（Top-100）/</id>
    <published>2022-05-25T03:36:40.000Z</published>
    <updated>2022-05-25T03:53:14.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长)</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 38 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code> 中的每个元素都 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 500</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(<span class="number">_</span> candidates: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> combination = [<span class="type">Int</span>](), combinations = [[<span class="type">Int</span>]]()</span><br><span class="line">        </span><br><span class="line">        dfs(candidates.sorted(), target, <span class="number">0</span>, &amp;combinations, &amp;combination)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> combinations</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> candidates: [Int], <span class="number">_</span> target: Int, <span class="number">_</span> index: Int, <span class="number">_</span> combinations: <span class="keyword">inout</span> [[Int]], <span class="number">_</span> combination: <span class="keyword">inout</span> [Int])</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            combinations.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> index..&lt;candidates.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> candidates[i] &lt;= target <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            combination.append(candidates[i])</span><br><span class="line">            dfs(candidates, target - candidates[i], i, &amp;combinations, &amp;combination)</span><br><span class="line">            combination.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索。</li><li>时间复杂度： O(n^n)</li><li>空间复杂度： O(2^n - 1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/combination-sum/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长)&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 38 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 38 外观数列</title>
    <link href="https://fanbaoying.github.io/LeetCode-38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/"/>
    <id>https://fanbaoying.github.io/LeetCode-38-外观数列/</id>
    <published>2022-05-25T03:36:27.000Z</published>
    <updated>2022-05-25T03:53:18.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 37 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li></ul><p><strong>前五项如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure><p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：这是一个基本样例。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：&quot;1211&quot;</span><br><span class="line">解释：</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = 读 &quot;1&quot; = 一 个 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = 读 &quot;11&quot; = 二 个 1 = &quot;21&quot;</span><br><span class="line">countAndSay(4) = 读 &quot;21&quot; = 一 个 2 + 一 个 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountAndSay</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">let</span> previousStr = countAndSay(n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> currentChar = previousStr.first!, currentCount = <span class="number">0</span>, res = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> (i, char) <span class="keyword">in</span> previousStr.enumerated() &#123; </span><br><span class="line"><span class="keyword">if</span> char == currentChar &#123;</span><br><span class="line">                currentCount += <span class="number">1</span>  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="string">"<span class="subst">\(currentCount)</span><span class="subst">\(currentChar)</span>"</span></span><br><span class="line">                currentCount = <span class="number">1</span></span><br><span class="line">                currentChar = char</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="string">"<span class="subst">\(currentCount)</span><span class="subst">\(currentChar)</span>"</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：递归获取前一个字符串，然后迭代生成当前字符串。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/count-and-say/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 37 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 37 解数独</title>
    <link href="https://fanbaoying.github.io/LeetCode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>https://fanbaoying.github.io/LeetCode-37-解数独/</id>
    <published>2022-05-25T03:36:15.000Z</published>
    <updated>2022-05-25T03:53:24.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 36 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则：</strong></p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p>[图片上传失败…(image-122cc7-1649473296178)]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**输入：board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：true输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</span><br></pre></td></tr></table></figure><p>[图片上传失败…(image-bfd31a-1649473296178)]</p><p><strong>约束条件：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuSolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">solveSudoku</span><span class="params">(<span class="number">_</span> board: <span class="keyword">inout</span> [[Character]])</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> board.<span class="built_in">count</span> != <span class="number">0</span> || board[<span class="number">0</span>].<span class="built_in">count</span> != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        helper(&amp;board)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(<span class="number">_</span> board: <span class="keyword">inout</span> [[Character]])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> m = board.<span class="built_in">count</span>, n = board[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">"."</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="number">1</span>...<span class="number">9</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> isValid(board, i, j, <span class="type">Character</span>(<span class="type">String</span>(num))) &#123;</span><br><span class="line">                            board[i][j] = <span class="type">Character</span>(<span class="type">String</span>(num))</span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span> helper(&amp;board) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                board[i][j] = <span class="string">"."</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(<span class="number">_</span> board: [[Character]], <span class="number">_</span> i: Int, <span class="number">_</span> j: Int, <span class="number">_</span> num: Character)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> m = board.<span class="built_in">count</span>, n = board[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// check row</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][x] == num &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check col</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">if</span> board[y][j] == num &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check square</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> i / <span class="number">3</span> * <span class="number">3</span>..&lt;i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> j / <span class="number">3</span> * <span class="number">3</span>..&lt;j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> board[x][y] == num &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：遍历整个矩阵，尝试用所有可能的情况填满空白，并检查有效性。</li><li>时间复杂度： O(n^4)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/sudoku-solver/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 36 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 36 有效的数独</title>
    <link href="https://fanbaoying.github.io/LeetCode-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>https://fanbaoying.github.io/LeetCode-36-有效的数独/</id>
    <published>2022-05-25T03:36:00.000Z</published>
    <updated>2022-05-25T03:53:27.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 35 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>空白格用 <code>&#39;.&#39;</code> 表示。</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><img src="https://upload-images.jianshu.io/upload_images/2829694-418cd395a699acdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]`` 是一位数字（</code>1-9<code>）或者</code>‘.’`</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidSudoku</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(<span class="number">_</span> board: [[Character]])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> areRowsValid(board) &amp;&amp; areColsValid(board) &amp;&amp; areSubsquaresValid(board)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">areRowsValid</span><span class="params">(<span class="number">_</span> board: [[Character]])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> existingDigits = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;board.<span class="built_in">count</span> &#123;</span><br><span class="line">            existingDigits.removeAll()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;board[<span class="number">0</span>].<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> !isDigitValid(board[i][j], &amp;existingDigits) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">areColsValid</span><span class="params">(<span class="number">_</span> board: [[Character]])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> existingDigits = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;board[<span class="number">0</span>].<span class="built_in">count</span> &#123;</span><br><span class="line">            existingDigits.removeAll()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;board.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> !isDigitValid(board[j][i], &amp;existingDigits) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">areSubsquaresValid</span><span class="params">(<span class="number">_</span> board: [[Character]])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> existingDigits = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: board.<span class="built_in">count</span>, by: <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: board[<span class="number">0</span>].<span class="built_in">count</span>, by: <span class="number">3</span>) &#123;</span><br><span class="line">                existingDigits.removeAll()</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> i..&lt;i + <span class="number">3</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> n <span class="keyword">in</span> j..&lt;j + <span class="number">3</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> !isDigitValid(board[m][n], &amp;existingDigits) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">isDigitValid</span><span class="params">(<span class="number">_</span> digit: Character, <span class="number">_</span> <span class="keyword">set</span>: <span class="keyword">inout</span> Set&lt;Character&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> digit == <span class="string">"."</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">set</span>.<span class="built_in">contains</span>(digit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">set</span>.insert(digit)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：分别检查行、列和单个正方形。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/valid-sudoku/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 35 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 35 搜索插入位置</title>
    <link href="https://fanbaoying.github.io/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://fanbaoying.github.io/LeetCode-35-搜索插入位置/</id>
    <published>2022-05-25T03:35:44.000Z</published>
    <updated>2022-05-25T03:53:31.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 34 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], target = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 为无重复元素的升序排列数组</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchInsertPosition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> mid = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> + <span class="number">1</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">            mid = (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span> + <span class="keyword">left</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[<span class="keyword">right</span>] &lt; target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">right</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="keyword">left</span>] &gt;= target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">left</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：二分搜索，直到剩下两个变量。</li><li>时间复杂度： O(logn)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/search-insert-position/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 34 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 34 在排序数组中查找元素的第一个和最后一个位置（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-34-在排序数组中查找元素的第一个和最后一个位置（Top-100）/</id>
    <published>2022-05-25T03:35:09.000Z</published>
    <updated>2022-05-25T03:53:35.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 33 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p><strong>进阶：</strong></p><ul><li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10^5</code></li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li><li><code>nums</code> 是一个非递减数组</li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchForARange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> !nums.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [searchStartIdx(nums, target), searchEndIdx(nums, target)]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">searchStartIdx</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> + <span class="number">1</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span> + <span class="keyword">left</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">left</span>] == target ? <span class="keyword">left</span> : nums[<span class="keyword">right</span>] == target ? <span class="keyword">right</span> : -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">searchEndIdx</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> + <span class="number">1</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span> + <span class="keyword">left</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">                <span class="keyword">right</span> = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">left</span> = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="keyword">right</span>] == target ? <span class="keyword">right</span> : nums[<span class="keyword">left</span>] == target ? <span class="keyword">left</span> : -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：二分搜索，分别检查左边或右边。</li><li>时间复杂度： O(logn)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 33 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 33 搜索旋转排序数组（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-33-搜索旋转排序数组（Top-100）/</id>
    <published>2022-05-25T03:34:55.000Z</published>
    <updated>2022-05-25T03:53:39.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 32 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><blockquote><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p></blockquote><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> mid = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt;= <span class="keyword">right</span> &#123;</span><br><span class="line">            mid = (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span> + <span class="keyword">left</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= nums[<span class="keyword">left</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target &amp;&amp; target &gt;= nums[<span class="keyword">left</span>] &#123;</span><br><span class="line">                    <span class="keyword">right</span> = mid - <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">left</span> = mid + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[<span class="keyword">right</span>] &#123;</span><br><span class="line">                    <span class="keyword">left</span> = mid + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">right</span> = mid - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：二叉搜索，检查左或右是否排序，然后在部分中搜索。</li><li>时间复杂度： O(logn)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 32 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 32 最长有效括号（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-32-最长有效括号（Top-100）/</id>
    <published>2022-05-25T03:34:36.000Z</published>
    <updated>2022-05-25T03:53:43.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 31 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 3 * 10^4</code></li><li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestValidParentheses</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stack = [<span class="type">Int</span>](), longest = <span class="number">0</span>, start = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i, char) <span class="keyword">in</span> s.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">"("</span> &#123;</span><br><span class="line">                stack.append(i)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> !stack.isEmpty &#123;</span><br><span class="line">                    stack.removeLast()</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> last = stack.last &#123;</span><br><span class="line">                        longest = <span class="built_in">max</span>(longest, i - last)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        longest = <span class="built_in">max</span>(longest, i - start + <span class="number">1</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = i + <span class="number">1</span>   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：将索引推到堆栈中，遇到 “)”。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/longest-valid-parentheses/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 31 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 31 下一个排列 （Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-31-下一个排列-（Top-100）/</id>
    <published>2022-05-25T03:25:58.000Z</published>
    <updated>2022-05-25T03:53:47.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 29 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p><p>例如，<code>arr = [1,2,3]</code>，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code>。</p><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code>。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code>，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须 <strong>原地</strong> 修改，只允许使用额外常数空间。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,5]</span><br><span class="line">输出：[1,5,1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NextPermutation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(<span class="number">_</span> nums: <span class="keyword">inout</span> [Int])</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> violateIndex = findViolate(nums) <span class="keyword">else</span> &#123;</span><br><span class="line">            nums.<span class="built_in">reverse</span>()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap</span>(&amp;nums, violateIndex, findLeastGreater(nums, violateIndex))</span><br><span class="line">        nums = nums[<span class="number">0</span>...violateIndex] + nums[(violateIndex + <span class="number">1</span>)...].reversed()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">findViolate</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..&lt;nums.<span class="built_in">count</span>).reversed() &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">findLeastGreater</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> violateIndex: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> (violateIndex + <span class="number">1</span>..&lt;nums.<span class="built_in">count</span>).reversed() &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[violateIndex] &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">fatalError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">swap</span>&lt;T&gt;<span class="params">(<span class="number">_</span> nums: <span class="keyword">inout</span> [T], <span class="number">_</span> indexL: Int, <span class="number">_</span> indexR: Int)</span></span> &#123;</span><br><span class="line">        (nums[indexL], nums[indexR]) = (nums[indexR], nums[indexL])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：从右到左遍历数字，将第一个较小的数字替换为最小的更大的数字，然后反转所有数字。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/next-permutation/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 29 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的幻象类型</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E7%9A%84%E5%B9%BB%E8%B1%A1%E7%B1%BB%E5%9E%8B/"/>
    <id>https://fanbaoying.github.io/Swift-中的幻象类型/</id>
    <published>2022-05-25T03:22:44.000Z</published>
    <updated>2022-05-25T03:27:40.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模糊的数据可以说是一般应用程序中最常见的错误和问题的来源之一。虽然 Swift 通过其强大的类型系统和完善的编译器帮助我们避免了许多含糊不清的来源——但只要我们无法在编译时保证某个数据总是符合我们的要求，就总是有风险，我们最终会处于含糊不清或不可预测的状态。</p><p>本周，让我们来看看一种技术，它可以让我们利用 Swift 的类型系统在编译时执行更多种类的数据验证——消除更多潜在的歧义来源，并帮助我们在整个代码库中保持类型安全——通过使用<strong>幻象类型</strong>(<em>phantom types</em>)。</p><a id="more"></a><h2 id="定义良好，但仍然含糊不清"><a href="#定义良好，但仍然含糊不清" class="headerlink" title="定义良好，但仍然含糊不清"></a>定义良好，但仍然含糊不清</h2><p>举个例子，假设我们正在开发一个文本编辑器，虽然它最初只支持纯文本文件——随着时间的推移，我们还增加了对编辑HTML文档的支持，以及PDF预览。</p><p>为了能够尽可能多地重复使用我们原来的文档处理代码，我们继续使用与开始时相同的<code>Document</code>模型——只是现在它获得了一个<code>Format</code>属性，告诉我们正在处理什么样的文档：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Format</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> text</span><br><span class="line">        <span class="keyword">case</span> html</span><br><span class="line">        <span class="keyword">case</span> pdf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> format: <span class="type">Format</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data</span></span><br><span class="line">    <span class="keyword">var</span> modificationDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">var</span> author: <span class="type">Author</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够避免代码重复当然是件好事，而且枚举是当我们在处理一个模型的不同格式或变体时<a href="https://www.swiftbysundell.com/articles/modelling-state-in-swift" target="_blank" rel="noopener">一般情况下建模</a> 的好方法，但是上述那种设置实际上最终会造成相当多的模糊性。</p><p>例如，我们可能有一些API，只有在调用给定格式的文档时才有意义——比如这个打开文本编辑器的函数，它假定任何传入它的<code>Document</code>都是文本文档：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openTextEditor</span><span class="params">(<span class="keyword">for</span> document: Document)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="type">String</span>(decoding: document.data, <span class="keyword">as</span>: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> editor = <span class="type">TextEditor</span>(text: text)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然如果我们不小心将一个HTML文档传递给上述函数并不是世界末日（HTML毕竟只是文本），但试图以这种方式打开一个PDF，很可能会导致呈现出完全无法理解的东西，我们的文本编辑功能将无法工作，我们的应用程序甚至可能最终崩溃。</p><p>我们在编写任何其他特定格式的代码时都会不断遇到同样的问题，例如，如果我们想通过实现一个解析器和一个专门的编辑器来改善编辑HTML文档的用户体验：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openHTMLEditor</span><span class="params">(<span class="keyword">for</span> document: Document)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 就像我们上面用于文本编辑的函数一样，</span></span><br><span class="line">    <span class="comment">// 这个函数假设它总是被传递给HTML文档。</span></span><br><span class="line">    <span class="keyword">let</span> parser = <span class="type">HTMLParser</span>()</span><br><span class="line">    <span class="keyword">let</span> html = parser.parse(document.data)</span><br><span class="line">    <span class="keyword">let</span> editor = <span class="type">HTMLEditor</span>(html: html)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个关于如何解决上述问题的初步想法可能是编写一个包装函数，切换到所传递文档的格式，然后为每种情况打开正确的编辑器。然而，虽然这对文本和HTML文档很有效，但由于PDF文档在我们的应用程序中是不可编辑的——当遇到PDF时，我们将被迫抛出一个错误，触发一个断言，或以<a href="https://www.swiftbysundell.com/articles/picking-the-right-way-of-failing-in-swift" target="_blank" rel="noopener">其他方式失败</a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openEditor</span><span class="params">(<span class="keyword">for</span> document: Document)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> document.format &#123;</span><br><span class="line">    <span class="keyword">case</span> .text:</span><br><span class="line">        openTextEditor(<span class="keyword">for</span>: document)</span><br><span class="line">    <span class="keyword">case</span> .html:</span><br><span class="line">        openHTMLEditor(<span class="keyword">for</span>: document)</span><br><span class="line">    <span class="keyword">case</span> .pdf:</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">"Cannot edit PDF documents"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述情况不是很好，因为它要求我们作为开发者始终跟踪我们在任何给定的代码路径中所处理的文件类型，而我们可能犯的任何错误只能在运行时被发现——编译器根本没有足够的信息可以在编译时进行这种检查。</p><p>因此，尽管我们的 “Document “模型乍一看可能非常优雅和完善，但事实证明，它并不完全是手头情况的正确解决方案。</p><h2 id="看起来我们需要一个协议"><a href="#看起来我们需要一个协议" class="headerlink" title="看起来我们需要一个协议!"></a>看起来我们需要一个协议!</h2><p>解决上述问题的一个方法是把<code>Document</code>变成一个协议，而不是作为一个具体的类型，把它的所有属性（除了<code>format</code>）都作为要求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> modificationDate: <span class="type">Date</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> author: <span class="type">Author</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述变化，我们现在可以为我们的三种文档格式中的每一种实现专门的类型，并让这些类型都符合我们新的文档协议——比如这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TextDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data</span></span><br><span class="line">    <span class="keyword">var</span> modificationDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">var</span> author: <span class="type">Author</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法的好处是，它使我们既能实现可以对任何<code>Document</code>进行操作的通用功能，又能实现只接受某种具体类型的特定API：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以保存任何文件，</span></span><br><span class="line"><span class="comment">// 所以它接受任何符合我们的新文档协议。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(<span class="number">_</span> document: Document)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们现在只能向我们的函数传递文本文件，</span></span><br><span class="line"><span class="comment">// 即打开一个文本编辑器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openTextEditor</span><span class="params">(<span class="keyword">for</span> document: TextDocument)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在上面所做的基本上是将以前在运行时进行的检查转为在编译时进行验证——因为编译器现在能够检查我们是否总是向我们的每个API传递正确格式的文件，这是一个很大的进步。</p><p>然而，通过执行上述改变，我们也<strong>失去了我们最初实现的优点——代码重用</strong>。由于我们现在使用一个协议来表示所有的文档格式，我们将需要为我们的三种文档类型中的每一种编写完全重复的模型实现，以及为我们将来可能增加的任何其他格式提供支持。</p><h2 id="引入幻象类型"><a href="#引入幻象类型" class="headerlink" title="引入幻象类型"></a>引入幻象类型</h2><p>如果我们能找到一种方法，既能为所有格式重用相同的<code>Document</code>模型，又能在编译时验证我们特定格式的代码，岂不妙哉？事实证明，我们之前的一行代码实际上可以给我们一个实现这一目标的提示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="type">String</span>(decoding: document.data, <span class="keyword">as</span>: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p>当把<code>Data</code>转换为<code>String</code>时，就像我们上面做的那样，我们通过传递对该类型本身的引用来传递我们希望字符串被解码的编码——在本例中是UTF8。这真的很有趣。如果我们再深入一点，就会发现 Swift 标准库将我们上面提到的UTF8类型定义为另一个类似命名空间的枚举中的一个无大小写枚举，称为<code>Unicode</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Unicode</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">UTF8</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">UTF8</span> = <span class="type">Unicode</span>.<span class="type">UTF8</span></span><br></pre></td></tr></table></figure><blockquote><p>请注意，如果你看一下<code>UTF8</code>类型的实际实现，它确实包含一个私有case，只是为了向后兼容 Swift 3 而存在。</p></blockquote><p>我们在这里看到的是一种被称为<strong>幻象类型的技术——当类型被用作标记，而不是被实例化来表示值或对象时</strong>。事实上，由于上述枚举都没有任何公开的情况，它们甚至不能被实例化！</p><p>让我们看看是否可以用同样的技术来解决我们的<code>Document</code>困境。我们首先将<code>Document</code>还原成一个结构体，只是这次我们将删除它的<code>format</code>属性（以及相关的枚举），而将它变成一个覆盖任何<code>Format</code>类型的泛型——比如这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Document</span>&lt;<span class="title">Format</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data</span></span><br><span class="line">    <span class="keyword">var</span> modificationDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">var</span> author: <span class="type">Author</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受标准库的<code>Unicode</code>枚举及其各种编码的启发，我们将定义一个类似的枚举——<code>DocumentFormat</code>——作为三个无大小写的枚举的命名空间，每种格式都有一个：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DocumentFormat</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Text</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">HTML</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">PDF</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这里不涉及任何协议——任何类型都可以被用作格式，因为就像<code>String</code>和它的各种编码一样，我们将只使用文档的<code>Format</code>类型作为编译时的标记。这将使我们能够像这样写出我们特定格式的API：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openTextEditor</span><span class="params">(<span class="keyword">for</span> document: Document&lt;DocumentFormat.Text&gt;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openHTMLEditor</span><span class="params">(<span class="keyword">for</span> document: Document&lt;DocumentFormat.HTML&gt;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openPreview</span><span class="params">(<span class="keyword">for</span> document: Document&lt;DocumentFormat.PDF&gt;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们仍然可以编写不需要任何特定格式的通用代码。例如，这里我们可以把之前的<code>save</code>API变成一个完全通用的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">save</span>&lt;F&gt;<span class="params">(<span class="number">_</span> document: Document&lt;F&gt;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，总是输入<code>Document&lt;DocumentFormat.Text&gt;</code>来引用一个文本文档是相当乏味的，所以让我们也使用类型别名为每种格式定义速记。这将给我们提供漂亮的、有语义的名字，而不需要任何重复的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">TextDocument</span> = <span class="type">Document</span>&lt;<span class="type">DocumentFormat</span>.<span class="type">Text</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">HTMLDocument</span> = <span class="type">Document</span>&lt;<span class="type">DocumentFormat</span>.<span class="type">HTML</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">PDFDocument</span> = <span class="type">Document</span>&lt;<span class="type">DocumentFormat</span>.<span class="type">PDF</span>&gt;</span><br></pre></td></tr></table></figure><p>在涉及到特定格式的扩展时，幻象类型也确实大放异彩，现在可以直接使用 Swift 强大的泛型系统和<a href="https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4/" target="_blank" rel="noopener">泛型型约束</a>来实现。例如，我们可以用一个生成<code>NSAttributedString</code>的方法来扩展所有文本文档:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Document</span> <span class="title">where</span> <span class="title">Format</span> == <span class="title">DocumentFormat</span>.<span class="title">Text</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeAttributedString</span><span class="params">(withFont font: UIFont)</span></span> -&gt; <span class="type">NSAttributedString</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> string = <span class="type">String</span>(decoding: data, <span class="keyword">as</span>: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSAttributedString</span>(string: string, attributes: [</span><br><span class="line">            .font: font</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们的幻象类型在最后只是普通的类型——我们也可以让它们遵守协议，并使用这些协议作为泛型约束。例如，我们可以让我们的一些<code>DocumentFormat</code>类型遵守<code>Printable</code>协议，然后我们可以在打印代码中使用这些协议作为约束条件。这里有大量的可能性。</p><h2 id="一个标准的模式"><a href="#一个标准的模式" class="headerlink" title="一个标准的模式"></a>一个标准的模式</h2><p>起初，幻象类型在 Swift 中可能看起来有点 “格格不入”。然而，虽然 Swift 并没有像更多的纯函数式语言（如Haskell）那样为幻象类型提供一流的支持，但在标准库和苹果平台SDK的许多不同地方都可以找到这种模式。</p><p>例如，<code>Foundation</code>的<code>Measurement</code> API使用幻象类型来确保在传递各种测量值时的类型安全——例如度数、长度和重量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meters = <span class="type">Measurement</span>&lt;<span class="type">UnitLength</span>&gt;(value: <span class="number">5</span>, unit: .meters)</span><br><span class="line"><span class="keyword">let</span> degrees = <span class="type">Measurement</span>&lt;<span class="type">UnitAngle</span>&gt;(value: <span class="number">90</span>, unit: .degrees)</span><br></pre></td></tr></table></figure><p>通过使用幻影类型，上述两个测量值不能被混合，因为每个值是哪种单位，都被编码到该值的类型中。这可以防止我们不小心将一个长度传递给一个接受角度的函数，反之亦然——就像我们之前防止文档格式被混淆一样。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用幻象类型是一种非常强大的技术，它可以让我们利用类型系统来验证一个特定值的不同变体。虽然使用幻象类型通常会使API更加冗长，而且确实伴随着泛型的复杂性——当处理不同的格式和变体时，它可以让我们减少对运行时检查的依赖，而让编译器来执行这些检查。</p><p>就像一般的泛型一样，我认为在部署幻象类型之前，首先要仔细评估当前的情况，这很重要。就像我们最初的<code>Document</code>模型并不是手头任务的正确选择，尽管它的结构很好，但如果部署在错误的情况下，幻象类型会使简单的设置变得更加复杂。像往常一样，它归结为为工作选择正确的工具。</p><p>谢谢你的阅读! 🚀</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;模糊的数据可以说是一般应用程序中最常见的错误和问题的来源之一。虽然 Swift 通过其强大的类型系统和完善的编译器帮助我们避免了许多含糊不清的来源——但只要我们无法在编译时保证某个数据总是符合我们的要求，就总是有风险，我们最终会处于含糊不清或不可预测的状态。&lt;/p&gt;
&lt;p&gt;本周，让我们来看看一种技术，它可以让我们利用 Swift 的类型系统在编译时执行更多种类的数据验证——消除更多潜在的歧义来源，并帮助我们在整个代码库中保持类型安全——通过使用&lt;strong&gt;幻象类型&lt;/strong&gt;(&lt;em&gt;phantom types&lt;/em&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 动画进阶 — Part 5：Canvas</title>
    <link href="https://fanbaoying.github.io/SwiftUI-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6-%E2%80%94-Part-5%EF%BC%9ACanvas/"/>
    <id>https://fanbaoying.github.io/SwiftUI-动画进阶-—-Part-5：Canvas/</id>
    <published>2022-04-06T02:31:33.000Z</published>
    <updated>2022-04-06T02:33:15.419Z</updated>
    
    <content type="html"><![CDATA[<p>这个高级SwiftUI动画系列的第五部分将探索Canvas视图。从技术上讲，它不是一个动画视图，但当它与第四部分的 <code>TimelineView</code> 结合时，它带来了很多有趣的可能性，正如这个数字雨的例子所示。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/120523a00d0eae25fce6b66bf2cbd5af.gif" alt=""></p><p>我不得不把这篇文章推迟几周，因为 Canvas 视图有点不稳定。我们仍然处于测试阶段，所以这是可以预期的。然而，该视图产生的崩溃使这里的一些例子无法分享。虽然不是所有的问题都得到了解决，但现在每个例子都能顺利运行。在文章的最后，我将指出我找到的一些解决方法。</p><a id="more"></a><h1 id="一个简单的-Canvas"><a href="#一个简单的-Canvas" class="headerlink" title="一个简单的 Canvas"></a>一个简单的 Canvas</h1><p>简而言之，画布<code>Canvas</code> 是一个 SwiftUI 视图，它从一个渲染闭包中获得绘制指令。与 SwiftUI API 中的大多数闭包不同，它不是一个视图生成器。这意味着我们可以使用 Swift 语言且没有任何限制。</p><p>该闭包接收两个参数：上下文<code>context</code> 和 尺寸<code>size</code>。上下文使用一个新的 SwiftUI 类型 <code>GraphicsContext</code>，它包含了很多方法和属性，可以让我们绘制任何东西。下面是一个关于如何使用 <code>Canvas</code> 的基本例子。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/5f98cc102dc7e6b6fba0ad5fca2c02ac.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> rect = <span class="type">CGRect</span>(origin: .zero, size: size).insetBy(dx: <span class="number">25</span>, dy: <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Path</span></span><br><span class="line">            <span class="keyword">let</span> path = <span class="type">Path</span>(roundedRect: rect, cornerRadius: <span class="number">35.0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Gradient</span></span><br><span class="line">            <span class="keyword">let</span> gradient = <span class="type">Gradient</span>(colors: [.green, .blue])</span><br><span class="line">            <span class="keyword">let</span> from = rect.origin</span><br><span class="line">            <span class="keyword">let</span> to = <span class="type">CGPoint</span>(x: rect.width + from.x, y: rect.height + from.y)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Stroke path</span></span><br><span class="line">            context.stroke(path, with: .color(.blue), lineWidth: <span class="number">25</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Fill path</span></span><br><span class="line">            context.fill(path, with: .linearGradient(gradient,</span><br><span class="line">                                                     startPoint: from,</span><br><span class="line">                                                     endPoint: to))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Canvas</code>初始值设定项还有其他参数（不透明度<code>opaque</code>、颜色模式<code>colorMode</code>和渲染同步<code>rendersAsynchronously</code>）。请参阅<a href="https://developer.apple.com/documentation/swiftui/canvas/init(opaque:colormode:rendersasynchronously:renderer:symbols:" target="_blank" rel="noopener">苹果的文档</a>)以了解更多信息。</p><h1 id="图形上下文-GraphicsContext"><a href="#图形上下文-GraphicsContext" class="headerlink" title="图形上下文 - GraphicsContext"></a>图形上下文 - GraphicsContext</h1><p><code>GraphicsContext</code>有很多方法和属性，但我并不打算把这篇文章作为一个参考，把它们z一一列出。这是一个很长的列表，可能会让人有点不知所措。然而，当我在更新<a href="https://swiftui-lab.com/companion/" target="_blank" rel="noopener">Companion for SwiftUI app</a> 时，我确实不得不去浏览所有这些方法。这让我有了一个整体的想法。我将尝试对现有的东西进行分类，这样你就能得到同样的东西。</p><ul><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#paths" target="_blank" rel="noopener">Drawing Paths</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#images" target="_blank" rel="noopener">Drawing Images and Text</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#symbols" target="_blank" rel="noopener">Drawing Symbols (aka SwiftUI views)</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#mutating" target="_blank" rel="noopener">Mutating the Graphics Context</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#coregraphics" target="_blank" rel="noopener">Reusing CoreGraphics Code</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#animating" target="_blank" rel="noopener">Animating the Canvas</a></li><li><a href="https://swiftui-lab.com/swiftui-animations-part5/#crashes" target="_blank" rel="noopener">Canvas Crashes</a></li></ul><h1 id="路径-Paths"><a href="#路径-Paths" class="headerlink" title="路径 - Paths"></a>路径 - Paths</h1><p>绘制路径的第一件事是创建它。从 SwiftUI 的第一个版本开始，路径可以通过多种方式创建和修改。一些可用的初始化器是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">Path</span>(roundedRect: rect, cornerSize: <span class="type">CGSize</span>(width: <span class="number">10</span>, height: <span class="number">50</span>), style: .continuous)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cgPath = <span class="type">CGPath</span>(ellipseIn: rect, transform: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">let</span> path = <span class="type">Path</span>(cgPath)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">Path</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> points: [<span class="type">CGPoint</span>] = [</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">10</span>, y: <span class="number">10</span>),</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">50</span>),</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">100</span>, y: <span class="number">100</span>),</span><br><span class="line">        .<span class="keyword">init</span>(x: <span class="number">100</span>, y: <span class="number">0</span>),</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    $<span class="number">0</span>.move(to: .zero)</span><br><span class="line">    $<span class="number">0</span>.addLines(points)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径也可以从一个 SwiftUI 形状中创建。<code>Shape</code> 协议有一个路径方法，你可以用它来创建一个 <code>path</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">Circle</span>().path(<span class="keyword">in</span>: rect)</span><br></pre></td></tr></table></figure><p> 当然，这也适用于自定义形状：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">MyCustomShape</span>().path(<span class="keyword">in</span>: rect)</span><br></pre></td></tr></table></figure><h2 id="填充路径"><a href="#填充路径" class="headerlink" title="填充路径"></a>填充路径</h2><p>要填充一个路径，请使用 <code>context.fill()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(<span class="number">_</span> path: <span class="type">Path</span>, with shading: <span class="type">GraphicsContext</span>.<span class="type">Shading</span>, style: <span class="type">FillStyle</span> = <span class="type">FillStyle</span>())</span><br></pre></td></tr></table></figure><p>着色<code>shading</code>表示如何填充形状（用颜色、渐变、平铺图像等）。如果你需要指示要使用的样式，请使用<code>FillStyle</code>类型（即偶数奇数/反义属性）。</p><h2 id="路径描边-Stroke"><a href="#路径描边-Stroke" class="headerlink" title="路径描边 - Stroke"></a>路径描边 - Stroke</h2><p>要描画一个路径，请使用这些<code>GraphicsContext</code>方法中的一个:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stroke(<span class="number">_</span> path: <span class="type">Path</span>, with shading: <span class="type">GraphicsContext</span>.<span class="type">Shading</span>, style: <span class="type">StrokeStyle</span>)</span><br><span class="line">stroke(<span class="number">_</span> path: <span class="type">Path</span>, with shading: <span class="type">GraphicsContext</span>.<span class="type">Shading</span>, lineWidth: <span class="type">CGFloat</span> = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>你可以指定一个<code>shading</code>（颜色、渐变等）来表示如何描画路径。如果你需要指定破折号、线帽、连接等，请使用样式<code>style</code>。另外，你也可以只指定线宽。</p><p>关于如何描边和填充一个形状的完整例子，请看上面的例子（<strong>一个简单的 Canvas</strong>）。</p><h2 id="图片和文本-Image-amp-Text"><a href="#图片和文本-Image-amp-Text" class="headerlink" title="图片和文本 - Image &amp; Text"></a>图片和文本 - Image &amp; Text</h2><p>图像和文本是使用上下文<code>draw()</code>方法绘制的，有两个版本：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">draw(image_or_text, at point: <span class="type">CGPoint</span>, anchor: <span class="type">UnitPoint</span> = .center)</span><br><span class="line">draw(image_or_text, <span class="keyword">in</span> rect: <span class="type">CGRect</span>)</span><br></pre></td></tr></table></figure><p>在图像的情况下，第二个<code>draw()</code>版本有一个额外的可选参数，<code>style</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw(image, <span class="keyword">in</span> rect: <span class="type">CGRect</span>, style: <span class="type">FillStyle</span> = <span class="type">FillStyle</span>())</span><br></pre></td></tr></table></figure><p>在这些元素之一可以被绘制之前，它们必须被解析。通过解析，SwiftUI将考虑到环境（例如，颜色方案、显示分辨率等）。此外，解析这些元素会暴露出一些有趣的属性，这些属性可能会被进一步用于我们的绘制逻辑。例如，解析后的文本会告诉我们指定字体的最终尺寸。或者我们也可以在绘制之前改变已解析元素的阴影。要了解更多关于可用的属性和方法，请查看 <a href="https://developer.apple.com/documentation/swiftui/graphicscontext/resolvedimage" target="_blank" rel="noopener">ResolvedImage</a> 和 <a href="https://developer.apple.com/documentation/swiftui/graphicscontext/resolvedtext" target="_blank" rel="noopener">ResolvedText</a> 。</p><p>使用上下文的<code>resolve()</code>方法从<code>Image</code>中获得<code>ResolvedImage</code>，从<code>Text</code>中获得<code>ResolvedText</code>。</p><p>解析是可选的，<code>draw()</code>方法也接受<code>Image</code>和<code>Text</code>（而不是<code>ResolvedImage</code>和<code>ResolvedText</code>）。在这种情况下，<code>draw()</code>会自动解析它们。如果你对已解析的属性和方法没有任何用途，这很方便。</p><p>在这个例子中，文本被解决了。我们用它的大小来计算渐变，并用着色<code>shading</code>来应用这种渐变：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/555ea370f0cd7dbabeb00b8130629f0c.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> midPoint = <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> font = <span class="type">Font</span>.custom(<span class="string">"Arial Rounded MT Bold"</span>, size: <span class="number">36</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> resolved = context.resolve(<span class="type">Text</span>(<span class="string">"Hello World!"</span>).font(font))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> start = <span class="type">CGPoint</span>(x: (size.width - resolved.measure(<span class="keyword">in</span>: size).width) / <span class="number">2.0</span>, y: <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> end = <span class="type">CGPoint</span>(x: size.width - start.x, y: <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            resolved.shading = .linearGradient(<span class="type">Gradient</span>(colors: [.green, .blue]),</span><br><span class="line">                                               startPoint: start,</span><br><span class="line">                                               endPoint: end)</span><br><span class="line">            </span><br><span class="line">            context.draw(resolved, at: midPoint, anchor: .center)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="符号-Symbols"><a href="#符号-Symbols" class="headerlink" title="符号 - Symbols"></a>符号 - Symbols</h2><p>在谈<code>Canvas</code>时，符号<code>Symbols</code>指的只是任何的 SwiftUI。不要与SF符号相混淆，后者是完全不同的东西。<code>Canvas</code> 视图有一种引用 SwiftUI 视图的方式，将其解析为一个符号，然后绘制它。</p><p>要解决的视图是在<code>ViewBuilder</code>闭包中传递的，如下面的例子所示。为了引用一个视图，它需要被标记为一个唯一的可散列的标识符。请注意，一个被解析的符号可以在<code>Canvas</code>上绘制不止一次。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/25c25b8a2fce3d78473c7971e7ee556e.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> r0 = context.resolveSymbol(id: <span class="number">0</span>)!</span><br><span class="line">            <span class="keyword">let</span> r1 = context.resolveSymbol(id: <span class="number">1</span>)!</span><br><span class="line">            <span class="keyword">let</span> r2 = context.resolveSymbol(id: <span class="number">2</span>)!</span><br><span class="line">            </span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">10</span>, y: <span class="number">10</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r1, at: .<span class="keyword">init</span>(x: <span class="number">30</span>, y: <span class="number">20</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r2, at: .<span class="keyword">init</span>(x: <span class="number">50</span>, y: <span class="number">30</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">70</span>, y: <span class="number">40</span>), anchor: .topLeading)</span><br><span class="line"></span><br><span class="line">        &#125; symbols: &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(.cyan)</span><br><span class="line">                .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                .tag(<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(.blue)</span><br><span class="line">                .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                .tag(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(.indigo)</span><br><span class="line">                .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                .tag(<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ViewBuilder</code>也可以使用一个<code>ForEach</code>。同样的例子可以改写成这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> colors: [<span class="type">Color</span>] = [.cyan, .blue, .indigo]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> r0 = context.resolveSymbol(id: <span class="number">0</span>)!</span><br><span class="line">            <span class="keyword">let</span> r1 = context.resolveSymbol(id: <span class="number">1</span>)!</span><br><span class="line">            <span class="keyword">let</span> r2 = context.resolveSymbol(id: <span class="number">2</span>)!</span><br><span class="line">            </span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">10</span>, y: <span class="number">10</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r1, at: .<span class="keyword">init</span>(x: <span class="number">30</span>, y: <span class="number">20</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r2, at: .<span class="keyword">init</span>(x: <span class="number">50</span>, y: <span class="number">30</span>), anchor: .topLeading)</span><br><span class="line">            context.draw(r0, at: .<span class="keyword">init</span>(x: <span class="number">70</span>, y: <span class="number">40</span>), anchor: .topLeading)</span><br><span class="line"></span><br><span class="line">        &#125; symbols: &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="type">Array</span>(colors.enumerated()), id: \.<span class="number">0</span>) &#123; n, <span class="built_in">c</span> <span class="keyword">in</span></span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10.0</span>).fill(<span class="built_in">c</span>)</span><br><span class="line">                    .frame(width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">                    .tag(n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="符号的动画-Animated-Symbols"><a href="#符号的动画-Animated-Symbols" class="headerlink" title="符号的动画 - Animated Symbols"></a>符号的动画 - Animated Symbols</h2><p>当我测试如果视图作为一个符号被解析为动画，会发生什么时，我感到非常惊喜。你猜怎么着，画布会不断地重绘它以保持动画效果。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/1279412a14866c8db5c9860d2a0522a8.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> symbol = context.resolveSymbol(id: <span class="number">1</span>)!</span><br><span class="line">            </span><br><span class="line">            context.draw(symbol, at: <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">        &#125; symbols: &#123;</span><br><span class="line">            <span class="type">SpinningView</span>()</span><br><span class="line">                .tag(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpinningView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">""</span>)</span><br><span class="line">            .font(.custom(<span class="string">"Arial"</span>, size: <span class="number">72</span>))</span><br><span class="line">            .rotationEffect(.degrees(flag ? <span class="number">0</span> : <span class="number">360</span>))</span><br><span class="line">            .onAppear&#123;</span><br><span class="line">                withAnimation(.linear(duration: <span class="number">1.0</span>).repeatForever(autoreverses: <span class="literal">false</span>)) &#123;</span><br><span class="line">                    flag.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="改变图形上下文"><a href="#改变图形上下文" class="headerlink" title="改变图形上下文"></a>改变图形上下文</h1><p>图形上下文可以被改变，使用以下方法之一：</p><ul><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/addfilter(_:options:" target="_blank" rel="noopener">addFilter</a>?changes=l_7_8_3)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/clip(to:style:options:" target="_blank" rel="noopener">clip</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/cliptolayer(opacity:options:content:" target="_blank" rel="noopener">clipToLayer</a>/)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/concatenate(_:" target="_blank" rel="noopener">concatenate</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/rotate(by:" target="_blank" rel="noopener">rotate</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/scaleby(x:y:" target="_blank" rel="noopener">scaleBy</a>)</li><li><a href="https://developer.apple.com/documentation/swiftui/graphicscontext/translateby(x:y:" target="_blank" rel="noopener">translateBy</a>)</li></ul><p>如果你熟悉 AppKit 的 <code>NSGraphicContext</code> 或 CoreGraphic 的 <code>CGContext</code>，你可能习惯于从堆栈中推送（保存）和弹出（恢复）图形上下文状态。Canvas GraphicsContext 的工作方式有些不同，如果你想对上下文做一个临时的改变，你有好几个选择。</p><p>为了说明这一点，让我们看看下面的例子。我们需要用三种颜色画三座房子。只有中间的房子，需要被模糊化：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/234d739c8d952cad3d383d0f2db9a55a.png" alt=""></p><p>下面的所有例子将使用以下<code>CGPoint</code>扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +<span class="params">(lhs: CGPoint, rhs: CGPoint)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGPoint</span>(x: lhs.x + rhs.x, y: lhs.y + rhs.y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -<span class="params">(lhs: CGPoint, rhs: CGPoint)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGPoint</span>(x: lhs.x - rhs.x, y: lhs.y - rhs.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有三种实现相同结果的方法：</p><h4 id="1、通过对相应操作排序"><a href="#1、通过对相应操作排序" class="headerlink" title="1、通过对相应操作排序"></a>1、通过对相应操作排序</h4><p>在可能的情况下，你可以选择以一种适合你的方式对绘制操作进行排序。在这种情况下，最后绘制模糊的房子，就能解决问题。否则，只要你添加了模糊过滤器，所有的绘制操作都会继续模糊。</p><p>有时这可能是行不通的，即使可以，也可能变成难以阅读的代码。如果是这种情况，请检查其他选项。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// All drawing is done at x4 the size</span></span><br><span class="line">            context.scaleBy(x: <span class="number">4</span>, y: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> midpoint = <span class="type">CGPoint</span>(x: size.width / (<span class="number">2</span> * <span class="number">4</span>), y: size.height / (<span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> house = context.resolve(<span class="type">Image</span>(systemName: <span class="string">"house.fill"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Left house</span></span><br><span class="line">            house.shading = .color(.red)</span><br><span class="line">            context.draw(house, at: midpoint - <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Right house</span></span><br><span class="line">            house.shading = .color(.blue)</span><br><span class="line">            context.draw(house, at: midpoint + <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Center house</span></span><br><span class="line">            context.addFilter(.blur(radius: <span class="number">1.0</span>, options: .dithersResult), options: .linearColor)</span><br><span class="line">            house.shading = .color(.green)</span><br><span class="line">            context.draw(house, at: midpoint, anchor: .center)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、通过拷贝上下文"><a href="#2、通过拷贝上下文" class="headerlink" title="2、通过拷贝上下文"></a>2、通过拷贝上下文</h3><p>由于图形上下文是一个值类型，你可以简单地创建一个副本。在副本上所做的所有改变，都不会影响到原始的上下文。一旦你完成了，你就可以继续在原始（未改变的）上下文上绘图。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// All drawing is done at x4 the size</span></span><br><span class="line">            context.scaleBy(x: <span class="number">4</span>, y: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> midpoint = <span class="type">CGPoint</span>(x: size.width / (<span class="number">2</span> * <span class="number">4</span>), y: size.height / (<span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> house = context.resolve(<span class="type">Image</span>(systemName: <span class="string">"house.fill"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Left house</span></span><br><span class="line">            house.shading = .color(.red)</span><br><span class="line">            context.draw(house, at: midpoint - <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Center house</span></span><br><span class="line">            <span class="keyword">var</span> blurContext = context</span><br><span class="line">            </span><br><span class="line">            blurContext.addFilter(.blur(radius: <span class="number">1.0</span>, options: .dithersResult), options: .linearColor)</span><br><span class="line">            house.shading = .color(.green)</span><br><span class="line">            blurContext.draw(house, at: midpoint, anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Right house</span></span><br><span class="line">            house.shading = .color(.blue)</span><br><span class="line">            context.draw(house, at: midpoint + <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、通过使用图层上下文"><a href="#3、通过使用图层上下文" class="headerlink" title="3、通过使用图层上下文"></a>3、通过使用图层上下文</h3><p>最后，你可以使用 <code>context</code> 的方法： <code>drawLayer</code>。该方法有一个闭包，接收一个你可以使用的上下文的副本。所有对图层上下文的改变都不会影响原始的上下文：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// All drawing is done at x4 the size</span></span><br><span class="line">            context.scaleBy(x: <span class="number">4</span>, y: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> midpoint = <span class="type">CGPoint</span>(x: size.width / (<span class="number">2</span> * <span class="number">4</span>), y: size.height / (<span class="number">2</span> * <span class="number">4</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> house = context.resolve(<span class="type">Image</span>(systemName: <span class="string">"house.fill"</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Left house</span></span><br><span class="line">            house.shading = .color(.red)</span><br><span class="line">            context.draw(house, at: midpoint - <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Center house</span></span><br><span class="line">            context.drawLayer &#123; layerContext <span class="keyword">in</span></span><br><span class="line">                layerContext.addFilter(.blur(radius: <span class="number">1.0</span>, options: .dithersResult), options: .linearColor)</span><br><span class="line">                house.shading = .color(.green)</span><br><span class="line">                layerContext.draw(house, at: midpoint, anchor: .center)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Right house</span></span><br><span class="line">            house.shading = .color(.blue)</span><br><span class="line">            context.draw(house, at: midpoint + <span class="type">CGPoint</span>(x: house.size.width, y: <span class="number">0</span>), anchor: .center)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重用-CoreGraphics-代码"><a href="#重用-CoreGraphics-代码" class="headerlink" title="重用 CoreGraphics 代码"></a>重用 CoreGraphics 代码</h1><p>如果你已经有使用 <code>CoreGraphics</code> 的绘制代码，你可以使用它。<code>Canvas</code>上下文有一个<code>withCGContext</code>方法，可以在如下这种情况下拯救你：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Canvas</span> &#123; context, size <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            context.withCGContext &#123; cgContext <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// CoreGraphics code here</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="对画布进行动画处理"><a href="#对画布进行动画处理" class="headerlink" title="对画布进行动画处理"></a>对画布进行动画处理</h2><p>通过将<code>Canvas</code>包裹在<code>TimelineView</code>内，我们可以实现一些相当有趣的动画。基本上，每一次时间线的更新，你都有机会绘制一个新的动画帧。</p><p>文章的其余部分假定你已经熟悉<code>TimelineView</code>，但如果你不熟悉，你可以查看本系列的<a href="https://swiftui-lab.com/swiftui-animations-part4/" target="_blank" rel="noopener">第四部分</a>来了解更多。</p><p>在下面的例子中，我们的 <code>Canvas</code> 绘制了一个给定日期的模拟时钟。通过将<code>Canvas</code>放在<code>TimelineView</code>内，并使用时间线更新日期，我们得到了动画时钟。以下屏幕截图的一部分是加速的，以显示分针和时针是如何移动的，否则就不容易观察到效果：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/ef94d171903c01b0297711d9e3d51929.gif" alt=""></p><p>当我们用 <code>Canvas</code> 创建动画时，通常会使用时间线时间表的 <code>.animation</code>。这可以尽可能快地更新，每秒重绘我们的 <code>Canvas</code> 几次。然而，在可能的情况下，我们应该使用 <code>minimumInterval</code> 参数来限制每秒的更新次数。这样对CPU的要求会低一些。例如，在这种情况下，使用<code>.animation</code>和<code>.animation(minimumInterval: 0.06)</code>在视觉上没有明显的区别。然而，在我的测试硬件上，CPU使用率从30%下降到14%。使用更高的最小间隔时间可能开始变得视觉上明显，所以你可能需要做一些错误的试验，以找到最佳值。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/f6a032bc77438cca45f5e308e7f89e8f.gif" alt=""></p><p>为了进一步提高性能，你应该考虑<code>Canvas</code>中是否有一些部分不需要不断重绘。在我们的例子中，只有时钟指针在移动，其他部分保持静止。因此，明智的做法是把它分成两个重叠的画布。一个画除了钟针以外的所有东西（在时间线视图之外），另一个只画钟针，在时间线视图之内。通过实施这一改变，CPU从16%下降到6%。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Clock</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">ClockFaceCanvas</span>()</span><br><span class="line">            </span><br><span class="line">            <span class="type">TimelineView</span>(.animation(minimumInterval: <span class="number">0.06</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">                <span class="type">ClockHandsCanvas</span>(date: timeline.date)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过仔细分析我们的画布，并做了些许改动，我们成功地将CPU的使用率提高到了5倍（从30%降到6%）。顺便说一下，如果你能接受每秒更新的秒针，你将进一步减少CPU的使用，使其低于1%。你应该通过测试来找到最适合你的效果。</p><p>该时钟的完整代码可以在<a href="https://gist.github.com/swiftui-lab/168d8bb3abbe894c9dbbac22fdfdec86" target="_blank" rel="noopener">这里</a>找到。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>一旦我们了解了<code>Canvas</code>，我们可能会想用它来画一切。然而，有时最好的选择是选择做什么和在哪里做。下面这个Matrix Digital Rain动画就是一个很好的例子。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/991bc2c8ebb00060bd77b6345cf290a6.gif" alt=""></p><p>数字雨的完整代码可以在<a href="https://gist.github.com/swiftui-lab/7f13f04e2d103e43685193eec0c33dd5" target="_blank" rel="noopener">这里</a>找到。</p><p>我们来分析一下其中的内容。我们有一列字符出现，字符数量增长，慢慢滑落，最后减少其字符，直到消失。每一列都是用渐变绘制的。还有一种深度感，通过使靠近观察者的柱子滑动得更快和稍大。为了增加效果，柱子越靠后，它就越显得失焦（模糊）。</p><p>在 <code>Canvas</code> 中实现所有这些要求是完全可能的。然而，如果我们把这些任务分割开来（分而治之），任务就会变得容易得多。正如我们在本文的符号的动画部分已经看到的，一个带动画的SwiftUI视图可以通过一个<code>draw()</code>调用被绘制到<code>Canvas</code>中。因此，并不是所有的东西都要在<code>Canvas</code>里面处理。</p><p>每一列都被实现为一个单独的SwiftUI视图。叠加字符和用渐变绘图是由视图处理的。当我们在画布上使用渐变时，起始/结束点或任何其他几何参数都是相对于整个画布的。对于柱状渐变，在视图中实现它比较容易，因为它将相对于视图的原点。</p><p>每一列都有许多参数：位置（x、y、z）、字符、从顶部删除多少个字符，等等。这些值在每次<code>TimelineView</code>更新后都会被变更。</p><p>最后，<code>Canvas</code>负责解析每个视图，在它们的（x，y）位置上绘制，并根据其z值添加模糊和缩放效果。我在代码中添加了一些注释，以帮助你浏览它，如果你有兴趣的话。</p><h1 id="Canvas-崩溃"><a href="#Canvas-崩溃" class="headerlink" title="Canvas 崩溃"></a>Canvas 崩溃</h1><p>不幸的是，在写这篇文章的时候，我遇到了 Canvas 的一些崩溃问题。幸运的是，它们在每个测试版中都有很大的改进。我希望在iOS15正式发布时，它们都能得到解决。这条信息通常是这样的。</p><blockquote><p>-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:]:5252: failed assertion `Draw Errors Validation<br>Fragment Function(primitive_gradient_fragment): argument small[0] from buffer(3) with offset(65460) and length(65536) has space for 76 bytes, but argument has a length(96).</p></blockquote><p>我设法解决了这些崩溃的问题，至少使用了其中一个方法：</p><ul><li>减少绘图量。在数字雨的例子中，你可以减少列的数量。</li><li>使用更简单的渐变。最初，数字雨柱有三个颜色的渐变。当我把它减少到两个时，崩溃就消失了。</li><li>减少更新Canvas的频率。使用较慢的时间轴视图，可以防止崩溃。</li></ul><p>我并不是说你不能使用超过两种颜色的渐变，但这只是你可以考虑的一个地方，如果你发现自己处于Canvas崩溃的情况。如果这还不能解决你的问题，我建议你开始删除绘图操作，直到应用程序不再崩溃。这可以引导你找到导致崩溃的原因。一旦你知道是什么原因，你可以尝试用不同的方法来做。</p><p>如果你遇到这个问题，我鼓励你向苹果公司反馈。如果你愿意，你可以参考我的反馈：FB9363322。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我希望这篇文章能帮助你为你的SwiftUI动画工具箱添加一个新的工具。第五部分的动画系列到此结束。至少在今年……谁知道WWDC’22会带来什么呢!</p><blockquote><p>译自 <a href="https://swiftui-lab.com/" target="_blank" rel="noopener">The SwiftUI Lab</a> 的 <a href="https://swiftui-lab.com/swiftui-animations-part5/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 5: Canvas</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个高级SwiftUI动画系列的第五部分将探索Canvas视图。从技术上讲，它不是一个动画视图，但当它与第四部分的 &lt;code&gt;TimelineView&lt;/code&gt; 结合时，它带来了很多有趣的可能性，正如这个数字雨的例子所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/120523a00d0eae25fce6b66bf2cbd5af.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我不得不把这篇文章推迟几周，因为 Canvas 视图有点不稳定。我们仍然处于测试阶段，所以这是可以预期的。然而，该视图产生的崩溃使这里的一些例子无法分享。虽然不是所有的问题都得到了解决，但现在每个例子都能顺利运行。在文章的最后，我将指出我找到的一些解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画进阶 —— Part4：TimelineView</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6-%E2%80%94%E2%80%94-Part4%EF%BC%9ATimelineView/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画进阶-——-Part4：TimelineView/</id>
    <published>2022-04-06T02:31:24.000Z</published>
    <updated>2022-04-06T02:33:46.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前三篇<a href="https://xiaozhuanlan.com/topic/6089153247" target="_blank" rel="noopener">高级 SwiftUI 动画系列</a>是作者在 WWDC 2021 之前实战总结的内容。对 2021 年 WWDC 介绍的 <code>TimelineView</code> 和 <code>Canvas</code> 感到激动。这开启了一个全新的可能性，笔者将试图在这一部分和下一部分的系列中阐释这些可能性。</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/hello-there-25.gif" alt="" title="Hello There"></p><p>在这篇文章中，我们将详细地探索 <code>TimelineView</code> 。我们将从最常见的用途缓慢开始。然而笔者认为，最大的可能性来自于 <code>TimelineView</code> 和我们已知现有的动画相结合。在其他事物中，通过一点创意，这样的组合将让我们最终实现“关键帧类似”的动画。</p><p>在第 5 部分，我们将探索 <code>Canvas</code> 视图，以及它和我们的新朋友 <code>TimelineView</code> 相结合是如此的优秀。</p><p>上文中展示的动画，是使用本文中介绍的技术创建的。该动画的完整代码可在此 <a href="https://gist.github.com/swiftui-lab/c1d089207d6f7b365729b1af2e695cc4" target="_blank" rel="noopener">gist</a> 中找到。</p><a id="more"></a><h2 id="TimelineView-的组件"><a href="#TimelineView-的组件" class="headerlink" title="TimelineView 的组件"></a>TimelineView 的组件</h2><p><code>TimelineView</code> 是一个容器视图，它以相关调度程序确定的频率重新评估其内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">0.5</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ViewToEvaluatePeriodically</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TimelineView</code> 接收调度程序作为参数。 稍后我们将详细认识它们，现在，上述示例使用每半秒触发一次的调度程序。</p><p>另一个参数是一个内容闭包，它接收一个看起来像这样的 <code>TimelineView.Context</code> 参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cadence: <span class="type">Cadence</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Cadence</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> live</span><br><span class="line">        <span class="keyword">case</span> seconds</span><br><span class="line">        <span class="keyword">case</span> minutes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cadence</code> 是一个枚举类型，我们可以使用它来决定在我们的视图中显示什么。 可能的值是：live、seconds 和 minutes。 以此为提示，避免显示与 <code>Cadence</code> 无关的信息。 典型的例子，是避免在具有秒或分钟节奏的调度程序的时钟上显示毫秒。</p><p>请注意，<code>Cadence</code> 不是你可以更改的东西，而是反映设备状态的东西。文档仅提供了一个例子。 在 watchOS 上，降低手腕时 <code>Cadence</code> 会减慢。 如果你发现了 <code>Cadence</code> 发生变化的其他情况，笔者非常想知道。 请在下方发表评论。</p><p>好吧，这一切看起来都很棒，但是我们应该注意许多微妙之处。 让我们开始构建我们的第一个 <code>TimelineView</code> 动画，看看它们是什么。</p><h2 id="理解-TimelineView-如何工作"><a href="#理解-TimelineView-如何工作" class="headerlink" title="理解 TimelineView 如何工作"></a>理解 TimelineView 如何工作</h2><p>观察下面的代码。 我们有两个随机变化的表情符号。 两者之间的唯一区别是，一个写在内容闭包中，而另一个被放在单独的视图中以提高可读性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ManyFaces</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> emoji = [<span class="string">"😀"</span>, <span class="string">"😬"</span>, <span class="string">"😄"</span>, <span class="string">"🙂"</span>, <span class="string">"😗"</span>, <span class="string">"🤓"</span>, <span class="string">"😏"</span>, <span class="string">"😕"</span>, <span class="string">"😟"</span>, <span class="string">"😎"</span>, <span class="string">"😜"</span>, <span class="string">"😍"</span>, <span class="string">"🤪"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">0.2</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="type">HStack</span>(spacing: <span class="number">120</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> randomEmoji = <span class="type">ManyFaces</span>.emoji.randomElement() ?? <span class="string">""</span></span><br><span class="line">            </span><br><span class="line">                <span class="type">Text</span>(randomEmoji)</span><br><span class="line">                    .font(.largeTitle)</span><br><span class="line">                    .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="type">SubView</span>()</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SubView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> randomEmoji = <span class="type">ManyFaces</span>.emoji.randomElement() ?? <span class="string">""</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(randomEmoji)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们看下运行代码会发生什么：</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/emojis-changing-one.gif" alt="" title="Emoji"></p><p>惊了？ 为什么左边的 emoji 会变，而另一个总是悲伤？ 事实证明， <code>SubView</code> 没有接收到任何变化的参数，这意味着它没有依赖关系。 <code>SwiftUI</code> 没有理由重新计算视图的主体。 2021 年 WWDC 的一个精彩演讲是 <code>Demystify SwiftUI</code>。 它解释了视图标识、生命周期和依赖关系。 所有这些主题对于理解时间线为何如此运行都非常重要。</p><p>为了解决这个问题，我们更改了 <code>SubView</code> 视图以添加一个参数，该参数将随着时间轴的每次更新而改变。 请注意，我们不需要使用参数，它只需要在那里。 尽管如此，我们将看到这个未使用的值稍后会非常有用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span> <span class="comment">// just by declaring it, the view will now be recomputed apropriately.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> randomEmoji = <span class="type">ManyFaces</span>.emoji.randomElement() ?? <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Text</span>(randomEmoji)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>SubView</code> 是这样创建的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SubView</span>(date: timeline.date)</span><br></pre></td></tr></table></figure><p>最后，我们的两个表情都可以体验到情绪的狂飙：</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/emojis-changing-two.gif" alt="" title="Emoji"></p><h2 id="按照时间线执行"><a href="#按照时间线执行" class="headerlink" title="按照时间线执行"></a>按照时间线执行</h2><p>大多数关于 <code>TimelineView</code> 的示例（截至编写本文）通常是关于绘制时钟的。 这就说得通了。 时间线提供的数据毕竟是一个日期类型实例。</p><p>有史以来最简单的 <code>TimelineView</code> 时钟：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">1.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"<span class="subst">\(timeline.date)</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时钟可能会变得更加精致。 例如，使用带有形状的模拟时钟，或使用新的 <code>Canvas</code> 视图绘制时钟。</p><p>但是，<code>TimelineView</code> 不仅仅用于时钟。 在许多情况下，我们希望每次时间线更新我们的视图时，视图处理一些事情。 放置此代码的最佳位置是 <code>onChange(of:perform)</code> 闭包。</p><p>在以下示例中，我们使用此技术每 3 秒更新一次模型。</p><p><img src="https://swiftui-lab.com/wp-content/uploads/2021/06/anim-part4-example-3.gif" alt="" title="Animation"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">3.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">QuipView</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QuipView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        @<span class="type">StateObject</span> <span class="keyword">var</span> quips = <span class="type">QuipDatabase</span>()</span><br><span class="line">        <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"_<span class="subst">\(quips.sentence)</span>_"</span>)</span><br><span class="line">                .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                    quips.<span class="built_in">advance</span>()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuipDatabase</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> sentences = [</span><br><span class="line">        <span class="string">"There are two types of people, those who can extrapolate from incomplete data"</span>,</span><br><span class="line">        <span class="string">"After all is said and done, more is said than done."</span>,</span><br><span class="line">        <span class="string">"Haikus are easy. But sometimes they don't make sense. Refrigerator."</span>,</span><br><span class="line">        <span class="string">"Confidence is the feeling you have before you really understand the problem."</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> sentence: <span class="type">String</span> = <span class="type">QuipDatabase</span>.sentences[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">advance</span><span class="params">()</span></span> &#123;</span><br><span class="line">        idx = (idx + <span class="number">1</span>) % <span class="type">QuipDatabase</span>.sentences.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        sentence = <span class="type">QuipDatabase</span>.sentences[idx]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，每次时间线更新，我们的 <code>QuipView</code> 都会刷新两次。 也就是说，在时间线更新时一次，然后在之后立即再次，因为通过调用 <code>quips.advance()</code> 导致 <code>quips.sentence</code> 的 <code>@Published</code> 值发生变化并触发视图更新。 这很好，但需要注意，因为稍后它会变得更加重要。</p><blockquote><p>我们从中得出的一个重要概念是，尽管时间线可能会产生一定数量的更新，但视图的内容很可能会更新更多次。</p></blockquote><h2 id="TimelineView-与传统动画相结合"><a href="#TimelineView-与传统动画相结合" class="headerlink" title="TimelineView 与传统动画相结合"></a>TimelineView 与传统动画相结合</h2><p>新的 <code>TimelineView</code> 带来了很多新的机会。 正如我们将在以后的文章中看到的那样，将它与 <code>Canvas</code> 结合起来是一个很好的补充。 但为动画的每一帧编写所有代码给了我们带来了很多负担。 笔者将在本节中介绍的技术，使用我们已熟知的动画并且热衷于视图动画从一个时间线更新到下一个时间线。 这最终将让我们在纯 <code>SwiftUI</code> 中创建我们自己的类似关键帧的动画。</p><p>但是让我们慢慢开始，从我们的小项目开始：如下所示的节拍器。 调高音量播放视频，欣赏节拍声如何与钟摆同步。 此外，就像节拍器一样，每隔几拍就会响起一次铃声：</p><p><a href="https://swiftui-lab.com/wp-content/uploads/2021/06/metronome.mp4" target="_blank" rel="noopener">https://swiftui-lab.com/wp-content/uploads/2021/06/metronome.mp4</a></p><p>首先，让我们看看我们的时间线是什么样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Metronome</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> bpm: <span class="type">Double</span> = <span class="number">60</span> <span class="comment">// beats per minute</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">60</span> / bpm)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">MetronomeBack</span>()</span><br><span class="line">                .overlay(<span class="type">MetronomePendulum</span>(bpm: bpm, date: timeline.date))</span><br><span class="line">                .overlay(<span class="type">MetronomeFront</span>(), alignment: .bottom)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节拍器速度通常以 bpm（每分钟节拍数）指定。 该示例使用周期性调度程序，每 60/bpm 秒重复一次。 对于我们的例子，<code>bpm = 60</code>，所以调度程序每 1 秒触发一次。 即每分钟 60 次。</p><p><code>Metronome</code> 视图由三层组成：<code>MetronomeBack</code>、<code>MetronomePendulum</code> 和 <code>MetronomeFront</code>。 它们按此顺序叠加。 每次时间线更新都必须刷新的唯一视图是 <code>MetronomePendulum</code>，它可以左右摆动。 其他视图不会刷新，因为它们没有依赖关系。</p><p>MetronomeBack 和 Metronome Front 的代码非常简单，它们使用了一种称为圆形梯形的自定义形状。 为避免使此页面过长，自定义形状的代码在此 <a href="https://gist.github.com/swiftui-lab/62c3a7512644271e7881985f0b4f7357" target="_blank" rel="noopener">gist</a> 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetronomeBack</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c1 = <span class="type">Color</span>(red: <span class="number">0</span>, green: <span class="number">0.3</span>, blue: <span class="number">0.5</span>, opacity: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> c2 = <span class="type">Color</span>(red: <span class="number">0</span>, green: <span class="number">0.46</span>, blue: <span class="number">0.73</span>, opacity: <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> gradient = <span class="type">LinearGradient</span>(colors: [c1, c2],</span><br><span class="line">                                      startPoint: .topLeading,</span><br><span class="line">                                      endPoint: .bottomTrailing)</span><br><span class="line">        </span><br><span class="line">        <span class="type">RoundedTrapezoid</span>(pct: <span class="number">0.5</span>, cornerSizes: [<span class="type">CGSize</span>(width: <span class="number">15</span>, height: <span class="number">15</span>)])</span><br><span class="line">            .foregroundStyle(gradient)</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">350</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetronomeFront</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">RoundedTrapezoid</span>(pct: <span class="number">0.85</span>, cornerSizes: [.zero, <span class="type">CGSize</span>(width: <span class="number">10</span>, height: <span class="number">10</span>)])</span><br><span class="line">            .foregroundStyle(<span class="type">Color</span>(red: <span class="number">0</span>, green: <span class="number">0.46</span>, blue: <span class="number">0.73</span>, opacity: <span class="number">1</span>))</span><br><span class="line">            .frame(width: <span class="number">180</span>, height: <span class="number">100</span>).padding(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，<code>MetronomePendulum</code> 视图是事情开始变得有趣的地方：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetronomePendulum</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> pendulumOnLeft: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> bellCounter = <span class="number">0</span> <span class="comment">// sound bell every 4 beats</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bpm: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Pendulum</span>(angle: pendulumOnLeft ? -<span class="number">30</span> : <span class="number">30</span>)</span><br><span class="line">            .animation(.easeInOut(duration: <span class="number">60</span> / bpm), value: pendulumOnLeft)</span><br><span class="line">            .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span> beat() &#125;</span><br><span class="line">            .onAppear &#123; beat() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">beat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pendulumOnLeft.toggle() <span class="comment">// triggers the animation</span></span><br><span class="line">        bellCounter = (bellCounter + <span class="number">1</span>) % <span class="number">4</span> <span class="comment">// keeps count of beats, to sound bell every 4th</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sound bell or beat?</span></span><br><span class="line">        <span class="keyword">if</span> bellCounter == <span class="number">0</span> &#123;</span><br><span class="line">            bellSound?.play()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            beatSound?.play()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pendulum</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> angle: <span class="type">Double</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Capsule</span>()</span><br><span class="line">                .fill(.red)</span><br><span class="line">                .frame(width: <span class="number">10</span>, height: <span class="number">320</span>)</span><br><span class="line">                .overlay(weight)</span><br><span class="line">                .rotationEffect(<span class="type">Angle</span>.degrees(angle), anchor: .bottom)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> weight: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>)</span><br><span class="line">                .fill(.orange)</span><br><span class="line">                .frame(width: <span class="number">35</span>, height: <span class="number">35</span>)</span><br><span class="line">                .padding(.bottom, <span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的视图需要跟踪我们在动画中的位置。 我称之为动画阶段。 由于我们需要跟踪这些阶段，我们将使用 <code>@State</code> 变量：</p><ol><li><code>pendulumOnLeft</code>: 跟踪钟摆 <code>Pendulum</code> 摆动的方向。</li><li><code>bellCounter</code>: 记录节拍的数量，以确定是否应该听到节拍或铃声。</li></ol><p>该示例使用 <code>.animation(_:value:)</code> 修饰语。 此版本的修改器，在指定值更改时应用动画。 请注意，也可以使用显式动画。 无需调用 <code>.animation()</code>，只需在 <code>withAnimation</code> 闭包内切换 <code>pendulumOnLeft</code> 变量。</p><p>为了使我们的视图在动画阶段前进，我们使用 <code>onChange(of:perform)</code> 修饰符监视日期的变化，就像我们在前面的 quip 示例中所做的那样。</p><p>除了在每次日期值更改时推进动画阶段，我们还在 <code>onAppear</code> 闭包中执行此操作。 否则，一开始就会有停顿。</p><p>最后一段与 <code>SwiftUI</code> 无关的代码是创建 <code>NSSound</code> 实例。 为了避免使示例过于复杂，笔者创建了几个全局变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bellSound: <span class="type">NSSound</span>? = &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"bell"</span>, withExtension: <span class="string">"mp3"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSSound</span>(contentsOf: url, byReference: <span class="literal">true</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beatSound: <span class="type">NSSound</span>? = &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"beat"</span>, withExtension: <span class="string">"mp3"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSSound</span>(contentsOf: url, byReference: <span class="literal">true</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>如果你需要声音文件，可以到 freesound 下载：<a href="https://freesound.org/" target="_blank" rel="noopener">https://freesound.org/</a></p><p>示例代码中的声音为：</p><ul><li><p>钟声: <a href="https://freesound.org/people/m1rk0/sounds/50071/" target="_blank" rel="noopener">metronome_pling</a> 根据许可证 CC BY 3.0 (m1rk0)</p></li><li><p>节拍声: <a href="https://freesound.org/people/Druminfected/sounds/250552/" target="_blank" rel="noopener">metronome.wav</a> 根据 CC0 1.0 </p></li></ul><h2 id="TimelineScheduler"><a href="#TimelineScheduler" class="headerlink" title="TimelineScheduler"></a>TimelineScheduler</h2><p>正如我们已经看到的，<code>TimelineView</code> 需要一个 <code>TimelineScheduler</code> 来确定何时更新其内容。 <code>SwiftUI</code> 提供了一些预定义的调度器，比如我们使用的那些。 但是，我们也可以创建自己的自定义调度程序。 笔者将在下一节中详细说明。 但让我们从已有的调度器开始。</p><p>时间线调度器基本上是一个采用 <code>TimelineScheduler</code> 协议的结构。 现有的类型有：</p><ul><li><code>AnimationTimelineSchedule</code>： 尽可能快地更新，给你绘制动画每一帧的机会。 它具有让你限制更新频率和暂停更新的参数。 在 <code>TimelineView</code> 与新的 <code>Canvas</code> 视图结合使用时，这将非常有用。</li><li><code>EveryMinuteTimelineSchedule</code>： 顾名思义，它每分钟更新一次，在每分钟开始时更新。</li><li><code>ExplicitTimelineSchedule</code>： 可以提供一个数组，其中包含你希望时间线更新的所有时间。</li><li><code>PeriodicTimelineSchedule</code>： 可以提供开始时间和发生更新的频率。</li></ul><p>尽管你可以以这种方式创建 <code>Timeline</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timeline</span>(<span class="type">EveryMinuteTimelineSchedule</span>()) &#123; timeline <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自 Swift 5.5 和 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0299-extend-generic-static-member-lookup.md" target="_blank" rel="noopener">SE-0299</a> 的引入以来，我们现在已经支持类枚举语法。 这使代码更具可读性并改进了自动完成功能。 建议我们改用这种语法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.everyMinute) &#123; timeline <span class="keyword">in</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：你可能听说过，但今年也引入了样式。 更好的是，对于样式，只要你使用的是 Swift 5.5，你就可以使用以前的版本进行反向部署。</em></p><p>对于每个现有的调度程序，可能有多个类似枚举的选项。 例如，这两行代码创建了 <code>AnimationTimelineSchedule</code> 类型的调度程序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimelineView</span>(.animation) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TimelineView</span>(.animation(minimumInterval: <span class="number">0.3</span>, paused: <span class="literal">false</span>)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>你甚至可以创建属于自己的调度程序（不要忘记 <code>static</code> 关键字）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimelineSchedule</span> <span class="title">where</span> <span class="title">Self</span> == <span class="title">PeriodicTimelineSchedule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> everyFiveSeconds: <span class="type">PeriodicTimelineSchedule</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; .<span class="keyword">init</span>(from: .now, by: <span class="number">5.0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.everyFiveSeconds) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-TimelineScheduler"><a href="#自定义-TimelineScheduler" class="headerlink" title="自定义 TimelineScheduler"></a>自定义 TimelineScheduler</h2><p>如果现有调度程序都不符合你的需求，可以创建自己的调度程序。 思考以下动画： </p><p><img src="https://images.xiaozhuanlan.com/photo/2022/d4c8ee7e28437fd6880043228b366cf7.gif" alt=""></p><p>在这个动画中，我们有一个心形表情符号，它会以不规则的间隔和不规则的幅度改变其比例。<br>它以 1.0 的比例开始，0.2 秒后增长到 1.6，0.2 秒后增长到 2.0，然后缩小到 1.0 并保持 0.4 秒，然后重新开始。 换一种说法：</p><p>尺度变化：1.0 → 1.6 → 2.0 → 重新开始</p><p>变化之间的时间：0.2 → 0.2 → 0.4 → 重新开始</p><p>我们可以创建一个 <code>HeartTimelineSchedule</code>，它完全按照心脏的需要进行更新。 但是以可重用性的名义，让我们做一些更通用的东西，将来可以重用。</p><p>我们新调度程序将被称为：<code>CyclicTimelineSchedule</code>，并将接收一组时间偏移量。 每个偏移值都将相对于数组中的前一个值。 当调度程序用尽偏移量时，它将循环回到数组的开头并重新开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CyclicTimelineSchedule</span>: <span class="title">TimelineSchedule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeOffsets: [<span class="type">TimeInterval</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">entries</span><span class="params">(from startDate: Date, mode: TimelineScheduleMode)</span></span> -&gt; <span class="type">Entries</span> &#123;</span><br><span class="line">        <span class="type">Entries</span>(last: startDate, offsets: timeOffsets)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Entries</span>: <span class="title">Sequence</span>, <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> last: <span class="type">Date</span></span><br><span class="line">        <span class="keyword">let</span> offsets: [<span class="type">TimeInterval</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> idx: <span class="type">Int</span> = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Date</span>? &#123;</span><br><span class="line">            idx = (idx + <span class="number">1</span>) % offsets.<span class="built_in">count</span></span><br><span class="line">            </span><br><span class="line">            last = last.addingTimeInterval(offsets[idx])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> last</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>TimelineSchedule</code> 有几个要求：</p><ul><li>提供 <code>entry(from:mode:)</code> 函数。</li><li>我们 <code>Entries</code> 的类型必须符合 <code>Sequence where Entries.Element == Date</code></li></ul><p>有几种方法可以符合 <code>Sequence</code>。 此示例实现 <code>IteratorProtocol</code> 并声明符合 <code>Sequence</code> 和 <code>IteratorProtocol</code>。 你可以在<a href="https://developer.apple.com/documentation/swift/sequence" target="_blank" rel="noopener">此处</a>阅读有关序列一致性的更多信息。</p><p>对于实现 <code>IteratorProtocol</code> 的 <code>Entries</code>，我们必须编写 <code>next()</code> 函数，该函数在时间线中生成日期。 我们的调度程序会记住最后日期并添加适当的偏移量。 当没有更多的偏移量时，它会循环回到数组中的第一个。</p><p>最后，锦上添花的是，为我们的调度器创建一个类似枚举的初始化器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimelineSchedule</span> <span class="title">where</span> <span class="title">Self</span> == <span class="title">CyclicTimelineSchedule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cyclic</span><span class="params">(timeOffsets: [TimeInterval])</span></span> -&gt; <span class="type">CyclicTimelineSchedule</span> &#123;</span><br><span class="line">            .<span class="keyword">init</span>(timeOffsets: timeOffsets)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经准备好 <code>TimelineSchedue</code> 类型了，让我们为我们的心脏注入一些活力：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BeatingHeart</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.cyclic(timeOffsets: [<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.4</span>])) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">Heart</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heart</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> phase = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> scales: [<span class="type">CGFloat</span>] = [<span class="number">1.0</span>, <span class="number">1.6</span>, <span class="number">2.0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"❤️"</span>)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .scaleEffect(scales[phase])</span><br><span class="line">                .animation(.spring(response: <span class="number">0.10</span>,</span><br><span class="line">                                   dampingFraction: <span class="number">0.24</span>,</span><br><span class="line">                                   blendDuration: <span class="number">0.2</span>),</span><br><span class="line">                           value: phase)</span><br><span class="line">                .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                    advanceAnimationPhase()</span><br><span class="line">                &#125;</span><br><span class="line">                .onAppear &#123;</span><br><span class="line">                    advanceAnimationPhase()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">advanceAnimationPhase</span><span class="params">()</span></span> &#123;</span><br><span class="line">        phase = (phase + <span class="number">1</span>) % scales.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你现在应该熟悉这种模式，它与我们使用节拍器的模式相同。 使用 <code>onChange</code> 和 <code>onAppear</code> 推进动画，使用 <code>@State</code> 变量来跟踪动画，并设置一个动画，将我们的视图从一个时间线更新过渡到下一个。 在这种情况下，我们使用 <code>.spring</code> 动画，给它一个很好的摇晃效果。</p><h2 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><p>心脏和节拍器示例在某种程度上是关键帧动画。 我们在整个动画中定义了几个关键点，在这里我们改变了我们视图的参数，并让 <code>SwiftUI</code> 动画这些点之间的过渡。 以下示例将尝试概括该想法，并使其更加明显。 认识我们的新项目朋友，跳跃的家伙：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/603741f728ab66e0171c89ebe7ff95d0.gif" alt=""></p><p>如果你仔细观察动画，你会注意到这个表情符号角色的许多参数在不同的时间点发生了变化。 这些参数是：<code>y-offset</code>、<code>rotation</code> 和 <code>y-scale</code>。 同样重要的是，动画的不同片段有不同的动画类型（线性、缓入和缓出）。 由于这些是我们更改的参数，因此最好将它们放在一个数组中。 让我们开始： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset: <span class="type">TimeInterval</span>    </span><br><span class="line">    <span class="keyword">let</span> rotation: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> yScale: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> animation: <span class="type">Animation</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyframes = [</span><br><span class="line">    <span class="comment">// Initial state, will be used once. Its offset is useless and will be ignored</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.0</span>, rotation: <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: <span class="number">0</span>, animation: <span class="literal">nil</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Animation keyframes</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animation: .linear(duration: <span class="number">0.2</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .linear(duration: <span class="number">0.4</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animation: .easeOut(duration: <span class="number">0.5</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .easeIn(duration: <span class="number">0.4</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation: <span class="number">360</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animation: .easeOut(duration: <span class="number">0.2</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .linear(duration: <span class="number">0.4</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animation: .easeOut(duration: <span class="number">0.5</span>)),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animation: .easeIn(duration: <span class="number">0.4</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>重要的是要知道，当 <code>TimelineView</code> 出现时，它会绘制我们的视图，即使没有计划的更新，或者它们是否在将来。 当 <code>TimelineView</code> 出现时，它需要显示一些东西，以便绘制我们的视图。 我们将使用第一个关键帧作为我们的视图状态，但是当我们循环时，该帧将被忽略。 这是一个实施决策，你可能需要或想要以不同的方式进行。</p><p>现在，让我们看看我们的时间线：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JumpingEmoji</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use all offset, minus the first</span></span><br><span class="line">    <span class="keyword">let</span> offsets = <span class="type">Array</span>(keyframes.<span class="built_in">map</span> &#123; $<span class="number">0</span>.offset &#125;.<span class="built_in">dropFirst</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.cyclic(timeOffsets: offsets)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">HappyEmoji</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经从我们在前一个示例中所做的工作中受益，并重用了 <code>CyclicTimelineScheduler</code>。 如前所述，我们不需要第一个关键帧的偏移量，因此我们将其丢弃。</p><p>现在，有趣的部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HappyEmoji</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// current keyframe number</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> idx: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// timeline update</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"😃"</span>)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .scaleEffect(<span class="number">4.0</span>)</span><br><span class="line">            .modifier(<span class="type">Effects</span>(keyframe: keyframes[idx]))</span><br><span class="line">            .animation(keyframes[idx].animation, value: idx)</span><br><span class="line">            .onChange(of: date) &#123; <span class="number">_</span> <span class="keyword">in</span> advanceKeyFrame() &#125;</span><br><span class="line">            .onAppear &#123; advanceKeyFrame()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">advanceKeyFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// advance to next keyframe</span></span><br><span class="line">        idx = (idx + <span class="number">1</span>) % keyframes.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// skip first frame for animation, which we</span></span><br><span class="line">        <span class="comment">// only used as the initial state.</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span> &#123; idx = <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Effects</span>: <span class="title">ViewModifier</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> keyframe: <span class="type">KeyFrame</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">            content</span><br><span class="line">                .scaleEffect(<span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: keyframe.yScale))</span><br><span class="line">                .rotationEffect(<span class="type">Angle</span>(degrees: keyframe.rotation))</span><br><span class="line">                .offset(y: keyframe.y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的可读性，我将所有变化的参数放在一个名为 <code>Effects</code> 的修改器中。 如你所见，它还是相同的模式：使用 <code>onChange</code> 和 <code>onAppear</code> 来推进我们的动画，并为每个关键帧片段添加一个动画。 那里没有什么新鲜事。</p><h2 id="不要！-这是一个陷阱！"><a href="#不要！-这是一个陷阱！" class="headerlink" title="不要！ 这是一个陷阱！"></a>不要！ 这是一个陷阱！</h2><p>在你的 <code>TimelineView</code> 发现路径中，你可能会遇到此错误：</p><blockquote><p>Action Tried to Update Multiple Times Per Frame</p></blockquote><p>让我们看一个生成此消息的示例： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">2.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">                .foregroundStyle(flag ? .red : .blue)</span><br><span class="line">                .onChange(of: timeline.date) &#123; (date: <span class="type">Date</span>) <span class="keyword">in</span></span><br><span class="line">                    flag.toggle()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来没有问题，它应该每两秒改变一次文本颜色，在红色和蓝色之间交替。那么可能会发生什么？稍等片刻，看看你是否能找出背后的原因。</p><p>我们不是在处理一个 bug。事实上，这个问题是可以预见的。<br><code>重要的是要记住，时间线的第一次更新是在它第一次出现时，然后它遵循调度程序规则来触发以下更新。因此，即使我们的调度程序没有产生更新，</code>TimelineView` 内容也至少会生成一次。</p><p>在这个具体的例子中，我们监控 <code>timeline.date</code> 值的变化，当它发生变化时，我们切换 <code>flag</code> 变量，它会产生颜色变化。</p><p><code>TimelineView</code> 将首先出现。两秒后，时间线将更新（例如，由于第一次调度程序更新），触发 <code>onChange</code> 关闭。这将反过来改变标志变量。现在，由于我们的 <code>TimelineView</code> 依赖于它，它需要立即刷新，触发标志变量的另一个切换，强制另一个 <code>TimelineView</code> 刷新，依此类推……你明白了：每帧多次更新。</p><p>那么我们该如何解决呢？解决方案可能会有所不同。在这种情况下，我们只需封装内容并将标志变量移动到封装的视图内。现在 <code>TimelineView</code> 不再依赖它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TimelineView</span>(.periodic(from: .now, by: <span class="number">1.0</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">            <span class="type">SubView</span>(date: timeline.date)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flag = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello"</span>)</span><br><span class="line">            .foregroundStyle(flag ? .red : .blue)</span><br><span class="line">            .onChange(of: date) &#123; (date: <span class="type">Date</span>) <span class="keyword">in</span></span><br><span class="line">                flag.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="探索新点子"><a href="#探索新点子" class="headerlink" title="探索新点子"></a>探索新点子</h2><p><strong>每次时间线更新刷新一次</strong>：如前所述，这种模式使我们的视图每次更新计算它们的主体两次：第一次是在时间线更新时，然后在我们推进动画状态值时再次计算。在这种类型的动画中，我们在时间上间隔了关键点，这非常好。</p><p>在这些时间点太靠近的动画中，你可能需要/想要避免这种情况。如果你需要更改存储的值，但要避免视图刷新……你可以使用一个技巧。使用 <code>@StateObject</code> 代替<code>@State</code>。确保你不要在 <code>@Published</code> 中设置这样的值。如果在某个时候，你想要/需要告诉你的视图刷新，你可以随时调用<code>objectWillChange.send()</code></p><p><strong>匹配动画持续时间和偏移量</strong>：在关键帧示例中，我们为每个动画片段使用不同的动画。为此，我们将动画值存储在数组中。如果你仔细观察，你会发现在我们的具体示例中，偏移量和动画持续时间匹配！这是合理的，对吧？因此，你可以定义一个具有动画类型的枚举，而不是在数组中包含 <code>Animation</code> 值。稍后在你的视图中，你将根据动画类型创建动画值，但使用偏移值的持续时间对其进行实例化。类似这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KeyFrameAnimation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> linear</span><br><span class="line">    <span class="keyword">case</span> easeOut</span><br><span class="line">    <span class="keyword">case</span> easeIn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyFrame</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> offset: <span class="type">TimeInterval</span>    </span><br><span class="line">    <span class="keyword">let</span> rotation: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> yScale: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> animationKind: <span class="type">KeyFrameAnimation</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animation: <span class="type">Animation</span>? &#123;</span><br><span class="line">        <span class="keyword">switch</span> animationKind &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> .linear: <span class="keyword">return</span> .linear(duration: offset)</span><br><span class="line">        <span class="keyword">case</span> .easeIn: <span class="keyword">return</span> .easeIn(duration: offset)</span><br><span class="line">        <span class="keyword">case</span> .easeOut: <span class="keyword">return</span> .easeOut(duration: offset)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyframes = [</span><br><span class="line">    <span class="comment">// Initial state, will be used once. Its offset is useless and will be ignored</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.0</span>, rotation: <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: <span class="number">0</span>, animationKind: .<span class="keyword">none</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Animation keyframes</span></span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animationKind: .linear),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .linear),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animationKind: .easeOut),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .easeIn),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.2</span>, rotation: <span class="number">360</span>, yScale: <span class="number">0.5</span>, y:  <span class="number">20</span>, animationKind: .easeOut),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation: <span class="number">360</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .linear),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.5</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">80</span>, animationKind: .easeOut),</span><br><span class="line">    <span class="type">KeyFrame</span>(offset: <span class="number">0.4</span>, rotation:   <span class="number">0</span>, yScale: <span class="number">1.0</span>, y: -<span class="number">20</span>, animationKind: .easeIn),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果你想知道为什么我一开始不这样做，我只是想向你展示两种方式都是可能的。 第一种情况更灵活，但更冗长。 也就是说，我们被迫为每个动画指定持续时间，但是，它更灵活，因为我们可以自由使用与偏移量不匹配的持续时间。</p><p>然而，当使用这种新方法时，你可以轻松地添加一个可自定义的因素，这可以让你减慢或加快动画速度，而无需触摸关键帧。</p><p><strong>嵌套 TimelineViews</strong>：没有什么能阻止你将一个 <code>TimelineView</code> 嵌套在另一个 <code>TimelineView</code> 中。 现在我们有了 <code>JumpingEmoji</code>，我们可以在 <code>TimelineView</code> 中放置三个 <code>JumpingEmoji</code> 视图，使它们一次出现一个，并有延迟：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/305e84985d4d239e6ae75c508a025062.gif" alt=""></p><p>对于 Emoji 波浪的全部源码，检出这个 <a href="https://gist.github.com/swiftui-lab/f4e77af35ba15853cc1426c735cc6cdc" target="_blank" rel="noopener">gits</a>。</p><h2 id="GifImage-示例"><a href="#GifImage-示例" class="headerlink" title="GifImage 示例"></a>GifImage 示例</h2><p>笔者原本还有一个示例，但是它在笔者发布文章的时候废弃了。 它没有入选的原因是并发 API 还不稳定。 幸运的是，现在可以安全地发布它。 该代码使用 <code>TimelineView</code> 来实现动画 gif 的视图。 视图从 URL（可以是本地的或远程的）异步加载 gif。 此 <a href="https://gist.github.com/swiftui-lab/aa5d73b81c8696dee4a5996954b22e5c" target="_blank" rel="noopener">gist</a> 中提供了所有代码。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>恭喜阅读到这么长的一篇文章的结尾。这是一次骑行！我们从最简单的 <code>TimelineView</code> 示例转到视图的一些创造性使用。 在第 5 部分中，笔者将探索新的 <code>Canvas</code> 视图，以及它与 <code>TimelineView</code> 的结合程度。 通过将它们放在一起，我们将扩展 <code>SwiftUI</code> 动画世界中的更多可能性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前三篇&lt;a href=&quot;https://xiaozhuanlan.com/topic/6089153247&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高级 SwiftUI 动画系列&lt;/a&gt;是作者在 WWDC 2021 之前实战总结的内容。对 2021 年 WWDC 介绍的 &lt;code&gt;TimelineView&lt;/code&gt; 和 &lt;code&gt;Canvas&lt;/code&gt; 感到激动。这开启了一个全新的可能性，笔者将试图在这一部分和下一部分的系列中阐释这些可能性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://swiftui-lab.com/wp-content/uploads/2021/06/hello-there-25.gif&quot; alt=&quot;&quot; title=&quot;Hello There&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将详细地探索 &lt;code&gt;TimelineView&lt;/code&gt; 。我们将从最常见的用途缓慢开始。然而笔者认为，最大的可能性来自于 &lt;code&gt;TimelineView&lt;/code&gt; 和我们已知现有的动画相结合。在其他事物中，通过一点创意，这样的组合将让我们最终实现“关键帧类似”的动画。&lt;/p&gt;
&lt;p&gt;在第 5 部分，我们将探索 &lt;code&gt;Canvas&lt;/code&gt; 视图，以及它和我们的新朋友 &lt;code&gt;TimelineView&lt;/code&gt; 相结合是如此的优秀。&lt;/p&gt;
&lt;p&gt;上文中展示的动画，是使用本文中介绍的技术创建的。该动画的完整代码可在此 &lt;a href=&quot;https://gist.github.com/swiftui-lab/c1d089207d6f7b365729b1af2e695cc4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gist&lt;/a&gt; 中找到。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画 — Part 3：AnimatableModifier</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB-%E2%80%94-Part-3%EF%BC%9AAnimatableModifier/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画-—-Part-3：AnimatableModifier/</id>
    <published>2022-04-06T02:31:12.000Z</published>
    <updated>2022-04-06T02:37:25.566Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2022/44ccd720a2cc827b4921c612d1dbf6f9.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的两篇文章<a href="https://xiaozhuanlan.com/topic/9583407126" target="_blank" rel="noopener">animating paths</a> 和 <a href="https://xiaozhuanlan.com/topic/9685470312" target="_blank" rel="noopener">transform matrices</a> 对 Animatable 协议使用做了介绍，今天这篇文章将为大家介绍 AnimatableModifier，使用它可以完成更多的动画工作。</p><p>AnimatableModifier 是一个 ViewModifier，符合 Animatable 协议，如果对这个协议不了解可以阅读之前发布的两篇文章。</p><a id="more"></a><h1 id="AnimatableModifier-无法实现动画"><a href="#AnimatableModifier-无法实现动画" class="headerlink" title="AnimatableModifier 无法实现动画"></a>AnimatableModifier 无法实现动画</h1><p>如果是第一次使用 AnimatableModifier，可能会遇到问题。写一个简单的动画，但是没有动画效果。 我又试了几次，也没有成功。因此我认为该功能不存并且放弃使用。幸运的是，后来我坚持了下来。事实证明，我的第一个 <code>modifier</code> 非常好，但是 <code>animatable modifiers</code> 在容器中不起作用。 我在第二次尝试时，动画视图不在容器内。</p><p>例如，以下 modifier 可以成功实现动画：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyView</span>().modifier(<span class="type">MyAnimatableModifier</span>(value: flag ? <span class="number">1</span> : <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>但是相同的代码，在 VStack 中就没有动画了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">MyView</span>().modifier(<span class="type">MyAnimatableModifier</span>(value: flag ? <span class="number">1</span> : <span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题在官方解决之前，经过尝试，可以在 VStack 中改成下面的代码，就可以实现动画：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Color</span>.clear.overlay(<span class="type">MyView</span>().modifier(<span class="type">MyAnimatableModifier</span>(value: flag ? <span class="number">1</span> : <span class="number">0</span>))).frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写是使用一个透明视图占据实际视图空间，动画被放在透明视图上，使用 <code>.overlay()</code>。有点不方便的是，我们需要知道实际视图有多大，所以我们可以在它后面设置透明视图的框架。在下面的示例中可以开到实现代码。</p><h1 id="动画文本"><a href="#动画文本" class="headerlink" title="动画文本"></a>动画文本</h1><p>首先需要制作一些文字动画。对于这个例子，我们将创建一个进度加载指示器。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/5758d75eef91ca96c7591467047153f4.gif" alt=""></p><p>可能很多人都认为应该使用动画路径实现。但是，内部标签就无法设置动画，使用 <code>AnimatableModifier</code> 可以实现。</p><p>完整的代码作为 <strong>示例10</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PercentageIndicator</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .overlay(<span class="type">ArcShape</span>(pct: pct).foregroundColor(.red))</span><br><span class="line">            .overlay(<span class="type">LabelView</span>(pct: pct))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> pct: <span class="type">CGFloat</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="type">Path</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> p = <span class="type">Path</span>()</span><br><span class="line"></span><br><span class="line">            p.addArc(center: <span class="type">CGPoint</span>(x: rect.width / <span class="number">2.0</span>, y:rect.height / <span class="number">2.0</span>),</span><br><span class="line">                     radius: rect.height / <span class="number">2.0</span> + <span class="number">5.0</span>,</span><br><span class="line">                     startAngle: .degrees(<span class="number">0</span>),</span><br><span class="line">                     endAngle: .degrees(<span class="number">360.0</span> * <span class="type">Double</span>(pct)), clockwise: <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> p.strokedPath(.<span class="keyword">init</span>(lineWidth: <span class="number">10</span>, dash: [<span class="number">6</span>, <span class="number">3</span>], dashPhase: <span class="number">10</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LabelView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> pct: <span class="type">CGFloat</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"<span class="subst">\(Int(pct * <span class="number">100</span>)</span>) %"</span>)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .fontWeight(.bold)</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在示例代码中可以看到，没有使 <code>ArcShape animatable</code>。 因为 <code>modifier</code> 已经多次创建形状，具有不同的 pct 值。</p><h1 id="动画渐变"><a href="#动画渐变" class="headerlink" title="动画渐变"></a>动画渐变</h1><p>在实现渐变动画时，可能会遇到一些限制。比如，可以为起点和终点设置动画，但是不能为渐变颜色设置动画。使用 <code>AnimatableModifier</code> 可以避免出现这种情况。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/eaedb1f634b7e68c3e7967cbe1ecb15c.gif" alt=""></p><p>很容易就可以实现这个功能，在这个基础上可以实现更多复杂的动画。如果需要插入中间颜色，我们只需要计算 RGB 值的平均值。另外需要注意，<code>modifier</code> 假设输入颜色数组都包含相同数量的颜色。</p><p>完整的代码作为 <strong>示例11</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnimatableGradient</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> from: [<span class="type">UIColor</span>]</span><br><span class="line">    <span class="keyword">let</span> to: [<span class="type">UIColor</span>]</span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> gColors = [<span class="type">Color</span>]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;from.<span class="built_in">count</span> &#123;</span><br><span class="line">            gColors.append(colorMixer(c1: from[i], c2: to[i], pct: pct))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">15</span>)</span><br><span class="line">            .fill(<span class="type">LinearGradient</span>(gradient: <span class="type">Gradient</span>(colors: gColors),</span><br><span class="line">                                 startPoint: <span class="type">UnitPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>),</span><br><span class="line">                                 endPoint: <span class="type">UnitPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)))</span><br><span class="line">            .frame(width: <span class="number">200</span>, height: <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This is a very basic implementation of a color interpolation</span></span><br><span class="line">    <span class="comment">// between two values.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">colorMixer</span><span class="params">(c1: UIColor, c2: UIColor, pct: CGFloat)</span></span> -&gt; <span class="type">Color</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cc1 = c1.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cc2 = c2.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> r = (cc1[<span class="number">0</span>] + (cc2[<span class="number">0</span>] - cc1[<span class="number">0</span>]) * pct)</span><br><span class="line">        <span class="keyword">let</span> g = (cc1[<span class="number">1</span>] + (cc2[<span class="number">1</span>] - cc1[<span class="number">1</span>]) * pct)</span><br><span class="line">        <span class="keyword">let</span> b = (cc1[<span class="number">2</span>] + (cc2[<span class="number">2</span>] - cc1[<span class="number">2</span>]) * pct)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Color</span>(red: <span class="type">Double</span>(r), green: <span class="type">Double</span>(g), blue: <span class="type">Double</span>(b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多文本动画"><a href="#更多文本动画" class="headerlink" title="更多文本动画"></a>更多文本动画</h1><p>这个示例中，将再次实现一个文本动画。但是是逐步进行，一次放大一个字符</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/2dc189297ef8f91cd26ebd11eef0c86c.gif" alt=""></p><p>完整的代码作为 <strong>示例12</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WaveTextModifier</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> waveWidth: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGFloat</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HStack</span>(spacing: <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="type">Array</span>(text.enumerated()), id: \.<span class="number">0</span>) &#123; (n, ch) <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(<span class="type">String</span>(ch))</span><br><span class="line">                    .font(<span class="type">Font</span>.custom(<span class="string">"Menlo"</span>, size: <span class="keyword">self</span>.size).bold())</span><br><span class="line">                    .scaleEffect(<span class="keyword">self</span>.effect(<span class="keyword">self</span>.pct, n, <span class="keyword">self</span>.text.<span class="built_in">count</span>, <span class="type">Double</span>(<span class="keyword">self</span>.waveWidth)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effect</span><span class="params">(<span class="number">_</span> pct: Double, <span class="number">_</span> n: Int, <span class="number">_</span> total: Int, <span class="number">_</span> waveWidth: Double)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="type">Double</span>(n)</span><br><span class="line">        <span class="keyword">let</span> total = <span class="type">Double</span>(total)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="number">1</span> + valueInCurve(pct: pct, total: total, x: n/total, waveWidth: waveWidth))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">valueInCurve</span><span class="params">(pct: Double, total: Double, x: Double, waveWidth: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> chunk = waveWidth / total</span><br><span class="line">        <span class="keyword">let</span> m = <span class="number">1</span> / chunk</span><br><span class="line">        <span class="keyword">let</span> offset = (chunk - (<span class="number">1</span> / total)) * pct</span><br><span class="line">        <span class="keyword">let</span> lowerLimit = (pct - chunk) + offset</span><br><span class="line">        <span class="keyword">let</span> upperLimit = (pct) + offset</span><br><span class="line">        <span class="keyword">guard</span> x &gt;= lowerLimit &amp;&amp; x &lt; upperLimit <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> angle = ((x - pct - offset) * m)*<span class="number">360</span>-<span class="number">90</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (sin(angle.rad) + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rad: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * .pi / <span class="number">180</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> deg: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">180</span> / .pi &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数器动画"><a href="#计数器动画" class="headerlink" title="计数器动画"></a>计数器动画</h1><p>如果你没有用过或者对 AnimatableModifier 不了解，下面这个示例基本上是无法实现的。下面我们来介绍一下如何创建一个计数器动画：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/cc47950bb3f88ec3dd90d006f27491aa.gif" alt=""></p><p>这个练习的诀窍是为每个数字使用 5 个文本视图，并使用 .spring() 动画上下移动它们。 我们还需要使用 .clipShape() 修饰符来隐藏在边框之外绘制的部分。 为了更好地理解它是如何工作的，您可以评论 .clipShape() 并大大减慢动画的速度。 完整代码在本页顶部链接的 gist 文件中以 Example13 的形式提供。</p><p>这个动画实现的主要内容是每个数字使用 5 个文本视图，并使用 .spring() 动画上下移动它们。然后使用  <code>.clipShape()</code> 修饰符来隐藏边框之外区域。如果想跟清晰的理解他们是如何实现的，可以通过    <code>.clipShape()</code>  让动画速度变慢。</p><p>完整的代码作为 <strong>示例13</strong> 在文末链接中。关键代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovingCounterModifier</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">        @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> height: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> number: <span class="type">Double</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; number &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; number = newValue &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> n = <span class="keyword">self</span>.number + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> tOffset: <span class="type">CGFloat</span> = getOffsetForTensDigit(n)</span><br><span class="line">            <span class="keyword">let</span> uOffset: <span class="type">CGFloat</span> = getOffsetForUnitDigit(n)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> u = [n - <span class="number">2</span>, n - <span class="number">1</span>, n + <span class="number">0</span>, n + <span class="number">1</span>, n + <span class="number">2</span>].<span class="built_in">map</span> &#123; getUnitDigit($<span class="number">0</span>) &#125;</span><br><span class="line">            <span class="keyword">let</span> x = getTensDigit(n)</span><br><span class="line">            <span class="keyword">var</span> t = [<span class="built_in">abs</span>(x - <span class="number">2</span>), <span class="built_in">abs</span>(x - <span class="number">1</span>), <span class="built_in">abs</span>(x + <span class="number">0</span>), <span class="built_in">abs</span>(x + <span class="number">1</span>), <span class="built_in">abs</span>(x + <span class="number">2</span>)]</span><br><span class="line">            t = t.<span class="built_in">map</span> &#123; getUnitDigit(<span class="type">Double</span>($<span class="number">0</span>)) &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> font = <span class="type">Font</span>.custom(<span class="string">"Menlo"</span>, size: <span class="number">34</span>).bold()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">HStack</span>(alignment: .top, spacing: <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">VStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">0</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">1</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">2</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">3</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(t[<span class="number">4</span>])</span>"</span>).font(font)</span><br><span class="line">                &#125;.foregroundColor(.green).modifier(<span class="type">ShiftEffect</span>(pct: tOffset))</span><br><span class="line">                </span><br><span class="line">                <span class="type">VStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">0</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">1</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">2</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">3</span>])</span>"</span>).font(font)</span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"<span class="subst">\(u[<span class="number">4</span>])</span>"</span>).font(font)</span><br><span class="line">                &#125;.foregroundColor(.green).modifier(<span class="type">ShiftEffect</span>(pct: uOffset))</span><br><span class="line">            &#125;</span><br><span class="line">            .clipShape(<span class="type">ClipShape</span>())</span><br><span class="line">            .overlay(<span class="type">CounterBorder</span>(height: $height))</span><br><span class="line">            .background(<span class="type">CounterBackground</span>(height: $height))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getUnitDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="type">Int</span>(number) - ((<span class="type">Int</span>(number) / <span class="number">10</span>) * <span class="number">10</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getTensDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="type">Int</span>(number) / <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getOffsetForUnitDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - <span class="type">CGFloat</span>(number - <span class="type">Double</span>(<span class="type">Int</span>(number)))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">getOffsetForTensDigit</span><span class="params">(<span class="number">_</span> number: Double)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> getUnitDigit(number) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> - <span class="type">CGFloat</span>(number - <span class="type">Double</span>(<span class="type">Int</span>(number)))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="动画文本颜色"><a href="#动画文本颜色" class="headerlink" title="动画文本颜色"></a>动画文本颜色</h1><p>通常情况下是通过 <code>.foregroundColor()</code> 为动画添加颜色，但是在文本类动画中使用没有效果，不知道是缺少什么配置还是什么原因。我通过下面的方法实现给文本动画添加颜色。</p><p>完整的代码作为 <strong>示例14</strong> 在文末链接中。关键代码如下：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/7d75cef39eac0ff99a6549da9912d440.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnimatableColorText</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> from: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">let</span> to: <span class="type">UIColor</span></span><br><span class="line">    <span class="keyword">let</span> pct: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> text: () -&gt; <span class="type">Text</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> textView = text()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> textView.foregroundColor(<span class="type">Color</span>.clear)</span><br><span class="line">            .overlay(<span class="type">Color</span>.clear.modifier(<span class="type">AnimatableColorTextModifier</span>(from: from, to: to, pct: pct, text: textView)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AnimatableColorTextModifier</span>: <span class="title">AnimatableModifier</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> from: <span class="type">UIColor</span></span><br><span class="line">        <span class="keyword">let</span> to: <span class="type">UIColor</span></span><br><span class="line">        <span class="keyword">var</span> pct: <span class="type">CGFloat</span></span><br><span class="line">        <span class="keyword">let</span> text: <span class="type">Text</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; pct &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> text.foregroundColor(colorMixer(c1: from, c2: to, pct: pct))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// This is a very basic implementation of a color interpolation</span></span><br><span class="line">        <span class="comment">// between two values.</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">colorMixer</span><span class="params">(c1: UIColor, c2: UIColor, pct: CGFloat)</span></span> -&gt; <span class="type">Color</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> cc1 = c1.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> cc2 = c2.cgColor.components <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">Color</span>(c1) &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> r = (cc1[<span class="number">0</span>] + (cc2[<span class="number">0</span>] - cc1[<span class="number">0</span>]) * pct)</span><br><span class="line">            <span class="keyword">let</span> g = (cc1[<span class="number">1</span>] + (cc2[<span class="number">1</span>] - cc1[<span class="number">1</span>]) * pct)</span><br><span class="line">            <span class="keyword">let</span> b = (cc1[<span class="number">2</span>] + (cc2[<span class="number">2</span>] - cc1[<span class="number">2</span>]) * pct)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Color</span>(red: <span class="type">Double</span>(r), green: <span class="type">Double</span>(g), blue: <span class="type">Double</span>(b))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="版本相关问题"><a href="#版本相关问题" class="headerlink" title="版本相关问题"></a>版本相关问题</h1><p>通过上面介绍可以看出 <code>AnimatableModifier</code> 非常强大，但是还存在一些问题。另外在 Xcode 和 iOS/macOS 某些版本中，App 在启动时会崩溃。而且是在部署时，正常开发编译中是不会发生这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Symbol not found: _$s7SwiftUI18AnimatableModifierPAAE13_makeViewList8modifier6inputs4bodyAA01_fG7OutputsVAA11_GraphValueVyxG_AA01_fG6InputsVAiA01_L0V_ANtctFZ</span><br><span class="line">  Referenced from: /Applications/MyApp.app/Contents/MacOS/MyApp</span><br><span class="line">  Expected in: /System/Library/Frameworks/SwiftUI.framework/Versions/A/SwiftUI</span><br></pre></td></tr></table></figure><p>例如，如果 App 在 Xcode 11.3 上部署并在 macOS 10.15.0 上执行，就会出现 “Symbol not found” 错误。然而，在 macOS  10.15.1 上运行相同的可执行文件可以正常工作。</p><blockquote><p>译自 <a href="https://swiftui-lab.com/" target="_blank" rel="noopener">The SwiftUI Lab</a> 的 <a href="https://swiftui-lab.com/swiftui-animations-part3/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 3: AnimatableModifier</a></p><p>本文的完整示例代码可在以下位置找到：</p><p><a href="https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798" target="_blank" rel="noopener">https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798</a></p><p>示例8 需要的图片资源。从这里下载：</p><p><a href="https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916" target="_blank" rel="noopener">https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/44ccd720a2cc827b4921c612d1dbf6f9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前的两篇文章&lt;a href=&quot;https://xiaozhuanlan.com/topic/9583407126&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;animating paths&lt;/a&gt; 和 &lt;a href=&quot;https://xiaozhuanlan.com/topic/9685470312&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;transform matrices&lt;/a&gt; 对 Animatable 协议使用做了介绍，今天这篇文章将为大家介绍 AnimatableModifier，使用它可以完成更多的动画工作。&lt;/p&gt;
&lt;p&gt;AnimatableModifier 是一个 ViewModifier，符合 Animatable 协议，如果对这个协议不了解可以阅读之前发布的两篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画 — Part 2：GeometryEffect</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB-%E2%80%94-Part-2%EF%BC%9AGeometryEffect/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画-—-Part-2：GeometryEffect/</id>
    <published>2022-04-06T02:31:01.000Z</published>
    <updated>2022-04-06T02:38:03.010Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2022/c5eea293e62e03a91b514d2b1cea765f.png" alt=""></p><p>在本系列的第一部分，我介绍了<code>Animatable</code>协议，以及我们如何使用它来为路径制作动画。接下来，我们将使用一个新的工具: <code>GeometryEffect</code>，用同样的协议对变换矩阵进行动画处理。如果你没有读过第一部分，也不知道<code>Animatable</code>协议是什么，你应该先读一下。或者如果你只是对<code>GeometryEffect</code>感兴趣，不关心动画，你可以跳过第一部分，继续阅读本文。</p><a id="more"></a><h1 id="GeometryEffect"><a href="#GeometryEffect" class="headerlink" title="GeometryEffect"></a>GeometryEffect</h1><p><code>GeometryEffect</code>是一个符合<code>Animatable</code>和<code>ViewModifier</code>的协议。为了符合<code>GeometryEffect</code>协议，你需要实现以下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span></span><br></pre></td></tr></table></figure><p>假设你的方法叫<code>SkewEffect</code>，为了把它应用到一个视图上，你会这样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello"</span>).modifier(<span class="type">SkewEfect</span>(skewValue: <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><p><code>Text(&quot;Hello&quot;)</code>将被转换为由<code>SkewEfect.effectValue()</code>方法创建的矩阵。就这么简单。请注意，这些变化将影响视图，但不会影响其祖先或后代的布局。</p><p>因为<code>GeometryEffect</code>也符合<code>Animatable</code>，你可以添加一个<code>animatableData</code>属性，然后你就有了一个可动的效果。</p><p>你可能没有意识到，你可能一直在使用<code>GeometryEffect</code>。如果你曾经使用过<code>.offset()</code>，你实际上是在使用<code>GeometryEffect</code>。让我告诉你它是如何实现的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(x: CGFloat, y: CGFloat)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> modifier(_OffsetEffect(offset: <span class="type">CGSize</span>(width: x, height: y)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(<span class="number">_</span> offset: CGSize)</span></span> -&gt; some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> modifier(_OffsetEffect(offset: offset))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_OffsetEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">CGSize</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGSize</span>.<span class="type">AnimatableData</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">CGSize</span>.<span class="type">AnimatableData</span>(offset.width, offset.height) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; offset = <span class="type">CGSize</span>(width: newValue.first, height: newValue.second) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: offset.width, y: offset.height))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Animation-Keyframes"><a href="#Animation-Keyframes" class="headerlink" title="Animation Keyframes"></a>Animation Keyframes</h1><p>大多数动画框架都有关键帧的概念。它是一种告诉动画引擎将动画分成若干块的方式。虽然 SwiftUI 没有这些功能，但我们可以模拟它。在下面的例子中，我们将创建一个水平移动视图的效果，但它也会在开始时倾斜，在结束时取消倾斜：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/8a7e081311517626f17a879214256f9c.gif" alt=""></p><p>倾斜效果需要在动画的第一个和最后一个20%期间增加和减少。在中间，倾斜效果将保持稳定。好了，现在我们有一个挑战，让我们看看如何解决这个问题。</p><p>我们将首先创建一个使我们的视图倾斜和移动的效果，而不必太注意20%的要求。如果你对变换矩阵了解不多，那也没关系。只需要知道：<code>CGAffineTransform</code> <code>c</code> 参数驱动倾斜，而 <code>tx</code> 则驱动 <code>x</code> 偏移。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/fb395e91688d2044f116e7d2993b814d.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkewedOffset</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">var</span> skew: <span class="type">CGFloat</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">AnimatablePair</span>(offset, skew) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            offset = newValue.first</span><br><span class="line">            skew = newValue.second</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(a: <span class="number">1</span>, b: <span class="number">0</span>, <span class="built_in">c</span>: skew, d: <span class="number">1</span>, tx: offset, ty: <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>好了，现在是有趣的部分。为了模拟关键帧，我们将定义一个可动画的参数，我们将其从 0 到 1 改变。当该参数为 0.2 时，我们达到了动画的前 20%。当该参数为 0.8 或更大时，我们就进入了动画的最后 20%。我们的代码应该利用这一点来改变相应的效果。最重要的是，我们还要告诉效果，我们是向右还是向左移动视图，所以它可以向一边倾斜，或者向另一边倾斜：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkewedOffset</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> offset: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> goingRight: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(offset: <span class="type">CGFloat</span>, pct: <span class="type">CGFloat</span>, goingRight: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.offset = offset</span><br><span class="line">        <span class="keyword">self</span>.pct = pct</span><br><span class="line">        <span class="keyword">self</span>.goingRight = goingRight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;(offset, pct) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            offset = newValue.first</span><br><span class="line">            pct = newValue.second</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> skew: <span class="type">CGFloat</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pct &lt; <span class="number">0.2</span> &#123;</span><br><span class="line">            skew = (pct * <span class="number">5</span>) * <span class="number">0.5</span> * (goingRight ? -<span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> pct &gt; <span class="number">0.8</span> &#123;</span><br><span class="line">            skew = ((<span class="number">1</span> - pct) * <span class="number">5</span>) * <span class="number">0.5</span> * (goingRight ? -<span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            skew = <span class="number">0.5</span> * (goingRight ? -<span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(a: <span class="number">1</span>, b: <span class="number">0</span>, <span class="built_in">c</span>: skew, d: <span class="number">1</span>, tx: offset, ty: <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，只是为了好玩，我们将把这个效果应用于多个视图，但它们的动画将交错进行，使用<code>.delay()</code>动画修饰符。完整的代码可在本页面顶部链接的gist文件中 <strong>实例6</strong> 获得。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/cd77c096eb465b1fe95c16a56c9bdb9b.gif" alt=""></p><h1 id="动画反馈"><a href="#动画反馈" class="headerlink" title="动画反馈"></a>动画反馈</h1><p>在下一个例子中，我将向你展示一个简单的技术，它将使我们的视图对效果动画的进展做出反应。</p><p>我们将创建一个效果，让我们进行三维旋转。虽然SwiftUI已经有了一个修饰符，即<code>.rotrotation3DEffect()</code>，但这个修饰符将是特别的。每当我们的视图旋转到足以向我们展示另一面时，一个布尔绑定将被更新。</p><p>通过对绑定变量的变化做出反应，我们将能够替换正在旋转动画的过程中的视图。这将创造一种错觉，即视图有两个面。下面是一个例子：</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/c88e7be22086f5a0341777430c31a874.gif" alt=""></p><h2 id="落实我们的效果"><a href="#落实我们的效果" class="headerlink" title="落实我们的效果"></a>落实我们的效果</h2><p>让我们开始创建我们的效果。你会注意到，三维旋转变换可能与你在核心动画中的习惯略有不同。在SwiftUI中，默认的锚点是在视图的前角，而在Core Animation中是在中心。虽然现有的<code>.rotrotingg3DEffect()</code>修饰符可以让你指定一个锚点，但我们正在建立我们自己的效果。这意味着我们必须自己处理它。由于我们不能改变锚点，我们需要在组合中加入一些转换效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlipEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; angle &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; angle = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> flipped: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> angle: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> axis: (x: <span class="type">CGFloat</span>, y: <span class="type">CGFloat</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 我们把修改安排在视图绘制完成后进行。</span></span><br><span class="line">        <span class="comment">// 否则，我们会收到一个运行时错误，表明我们正在改变</span></span><br><span class="line">        <span class="comment">// 视图正在绘制时改变状态。</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.flipped = <span class="keyword">self</span>.angle &gt;= <span class="number">90</span> &amp;&amp; <span class="keyword">self</span>.angle &lt; <span class="number">270</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> a = <span class="type">CGFloat</span>(<span class="type">Angle</span>(degrees: angle).radians)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> transform3d = <span class="type">CATransform3DIdentity</span>;</span><br><span class="line">        transform3d.m34 = -<span class="number">1</span>/<span class="built_in">max</span>(size.width, size.height)</span><br><span class="line">        </span><br><span class="line">        transform3d = <span class="type">CATransform3DRotate</span>(transform3d, a, axis.x, axis.y, <span class="number">0</span>)</span><br><span class="line">        transform3d = <span class="type">CATransform3DTranslate</span>(transform3d, -size.width/<span class="number">2.0</span>, -size.height/<span class="number">2.0</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> affineTransform = <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: size.width/<span class="number">2.0</span>, y: size.height / <span class="number">2.0</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(transform3d).concatenating(affineTransform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看几何效果代码，有一个有趣的事实。我们用<code>@Bindingd</code>属性<code>flipped</code>来向视图报告，哪一面是面向用户的。</p><p>在我们的视图中，我们将使用<code>flipped</code>的值来有条件地显示两个视图中的一个。然而，在这个具体的例子中，我们将使用一个更多的技巧。如果你仔细观察视频，你会发现这张牌一直在变化。背面总是一样的，但正面却每次都在变化。因此，这不是简单的为一面展示一个视图，为另一面展示另一个视图。我们不是基于<code>flipped</code>的值，而是要监测<code>flipped</code>的值的变化。然后每一个完整的回合，我们将使用不同的牌。</p><p>我们有一个图像名称的数组，我们想逐一查看。为了做到这一点，我们将使用一个自定义绑定变量。这个技巧最好用代码来解释：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RotatingCard</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> flipped = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> animate3d = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rotate = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> imgIndex = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> images = [<span class="string">"diamonds-7"</span>, <span class="string">"clubs-8"</span>, <span class="string">"diamonds-6"</span>, <span class="string">"clubs-b"</span>, <span class="string">"hearts-2"</span>, <span class="string">"diamonds-b"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> binding = <span class="type">Binding</span>&lt;<span class="type">Bool</span>&gt;(<span class="keyword">get</span>: &#123; <span class="keyword">self</span>.flipped &#125;, <span class="keyword">set</span>: &#123; <span class="keyword">self</span>.updateBinding($<span class="number">0</span>) &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            <span class="type">Image</span>(flipped ? <span class="string">"back"</span> : images[imgIndex]).resizable()</span><br><span class="line">                .frame(width: <span class="number">265</span>, height: <span class="number">400</span>)</span><br><span class="line">                .modifier(<span class="type">FlipEffect</span>(flipped: binding, angle: animate3d ? <span class="number">360</span> : <span class="number">0</span>, axis: (x: <span class="number">1</span>, y: <span class="number">5</span>)))</span><br><span class="line">                .rotationEffect(<span class="type">Angle</span>(degrees: rotate ? <span class="number">0</span> : <span class="number">360</span>))</span><br><span class="line">                .onAppear &#123;</span><br><span class="line">                    withAnimation(<span class="type">Animation</span>.linear(duration: <span class="number">4.0</span>).repeatForever(autoreverses: <span class="literal">false</span>)) &#123;</span><br><span class="line">                        <span class="keyword">self</span>.animate3d = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    withAnimation(<span class="type">Animation</span>.linear(duration: <span class="number">8.0</span>).repeatForever(autoreverses: <span class="literal">false</span>)) &#123;</span><br><span class="line">                        <span class="keyword">self</span>.rotate = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateBinding</span><span class="params">(<span class="number">_</span> value: Bool)</span></span> &#123;</span><br><span class="line">        <span class="comment">// If card was just flipped and at front, change the card</span></span><br><span class="line">        <span class="keyword">if</span> flipped != value &amp;&amp; !flipped &#123;</span><br><span class="line">            <span class="keyword">self</span>.imgIndex = <span class="keyword">self</span>.imgIndex+<span class="number">1</span> &lt; <span class="keyword">self</span>.images.<span class="built_in">count</span> ? <span class="keyword">self</span>.imgIndex+<span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        flipped = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在本页顶部链接的gist文件中的 <strong>实例7</strong> 中找到。</p><p>=============================================================</p><p>如前所述，我们可能想使用两个完全不同的视图，而不是改变图像名称。这也是可以的，这里有一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Color</span>.clear.overlay(<span class="type">ViewSwapper</span>(showFront: flipped))</span><br><span class="line">    .frame(width: <span class="number">265</span>, height: <span class="number">400</span>)</span><br><span class="line">    .modifier(<span class="type">FlipEffect</span>(flipped: $flipped, angle: animate3d ? <span class="number">360</span> : <span class="number">0</span>, axis: (x: <span class="number">1</span>, y: <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewSwapper</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> showFront: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Group</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> showFront &#123;</span><br><span class="line">                <span class="type">FrontView</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">BackView</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="让视图遵循一个路径"><a href="#让视图遵循一个路径" class="headerlink" title="让视图遵循一个路径"></a>让视图遵循一个路径</h1><p>接下来，我们将建立一个完全不同的<code>GeometryEffect</code>。在这个例子中，我们的效果将通过一个任意的路径移动一个视图。这个问题有两个主要挑战:</p><p>1.如何获取路径中特定点的坐标。</p><p>2.如何在通过路径移动时确定视图的方向。在这个特定的案例中，我们如何知道飞机的机头指向哪里（扰流板警告，一点三角函数就可以了）。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/d463cca79f4a1dea31de5d7567b9855a.gif" alt=""></p><p>这个效果的可动画参数将是 pct。它代表飞机在路径中的位置。如果我们想让飞机执行一个完整的转弯，我们将使用0到1的值。对于一个0.25的值，它意味着飞机已经前进了1/4的路径。</p><h2 id="寻找路径中的x、y位置"><a href="#寻找路径中的x、y位置" class="headerlink" title="寻找路径中的x、y位置"></a>寻找路径中的x、y位置</h2><p>为了获得飞机在给定的pct值下的x和y位置，我们将使用<code>Path</code>结构体的 <a href="">.trimmedPath()</a> 修饰符。给定一个起点和终点百分比，该方法返回一个<code>CGRect</code>。它包含了该段路径的边界。根据我们的需求，我们只需用使用非常接近的起点和终点来调用它。它将返回一个非常小的矩形，我们将使用其中心作为我们的X和Y位置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">percentPoint</span><span class="params">(<span class="number">_</span> percent: CGFloat)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">    <span class="comment">// percent difference between points</span></span><br><span class="line">    <span class="keyword">let</span> diff: <span class="type">CGFloat</span> = <span class="number">0.001</span></span><br><span class="line">    <span class="keyword">let</span> comp: <span class="type">CGFloat</span> = <span class="number">1</span> - diff</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// handle limits</span></span><br><span class="line">    <span class="keyword">let</span> pct = percent &gt; <span class="number">1</span> ? <span class="number">0</span> : (percent &lt; <span class="number">0</span> ? <span class="number">1</span> : percent)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> f = pct &gt; comp ? comp : pct</span><br><span class="line">    <span class="keyword">let</span> t = pct &gt; comp ? <span class="number">1</span> : pct + diff</span><br><span class="line">    <span class="keyword">let</span> tp = path.trimmedPath(from: f, to: t)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGPoint</span>(x: tp.boundingRect.midX, y: tp.boundingRect.midY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找方向"><a href="#寻找方向" class="headerlink" title="寻找方向"></a>寻找方向</h2><p>为了获得我们平面的旋转角度，我们将使用一点三角函数。使用上面描述的技术，我们将得到两点的X和Y的位置：当前位置和刚才的位置。通过创建一条假想线，我们可以计算出它的角度，这就是飞机的方向了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateDirection</span><span class="params">(<span class="number">_</span> pt1: CGPoint,<span class="number">_</span> pt2: CGPoint)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = pt2.x - pt1.x</span><br><span class="line">    <span class="keyword">let</span> b = pt2.y - pt1.y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> angle = a &lt; <span class="number">0</span> ? atan(<span class="type">Double</span>(b / a)) : atan(<span class="type">Double</span>(b / a)) - <span class="type">Double</span>.pi</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGFloat</span>(angle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把所有的内容结合在一起"><a href="#把所有的内容结合在一起" class="headerlink" title="把所有的内容结合在一起"></a>把所有的内容结合在一起</h2><p>现在，我们知道了实现目标所需的工具，我们将实现这种效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FollowEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pct: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> path: <span class="type">Path</span></span><br><span class="line">    <span class="keyword">var</span> rotate = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> pct &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; pct = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !rotate &#123; <span class="comment">// Skip rotation login</span></span><br><span class="line">            <span class="keyword">let</span> pt = percentPoint(pct)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: pt.x, y: pt.y))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pt1 = percentPoint(pct)</span><br><span class="line">            <span class="keyword">let</span> pt2 = percentPoint(pct - <span class="number">0.01</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> angle = calculateDirection(pt1, pt2)</span><br><span class="line">            <span class="keyword">let</span> transform = <span class="type">CGAffineTransform</span>(translationX: pt1.x, y: pt1.y).rotated(by: angle)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(transform)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">percentPoint</span><span class="params">(<span class="number">_</span> percent: CGFloat)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">        <span class="comment">// percent difference between points</span></span><br><span class="line">        <span class="keyword">let</span> diff: <span class="type">CGFloat</span> = <span class="number">0.001</span></span><br><span class="line">        <span class="keyword">let</span> comp: <span class="type">CGFloat</span> = <span class="number">1</span> - diff</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// handle limits</span></span><br><span class="line">        <span class="keyword">let</span> pct = percent &gt; <span class="number">1</span> ? <span class="number">0</span> : (percent &lt; <span class="number">0</span> ? <span class="number">1</span> : percent)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> f = pct &gt; comp ? comp : pct</span><br><span class="line">        <span class="keyword">let</span> t = pct &gt; comp ? <span class="number">1</span> : pct + diff</span><br><span class="line">        <span class="keyword">let</span> tp = path.trimmedPath(from: f, to: t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGPoint</span>(x: tp.boundingRect.midX, y: tp.boundingRect.midY)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">calculateDirection</span><span class="params">(<span class="number">_</span> pt1: CGPoint,<span class="number">_</span> pt2: CGPoint)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = pt2.x - pt1.x</span><br><span class="line">        <span class="keyword">let</span> b = pt2.y - pt1.y</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> angle = a &lt; <span class="number">0</span> ? atan(<span class="type">Double</span>(b / a)) : atan(<span class="type">Double</span>(b / a)) - <span class="type">Double</span>.pi</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(angle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在本页面顶部链接的gist文件中以 <strong>Example8</strong> 的形式提供。</p><h2 id="Ignored-By-Layout"><a href="#Ignored-By-Layout" class="headerlink" title="Ignored By Layout"></a>Ignored By Layout</h2><p>我们对<code>GeometryEffect</code>的最后技巧是方 <a href="https://developer.apple.com/documentation/swiftui/geometryeffect/ignoredbylayout(" target="_blank" rel="noopener">.ignoredByLayout()</a>/) 。让我们看看文档中是怎么说的：</p><blockquote><p>Returns an effect that produces the same geometry transform as this effect, but only applies the transform while rendering its view.</p><p>返回一个产生与此效果相同的几何变换的效果，但只在渲染其视图时应用该变换。</p><p>Use this method to disable layout changes during transitions. The view ignores the transform returned by this method while the view is performing its layout calculations.</p><p>使用此方法可以在转换期间禁用布局更改。在视图执行布局计算时，视图将忽略此方法返回的变换。</p></blockquote><p>我很快就会介绍过渡的内容。同时，让我介绍一个例子，使用<code>.ignoredByLayout()</code>有一些明显的效果。我们将看到<code>GeometryReader</code>是如何报告不同的位置的，这取决于效果是如何被添加的（即，有或没有<code>.ignoredByLayout()</code>）。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/6227090f80410efbd2de83afea234609.gif" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> animate = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">5</span>)</span><br><span class="line">                .foregroundColor(.green)</span><br><span class="line">                .frame(width: <span class="number">300</span>, height: <span class="number">50</span>)</span><br><span class="line">                .overlay(<span class="type">ShowSize</span>())</span><br><span class="line">                .modifier(<span class="type">MyEffect</span>(x: animate ? -<span class="number">10</span> : <span class="number">10</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">5</span>)</span><br><span class="line">                .foregroundColor(.blue)</span><br><span class="line">                .frame(width: <span class="number">300</span>, height: <span class="number">50</span>)</span><br><span class="line">                .overlay(<span class="type">ShowSize</span>())</span><br><span class="line">                .modifier(<span class="type">MyEffect</span>(x: animate ? <span class="number">10</span> : -<span class="number">10</span>).ignoredByLayout())</span><br><span class="line">            </span><br><span class="line">        &#125;.onAppear &#123;</span><br><span class="line">            withAnimation(<span class="type">Animation</span>.easeInOut(duration: <span class="number">1.0</span>).repeatForever()) &#123;</span><br><span class="line">                <span class="keyword">self</span>.animate = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyEffect</span>: <span class="title">GeometryEffect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; x &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; x = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">effectValue</span><span class="params">(size: CGSize)</span></span> -&gt; <span class="type">ProjectionTransform</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ProjectionTransform</span>(<span class="type">CGAffineTransform</span>(translationX: x, y: <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShowSize</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"x = <span class="subst">\(Int(proxy.frame(<span class="keyword">in</span>: .global)</span>.minX))"</span>)</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接下来有什么内容？"><a href="#接下来有什么内容？" class="headerlink" title="接下来有什么内容？"></a>接下来有什么内容？</h1><p>我们今天所做的三个例子，几乎没有什么共同点，只是它们都使用相同的协议来实现其目标。<code>GeometryEffect</code>很简单：它只有一个方法需要实现，然而，它的可能性是无穷的，我们只需要运用一点想象力。</p><p>接下来，我们将介绍本系列的最后一个协议: <code>AnimatableModifier</code>。如果<code>GeometryEffect</code>很强大，那就等着看你能用<code>AnimatableModifier</code>做的所有精彩事情吧。下面是整个系列的一个快速预览:</p><p><a href="https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4" target="_blank" rel="noopener">https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4</a></p><blockquote><p>译自 <a href="https://swiftui-lab.com/" target="_blank" rel="noopener">The SwiftUI Lab</a> 的 <a href="https://swiftui-lab.com/swiftui-animations-part2/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 2: GeometryEffect</a></p><p>本文的完整示例代码可在以下位置找到：</p><p><a href="https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798" target="_blank" rel="noopener">https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798</a></p><p>示例8 需要的图片资源。从这里下载：</p><p><a href="https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916" target="_blank" rel="noopener">https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/c5eea293e62e03a91b514d2b1cea765f.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在本系列的第一部分，我介绍了&lt;code&gt;Animatable&lt;/code&gt;协议，以及我们如何使用它来为路径制作动画。接下来，我们将使用一个新的工具: &lt;code&gt;GeometryEffect&lt;/code&gt;，用同样的协议对变换矩阵进行动画处理。如果你没有读过第一部分，也不知道&lt;code&gt;Animatable&lt;/code&gt;协议是什么，你应该先读一下。或者如果你只是对&lt;code&gt;GeometryEffect&lt;/code&gt;感兴趣，不关心动画，你可以跳过第一部分，继续阅读本文。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>高级 SwiftUI 动画 — Part 1：Paths</title>
    <link href="https://fanbaoying.github.io/%E9%AB%98%E7%BA%A7-SwiftUI-%E5%8A%A8%E7%94%BB-%E2%80%94-Part-1%EF%BC%9APaths/"/>
    <id>https://fanbaoying.github.io/高级-SwiftUI-动画-—-Part-1：Paths/</id>
    <published>2022-04-06T02:30:47.000Z</published>
    <updated>2022-04-06T02:38:36.974Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2022/28c53aa3fd2e980731e70075a1857a27.png" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在本文中，我们将深入探讨一些创建 SwiftUI 动画的高级技术。我将广泛讨论 <a href="https://developer.apple.com/documentation/swiftui/animatable" target="_blank" rel="noopener">Animatable</a> 协议，它可靠的伙伴 <a href="https://developer.apple.com/documentation/swiftui/animatable/3046497-animatabledata" target="_blank" rel="noopener">animatableData</a>，强大但经常被忽略的 <a href="https://developer.apple.com/documentation/swiftui/geometryeffect" target="_blank" rel="noopener">GeometryEffect</a> 以及完全被忽视但全能的 <a href="https://developer.apple.com/documentation/swiftui/animatablemodifier" target="_blank" rel="noopener">AnimatableModifier</a> 协议。</p><p>这些都是被官方文档完全忽略的主题，在SwiftUI 的帖子和文章中也几乎没有提及。不过，它们还是为我们提供了创建一些相当不错的动画的工具。</p><p>在我们进入这些隐藏的瑰宝之前，我想对一些基本的 SwiftUI 动画概念做一个非常快速的总结。只是为了让我们能有共同语言，请耐心听我说。</p><a id="more"></a><h1 id="显式动画-VS-隐式动画"><a href="#显式动画-VS-隐式动画" class="headerlink" title="显式动画 VS 隐式动画"></a>显式动画 VS 隐式动画</h1><p>在SwiftUI中，有两种类型的动画。显式和隐式。<strong>隐式动画</strong>是你用 <code>.animation()</code> 修饰符指定的那些动画。每当视图上的可动画参数发生变化时，SwiftUI 就会从旧值到新值制作动画。一些可动画的参数包括大小(size)、偏移(offset)、颜色(color)、比例(scale)等。</p><p>显式动画是使用 <code>withAnimation{ … }</code> 指定的动画闭包。只有那些依赖于 <code>withAnimation</code> 闭包中改变值的参数才会被动画化。让我们尝试举一些例子来说明：</p><p>以下示例使用隐式动画更改图像的大小和不透明度：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example1</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> half = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> dim = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">"tower"</span>)</span><br><span class="line">            .scaleEffect(half ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .opacity(dim ? <span class="number">0.2</span> : <span class="number">1.0</span>)</span><br><span class="line">            .animation(.easeInOut(duration: <span class="number">1.0</span>))</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                <span class="keyword">self</span>.dim.toggle()</span><br><span class="line">                <span class="keyword">self</span>.half.toggle()</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://images.xiaozhuanlan.com/photo/2022/d06e59d9851af539adf53d2a90bdd2df.gif" alt=""></p><p>下面的示例使用显式动画。在这里，缩放和不透明度都会更改，但只有不透明度会设置动画，因为它是 <code>withAnimation</code> 闭包中唯一更改的参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> half = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> dim = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">"tower"</span>)</span><br><span class="line">            .scaleEffect(half ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .opacity(dim ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                <span class="keyword">self</span>.half.toggle()</span><br><span class="line">                </span><br><span class="line">                withAnimation(.easeInOut(duration: <span class="number">1.0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.dim.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images.xiaozhuanlan.com/photo/2022/e5d5999cb7891fa51bd59609c7cb190f.gif" alt=""></p><p>请注意，通过更改修饰符的前后顺序，可以使用隐式动画创建相同的效果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example2</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> half = <span class="literal">false</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> dim = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Image</span>(<span class="string">"tower"</span>)</span><br><span class="line">            .opacity(dim ? <span class="number">0.2</span> : <span class="number">1.0</span>)</span><br><span class="line">            .animation(.easeInOut(duration: <span class="number">1.0</span>))</span><br><span class="line">            .scaleEffect(half ? <span class="number">0.5</span> : <span class="number">1.0</span>)</span><br><span class="line">            .onTapGesture &#123;</span><br><span class="line">                <span class="keyword">self</span>.dim.toggle()</span><br><span class="line">                <span class="keyword">self</span>.half.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要禁用动画，可以使用 <code>.animation(nil)</code>。</p><h2 id="动画是如何工作的"><a href="#动画是如何工作的" class="headerlink" title="动画是如何工作的"></a>动画是如何工作的</h2><p>在所有SwiftUI动画的背后，有一个名为 <strong>Animatable</strong> 的协议。我们将在后面讨论细节，但主要是，它拥有一个计算属性，其类型遵守 <code>VectorArithmetic</code> 协议。这使得框架可以随意地插值。</p><p>当给一个视图制作动画时，SwiftUI 实际上是多次重新生成该视图，并且每次都修改动画参数。这样，它就会从原点值渐渐走向最终值。</p><p>假设我们为一个视图的不透明度创建一个线性动画。我们打算从 0.3 到 0.8。该框架将多次重新生成视图，以小幅度的增量来改变不透明度。由于不透明度是以 <code>Double</code>表示的，而且<code>Double</code> 遵守 VectorArithmetic` 协议，SwiftUI 可以插值出所需的不透明度值。在框架代码的某个地方，可能有一个类似的算法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> from:<span class="type">Double</span> = <span class="number">0.3</span></span><br><span class="line"><span class="keyword">let</span> to:<span class="type">Double</span> = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">6</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pct = <span class="type">Double</span>(i) / <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> difference = to - from</span><br><span class="line">    difference.scale(by: pct)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> currentOpacity = from + difference</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"currentOpacity = <span class="subst">\(currentOpacity)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码将创建从起点到终点的渐进式更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentOpacity = 0.3</span><br><span class="line">currentOpacity = 0.4</span><br><span class="line">currentOpacity = 0.5</span><br><span class="line">currentOpacity = 0.6</span><br><span class="line">currentOpacity = 0.7</span><br><span class="line">currentOpacity = 0.8</span><br></pre></td></tr></table></figure><h1 id="为什么我关心-Animatable？"><a href="#为什么我关心-Animatable？" class="headerlink" title="为什么我关心 Animatable？"></a>为什么我关心 <code>Animatable</code>？</h1><p>你可能会问，为什么我需要关心所有这些小细节。SwiftUI 已经为不透明度制作了动画，而不需要我担心这一切。是的，这是真的，但只要 SwiftUI 知道如何将数值从原点插值到终点。对于不透明度，这是一个直接的过程，SwiftUI 知道该怎么做。然而，正如我们接下来要看到的，情况并非总是如此。</p><p>我想到了一些大的例外情况：路径(paths)、变换矩阵(matrices)和任意的视图变化（例如，文本视图中的文本、渐变视图中的渐变颜色或停顿，等等）。在这种情况下，框架不知道该怎么做。我们将在本文的第二和第三部分中讨论转换矩阵和视图变化。目前，让我们把重点放在形状(shapes)上。</p><h2 id="形状路径的动画化"><a href="#形状路径的动画化" class="headerlink" title="形状路径的动画化"></a>形状路径的动画化</h2><p>想象一下，你有一个形状，使用路径来绘制一个规则的多边形。我们的实现当然会让你指出这个多边形将有多少条边。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PolygonShape</span>(sides: <span class="number">3</span>).stroke(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line"><span class="type">PolygonShape</span>(sides: <span class="number">4</span>).stroke(<span class="type">Color</span>.purple, lineWidth: <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><img src="https://images.xiaozhuanlan.com/photo/2022/af3cc99556499081e410cfed1a59cf16.png" alt=""></p><p>下面是我们的<code>PolygonShape</code>的实现。请注意，我使用了一点三角学的知识。这对理解这篇文章的主题并不重要，但如果你想了解更多关于它的信息，我写了另一篇文章，阐述了基础知识。你可以在 “<a href="https://swiftui-lab.com/trigonometric-recipes-for-swiftui/" target="_blank" rel="noopener">SwiftUI 的三角公式</a> “中阅读更多内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="type">Path</span> &#123;        </span><br><span class="line">        <span class="comment">// hypotenuse</span></span><br><span class="line">        <span class="keyword">let</span> h = <span class="type">Double</span>(<span class="built_in">min</span>(rect.size.width, rect.size.height)) / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// center</span></span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">CGPoint</span>(x: rect.size.width / <span class="number">2.0</span>, y: rect.size.height / <span class="number">2.0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> path = <span class="type">Path</span>()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;sides &#123;</span><br><span class="line">            <span class="keyword">let</span> angle = (<span class="type">Double</span>(i) * (<span class="number">360.0</span> / <span class="type">Double</span>(sides))) * <span class="type">Double</span>.pi / <span class="number">180</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate vertex position</span></span><br><span class="line">            <span class="keyword">let</span> pt = <span class="type">CGPoint</span>(x: <span class="built_in">c</span>.x + <span class="type">CGFloat</span>(cos(angle) * h), y: <span class="built_in">c</span>.y + <span class="type">CGFloat</span>(sin(angle) * h))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                path.move(to: pt) <span class="comment">// move to first vertex</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path.addLine(to: pt) <span class="comment">// draw line to next vertex</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path.closeSubpath()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以更进一步，尝试使用与不透明度相同的方法对形状边数(<code>sides</code>)参数进行动画处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PolygonShape</span>(sides: isSquare ? <span class="number">4</span> : <span class="number">3</span>)</span><br><span class="line">    .stroke(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">    .animation(.easeInOut(duration: duration))</span><br></pre></td></tr></table></figure><p>你认为 SwiftUI 将如何把三角形转化为正方形？你可能猜到了。它不会的。当然，框架不知道如何给它做动画。你可以随心所欲地使用<code>.animation()</code>，但这个形状会从三角形跳到正方形，而且没有任何动画。原因很简单：你只教了 SwiftUI 如何画一个 3 边的多边形，或 4 边的多边形，但你的代码却不知道如何画一个 3.379 边的多边形!</p><p>因此，为了使动画发生，我们需要两件事:</p><ol><li><p>我们需要改变形状的代码，使其知道如何绘制边数为非整数的多边形。</p></li><li><p>让框架多次生成这个形状，并让可动画参数一点点变化。也就是说，我们希望这个形状被要求绘制多次，每次都有一个不同的边数数值：3、3.1、3.15、3.2、3.25，一直到 4。</p></li></ol><p>一旦我们把这两点做到位，我们将能够在任何数量的边数之间制作动画:</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/c12634ccd556d04558154aa3e50ba902.gif" alt=""></p><p><strong>创建可动画数据(<code>animatableData</code>)</strong></p><p>为了使形状可动画化，我们需要 SwiftUI 多次渲染视图，使用从原点到目标数之间的所有边值。幸运的是，<code>Shape</code>已经符合了<code>Animatable</code>协议的要求。这意味着，有一个计算的属性（<code>animatableData</code>），我们可以用它来处理这个任务。然而，它的默认实现被设置为<code>EmptyAnimatableData</code>。所以它什么都不做。</p><p>为了解决我们的问题，我们将首先改变边的属性的类型，从<code>Int</code>到<code>Double</code>。这样我们就可以有小数的数字。我们将在后面讨论如何保持该属性为<code>Int</code>，并仍然执行动画。但是现在，为了使事情简单，我们只使用<code>Double</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Double</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们需要创建我们的计算属性<code>animatableData</code>。在这种情况下，它非常简单。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> sides &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; sides = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用小数画边</strong></p><p>最后，我们需要教 SwiftUI 如何绘制一个边数为非整数的多边形。我们将稍微改变我们的代码。随着小数部分的增长，这个新的边将从零到全长。其他顶点将相应地平稳地重新定位。这听起来很复杂，但这是一个最小的变化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="type">Path</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hypotenuse</span></span><br><span class="line">        <span class="keyword">let</span> h = <span class="type">Double</span>(<span class="built_in">min</span>(rect.size.width, rect.size.height)) / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// center</span></span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">CGPoint</span>(x: rect.size.width / <span class="number">2.0</span>, y: rect.size.height / <span class="number">2.0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> path = <span class="type">Path</span>()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">let</span> extra: <span class="type">Int</span> = <span class="type">Double</span>(sides) != <span class="type">Double</span>(<span class="type">Int</span>(sides)) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="type">Int</span>(sides) + extra &#123;</span><br><span class="line">            <span class="keyword">let</span> angle = (<span class="type">Double</span>(i) * (<span class="number">360.0</span> / <span class="type">Double</span>(sides))) * <span class="type">Double</span>.pi / <span class="number">180</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate vertex</span></span><br><span class="line">            <span class="keyword">let</span> pt = <span class="type">CGPoint</span>(x: <span class="built_in">c</span>.x + <span class="type">CGFloat</span>(cos(angle) * h), y: <span class="built_in">c</span>.y + <span class="type">CGFloat</span>(sin(angle) * h))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                path.move(to: pt) <span class="comment">// move to first vertex</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path.addLine(to: pt) <span class="comment">// draw line to next vertex</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path.closeSubpath()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在文章顶部链接的 gist 文件中以 <strong>Example1</strong> 的形式提供。</p><p>如前所述，对于我们这个形状的用户来说，边的参数是一个<code>Double</code>，这可能显得很奇怪。人们应该期望边是一个<code>Int</code>参数。幸运的是，我们可以再次改变我们的代码，把这个事实隐藏在我们的形状的实现中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> sidesAsDouble: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> sidesAsDouble &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; sidesAsDouble = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(sides: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides = sides</span><br><span class="line">        <span class="keyword">self</span>.sidesAsDouble = <span class="type">Double</span>(sides)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些变化，我们在内部使用<code>Double</code>，但在外部则使用<code>Int</code>。现在它看起来更优雅了。不要忘记修改绘图代码，这样它就会使用<code>sidesAsDouble</code> 而不是<code>sides</code>。完整的代码可以在文章顶部链接的 gist 文件中的 <strong>Example2</strong> 中找到。</p><h2 id="设置多个参数的动画"><a href="#设置多个参数的动画" class="headerlink" title="设置多个参数的动画"></a>设置多个参数的动画</h2><p>很多时候，我们会发现自己需要对一个以上的参数进行动画处理。单一的<code>Double</code>是不够的。在这些时候，我们可以使用<code>AnimatablePair&lt;First, Second&gt;</code>。这里，第一和第二都是符合<code>VectorArithmetic</code>的类型。例如<code>AnimatablePair&lt;CGFloat, Double&gt;</code>。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/a9d74ce65e124f4181701f5f5616253e.gif" alt=""></p><p>为了演示 <code>AnimatablePair</code> 的使用，我们将修改我们的例子。现在我们的多边形形状将有两个参数：边和比例。两者都将用<code>Double</code>来表示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PolygonShape</span>: <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sides: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> scale: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">AnimatablePair</span>&lt;<span class="type">Double</span>, <span class="type">Double</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">AnimatablePair</span>(sides, scale) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sides = newValue.first</span><br><span class="line">            scale = newValue.second</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码可在文章顶部链接的 gist 文件中的 <strong>Example3</strong> 中找到。同一个文件中的<strong>Example4</strong>，有一个更复杂的路径。它基本上是相同的形状，但增加了一条连接每个顶点的线。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/cc060bf316c70d480d9c64dcf75f562d.gif" alt=""></p><h2 id="超过两个可动画的参数"><a href="#超过两个可动画的参数" class="headerlink" title="超过两个可动画的参数"></a>超过两个可动画的参数</h2><p>如果你浏览一下 SwiftUI 的声明文件，你会发现该框架相当广泛地使用<code>AnimatablePair</code>。比如说。<code>CGSize</code>、<code>CGPoint</code>、<code>CGRect</code>。尽管这些类型不符合<code>VectorArithmetic</code>，但它们可以被动画化，因为它们确实符合<code>Animatable</code>。</p><p>他们都以这样或那样的方式使用<code>AnimatablePair</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span> : <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnimatableData</span> = <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> animatableData: <span class="type">CGPoint</span>.<span class="type">AnimatableData</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span> : <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnimatableData</span> = <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> animatableData: <span class="type">CGSize</span>.<span class="type">AnimatableData</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGRect</span> : <span class="title">Animatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnimatableData</span> = <span class="type">AnimatablePair</span>&lt;<span class="type">CGPoint</span>.<span class="type">AnimatableData</span>, <span class="type">CGSize</span>.<span class="type">AnimatableData</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> animatableData: <span class="type">CGRect</span>.<span class="type">AnimatableData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你仔细注意一下 <code>CGRect</code>，你会发现它实际上是在使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnimatablePair</span>&lt;<span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;, <span class="type">AnimatablePair</span>&lt;<span class="type">CGFloat</span>, <span class="type">CGFloat</span>&gt;&gt;</span><br></pre></td></tr></table></figure><p>这意味着矩形的 x、y、宽度和高度值可以通过 <code>first.first</code>、<code>first.second</code>、<code>second.first</code>和<code>second.second</code>访问。</p><h2 id="使你自己的类型动画化（通过VectorArithmetic）"><a href="#使你自己的类型动画化（通过VectorArithmetic）" class="headerlink" title="使你自己的类型动画化（通过VectorArithmetic）"></a>使你自己的类型动画化（通过<code>VectorArithmetic</code>）</h2><p>以下类型默认实现了 <code>Animatable</code> : <code>Angle</code>, <code>CGPoint</code>, <code>CGRect</code>, <code>CGSize</code>, <code>EdgeInsets</code>, <code>StrokeStyle</code> 和 <code>UnitPoint</code>。以下类型符合<code>VectorArithmetic</code>。<code>AnimatablePair</code>, <code>CGFloat</code>, <code>Double</code>, <code>EmptyAnimatableData</code> 和 <code>Float</code>。你可以使用它们中的任何一种来为你的形状制作动画。</p><p>现有的类型提供了足够的灵活性来实现任何东西的动画。然而，如果你发现自己有一个想做动画的复杂类型，没有什么能阻止你添加自己的<code>VectorArithmetic</code>协议的实现。事实上，我们将在下一个例子中这样做。</p><p>为了说明这一点，我们将创建一个模拟时钟形状。它将根据一个自定义的可动画的参数类型移动它的指针：<code>ClockTime</code>。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/631640b6fd2099e4ccd9bcce295dade7.gif" alt=""></p><p>我们将像这样使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClockShape</span>(clockTime: show ? <span class="type">ClockTime</span>(<span class="number">9</span>, <span class="number">51</span>, <span class="number">15</span>) : <span class="type">ClockTime</span>(<span class="number">9</span>, <span class="number">55</span>, <span class="number">00</span>))</span><br><span class="line">    .stroke(<span class="type">Color</span>.blue, lineWidth: <span class="number">3</span>)</span><br><span class="line">    .animation(.easeInOut(duration: duration))</span><br></pre></td></tr></table></figure><p>首先，我们开始创建我们的自定义类型<code>ClockTime</code>。它包含三个属性（小时、分钟和秒），几个有用的初始化器，以及一些辅助计算的属性和方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClockTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hours: <span class="type">Int</span>      <span class="comment">// Hour needle should jump by integer numbers</span></span><br><span class="line">    <span class="keyword">var</span> minutes: <span class="type">Int</span>    <span class="comment">// Minute needle should jump by integer numbers</span></span><br><span class="line">    <span class="keyword">var</span> seconds: <span class="type">Double</span> <span class="comment">// Second needle should move smoothly</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initializer with hour, minute and seconds</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> h: <span class="type">Int</span>, <span class="number">_</span> m: <span class="type">Int</span>, <span class="number">_</span> s: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.hours = h</span><br><span class="line">        <span class="keyword">self</span>.minutes = m</span><br><span class="line">        <span class="keyword">self</span>.seconds = s</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initializer with total of seconds</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> seconds: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> h = <span class="type">Int</span>(seconds) / <span class="number">3600</span></span><br><span class="line">        <span class="keyword">let</span> m = (<span class="type">Int</span>(seconds) - (h * <span class="number">3600</span>)) / <span class="number">60</span></span><br><span class="line">        <span class="keyword">let</span> s = seconds - <span class="type">Double</span>((h * <span class="number">3600</span>) + (m * <span class="number">60</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.hours = h</span><br><span class="line">        <span class="keyword">self</span>.minutes = m</span><br><span class="line">        <span class="keyword">self</span>.seconds = s</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compute number of seconds</span></span><br><span class="line">    <span class="keyword">var</span> asSeconds: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Double</span>(<span class="keyword">self</span>.hours * <span class="number">3600</span> + <span class="keyword">self</span>.minutes * <span class="number">60</span>) + <span class="keyword">self</span>.seconds</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// show as string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: <span class="string">"%2i"</span>, <span class="keyword">self</span>.hours) + <span class="string">":"</span> + <span class="type">String</span>(format: <span class="string">"%02i"</span>, <span class="keyword">self</span>.minutes) + <span class="string">":"</span> + <span class="type">String</span>(format: <span class="string">"%02f"</span>, <span class="keyword">self</span>.seconds)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，为了符合<code>VectorArithmetic</code>协议，我们需要编写以下方法和计算属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ClockTime</span>: <span class="title">VectorArithmetic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> zero: <span class="type">ClockTime</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClockTime</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> magnitudeSquared: <span class="type">Double</span> &#123; <span class="keyword">return</span> asSeconds * asSeconds &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -= <span class="params">(lhs: <span class="keyword">inout</span> ClockTime, rhs: ClockTime)</span></span> &#123;</span><br><span class="line">        lhs = lhs - rhs</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> - <span class="params">(lhs: ClockTime, rhs: ClockTime)</span></span> -&gt; <span class="type">ClockTime</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClockTime</span>(lhs.asSeconds - rhs.asSeconds)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> += <span class="params">(lhs: <span class="keyword">inout</span> ClockTime, rhs: ClockTime)</span></span> &#123;</span><br><span class="line">        lhs = lhs + rhs</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> + <span class="params">(lhs: ClockTime, rhs: ClockTime)</span></span> -&gt; <span class="type">ClockTime</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ClockTime</span>(lhs.asSeconds + rhs.asSeconds)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">scale</span><span class="params">(by rhs: Double)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="type">Double</span>(<span class="keyword">self</span>.asSeconds)</span><br><span class="line">        s.scale(by: rhs)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> ct = <span class="type">ClockTime</span>(s)</span><br><span class="line">        <span class="keyword">self</span>.hours = ct.hours</span><br><span class="line">        <span class="keyword">self</span>.minutes = ct.minutes</span><br><span class="line">        <span class="keyword">self</span>.seconds = ct.seconds</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一要做的，就是写出形状来适当地定位针头。时钟形状的完整代码，可在本文顶部链接的gist文件中的  <strong>Example5</strong> 中找到。</p><h1 id="SwiftUI-Metal"><a href="#SwiftUI-Metal" class="headerlink" title="SwiftUI + Metal"></a>SwiftUI + Metal</h1><p>如果你发现自己正在编写复杂的动画，你可能会开始看到你的设备受到影响，同时试图跟上所有的绘图。如果是这样，你肯定会从启用金属的使用中受益。这里有一个例子，说明启用 Metal 后，一切都会变得不同。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/1f7298958b84e19cf6b5ca133e2c8fd5.gif" alt=""></p><p>在模拟器上运行时，你可能感觉不到有什么不同。然而，在真正的设备上，你会发现。视频演示来自iPad第六代（2016）。完整的代码在 gist 文件中，名称为 <strong>Example6</strong>。</p><p>幸运的是，启用 Metal，是非常容易的。你只需要添加 <code>.drawingGroup()</code> 修饰符:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FlowerView</span>().drawingGroup()</span><br></pre></td></tr></table></figure><p>根据 WWDC 2019, Session 237（<a href="https://developer.apple.com/videos/play/wwdc2019/237/" target="_blank" rel="noopener">用SwiftUI构建自定义视图</a>）：绘图组是一种特殊的渲染方式，但只适用于图形等东西。它基本上会将 SwiftUI 视图平铺到一个单一的 NSView/UIView 中，并用 Metal 进行渲染。跳到 WWDC 视频到37:27 了解更多细节。</p><p>如果你想尝试一下，但你的形状还没有复杂到让设备挣扎的地步，添加一些渐变和阴影，你会立即看到不同。</p><h1 id="接下来有什么内容？"><a href="#接下来有什么内容？" class="headerlink" title="接下来有什么内容？"></a>接下来有什么内容？</h1><p>在本文的第二部分，我们将学习如何使用 <code>GeometryEffect</code> 协议。它将打开改变我们的视图和动画的新方法的大门。与 <code>Paths</code> 一样，SwiftUI 没有关于如何在两个不同的变换矩阵之间转换的内置知识。<code>GeometryEffect</code>将有助于我们这样做。</p><p>目前，SwiftUI 没有关键帧功能。我们将看到我们如何用一个基本的动画来模拟一个。</p><p>在文章的第三部分，我们将介绍AnimatableModifier，这是一个非常强大的工具，它可以让我们对视图中任何可以变化的东西进行动画处理，甚至是文本！在这个系列的第三部分中，我们将介绍一些动画实例。关于这三部分系列中的一些动画例子，请看下面的视频: </p><p><a href="https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4" target="_blank" rel="noopener">https://swiftui-lab.com/wp-content/uploads/2019/08/animations.mp4</a></p><blockquote><p>译自 The SwiftUI Lab 的 <a href="https://swiftui-lab.com/swiftui-animations-part1/" target="_blank" rel="noopener">Advanced SwiftUI Animations – Part 1: Paths</a></p><p>本文的完整示例代码可在以下网址找到：<br><a href="https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798" target="_blank" rel="noopener">https://gist.github.com/swiftui-lab/e5901123101ffad6d39020cc7a810798</a></p><p>示例8 需要的图片资源，可在这里下载：<br><a href="https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916" target="_blank" rel="noopener">https://swiftui-lab.com/?smd_process_download=1&amp;download_id=916</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2022/28c53aa3fd2e980731e70075a1857a27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在本文中，我们将深入探讨一些创建 SwiftUI 动画的高级技术。我将广泛讨论 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/animatable&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Animatable&lt;/a&gt; 协议，它可靠的伙伴 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/animatable/3046497-animatabledata&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;animatableData&lt;/a&gt;，强大但经常被忽略的 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/geometryeffect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GeometryEffect&lt;/a&gt; 以及完全被忽视但全能的 &lt;a href=&quot;https://developer.apple.com/documentation/swiftui/animatablemodifier&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AnimatableModifier&lt;/a&gt; 协议。&lt;/p&gt;
&lt;p&gt;这些都是被官方文档完全忽略的主题，在SwiftUI 的帖子和文章中也几乎没有提及。不过，它们还是为我们提供了创建一些相当不错的动画的工具。&lt;/p&gt;
&lt;p&gt;在我们进入这些隐藏的瑰宝之前，我想对一些基本的 SwiftUI 动画概念做一个非常快速的总结。只是为了让我们能有共同语言，请耐心听我说。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI 动画" scheme="https://fanbaoying.github.io/categories/SwiftUI-%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 29 两数相除</title>
    <link href="https://fanbaoying.github.io/LeetCode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <id>https://fanbaoying.github.io/LeetCode-29-两数相除/</id>
    <published>2022-04-01T08:59:35.000Z</published>
    <updated>2022-05-25T07:26:21.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 29 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p><p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code>。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7/-3 = truncate(-2.33333..) = -2</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>被除数和除数均为 <code>32</code> 位有符号整数。</li><li>除数不为 <code>0</code>。</li><li>假设我们的环境只能存储 <code>32</code> 位有符号整数，其数值范围是 <code>[−231,  231 − 1]</code>。本题中，如果除法结果溢出，则返回 2^31 − 1。</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DivideTwoIntegers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(<span class="number">_</span> dividend: Int, <span class="number">_</span> divisor: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> isPositive = (dividend &lt; <span class="number">0</span>) == (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> dividend = <span class="built_in">abs</span>(dividend), divisor = <span class="built_in">abs</span>(divisor), <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor &#123;</span><br><span class="line">            <span class="keyword">var</span> shift = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> dividend &gt;= (divisor &lt;&lt; shift) &#123;</span><br><span class="line">                shift += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dividend -= divisor &lt;&lt; (shift - <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">count</span> += (<span class="number">1</span> &lt;&lt; (shift - <span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> refactorCount(<span class="built_in">count</span>, isPositive)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refactorCount</span><span class="params">(<span class="number">_</span> <span class="built_in">count</span>: Int, <span class="number">_</span> isPositive: Bool)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="type">INTMAX</span> = <span class="number">2147483647</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">count</span> = <span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isPositive &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="type">INTMAX</span> &#123;</span><br><span class="line">                <span class="built_in">count</span> = <span class="type">INTMAX</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">count</span> *= -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用左移和减法得到每个数字的个数。</li><li>时间复杂度： O(logn)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/divide-two-integers/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 29 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 28 实现 strStr()</title>
    <link href="https://fanbaoying.github.io/LeetCode-28-%E5%AE%9E%E7%8E%B0-strStr/"/>
    <id>https://fanbaoying.github.io/LeetCode-28-实现-strStr/</id>
    <published>2022-04-01T08:59:27.000Z</published>
    <updated>2022-05-25T07:26:24.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 27 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>实现 <code>strStr()</code> 函数。</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code>，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  <code>-1</code> 。</p><p><strong>说明：</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <code>strstr()</code> 以及 Java 的 <code>indexOf()</code> 定义相符。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;&quot;, needle = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= haystack.length, needle.length &lt;= 5 * 10^4</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrStr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(<span class="number">_</span> haystack: String, <span class="number">_</span> needle: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> hChars = <span class="type">Array</span>(haystack.characters), nChars = <span class="type">Array</span>(needle.characters)</span><br><span class="line">        <span class="keyword">let</span> hLen = hChars.<span class="built_in">count</span>, nLen = nChars.<span class="built_in">count</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">guard</span> hLen &gt;= nLen <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> nLen != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...hLen - nLen &#123;</span><br><span class="line">            <span class="keyword">if</span> hChars[i] == nChars[<span class="number">0</span>] &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;nLen &#123;</span><br><span class="line">                    <span class="keyword">if</span> hChars[i + j] != nChars[j] &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> j + <span class="number">1</span> == nLen &#123;</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：保留一个索引，向前移动时将该索引处的元素与 val 进行比较</li><li>时间复杂度： O(nm)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/implement-strstr/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 27 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 27 移除元素</title>
    <link href="https://fanbaoying.github.io/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>https://fanbaoying.github.io/LeetCode-27-移除元素/</id>
    <published>2022-04-01T08:59:04.000Z</published>
    <updated>2022-05-25T07:26:27.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 26 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <code>原地</code> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <code>原地</code> <strong>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">inout</span> nums: [Int], <span class="number">_</span> val: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        nums = nums.<span class="built_in">filter</span> &#123; (num) <span class="keyword">in</span> num != val &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：保留一个索引，向前移动时将该索引处的元素与 val 进行比较</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/remove-element/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 26 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
