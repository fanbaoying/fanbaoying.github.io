<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2022-08-01T06:04:49.531Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift 周报 第十期</title>
    <link href="https://fanbaoying.github.io/Swift-%E5%91%A8%E6%8A%A5-%E7%AC%AC%E5%8D%81%E6%9C%9F/"/>
    <id>https://fanbaoying.github.io/Swift-周报-第十期/</id>
    <published>2022-08-01T06:01:43.000Z</published>
    <updated>2022-08-01T06:04:49.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png" alt=""></p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几期周报内容是同步翻译的英文版周报，目前英文版停更，周报停滞半年多。经过多次讨论，我们决定<strong>重启周报</strong>，分模块整理内容同步给大家。</p><p>周报内容模块分为：<strong>新闻</strong>、<strong>提案</strong>、<strong>Swift论坛</strong>、<strong>推荐博文</strong>。初期计划每两周发布一期，欢迎志同道合的朋友一起加入周报整理。</p><p>昨日的生活与工作是否也曾迷茫？对新技术渴望突破的心是否依旧执着？<strong>Swift社区</strong>，为你的技术栈添砖加瓦，你，准备好了吗？</p><h2 id="新闻和社区"><a href="#新闻和社区" class="headerlink" title="新闻和社区"></a>新闻和社区</h2><h3 id="苹果先买后付服务被警告：破坏这一新兴行业的竞争"><a href="#苹果先买后付服务被警告：破坏这一新兴行业的竞争" class="headerlink" title="苹果先买后付服务被警告：破坏这一新兴行业的竞争"></a>苹果先买后付服务被警告：破坏这一新兴行业的竞争</h3><p>据英国《金融时报》7月27日报道，美国消费者金融保护局罗希特·乔普拉向硅谷发出警告。大型科技公司进入“先买后付”贷款业务会破坏这一新兴行业的竞争，他还对客户数据的使用提出了质疑。此前6月6日苹果公司在年度开发者大会上推出“先买后付”的<code>“Apple Pay Later”</code>服务，允许用户6周内分4期付款，期间不产生利息等其他费用。（via 泰山财经）</p><h3 id="与-App-Store-专家会面交流"><a href="#与-App-Store-专家会面交流" class="headerlink" title="与 App Store 专家会面交流"></a>与 App Store 专家会面交流</h3><p>准备好与专家在线交流探讨，了解如何充分利用 <code>App Store</code> 的功能。探索如何吸引新顾客、测试营销策略、添加订阅等等。在整个 8 月，苹果官方将在多个时区以多种语言进行实时演讲和答疑。如果您也是苹果开发者的话，最近肯定收到了相关的邮件邀请吧，不知道您是否参加了本次会面交流呢？（Apple Developer Program）</p><h3 id="即将从-XML-Feed-过渡到-App-Store-Connect-API"><a href="#即将从-XML-Feed-过渡到-App-Store-Connect-API" class="headerlink" title="即将从 XML Feed 过渡到 App Store Connect API"></a>即将从 XML Feed 过渡到 App Store Connect API</h3><p><code>App Store Connect REST API</code> 让您可以跨各种开发者工具自定义任务并实现任务自动化，使工作流程更灵活、更高效。从 <strong>2022 年 11 月</strong>开始，您将需要使用此 API 来代替 <code>XML Feed</code>，从而实现对 App 内购买项目、订阅、元数据和 App 定价的自动化管理。XML Feed 将继续为现有的 <code>Game Center</code> 管理功能提供支持。（Apple Developer News）</p><h3 id="新功能-RoomPlan"><a href="#新功能-RoomPlan" class="headerlink" title="新功能 RoomPlan"></a>新功能 RoomPlan</h3><p>使用 <a href="https://developer.apple.com/augmented-reality/roomplan/" title="Introducing RoomPlan" target="_blank" rel="noopener">RoomPlan</a> 创建房间的 3D 户型图，包括家具的尺寸和类型等关键特征。这个是由 ARKit 提供支持的全新 Swift API 能够利用 iPhone 和 iPad 上的摄像头和激光雷达扫描仪将现实环境带入您的 App 中。</p><p><img src="https://github.com/SwiftCommunityRes/image/blob/main/weekly/weeklynew01.png?raw=true" alt=""></p><p>使用详情可以观看 WWDC22 中的 <a href="https://developer.apple.com/videos/play/wwdc2022/10127/" title="Create parametric 3D room scans with RoomPlan" target="_blank" rel="noopener">使用 RoomPlan 创建参数 3D 房间扫描</a></p><h3 id="立即注册-WWDC22-实验室和聊天室"><a href="#立即注册-WWDC22-实验室和聊天室" class="headerlink" title="立即注册 WWDC22 实验室和聊天室"></a>立即注册 WWDC22 实验室和聊天室</h3><p><a href="https://developer.apple.com/news/?id=kvwb7ph4" title="Sign up now for WWDC22 labs and lounges" target="_blank" rel="noopener">注册实验室和线上聊天室</a>，即可在一整周内与 Apple 工程师、设计师和专家在线交流。</p><p><img src="https://github.com/SwiftCommunityRes/image/blob/main/weekly/weeklynew02.png?raw=true" alt=""></p><h3 id="已推出-Xcode-14-Beta-版"><a href="#已推出-Xcode-14-Beta-版" class="headerlink" title="已推出 Xcode 14 Beta 版"></a>已推出 Xcode 14 Beta 版</h3><p>包含了适用于所有 Apple 平台 SDK 的 <code>Xcode 14 Beta</code> 版现已推出。利用简洁且强大的 Swift 和 SwiftUI 以及全新的跨平台 App 体验，使用编辑器的增强功能更快捷地编写代码，并着手开始进行从 <code>Xcode Cloud</code> 到 <code>TestFlight</code> 以及 <code>App Store</code> 的测试和部署。</p><p><a href="https://developer.apple.com/xcode/" title="Xcode 14 Beta" target="_blank" rel="noopener">下载 Xcode 14 Beta 版</a></p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><h3 id="通过的提案"><a href="#通过的提案" class="headerlink" title="通过的提案"></a>通过的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0352-implicit-open-existentials.md#introduction" title="Implicitly Opened Existentials" target="_blank" rel="noopener">SE-0352: 隐式开放的存在类型</a> <strong>状态：Swift 5.7 已实现</strong><br>Swift 中的存在类型允许存储一个特定类型为未知的值，且可能在运行时更改。被存储值的动态类型，我们称为<strong>存在类型的底层类型</strong>，仅由它遵循的协议集以及潜在的超类知道。尽管存在类型对于表达动态类型的值非常有用，但由于它们的动态性质，它们受到一定限制。最近的提议使<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md" title="existential types more explicit" target="_blank" rel="noopener">存在类型更加明确</a>，以帮助开发人员理解这种动态性质，并通过消除一些限制<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md" title="making existential types more expressive" target="_blank" rel="noopener">使存在类型更具表现力</a>。但是存在类型中的基本类型仍然存在，一旦你有一个存在类型的值，你就很难对其使用泛型。开发者通常会遇到 <code>protocol &#39;P&#39; as a type cannot conform to itself</code> 这样的报错问题。</p><p><strong>SE-0352: 隐式开放的存在类型</strong> 已于 2022 年 5 月 18 日完成，核心团队已决定接受该提案。第二次审查的重点是关注向前兼容性，当一个调用唤起一个隐式开放的存在类型，必须被抹除类型以防止存在的动态类型内存泄漏到返回值中。当存在类型的表达能力增加，我们可能会有能力使用一个更具体的类型作为这一个调用的返回类型，这可能造成源中断。为了避免这种情况，该提案要求在调用中显式地作为任何 P 类型注释，其中当前可以表达的返回类型将丢弃对被类型擦除的原始关联类型的约束，如提案中的示例所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  associatedtype <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Q</span> </span>&#123;</span><br><span class="line">  associatedtype <span class="type">B</span>: <span class="type">P</span> <span class="keyword">where</span> <span class="type">B</span>.<span class="type">A</span> == <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getP</span>&lt;T: P&gt;<span class="params">(<span class="number">_</span> p: T)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBFromQ</span>&lt;T: Q&gt;<span class="params">(<span class="number">_</span> q: T)</span></span> -&gt; <span class="type">T</span>.<span class="type">B</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseQAssoc</span><span class="params">(q: any Q)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x = getBFromQ(q)          <span class="comment">// 错误，必须指定 "as any P" 由于缺少 T.B.A == Int 的约束</span></span><br><span class="line">  <span class="keyword">let</span> y = getBFromQ(q) <span class="keyword">as</span> any <span class="type">P</span> <span class="comment">// 可以, 明确抛弃约束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0353-constrained-existential-types.md" title="Constrained Existential Types" target="_blank" rel="noopener">SE-0353: 受约束的存在类型</a> <strong>状态：Swift 5.7 已实现</strong><br>存在类型弥补了 Swift 类型系统中的抽象能力。与泛型一样，它们使函数能够获取和返回多种可能的类型。与泛型参数类型不同，存在类型在作为输入传递给函数时不需要预先知道。此外，当从函数返回时，可以删除具体类型（隐藏在协议接口后面）。在这个领域出现了一系列活动，<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md#covariant-erasure-for-associated-types" title="SE-0309: unlock existential types for all protocols" target="_blank" rel="noopener">SE-0309</a> 解除了对使用具有关联类型的协议作为存在类型的剩余限制，而 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0346-light-weight-same-type-syntax.md" title="SE-0346: light weight same type syntax" target="_blank" rel="noopener">SE-0346</a> 为关联类型协议的轻量级约束语法铺平了道路。该提案直接基于这些想法，旨在在存在类型的上下文中重用轻量级关联类型约束的语法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0356-swift-snippets.md" title="Swift Snippets" target="_blank" rel="noopener">SE-0356: Swift 代码片段</a><br>该提案描述了编写成为片段的新形式示例代码的约定。片段是简短的单文件示例，可以在 Swift 包中构建和运行，可以访问该包中的其他代码，并且可以以多种方式使用。</p><h3 id="正在审查的提案"><a href="#正在审查的提案" class="headerlink" title="正在审查的提案"></a>正在审查的提案</h3><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0359-build-time-constant-values.md" title="Build-Time Constant Values" target="_blank" rel="noopener">SE-0359: 构建时间常数值</a> <strong>状态：已接受</strong><br>构建时间常数值是一个 Swift 语言特性，要求在编译时知道某些值。这是通过属性、<code>@const</code>、约束属性和函数参数来实现的，以使其具有编译时可知的值。这些信息为未来更丰富的编译时特性奠定了基础，例如在编译时提取和验证值。</p><p><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0362-piecemeal-future-features.md" title="Piecemeal adoption of upcoming language improvements" target="_blank" rel="noopener">SE-0362: 即将到来的语言改进的逐渐采用</a> <strong>状态：已接受</strong><br>Swift 6 积累了许多对语言有源码兼容性影响的改进，从而在以前的语言模式（Swift 4.x 和 Swift 5.x）中默认情况下无法启用它们。这些改进已经在背后为 Swift 6 语言模式的 Swift 编译器中实现，但他们对于开发者是无法访问的，并将持续直到 Swift 6 作为一个可获得的语言模式。这有很多原因，为什么我们应该思考尽快提供这些改动。</p><ul><li>开发者希望很快从这些改进中受益，而不是等到 Swift 6 可用。</li><li>向开发者提供这些改进比 Swift 6 提供更多体验优先级更高，如果有必要，允许我们针对 Swift 6 进一步调试它们。</li><li>对于某些模块，所有在 Swift 6 中改动的总数或许会造成迁移繁重，并且在 Swift 4.x/5.x 中逐一采纳这些语言改动，可以使过渡期路径变得丝滑。</li></ul><p>一些提案已经引入了定制解决方案来提供迁移路径：<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md" title="support-incremental-migration-to-concurrency-checking" target="_blank" rel="noopener">SE-0337</a> 添加了 <code>-warn-concurrency</code> 在 Swift 4.x/5.x 中启用与 <code>Sendable</code> 相关检查的警告。 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0354-regex-literals.md" title="regex-literals" target="_blank" rel="noopener">SE-0354</a> 添加标志 <code>-enable-bare-slash-regex</code> 以启用原始 <code>/.../</code> 正则表达式语法。尽管它不是提案的一部分，但对 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md" title="existential-any" target="_blank" rel="noopener">SE-0335</a> 的讨论包括对编译器标志的请求，以在存在类型上要求使用 <code>any</code> 。这些都具有相同的风格，即选择现有的 Swift 4.x/5.x 代码进行改进，这些改进将出现在 Swift 6 中。</p><p>这个提议明确地包含了零碎的、有意采用的特性，这些特性在 Swift 6 之前出于源代码兼容性的原因而保留。它为逐步采用 Swift 6 特性建立了一条直接路径，以在 Swift 4.x/5.x 代码库中获得它们的优势，并顺利迁移到 Swift 6 语言模式。开发人员可以使用新的编译器标志 <code>-enable-upcoming-feature X</code> 为该模块启用名为 <code>X</code> 的特定功能，并且可以以这种方式指定多个功能。当开发人员移动到下一个主要语言版本时，该语言版本将隐含 <code>X</code> 并且编译器标志将被拒绝。这样，即将推出的功能标志只会累积到下一个主要的 Swift 语言版本，然后被清除，所以我们不会将语言分拆成不兼容的方言。</p><h2 id="Swift论坛"><a href="#Swift论坛" class="headerlink" title="Swift论坛"></a>Swift论坛</h2><ol><li><p><a href="https://developer.apple.com/forums/tags/wwdc2022-10052" title="What&#39;s new in SwiftUI" target="_blank" rel="noopener">SwiftUI 中的新功能</a> 围绕 <code>WWDC2022-10052</code> 内容进行讨论</p></li><li><p><a href="https://developer.apple.com/forums/tags/wwdc2022-110357" title="Meet Swift Regex" target="_blank" rel="noopener">Swift 正则表达式</a> 围绕 <code>WWDC2022-110357</code> 内容进行讨论</p></li><li><p><a href="https://developer.apple.com/forums/tags/wwdc2022-10054" title="The SwiftUI cookbook for navigation" target="_blank" rel="noopener">SwiftUI 导航</a> 围绕 <code>WWDC2022-10054</code> 内容进行讨论</p></li><li><p><a href="https://developer.apple.com/forums/tags/wwdc2022-10137" title="Swift Charts" target="_blank" rel="noopener">Swift 图表</a> 围绕 <code>WWDC2022-10137</code> 内容进行讨论</p></li><li><p>使用 <a href="https://forums.swift.org/t/using-cmake-to-build-swift-instead-of-build-script/59095" title="Using cmake to build swift" target="_blank" rel="noopener">cmake 构建 swift</a> 而不是 <code>build-script</code>。</p></li></ol><p><code>build-script</code> 是 <code>build-script-impl</code> 的 python 包装器，本身是一个 <code>shell</code> 脚本，然后运行 CMake，执行可以构建项目的工作主体。 例如，如果您想执行 <code>utils/build-script -x</code>，将调用 <code>cmake -G Xcode</code>。</p><ol><li><p><strong>Visual Studio Code</strong> <a href="https://forums.swift.org/t/introducing-swift-for-visual-studio-code/54246" title="VSCode extension" target="_blank" rel="noopener">增加扩展包</a> 支持 Swift 开发</p></li><li><p><a href="https://forums.swift.org/t/swiftnio-channelinboundhandler-is-docc-incompatible/58611" title="SwiftNIO _ChannelInboundHandler is DocC incompatible" target="_blank" rel="noopener">SwiftNIO _ChannelInboundHandler 与 DocC 不兼容</a></p></li></ol><p>在阅读 swift-biome 中的 <code>SwiftNIO</code> 文档时，遇到一个问题。文档其中引用了 3 个带下划线的属性。例如：<code>_ChannelInboundHandler</code>、<code>_EmittingChannelHandler</code> 等，但是这些属性在 swift-biome 和其他基于 <code>SymbolGraphGen</code> 的工具是不可见的，包括 DocC。</p><ol><li><a href="https://twitter.com/natpanferova/status/1547103127429857280" title="KeyPath-based comparison API in Foundation" target="_blank" rel="noopener">Foundation 中基于 KeyPath 的对比 API</a></li></ol><p>在 <code>Foundation</code> 中引入的 <code>KeyPathComparator</code> API，比 Swift 中的 <code>sorted(by:)</code> 方法更清晰。这个 API 可以根据数组中的某个特定元素进行排序。</p><p><img src="https://github.com/SwiftCommunityRes/image/blob/main/FXhpnbMacAE1d6P.jpg?raw=true" alt=""></p><h2 id="推荐博文"><a href="#推荐博文" class="headerlink" title="推荐博文"></a>推荐博文</h2><p><strong>SwiftUI 动画系列</strong>，文章结合动画 Gif 原图和源码为案例，深入探讨了如何创建应用 SwiftUI 动画。</p><p><a href="https://xiaozhuanlan.com/topic/9583407126" target="_blank" rel="noopener">高级 SwiftUI 动画 — Part 1：Paths</a></p><p><strong>摘要：</strong> 本文主要介绍了显式动画和隐式动画，以及针对 Animatable 协议的相关讨论。</p><p><a href="https://xiaozhuanlan.com/topic/9685470312" target="_blank" rel="noopener">高级 SwiftUI 动画 — Part 2：GeometryEffect</a></p><p><strong>摘要：</strong> 主要介绍使用新工具 GeometryEffect 创建 SwiftUI 动画。GeometryEffect是一个符合Animatable 和 ViewModifier 的协议。</p><p><a href="https://xiaozhuanlan.com/topic/6089153247" target="_blank" rel="noopener">高级 SwiftUI 动画 — Part 3：AnimatableModifier</a></p><p><strong>摘要：</strong> 本文主要介绍使用 AnimatableModifier 完成更加复杂的动画效果。AnimatableModifier 是一个 ViewModifier，符合 Animatable 协议，如果对这个协议不了解可以阅读之前发布的两篇文章。</p><p><a href="https://xiaozhuanlan.com/topic/9182056374" target="_blank" rel="noopener">SwiftUI 动画进阶 — Part4：TimelineView</a></p><p><strong>摘要：</strong> 前三篇高级 SwiftUI 动画是作者在实战中总结的内容。本篇文章，我们将详细地探索 TimelineView。</p><p><a href="https://xiaozhuanlan.com/topic/1725803469" target="_blank" rel="noopener">SwiftUI 动画进阶 — Part 5：Canvas</a></p><p><strong>摘要：</strong> 本篇文章将探索 Canvas 视图。从技术上讲，它不是一个动画视图，但当它与第四部分的 TimelineView 结合时，可以现实很多有趣的功能。</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的各种交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。</p><p>周报仓库：<a href="https://github.com/SwiftCommunityRes" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes</a> 文章中外引链接较多，可以点击 <strong>阅读原文</strong> 更加方便阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/24238160/138631090-e34763aa-7ed8-4b9a-8e02-4fa56d55b045.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;周报仓库：&lt;a h
      
    
    </summary>
    
      <category term="Swift 周报" scheme="https://fanbaoying.github.io/categories/Swift-%E5%91%A8%E6%8A%A5/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 状态管理系统指南</title>
    <link href="https://fanbaoying.github.io/SwiftUI-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%8D%97/"/>
    <id>https://fanbaoying.github.io/SwiftUI-状态管理系统指南/</id>
    <published>2022-07-06T11:11:56.000Z</published>
    <updated>2022-07-06T11:14:54.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SwiftUI与苹果之前的UI框架的区别不仅仅在于如何定义视图和其他UI组件，还在于如何在整个使用它的应用程序中管理视图层级的状态。</p><p>SwiftUI没有使用委托、数据源或任何其他在UIKit和AppKit等命令式框架中常见的状态管理模式，而是配备了一些属性包装器，使我们能够准确地声明我们的数据如何被我们的视图观察、渲染和改变。</p><p>本周，让我们仔细看看这些属性包装器中的每一个，它们之间的关系，以及它们如何构成SwiftUI整体状态管理系统的不同部分。</p><a id="more"></a><h2 id="属性状态"><a href="#属性状态" class="headerlink" title="属性状态"></a>属性状态</h2><p>由于SwiftUI主要是一个UI框架（尽管它也开始获得用于定义更高层次结构（如应用程序和场景）的API），其声明式设计不一定需要影响应用程序的整个模型和数据层——而只是直接绑定到我们各种视图的状态。</p><p>例如，假设我们正在开发一个<code>SignupView</code>，使用户能够通过输入用户名和电子邮件地址在应用程序中注册一个新账户。我们将使用这两个值形成一个用户模型，并将其传递给一个闭包：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SignupView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> handler: (<span class="type">User</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">var</span> username = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> email = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这三个属性中只有两个——<code>username</code>和<code>email</code>——实际上会被我们的视图修改，而且这两个状态可以保持私有，我们将使用SwiftUI的<code>State</code>属性包装器来标记它们——像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SignupView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> handler: (<span class="type">User</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> username = <span class="string">""</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> email = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做将自动在这两个值和我们的视图本身之间建立一个连接——这意味着我们的视图将在每次改变这两个值的时候被重新渲染。在我们的主体中，我们将把这两个属性分别绑定到一个相应的<code>TextField</code>上，以使它们可以被用户编辑：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SignupView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> handler: (<span class="type">User</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> username = <span class="string">""</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> email = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Username"</span>, text: $username)</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Email"</span>, text: $email)</span><br><span class="line">            <span class="type">Button</span>(</span><br><span class="line">                action: &#123;</span><br><span class="line">                    <span class="keyword">self</span>.handler(<span class="type">User</span>(</span><br><span class="line">                        username: <span class="keyword">self</span>.username,</span><br><span class="line">                        email: <span class="keyword">self</span>.email</span><br><span class="line">                    ))</span><br><span class="line">                &#125;,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(<span class="string">"Sign up"</span>) &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>State</code>被用来表示SwiftUI视图的内部状态，并在该状态被改变时自动使视图更新。因此，最常见的做法是将<code>State</code>属性包装器保持为私有，这可以确保它们只在该视图的主体内被改变（试图在其他地方改变它们实际上会导致运行时崩溃）。</p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>看一下上面的代码样本，我们将每个属性传入其<code>TextField</code>的方式是在这些属性名称前加上<code>$</code>。这是因为我们不只是将普通的<code>String</code>值传入这些文本字段，而是与我们的<code>State</code>包装的属性本身绑定。</p><p>为了更详细地探讨这意味着什么，让我们现在假设我们想创建一个视图，让我们的用户编辑他们最初在注册时输入的个人资料信息。由于我们现在要修改外部状态值，而不仅仅是私人状态值，所以这次我们将<code>username</code>和<code>email</code>属性标记为<code>Bingding</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProfileEditingView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> email: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Username"</span>, text: $username)</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Email"</span>, text: $email)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最酷的是，绑定不仅仅局限于单一的内置值，比如字符串或整数，而是可以用来将任何Swift值绑定到我们的一个视图中。例如，我们可以将用户模型本身传递给<code>ProfileEditingView</code>，而不是传递两个单独的<code>username</code>和<code>email</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProfileEditingView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> user: <span class="type">User</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Username"</span>, text: $user.username)</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Email"</span>, text: $user.email)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像我们在将<code>State</code>和<code>Binding</code>包装的属性传入各种<code>TextField</code>实例时用<code>$</code>作为前缀一样，我们在将任何<code>State</code>值连接到我们自己定义的<code>Binding</code>属性时也可以做同样的事情。</p><p>例如，这里有一个<code>ProfileView</code>的实现，它使用一个<code>Stage</code>包装属性来跟踪一个用户模型，然后在将上述<code>ProfileEditingView</code>的实例作为工作表呈现时，将该模型传递一个绑定——这将自动同步用户对该原始<code>State</code>属性值的任何改变:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProfileView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> user = <span class="type">User</span>.load()</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isEditingViewShown = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Username: "</span>)</span><br><span class="line">                .foregroundColor(.secondary)</span><br><span class="line">                + <span class="type">Text</span>(user.username)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Email: "</span>)</span><br><span class="line">                .foregroundColor(.secondary)</span><br><span class="line">                + <span class="type">Text</span>(user.email)</span><br><span class="line">            <span class="type">Button</span>(</span><br><span class="line">                action: &#123; <span class="keyword">self</span>.isEditingViewShown = <span class="literal">true</span> &#125;,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(<span class="string">"Edit"</span>) &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">        .sheet(isPresented: $isEditingViewShown) &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">ProfileEditingView</span>(user: <span class="keyword">self</span>.$user)</span><br><span class="line">                <span class="type">Button</span>(</span><br><span class="line">                    action: &#123; <span class="keyword">self</span>.isEditingViewShown = <span class="literal">false</span> &#125;,</span><br><span class="line">                    label: &#123; <span class="type">Text</span>(<span class="string">"Done"</span>) &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，我们也可以通过给一个<code>State</code>包装的属性分配一个新的值来改变它——比如我们在 “Done “按钮的动作处理程序中把<code>isEditingViewShown</code>设置为<code>false</code>。</p></blockquote><p>因此，一个<code>Binding</code>标记的属性在给定的视图和定义在该视图之外的状态属性之间提供了一个双向的连接，而<code>Statr</code>和<code>Binding</code>包装的属性都可以通过在其属性名前加上<code>$</code>来作为绑定物传递。</p><h2 id="观察对象"><a href="#观察对象" class="headerlink" title="观察对象"></a>观察对象</h2><p><code>State</code>和<code>Bingding</code>的共同点是，它们处理的是在SwiftUI视图层次结构本身中管理的值。然而，虽然建立一个将所有的状态都保存在其各种视图中的应用程序是肯定可行的，但从架构和关注点分离的角度来看，这通常不是一个好主意，而且很容易导致我们的视图变得相当<a href="https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views/" target="_blank" rel="noopener">庞大和复杂</a>。</p><p>值得庆幸的是，SwiftUI还提供了一些机制，使我们能够将外部模型对象连接到我们的各种视图。其中一个机制是<code>ObservableObject</code>协议，当它与<code>ObservedObject</code>属性包装器结合时，我们可以设置与我们视图层之外管理的引用类型的绑定。</p><p>作为一个例子，让我们更新上面定义的<code>ProfileView</code>——通过将管理<code>User</code>模型的责任从视图本身转移到一个新的、专门的对象中。现在，我们可以用许多不同的方式来描述这样一个对象，但由于我们正在寻找创建一个类型来控制我们的一个模型的实例——让我们把它变成一个符合SwiftUI的<code>ObservableObject</code>协议的<a href="https://www.swiftbysundell.com/articles/model-controllers-in-swift/" target="_blank" rel="noopener">模型控制器</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModelController</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> user: <span class="type">User</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Published</code>属性包装器用于定义对象的哪些属性在被修改时应让观察通知被触发。</p></blockquote><p>有了上面的类型，现在让我们回到<code>ProfileView</code>，让它观察新的<code>UserModelController</code>的实例，作为一个<code>ObservedObject</code>，而不是用一个<code>State</code>属性包装器来跟踪我们的用户模型。最重要的是，我们仍然可以很容易地将这个模型绑定到我们的<code>ProfileEditingView</code>上，就像以前一样，因为<code>ObservedObject</code>属性包装器也可以转换为绑定：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProfileView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> userController: <span class="type">UserModelController</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isEditingViewShown = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Username: "</span>)</span><br><span class="line">                .foregroundColor(.secondary)</span><br><span class="line">                + <span class="type">Text</span>(userController.user.username)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Email: "</span>)</span><br><span class="line">                .foregroundColor(.secondary)</span><br><span class="line">                + <span class="type">Text</span>(userController.user.email)</span><br><span class="line">            <span class="type">Button</span>(</span><br><span class="line">                action: &#123; <span class="keyword">self</span>.isEditingViewShown = <span class="literal">true</span> &#125;,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(<span class="string">"Edit"</span>) &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">        .sheet(isPresented: $isEditingViewShown) &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                <span class="type">ProfileEditingView</span>(user: <span class="keyword">self</span>.$userController.user)</span><br><span class="line">                <span class="type">Button</span>(</span><br><span class="line">                    action: &#123; <span class="keyword">self</span>.isEditingViewShown = <span class="literal">false</span> &#125;,</span><br><span class="line">                    label: &#123; <span class="type">Text</span>(<span class="string">"Done"</span>) &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，我们的新实现与之前使用的基于状态的实现之间的一个重要区别是，我们的<code>UserModelController</code>现在需要作为初始化器的一部分被<a href="https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift/" target="_blank" rel="noopener">注入</a>到<code>ProfileView</code>中。</p><p>除了 “迫使 “我们在代码库中建立一个更明确的依赖关系图之外，原因是一个标有<code>ObservedObject</code>的属性并不意味着对这个属性所指向的对象有任何形式的所有权。</p><p>因此，虽然下面的内容在技术上可能会被编译，但最终会导致运行时的问题——因为当我们的视图在更新时被重新创建，<code>UserModelController</code>实例可能会被删除（因为我们的视图现在是它的主要所有者）:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProfileView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> userController = <span class="type">UserModelController</span>.load()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重要的是要记住: SwiftUI视图不是对正在屏幕上渲染的实际UI组件的引用，而是描述我们的UI的轻量级值——因此它们没有像<code>UIView</code>实例那样的生命周期。</p></blockquote><p>为了解决上述问题，苹果在iOS 14和macOS Big Sur中引入了一个新的属性包装器，名为<code>StateObject</code>。标记为<code>StateObject</code>的属性与<code>ObservedObject</code>的行为完全相同——此外，SwiftUI将确保存储在此类属性中的任何对象不会因为框架在重新渲染视图时重新创建新实例而被意外释放：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProfileView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">StateObject</span> <span class="keyword">var</span> userController = <span class="type">UserModelController</span>.load()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管从技术上来说，从现在开始可以只使用<code>StateObject</code>——我仍然建议在观察外部对象时使用<code>ObservedObject</code>，而在处理视图本身拥有的对象时只使用<code>StateObject</code>。把<code>StateObject</code>和<code>ObservedObject</code>看作是<code>State</code>和<code>Binding</code>的参考类型，或者SwiftUI版本的强和弱属性。</p><h2 id="观察和修改环境变量"><a href="#观察和修改环境变量" class="headerlink" title="观察和修改环境变量"></a>观察和修改环境变量</h2><p>最后，让我们来看看SwiftUI的环境系统如何被用来在两个互不直接连接的视图之间传递各种状态。尽管在一个父视图和它的一个子视图之间创建绑定通常很容易，但在整个视图层次结构中传递某个对象或值可能相当麻烦——而这正是环境变量旨在解决的问题类型。</p><p>有两种主要的方法来使用SwiftUI的环境。一种是首先在想要检索给定对象的视图中定义一个<code>EnvironmentObject</code>包装的属性——例如像这个<code>ArticleView</code>如何检索一个包含颜色信息的<code>Theme</code>对象:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArticleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">EnvironmentObject</span> <span class="keyword">var</span> theme: <span class="type">Theme</span></span><br><span class="line">    <span class="keyword">var</span> article: <span class="type">Article</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(article.title)</span><br><span class="line">                .foregroundColor(theme.titleTextColor)</span><br><span class="line">            <span class="type">Text</span>(article.body)</span><br><span class="line">                .foregroundColor(theme.bodyTextColor)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们必须确保在我们的视图的某一个父类中提供我们的环境对象（在这种情况下是一个<code>Theme</code>实例），然后SwiftUI会处理其余的事情。这是通过使用<code>environmentalObject</code>修饰符完成的，例如，像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RootView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> theme: <span class="type">Theme</span></span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> articleLibrary: <span class="type">ArticleLibrary</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ArticleListView</span>(articles: articleLibrary.articles)</span><br><span class="line">            .environmentObject(theme)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，我们不需要将上述修改器应用于将使用我们的环境对象的确切视图——我们可以将其应用于我们的层次结构中任何在其之上的视图。</p></blockquote><p>使用 SwiftUI 环境系统的第二种方式是定义一个自定义的<code>EnvironmentKey</code> ——然后它可以被用来向内置的<code>EnvironmentValues</code> 类型分配和检索值:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThemeEnvironmentKey</span>: <span class="title">EnvironmentKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue = <span class="type">Theme</span>.<span class="keyword">default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EnvironmentValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> theme: <span class="type">Theme</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">self</span>[<span class="type">ThemeEnvironmentKey</span>.<span class="keyword">self</span>] &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">self</span>[<span class="type">ThemeEnvironmentKey</span>.<span class="keyword">self</span>] = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述内容，我们现在可以使用<code>Enviroment</code>属性包装器（而不是<code>EnvironmentObject</code>）来标记我们视图的<code>theme</code>属性，并传入我们希望检索的环境键的<a href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift" target="_blank" rel="noopener">键值路径</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArticleView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Environment</span>(\.theme) <span class="keyword">var</span> theme: <span class="type">Theme</span></span><br><span class="line">    <span class="keyword">var</span> article: <span class="type">Article</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(article.title)</span><br><span class="line">                .foregroundColor(theme.titleTextColor)</span><br><span class="line">            <span class="type">Text</span>(article.body)</span><br><span class="line">                .foregroundColor(theme.bodyTextColor)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两种方法的一个明显区别是，基于键的方法要求我们在编译时定义一个默认值，而基于环境对象<code>EnvironmentObject</code>的方法则假设在运行时提供这样一个值（如果不这样做将导致崩溃）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>SwiftUI管理状态的方式绝对是该框架最有趣的方面之一，它可能需要我们稍微重新思考数据在应用中的传递方式——至少在涉及到将被我们的UI直接消费和修改的数据时是这样。</p><p>我希望这篇指南能成为一个很好的方式来概述SwiftUI的各种状态处理机制，尽管一些更具体的API被遗漏了，这篇文章中强调的概念应该涵盖了所有基于SwiftUI的状态处理的绝大多数用例。</p><p>感谢你的阅读! </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;SwiftUI与苹果之前的UI框架的区别不仅仅在于如何定义视图和其他UI组件，还在于如何在整个使用它的应用程序中管理视图层级的状态。&lt;/p&gt;
&lt;p&gt;SwiftUI没有使用委托、数据源或任何其他在UIKit和AppKit等命令式框架中常见的状态管理模式，而是配备了一些属性包装器，使我们能够准确地声明我们的数据如何被我们的视图观察、渲染和改变。&lt;/p&gt;
&lt;p&gt;本周，让我们仔细看看这些属性包装器中的每一个，它们之间的关系，以及它们如何构成SwiftUI整体状态管理系统的不同部分。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/categories/SwiftUI/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的类型占位符</title>
    <link href="https://fanbaoying.github.io/Swift-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8D%A0%E4%BD%8D%E7%AC%A6/"/>
    <id>https://fanbaoying.github.io/Swift-中的类型占位符/</id>
    <published>2022-07-06T11:11:41.000Z</published>
    <updated>2022-07-06T11:16:37.105Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 的类型推断能力从一开始就是语言的核心部分，它极大地减少了我们在声明有默认值的变量和属性时手动指定类型的工作。例如，表达式<code>var number = 7</code>不需要包含任何类型注释，因为编译器能够推断出值<code>7</code>是一个<code>Int</code>，我们的<code>number</code>变量应该被相应的类型化。</p><p>作为 Xcode 13.3 的一部分而一起发布的 Swift 5.6，通过引入 “类型占位符（type placeholders） “的概念，继续扩展这些类型推理能力，这在处理集合和其他通用类型时非常有用。</p><a id="more"></a><p>例如，假设我们想创建一个<code>Combine</code>里面具有默认整数值的 <code>CurrentValueSubject</code>的实例。关于如何做到这一点的初步想法可能是简单地将我们的默认值传递给该主体的初始化器，然后将结果存储在本地的一个<code>let</code>声明的属性中（就像创建一个普通的<code>Int</code>值时一样）。然而，这样做会给我们带来以下编译器错误：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error: "Generic parameter 'Failure' could not be inferred"</span></span><br><span class="line"><span class="comment">// Error: “无法被推断出泛型的`Failure`参数 ”</span></span><br><span class="line"><span class="keyword">let</span> counterSubject = <span class="type">CurrentValueSubject</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这是因为<code>CurrentValueSubject</code>是一个泛型类型，实例化时不仅需要<code>Output</code>类型，还需要<code>Failure</code>类型——这是该主体能够抛出的错误类型。</p><p>因为我们不希望我们的主体在这种情况下抛出任何错误，所以我们会给它一个<code>Failure</code>类型的值<code>Never</code>（这是在 Swift 中使用 <code>Combine</code> 的一个常见惯例）。但为了做到这一点，在 Swift 5.6 之前，我们需要明确地指定我们的<code>Int</code>输出类型——像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counterSubject = <span class="type">CurrentValueSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt;(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>不过从 Swift 5.6 开始，这种情况就不存在了——因为我们现在可以使用一个类型占位符来表示我们主体的<code>Output</code>类型，这让我们再次利用编译器为我们自动推断出该类型，就像在声明一个普通的<code>Int</code>值一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counterSubject = <span class="type">CurrentValueSubject</span>&lt;<span class="number">_</span>, <span class="type">Never</span>&gt;(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这很好，但可以说这并不是 swift 里面很大的改进。毕竟，我们用<code>_</code>代替<code>Int</code>只是节省了两个字符，而且手动指定像<code>Int</code>这样的简单类型也不是一开始就有问题的。</p><p><strong>但现在让我们看看这个功能如何扩展到更复杂的类型，这是它真正开始发光的地方。</strong>例如，假设我们的项目包含以下函数，让我们加载一个用户注解的PDF文件:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadAnnotatedPDF</span><span class="params">(named: String)</span></span> -&gt; <span class="type">Resource</span>&lt;<span class="type">PDF</span>&lt;<span class="type">UserAnnotations</span>&gt;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数使用了一个相当复杂的泛型作为它的返回类型，这可能是因为我们需要在多个地方中重复使用我们的<code>Resource</code>类型，也因为我们选择了使用<em><a href="https://www.swiftbysundell.com/articles/phantom-types-in-swift" target="_blank" rel="noopener">幻象类型</a></em>来指定我们当前处理的是哪种PDF。</p><p>现在让我们看看，如果我们在创建主体时调用上述函数，而不是仅仅使用一个简单的整数，那么我们之前基于<code>CurrentValueSubject</code>的代码会是什么样子:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before Swift 5.6:</span></span><br><span class="line"><span class="keyword">let</span> pdfSubject = <span class="type">CurrentValueSubject</span>&lt;<span class="type">Resource</span>&lt;<span class="type">PDF</span>&lt;<span class="type">UserAnnotations</span>&gt;&gt;, <span class="type">Never</span>&gt;(</span><br><span class="line">    loadAnnotatedPDF(named: name)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 5.6:</span></span><br><span class="line"><span class="keyword">let</span> pdfSubject = <span class="type">CurrentValueSubject</span>&lt;<span class="number">_</span>, <span class="type">Never</span>&gt;(</span><br><span class="line">    loadAnnotatedPDF(named: name)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这是一个相当大的改进啊 基于 Swift 5.6 的版本不仅为我们节省了一些输入，而且由于 <code>pdfSubject</code> 的类型现在完全来自 <code>loadAnnotatedPDF</code> 函数，这可能会使该函数（及其相关代码）的迭代更加容易——因为如果我们改变该函数的返回类型，需要更新的手动类型注释将减少。</p><p>不过，值得指出的是，在上述情况下，还有另一种方法可以利用Swift的类型推理能力——那就是使用<strong>类型别名</strong>，而不是<strong>类型占位符</strong>。例如，我们可以在这里定义一个<code>UnfailingValueSubject</code>类型别名，我们可以用它来轻松地创建不会产生任何错误的主体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">UnfailingValueSubject</span>&lt;<span class="type">T</span>&gt; = <span class="type">CurrentValueSubject</span>&lt;<span class="type">T</span>, <span class="type">Never</span>&gt;</span><br></pre></td></tr></table></figure><p>有了上述内容，我们现在就可以在没有任何泛型注解的情况下创建我们的<code>pdfSubject</code>了——因为编译器能够推断出<code>T</code>指的是什么类型，而且失败类型<code>Never</code>已经被硬编码到我们的新类型别名中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pdfSubject = <span class="type">UnfailingValueSubject</span>(loadAnnotatedPDF(named: name))</span><br></pre></td></tr></table></figure><p>但这并不意味着类型别名在通常情况下都比类型占位符好，因为如果我们要为每种特定情况定义新的类型别名，那么这也会使我们的代码库变得更加复杂。有时，在内联中指定所有的东西（比如使用类型占位符时）绝对是个好办法，因为这可以让我们定义完全独立的表达式。</p><p>在我们总结之前，让我们也来看看类型占位符是如何与集合字面量(literals)一起使用的——例如在创建一个字典时。在这里，我们选择手动指定我们的字典的 <code>Key</code> 类型（为了能够使用点语法来指代枚举的各种情况），同时为该字典的值使用一个类型占位符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserRole</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> local</span><br><span class="line">    <span class="keyword">case</span> remote</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> latestMessages: [<span class="type">UserRole</span>: <span class="number">_</span>] = [</span><br><span class="line">    .local: <span class="string">""</span>,</span><br><span class="line">    .remote: <span class="string">""</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这就是类型占位符——Swift 5.6 中引入的一个新功能，在处理稍微复杂的通用类型时，它可能真的很有用。但值得指出的是，这些占位符只能在调用站点使用，而不是在指定函数或计算属性的返回类型时使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 的类型推断能力从一开始就是语言的核心部分，它极大地减少了我们在声明有默认值的变量和属性时手动指定类型的工作。例如，表达式&lt;code&gt;var number = 7&lt;/code&gt;不需要包含任何类型注释，因为编译器能够推断出值&lt;code&gt;7&lt;/code&gt;是一个&lt;code&gt;Int&lt;/code&gt;，我们的&lt;code&gt;number&lt;/code&gt;变量应该被相应的类型化。&lt;/p&gt;
&lt;p&gt;作为 Xcode 13.3 的一部分而一起发布的 Swift 5.6，通过引入 “类型占位符（type placeholders） “的概念，继续扩展这些类型推理能力，这在处理集合和其他通用类型时非常有用。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 中的自定义导航</title>
    <link href="https://fanbaoying.github.io/SwiftUI-%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA/"/>
    <id>https://fanbaoying.github.io/SwiftUI-中的自定义导航/</id>
    <published>2022-07-06T11:11:22.000Z</published>
    <updated>2022-07-06T11:16:04.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>默认情况下，SwiftUI提供的各种导航API在很大程度上是以用户直接输入为中心的——也就是说，导航是在系统响应例如按钮的点击和标签切换等事件时由系统本身处理的。</p><p>然而，有时我们可能想更直接地控制应用程序的导航执行方式，尽管SwiftUI在这方面仍然不如UIKit或AppKit灵活，但它确实提供了相当多的方法，让我们在构建的视图中执行完全自定义的导航。</p><a id="more"></a><h2 id="切换标签（tabs）"><a href="#切换标签（tabs）" class="headerlink" title="切换标签（tabs）"></a>切换标签（tabs）</h2><p>让我们先来看看我们如何能控制当前在<code>TabView</code>中显示的标签。通常情况下，当用户手动点击每个标签栏中的一个项目时，标签就会被切换，但是通过在一个给定的<code>TabView</code>中注入一个选择(<code>selection</code>)绑定，我们可以观察并控制当前显示的标签。在这里，我们要做的就是在两个标签之间切换，这两个标签是用整数<code>0</code>和<code>1</code>标记的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RootView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> activeTabIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TabView</span>(selection: $activeTabIndex) &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Switch to tab B"</span>) &#123;</span><br><span class="line">                activeTabIndex = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            .tag(<span class="number">0</span>)</span><br><span class="line">            .tabItem &#123; <span class="type">Label</span>(<span class="string">"Tab A"</span>, systemImage: <span class="string">"a.circle"</span>) &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Switch to tab A"</span>) &#123;</span><br><span class="line">                activeTabIndex = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            .tag(<span class="number">1</span>)</span><br><span class="line">            .tabItem &#123; <span class="type">Label</span>(<span class="string">"Tab B"</span>, systemImage: <span class="string">"b.circle"</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但真正好的地方是，在识别和切换标签时，我们并不仅仅局限于使用整数。相反，我们可以自由地使用任何<code>Hashable</code>值来表示每个标签——例如通过使用一个枚举，其中包含我们想要显示的每个标签的情况。然后我们可以将这部分状态封装在一个<code>ObservableObject</code>中，这样我们就可以很容易地注入到我们的视图层次环境中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Tab</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> home</span><br><span class="line">    <span class="keyword">case</span> search</span><br><span class="line">    <span class="keyword">case</span> settings</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabController</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> activeTab = <span class="type">Tab</span>.home</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(<span class="number">_</span> tab: Tab)</span></span> &#123;</span><br><span class="line">        activeTab = tab</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述内容，我们现在可以用新的<code>Tab</code>类型来标记<code>TabView</code>中的每个视图，如果我们再把<code>TabController</code>注入到视图层次结构的环境中，那么其中的任何视图都可以随时切换显示的Tab。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RootView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> tabController = <span class="type">TabController</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TabView</span>(selection: $tabController.activeTab) &#123;</span><br><span class="line">            <span class="type">HomeView</span>()</span><br><span class="line">                .tag(<span class="type">Tab</span>.home)</span><br><span class="line">                .tabItem &#123; <span class="type">Label</span>(<span class="string">"Home"</span>, systemImage: <span class="string">"house"</span>) &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">SearchView</span>()</span><br><span class="line">                .tag(<span class="type">Tab</span>.search)</span><br><span class="line">                .tabItem &#123; <span class="type">Label</span>(<span class="string">"Search"</span>, systemImage: <span class="string">"magnifyingglass"</span>) &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">SettingsView</span>()</span><br><span class="line">                .tag(<span class="type">Tab</span>.settings)</span><br><span class="line">                .tabItem &#123; <span class="type">Label</span>(<span class="string">"Settings"</span>, systemImage: <span class="string">"gearshape"</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .environmentObject(tabController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，现在我们的<code>HomeView</code>可以使用一个完全自定义的按钮切换到设置标签——它只需要从环境中获取我们的<code>TabController</code>，然后它可以调用<code>open</code>方法来执行标签切换，像这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HomeView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">EnvironmentObject</span> <span class="keyword">private</span> <span class="keyword">var</span> tabController: <span class="type">TabController</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Open settings"</span>) &#123;</span><br><span class="line">                tabController.<span class="keyword">open</span>(.settings)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好! 另外，由于<code>TabController</code>是一个完全由我们控制的对象，我们也可以用它来切换主视图层次结构以外的标签。例如，我们可能想根据推送通知或其他类型的服务器事件来切换标签，现在可以通过调用上述视图代码中的相同的<code>open</code>方法来完成。</p><blockquote><p>要了解更多关于环境对象以及SwiftUI状态管理系统的其余部分，<a href="https://www.swiftbysundell.com/articles/swiftui-state-management-guide" target="_blank" rel="noopener">请查看本指南</a>。</p></blockquote><h2 id="控制导航堆栈"><a href="#控制导航堆栈" class="headerlink" title="控制导航堆栈"></a>控制导航堆栈</h2><p>就像标签视图一样，SwiftUI的<code>NavigationView</code>也可以被编程自定义控制。例如，假设我们正在开发一个应用程序，在其主导航堆栈中显示一个日历视图作为根视图，然后用户可以通过点击位于该应用程序导航栏中的编辑按钮来打开一个日历编辑视图。为了连接这两个视图，我们使用了一个<code>NavigationLink</code>，每当点击一个给定的视图时，它就会自动将其压入到导航栈中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RootView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> calendarController: <span class="type">CalendarController</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">CalendarView</span>(</span><br><span class="line">                calendar: calendarController.calendar</span><br><span class="line">            )</span><br><span class="line">            .toolbar &#123;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .navigationBarTrailing) &#123;</span><br><span class="line">                    <span class="type">NavigationLink</span>(<span class="string">"Edit"</span>) &#123;</span><br><span class="line">    <span class="type">CalendarEditView</span>(</span><br><span class="line">        calendar: $calendarController.calendar</span><br><span class="line">    )</span><br><span class="line">    .navigationTitle(<span class="string">"Edit your calendar"</span>)</span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">"Your calendar"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationViewStyle(.stack)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，我们在所有设备上使用堆栈式导航风格，甚至是iPad，而不是让系统选择使用哪种导航风格。</p></blockquote><p>现在我们假设，我们想让我们的<code>CalendarView</code>以自定义方式显示其编辑视图，而不需要构建一个单独的实例。要做到这一点，我们可以在编辑按钮的<code>NavigationLink</code>中注入一个<code>isActive</code>绑定，然后将其传递给我们的<code>CalendarView</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RootView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> calendarController: <span class="type">CalendarController</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isEditViewShown = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">CalendarView</span>(</span><br><span class="line">                calendar: calendarController.calendar,</span><br><span class="line">                isEditViewShown: $isEditViewShown</span><br><span class="line">            )</span><br><span class="line">            .toolbar &#123;</span><br><span class="line">                <span class="type">ToolbarItem</span>(placement: .navigationBarTrailing) &#123;</span><br><span class="line">                    <span class="type">NavigationLink</span>(<span class="string">"Edit"</span>, isActive: $isEditViewShown) &#123;</span><br><span class="line">                        <span class="type">CalendarEditView</span>(</span><br><span class="line">                            calendar: $calendarController.calendar</span><br><span class="line">                        )</span><br><span class="line">                        .navigationTitle(<span class="string">"Edit your calendar"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">"Your calendar"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationViewStyle(.stack)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们现在也更新<code>CalendarView</code>，使其使用<code>@Binding</code>绑定属性接受上述值，那么现在只要我们想显示我们的编辑视图，就可以简单地将该属性设置为<code>true</code>，我们的根视图的<code>NavigationLink</code>将自动被触发:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CalendarView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> calendar: <span class="type">Calendar</span></span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> isEditViewShown: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Edit calendar settings"</span>) &#123;</span><br><span class="line">                isEditViewShown = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然，我们也可以选择将<code>isEditViewShown</code>属性封装在某种形式的<code>ObservableObject</code>中，例如<code>NavigationController</code>，就像我们之前处理<code>TabView</code>时那样。</p></blockquote><p>这就是我们如何以自定义编程方式触发显示在我们的用户界面中的<code>NavigationLink</code>——但如果我们想在不给用户任何直接控制的情况下执行这种导航呢？</p><p>例如，我们现在假设我们正在开发一个包括导出功能的视频编辑应用程序。当用户进入导出流程时，一个<code>VideoExportView</code>被显示为模态，一旦导出操作完成，我们想把<code>VideoExportFinishedView</code>推送到该模态的导航栈中。</p><p>最初，这可能看起来非常棘手，因为（由于SwiftUI是一个声明式的UI框架）没有<code>push</code>方法，当我们想在导航栈中添加一个新视图时，我们可以调用该方法。事实上，在<code>NavigationView</code>中显示一个新视图的唯一内置方法是使用<code>NavigationLink</code>，它需要成为我们视图层次结构本身的一部分。</p><p>也就是说，这些<code>NavigationLink</code>实际上不一定是可见的——所以在这种情况下，实现我们目标的一个方法是在我们的视图中添加一个隐藏的导航链接，然后我们可以在视频导出操作完成后以编程方式触发该链接。如果我们也在我们的目标视图中隐藏系统提供的返回按钮，那么我们就可以完全锁定用户能够在这两个视图之间手动导航:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VideoExportView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> exporter: <span class="type">VideoExporter</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> didFinish = <span class="literal">false</span></span><br><span class="line">    @<span class="type">Environment</span>(\.presentationMode) <span class="keyword">private</span> <span class="keyword">var</span> presentationMode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">VStack</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="type">Button</span>(<span class="string">"Export"</span>) &#123;</span><br><span class="line">                    exporter.export &#123;</span><br><span class="line">    didFinish = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .disabled(exporter.isExporting)</span><br><span class="line"></span><br><span class="line">                <span class="type">NavigationLink</span>(<span class="string">"Hidden finish link"</span>, isActive: $didFinish) &#123;</span><br><span class="line">                    <span class="type">VideoExportFinishedView</span>(doneAction: &#123;</span><br><span class="line">                        presentationMode.wrappedValue.dismiss()</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .navigationTitle(<span class="string">"Export completed"</span>)</span><br><span class="line">                    .navigationBarBackButtonHidden(<span class="literal">true</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                .hidden()</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">"Export this video"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationViewStyle(.stack)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VideoExportFinishedView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doneAction: () -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Label</span>(<span class="string">"Your video was exported"</span>, systemImage: <span class="string">"checkmark.circle"</span>)</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Done"</span>, action: doneAction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们在<code>VideoExportFinishedView</code>中注入一个<code>doedAction</code>闭包，而不是让它检索当前的<code>presentationMode</code>本身，是因为我们希望解耦整个模态流程，而不仅仅是那个特定的视图。要了解更多信息，请查看 “<a href="https://www.swiftbysundell.com/articles/dismissing-swiftui-modal-and-detail-views" target="_blank" rel="noopener">解耦SwiftUI模态或详细视图</a>“。</p></blockquote><p>使用这样一个隐藏的<code>NavigationLink</code>绝对可以被认为是一个有点 “黑 “的解决方案，但它的效果非常好，如果我们把一个导航链接看成是导航堆栈中两个视图之间的连接（而不仅仅是一个按钮），那么上述设置可以说是有意义的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>尽管SwiftUI的导航系统仍然不如UIKit和AppKit提供的系统灵活，但它已经足够强大，可以满足很多不同的使用情——-特别是当与SwiftUI非常全面的状态管理系统相结合时。</p><p>当然，我们也可以选择将我们的SwiftUI视图层次包裹在<a href="https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-2" target="_blank" rel="noopener">托管控制器</a>中，只使用UIKit/AppKit来实现我们的导航代码。哪种解决方案是最合适的，可能取决于我们在每个项目中实际想要执行多少自定义和程序化的导航。</p><p>感谢您的阅读!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;默认情况下，SwiftUI提供的各种导航API在很大程度上是以用户直接输入为中心的——也就是说，导航是在系统响应例如按钮的点击和标签切换等事件时由系统本身处理的。&lt;/p&gt;
&lt;p&gt;然而，有时我们可能想更直接地控制应用程序的导航执行方式，尽管SwiftUI在这方面仍然不如UIKit或AppKit灵活，但它确实提供了相当多的方法，让我们在构建的视图中执行完全自定义的导航。&lt;/p&gt;
    
    </summary>
    
      <category term="SwiftUI" scheme="https://fanbaoying.github.io/categories/SwiftUI/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 66 加一</title>
    <link href="https://fanbaoying.github.io/LeetCode-66-%E5%8A%A0%E4%B8%80/"/>
    <id>https://fanbaoying.github.io/LeetCode-66-加一/</id>
    <published>2022-07-06T11:00:15.000Z</published>
    <updated>2022-07-06T11:09:28.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 65 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 <code>0</code> 之外，这个整数不会以零开头。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> digits = digits</span><br><span class="line">        <span class="keyword">var</span> index = digits.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> digits[index] &lt; <span class="number">9</span> &#123;</span><br><span class="line">                digits[index] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            digits[index] = <span class="number">0</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        digits.insert(<span class="number">1</span>, atIndex: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：迭代并将数组从最后一个更改为第一个。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/plus-one/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 65 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 65 有效数字</title>
    <link href="https://fanbaoying.github.io/LeetCode-65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/"/>
    <id>https://fanbaoying.github.io/LeetCode-65-有效数字/</id>
    <published>2022-07-06T11:00:03.000Z</published>
    <updated>2022-07-06T11:03:04.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 64 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 小数 或者 整数</li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 整数</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：<code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code></p><p>部分无效数字列举如下：<code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></p><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 有效数字 ，请返回 <code>true</code>。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimumPathSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(<span class="number">_</span> grid: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> grid.<span class="built_in">count</span> != <span class="number">0</span> &amp;&amp; grid[<span class="number">0</span>].<span class="built_in">count</span> != <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">let</span> m = grid.<span class="built_in">count</span>, n = grid[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">var</span> dp = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: n), <span class="built_in">count</span>: m)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>&#123;</span><br><span class="line">                    dp[i][j] = grid[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：遍历字符串并分别处理点、指数、数字和符号用例。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode-cn.com/problems/valid-number/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 64 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 64 最小路径和（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-64-最小路径和（Top-100）/</id>
    <published>2022-07-06T10:59:51.000Z</published>
    <updated>2022-07-06T11:02:49.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 63 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong> 每次只能向下或者向右移动一步。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinimumPathSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(<span class="number">_</span> grid: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> grid.<span class="built_in">count</span> != <span class="number">0</span> &amp;&amp; grid[<span class="number">0</span>].<span class="built_in">count</span> != <span class="number">0</span> <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">let</span> m = grid.<span class="built_in">count</span>, n = grid[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">var</span> dp = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: n), <span class="built_in">count</span>: m)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>&#123;</span><br><span class="line">                    dp[i][j] = grid[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的二维动态规划。</li><li>时间复杂度： O(mn)</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/minimum-path-sum/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 63 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 63 不同路径 II</title>
    <link href="https://fanbaoying.github.io/LeetCode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/"/>
    <id>https://fanbaoying.github.io/LeetCode-63-不同路径-II/</id>
    <published>2022-07-06T10:59:30.000Z</published>
    <updated>2022-07-06T11:02:31.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 62 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePathsII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="number">_</span> obstacleGrid: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> m = obstacleGrid.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">guard</span> m &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">guard</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> dp = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: -<span class="number">1</span>, <span class="built_in">count</span>: n), <span class="built_in">count</span>: m)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> help(m - <span class="number">1</span>, n - <span class="number">1</span>, &amp;dp, obstacleGrid)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">help</span><span class="params">(<span class="number">_</span> m: Int, <span class="number">_</span> n: Int, <span class="number">_</span> dp: <span class="keyword">inout</span> [[Int]], <span class="number">_</span> obstacleGrid: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[m][n] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dp[m][n] != -<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[m][n]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[m][n] = help(m - <span class="number">1</span>, n, &amp;dp, obstacleGrid) + help(m, n - <span class="number">1</span>, &amp;dp, obstacleGrid)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：2D动态编程，使用2D数组作为缓存来存储计算数据。</li><li>时间复杂度： O(mn)</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/unique-paths-ii/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 62 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 62 不同路径（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-62-不同路径（Top-100）/</id>
    <published>2022-07-06T10:59:10.000Z</published>
    <updated>2022-07-06T11:02:09.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 62 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 10^9</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePaths</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m: Int, <span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> pathNums = <span class="type">Array</span>(<span class="built_in">count</span>: m, repeatedValue: <span class="type">Array</span>(<span class="built_in">count</span>: n, repeatedValue: <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> _helper(&amp;pathNums, m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_helper</span><span class="params">(<span class="keyword">inout</span> pathNums: [[Int]], <span class="number">_</span> m: Int, <span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> || n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> pathNums[m][n] != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pathNums[m][n]</span><br><span class="line">        &#125;</span><br><span class="line">        pathNums[m][n] = _helper(&amp;pathNums, m - <span class="number">1</span>, n) + _helper(&amp;pathNums, m, n - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pathNums[m][n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：2D动态编程，使用2D数组作为缓存来存储计算数据。</li><li>时间复杂度： O(mn)</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/unique-paths/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 62 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 61 旋转链表</title>
    <link href="https://fanbaoying.github.io/LeetCode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://fanbaoying.github.io/LeetCode-61-旋转链表/</id>
    <published>2022-07-06T10:58:57.000Z</published>
    <updated>2022-07-06T11:09:10.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 61 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[4,5,1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [0,1,2], k = 4</span><br><span class="line">输出：[2,0,1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 2 * 10^9</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public var val: Int</span></span><br><span class="line"><span class="comment"> *     public var next: ListNode?</span></span><br><span class="line"><span class="comment"> *     public init(_ val: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.val = val</span></span><br><span class="line"><span class="comment"> *         self.next = nil</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RotateList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">rotateRight</span><span class="params">(head: ListNode?, <span class="number">_</span> k: Int)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> prev = head</span><br><span class="line">        <span class="keyword">var</span> post = head</span><br><span class="line">        <span class="keyword">let</span> len = _getLength(head)</span><br><span class="line">        <span class="keyword">var</span> k = k % len</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">            post = post!.next</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> post!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">            prev = prev!.next</span><br><span class="line">            post = post!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        post!.next = head</span><br><span class="line">        post = prev!.next</span><br><span class="line">        prev!.next = <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> post</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_getLength</span><span class="params">(head: ListNode?)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> node = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            len += <span class="number">1</span></span><br><span class="line">            node = node!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：Runner Tech。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/rotate-list/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 61 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 60 排列序列</title>
    <link href="https://fanbaoying.github.io/LeetCode-60-%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <id>https://fanbaoying.github.io/LeetCode-60-排列序列/</id>
    <published>2022-07-06T10:58:45.000Z</published>
    <updated>2022-07-06T11:08:52.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 59 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li><code>&quot;321&quot;</code></li></ol><p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, k = 3</span><br><span class="line">输出：&quot;213&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 9</span><br><span class="line">输出：&quot;2314&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, k = 1</span><br><span class="line">输出：&quot;123&quot;</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li><code>1 &lt;= k &lt;= n!</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermutationSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getPermutation</span><span class="params">(<span class="number">_</span> n: Int, <span class="number">_</span> k: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> factorial = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ..&lt; n &#123;</span><br><span class="line">            factorial *= i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">var</span> k = k</span><br><span class="line">        <span class="keyword">var</span> divisor = n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; n &#123;</span><br><span class="line">            <span class="keyword">for</span> (index, number) <span class="keyword">in</span> numbers.enumerated() &#123;</span><br><span class="line">                <span class="keyword">if</span> k &gt; factorial &#123;</span><br><span class="line">                    k -= factorial</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result += <span class="string">"<span class="subst">\(number)</span>"</span></span><br><span class="line">                    numbers.remove(at: index)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> divisor &gt; <span class="number">1</span> &#123;</span><br><span class="line">                factorial /= divisor</span><br><span class="line">                divisor -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：迭代并将数组从最后一个更改为第一个。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/permutation-sequence/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 59 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 59 螺旋矩阵 II</title>
    <link href="https://fanbaoying.github.io/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II/"/>
    <id>https://fanbaoying.github.io/LeetCode-59-螺旋矩阵-II/</id>
    <published>2022-07-06T10:58:32.000Z</published>
    <updated>2022-07-06T11:06:17.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 58 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrixII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">generateMatrix</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">guard</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [[<span class="type">Int</span>]]()</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> res = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: n), <span class="built_in">count</span>: n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="number">0</span>..&lt;n / <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> start = layer</span><br><span class="line">            <span class="keyword">let</span> end = n - layer - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// top</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> start..&lt;end &#123;</span><br><span class="line">                res[start][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// right</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> start..&lt;end &#123;</span><br><span class="line">                res[i][end] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// bottom</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: end, to: start, by: -<span class="number">1</span>) &#123;</span><br><span class="line">                res[end][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// left</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: end, to: start, by: -<span class="number">1</span>) &#123;</span><br><span class="line">                res[i][start] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// handle the center one</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            res[n / <span class="number">2</span>][n / <span class="number">2</span>] = n * n</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：从顺时针开始，填充数字，记住处理中间的一个。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/spiral-matrix-ii/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 58 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 58 最后一个单词的长度</title>
    <link href="https://fanbaoying.github.io/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>https://fanbaoying.github.io/LeetCode-58-最后一个单词的长度/</id>
    <published>2022-07-06T10:58:18.000Z</published>
    <updated>2022-07-06T11:05:57.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 56 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;Hello World&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最后一个单词是“World”，长度为5。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;   fly me   to   the moon  &quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最后一个单词是“moon”，长度为4。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;luffy is still joyboy&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：最后一个单词是长度为6的“joyboy”。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthLastWord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lengthOfLastWord</span><span class="params">(s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> sChars = [<span class="type">Character</span>](s.characters)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> sChars.<span class="built_in">count</span> != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">0</span>...sChars.<span class="built_in">count</span> - <span class="number">1</span>).<span class="built_in">reverse</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> res == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> sChars[i] == <span class="string">" "</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> sChars[i] == <span class="string">" "</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：向后迭代字符串。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/length-of-last-word/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 56 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 57 插入区间</title>
    <link href="https://fanbaoying.github.io/LeetCode-57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>https://fanbaoying.github.io/LeetCode-57-插入区间/</id>
    <published>2022-07-06T10:58:04.000Z</published>
    <updated>2022-07-06T11:05:33.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 56 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个 <strong>无重叠的</strong> ，按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [], newInterval = [5,7]</span><br><span class="line">输出：[[5,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,5]], newInterval = [2,3]</span><br><span class="line">输出：[[1,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,5]], newInterval = [2,7]</span><br><span class="line">输出：[[1,7]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= intervals.length &lt;= 10^4</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 10^5</code></li><li><code>intervals</code> 根据 <code>intervals[i][0]</code> 按 <strong>升序</strong> 排列</li><li><code>newInterval.length == 2</code></li><li><code>0 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 10^5</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     public var start: Int</span></span><br><span class="line"><span class="comment"> *     public var end: Int</span></span><br><span class="line"><span class="comment"> *     public init(_ start: Int, _ end: Int) &#123;</span></span><br><span class="line"><span class="comment"> *         self.start = start</span></span><br><span class="line"><span class="comment"> *         self.end = end</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertInterval</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> intervals: [Interval], <span class="number">_</span> newInterval: Interval)</span></span> -&gt; [<span class="type">Interval</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">Interval</span>] = []</span><br><span class="line">        <span class="keyword">var</span> tempInterval = <span class="type">Interval</span>(newInterval.start, newInterval.end)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> index &lt; intervals.<span class="built_in">count</span> &amp;&amp; newInterval.start &gt; intervals[index].end &#123;</span><br><span class="line">            result.append(intervals[index])</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> index &lt; intervals.<span class="built_in">count</span> &amp;&amp; newInterval.end &gt;= intervals[index].start &#123;</span><br><span class="line">            <span class="keyword">let</span> minStart = <span class="built_in">min</span>(tempInterval.start, intervals[index].start)</span><br><span class="line">            <span class="keyword">let</span> maxEnd = <span class="built_in">max</span>(tempInterval.end, intervals[index].end)</span><br><span class="line">            tempInterval = <span class="type">Interval</span>(minStart, maxEnd)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.append(tempInterval)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> index ..&lt; intervals.<span class="built_in">count</span> &#123;</span><br><span class="line">            result.append(intervals[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：首先，检查nuewInterval的开始是否大于一个interval的结束。如果是，保存索引，否则保存间隔；第二，如果nuewInterval的end大于一个interval的start，则继续更新一个新的interval。如果不能找到更多的interval，则将新的interval附加到结果数组中；最后一步，将剩余间隔添加到结果数组</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/insert-interval/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 56 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 56 合并区间（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-56-合并区间（Top-100）/</id>
    <published>2022-07-06T10:57:51.000Z</published>
    <updated>2022-07-06T11:04:59.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 55 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 10^4</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 10^4</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *   public var start: Int</span></span><br><span class="line"><span class="comment"> *   public var end: Int</span></span><br><span class="line"><span class="comment"> *   public init(_ start: Int, _ end: Int) &#123;</span></span><br><span class="line"><span class="comment"> *     self.start = start</span></span><br><span class="line"><span class="comment"> *     self.end = end</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals: [Interval])</span></span> -&gt; [<span class="type">Interval</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">Interval</span>]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> intervals = intervals.sorted &#123;</span><br><span class="line">            <span class="keyword">if</span> $<span class="number">0</span>.start != $<span class="number">1</span>.start &#123;</span><br><span class="line">                <span class="keyword">return</span> $<span class="number">0</span>.start &lt; $<span class="number">1</span>.start</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> $<span class="number">0</span>.end &lt; $<span class="number">1</span>.end</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> last = result.last <span class="keyword">else</span> &#123;</span><br><span class="line">                result.append(interval)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> last.end &lt; interval.start &#123;</span><br><span class="line">                result.append(interval)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last.end = <span class="built_in">max</span>(last.end, interval.end)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对原始的间隔进行排序，然后一个接一个地添加它们。</li><li>时间复杂度： O(nlogn)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/merge-intervals/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 55 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 55 跳跃游戏</title>
    <link href="https://fanbaoying.github.io/LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>https://fanbaoying.github.io/LeetCode-55-跳跃游戏/</id>
    <published>2022-07-06T10:57:36.000Z</published>
    <updated>2022-07-06T11:05:16.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 54 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JumpGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maximumIndex = nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (currentIndex, value) <span class="keyword">in</span> nums.enumerated()&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> currentIndex &gt; maximumIndex&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            maximumIndex = <span class="built_in">max</span>(maximumIndex, currentIndex + value)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：检查每个位置与前一步所能到达的最远距离。如果我走了最后一步，就意味着无法到达。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/jump-game/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 54 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 54 螺旋矩阵</title>
    <link href="https://fanbaoying.github.io/LeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>https://fanbaoying.github.io/LeetCode-54-螺旋矩阵/</id>
    <published>2022-07-06T10:57:22.000Z</published>
    <updated>2022-07-06T11:04:41.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 53 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(<span class="number">_</span> matrix: [[Int]])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> res = [<span class="type">Int</span>]()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">guard</span> matrix.<span class="built_in">count</span> != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> startX = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> endX = matrix.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> startY = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> endY = matrix[<span class="number">0</span>].<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">            <span class="comment">// top</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> startY...endY &#123;</span><br><span class="line">                res.append(matrix[startX][<span class="type">I</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            startX += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> startX &gt; endX &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// right</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> startX...endX &#123;</span><br><span class="line">                res.append(matrix[i][endY])</span><br><span class="line">            &#125;</span><br><span class="line">            endY -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> startY &gt; endY &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// bottom</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: endY, through: startY, by: -<span class="number">1</span>) &#123;</span><br><span class="line">                res.append(matrix[endX][<span class="type">I</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            endX -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> startX &gt; endX &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// left</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: endX, through: startX, by: -<span class="number">1</span>) &#123;</span><br><span class="line">                res.append(matrix[i][startY])</span><br><span class="line">            &#125;</span><br><span class="line">            startY += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> startY &gt; endY &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：在迭代过程中使用四个索引来获得正确的元素。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/spiral-matrix/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 53 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 53 最大子数组和（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-53-最大子数组和（Top-100）/</id>
    <published>2022-07-06T10:56:40.000Z</published>
    <updated>2022-07-06T11:04:22.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 52 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> max_current = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">var</span> max_global = nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;nums.<span class="built_in">count</span> &#123;</span><br><span class="line">            max_current = <span class="built_in">max</span>(max_current + nums[i], nums[i])</span><br><span class="line">            max_global = <span class="built_in">max</span>(max_current, max_global)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_global</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：动态规划中，每个角色要么与前一个序列匹配，要么以一个新序列为最大值。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/maximum-subarray/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 52 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>逐步实现基于源码的 Swift 代码覆盖率</title>
    <link href="https://fanbaoying.github.io/%E9%80%90%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E7%9A%84-Swift-%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>https://fanbaoying.github.io/逐步实现基于源码的-Swift-代码覆盖率/</id>
    <published>2022-06-24T07:12:47.000Z</published>
    <updated>2022-06-24T07:15:36.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近，正在为我司的项目研究基于 Swift 的代码覆盖率检测方案的解决方案，我已经努力尝试并且找到了最佳实践。</p><p>在这篇短文中，我将会给你介绍：</p><ul><li><p><strong>如何生成 *.profraw 文件并通过命令行测量代码覆盖率</strong></p></li><li><p><strong>如何在 Swift App 项目里调用 C/C++ 方法</strong></p></li><li><p><strong>如何在 Xcode 中测量完整 Swift App 项目的代码覆盖率</strong></p></li></ul><a id="more"></a><h2 id="使用命令行练习"><a href="#使用命令行练习" class="headerlink" title="使用命令行练习"></a>使用命令行练习</h2><p>在我们测量完整 App 项目的代码覆盖率之前，需要创建一个简单的 Swift 源代码文件，并且用命令行生成一个 <code>*.profraw</code> 文件，以便我们学习生成覆盖配置文件的基本工作流程。</p><p>创建一个 Swift 文件并包含以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> x: Double, <span class="number">_</span> y: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>在终端运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc -profile-generate -profile-coverage-mapping hello.swift</span><br></pre></td></tr></table></figure><p>传递给编译器的选项  <code>-profile-generate</code> 和 <code>-profile-coverage-mapping</code> 将在编译源码时启用覆盖特性。基于源码的代码覆盖功能直接对 AST 和预处理器信息进行操作。</p><p>然后运行输出的二进制文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure><p>运行完成之后，在当前目录下执行 <code>ls</code> ，我们会看到这里生成了一个名为 <code>default.profraw</code> 的新文件。该文件由 llvm 生成，为了衡量代码覆盖率，我们必须使用另一个工具 llvm-profdata 来组合多个原始配置文件并同时对其进行索引。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun llvm-profdata merge -sparse default.profraw -o hello.profdata</span><br></pre></td></tr></table></figure><p>在终端运行上面的命令行，我们会得到一个名为 <code>hello.profdata</code>  的新文件，它可以显示我们想要的覆盖率报告。我们可以使用 llvm-cov 来显示或生成 JSON 报告。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun llvm-cov show ./hello -instr-profile=hello.profdata</span><br><span class="line">xcrun llvm-cov export ./hello -instr-profile=hello.profdata</span><br></pre></td></tr></table></figure><p>现在，我们已经了解了生成快速代码覆盖率报告的基本工作流程。似乎 Swift 基于源码的代码覆盖并没有那么困难。但是，Xcode 中完整的 Swift App 项目的配置与命令行有很大的不同。那我们接着往下看吧！</p><h2 id="在-Xcode-中测量-Swift-App-项目的代码覆盖率"><a href="#在-Xcode-中测量-Swift-App-项目的代码覆盖率" class="headerlink" title="在 Xcode 中测量 Swift App 项目的代码覆盖率"></a>在 Xcode 中测量 Swift App 项目的代码覆盖率</h2><h3 id="创建-Swift-项目"><a href="#创建-Swift-项目" class="headerlink" title="创建 Swift 项目"></a>创建 Swift 项目</h3><p>选择  <code>SwiftCovApp target -&gt; Build Settings -&gt; Swift Compiler — Custom Flags</code>。</p><p>在 Other Swift Flags 添加  <code>-profile-generate</code> 和 <code>-profile-coverage-mapping</code> 选项：</p><p>如果现在尝试编译，我们将会得到以下错误报告：</p><p>为了解决这个问题，我们必须为所有目标启用代码覆盖率：</p><p>在启用代码覆盖率之后再次运行，项目将会构建成功。</p><p>我们了解到，当程序退出时，编译器会将原始配置文件写入 <code>LLVM_PROFILE_FILE</code> 环境变量指定的路径。所以我们应该杀掉 Application 的进程来实现 <code>*.profraw</code> 文件。但是，当我们结束应用程序时，它会在控制台中报错：</p><p>虽然我在 Build Settings 中设置了相同的配置，但 Xcode 中的默认环境路径为空。为了解决这个问题，我们必须新建一个头文件，并声明一些 llvm C api 函数供 Swift 调用。</p><h3 id="在-Swift-中调用-C-C-方法"><a href="#在-Swift-中调用-C-C-方法" class="headerlink" title="在 Swift 中调用 C/C++ 方法"></a>在 Swift 中调用 C/C++ 方法</h3><p>Swift 是一种基于 C/C++ 的强大语言，它可以直接调用 C/C++ 方法。但是，在我们调用 llvm C/C++ api 之前，我们必须将我们需要的方法导出为一个模块。</p><p>首先，创建一个头文件：</p><p>然后，将以下代码复制粘贴到该文件中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifndef <span class="type">PROFILE_INSTRPROFILING_H_</span></span><br><span class="line">#define <span class="type">PROFILE_INSTRPROFILING_H_int</span> __llvm_profile_runtime = <span class="number">0</span>;void __llvm_profile_initialize_file(void);</span><br><span class="line">const char *__llvm_profile_get_filename();</span><br><span class="line">void __llvm_profile_set_filename(const char *);</span><br><span class="line">int __llvm_profile_write_file();</span><br><span class="line">int __llvm_profile_register_write_file_atexit(void);</span><br><span class="line">const char *__llvm_profile_get_path_prefix();#endif <span class="comment">/* PROFILE_INSTRPROFILING_H_ */</span></span><br></pre></td></tr></table></figure><p>创建一个 <code>module.modulemap</code> 文件并将所有内容导出为一个模块。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  module.modulemap</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by yao on 2020/10/15.</span></span><br><span class="line"><span class="comment">//module InstrProfiling &#123;</span></span><br><span class="line">    header <span class="string">"InstrProfiling.h"</span></span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上我们不能直接创建 <code>module.modulemap</code>，首先创建一个 <code>module.c</code> 文件然后重命名为 <code>module.modulemap</code>，它还可以帮助我创建一个 <code>SwiftCovApp-Bridging-Header</code> 文件。</p><p>构建项目，然后，我们可以在 Swift 代码中调用 llvm apis。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> InstrProfiling</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"File Path Prefix: <span class="subst">\(String(cString: __llvm_profile_get_path_prefix()</span>) )"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"File Name: <span class="subst">\(String(cString: __llvm_profile_get_filename()</span>) )"</span>)</span><br><span class="line">        <span class="keyword">let</span> name = <span class="string">"test.profraw"</span></span><br><span class="line">        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> documentDirectory = <span class="keyword">try</span> fileManager.url(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask, appropriateFor:<span class="literal">nil</span>, create:<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">let</span> filePath: <span class="type">NSString</span> = documentDirectory.appendingPathComponent(name).path <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">            __llvm_profile_set_filename(filePath.utf8String)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"File Name: <span class="subst">\(String(cString: __llvm_profile_get_filename()</span>))"</span>)</span><br><span class="line">            __llvm_profile_write_file()</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建并启动 App，我们将在控制台中看到原始配置文件路径。</p><p>最后，我们得到了需要的原始配置文件！ 🎉</p><p>我们可以复制这个文件和 Swift App 项目中的 Mach-O（二进制文件）到 temp 目录下，这样我们就可以检查配置文件是否可以生成正确的报告。</p><p>创建一个新的 Swift 文件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BasicMath</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> a: Double, <span class="number">_</span> b: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(<span class="number">_</span> x: Double, <span class="number">_</span> <span class="built_in">min</span>: Double, <span class="number">_</span> <span class="built_in">max</span>: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> q = 1e-<span class="number">10</span></span><br><span class="line">    <span class="keyword">let</span> mid = (<span class="built_in">max</span> + <span class="built_in">min</span>) / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> fabs(mid * mid - x) &gt; q &#123;</span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt; x &#123;</span><br><span class="line">                <span class="keyword">return</span> sqrt(x, mid, <span class="built_in">max</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid * mid &gt; x &#123;</span><br><span class="line">                <span class="keyword">return</span> sqrt(x, <span class="built_in">min</span>, mid)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(<span class="number">_</span> x: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    sqrt(x, <span class="number">0</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ViewController.swift 中调用  __llvm_profile_write_file 之前调用 sqrt。然后，构建并运行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"√2=<span class="subst">\(BasicMath()</span>.sqrt(2))"</span>)</span><br><span class="line">__llvm_profile_write_file()</span><br></pre></td></tr></table></figure><p>在命令行中运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir TestCoverage</span><br><span class="line">cd TestCoverage</span><br><span class="line">cp /Users/yao/Library/Developer/CoreSimulator/Devices/4545834C-8D1F-4D2C-B243-F9E617F6C52D/data/Containers/Data/Application/6AEFAB1B-DA52-4FAF-9B27-3D47A898E55C/Documents/test.profraw .</span><br><span class="line">cp /Users/yao/Library/Developer/Xcode/DerivedData/SwiftCovApp-bohvioqnvkjxnnesyhlznzvmmgcg/Build/Products/Debug-iphonesimulator/SwiftCovApp.app/SwiftCovApp .</span><br><span class="line">ls</span><br><span class="line">xcrun llvm-profdata merge -sparse test.profraw -o test.profdata</span><br><span class="line">xcrun llvm-cov show ./SwiftCovApp -instr-profile=test.profdata</span><br></pre></td></tr></table></figure><p>我们就能看到最后的报告啦～👏🎉</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html" target="_blank" rel="noopener">Clang 12 Documentation</a></li><li><a href="https://mp.weixin.qq.com/s/14hmLWNXAh1FKZT5NI5QsQ" target="_blank" rel="noopener">Objective-C 与 Swift 混编工程精准测试探索</a>    </li></ul><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;最近，正在为我司的项目研究基于 Swift 的代码覆盖率检测方案的解决方案，我已经努力尝试并且找到了最佳实践。&lt;/p&gt;
&lt;p&gt;在这篇短文中，我将会给你介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如何生成 *.profraw 文件并通过命令行测量代码覆盖率&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如何在 Swift App 项目里调用 C/C++ 方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如何在 Xcode 中测量完整 Swift App 项目的代码覆盖率&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Swift" scheme="https://fanbaoying.github.io/categories/Swift/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 52 N皇后 II</title>
    <link href="https://fanbaoying.github.io/LeetCode-52-N%E7%9A%87%E5%90%8E-II/"/>
    <id>https://fanbaoying.github.io/LeetCode-52-N皇后-II/</id>
    <published>2022-06-24T07:12:08.000Z</published>
    <updated>2022-07-06T10:55:33.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 51 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NQueensII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> usedCols = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: n)</span><br><span class="line">        </span><br><span class="line">        dfs(&amp;usedCols, &amp;<span class="built_in">count</span>, n, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> usedCols: <span class="keyword">inout</span> [Int], <span class="number">_</span> <span class="built_in">count</span>: <span class="keyword">inout</span> Int, <span class="number">_</span> n: Int, <span class="number">_</span> row: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> row == n &#123;</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">            <span class="keyword">if</span> isValid(usedCols, row, col) &#123;</span><br><span class="line">                usedCols[row] = col</span><br><span class="line">                dfs(&amp;usedCols, &amp;<span class="built_in">count</span>, n, row + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(<span class="number">_</span> usedCols: [Int], <span class="number">_</span> row: Int, <span class="number">_</span> col: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">c</span> = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;row &#123;</span><br><span class="line">            <span class="built_in">c</span> = usedCols[<span class="type">I</span>] </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check col</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">c</span> == col &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(<span class="built_in">c</span> - col) == <span class="built_in">abs</span>(i - row) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索，逐行填写，每次检查列和诊断，只需要关心使用哪个列。</li><li>时间复杂度： O(n^n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/n-queens-ii/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 51 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="LeetCode" scheme="https://fanbaoying.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
