<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FBY展菲个人博客</title>
  
  <subtitle>『公众号：网罗开发』</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2018-12-16T09:36:04.066Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>FBY展菲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS--React Native浏览器插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native浏览器插件/</id>
    <published>2018-12-16T09:34:19.000Z</published>
    <updated>2018-12-16T09:36:04.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><a id="more"></a><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生浏览器插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生浏览器插件是需要实现打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建WebviewManager类，实现自定义浏览器</p></li><li><p>新建Webview类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>URL规范检测</p></li><li><p>根据传参打开浏览器</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建WebviewManager类，实现自定义浏览器"><a href="#1-新建WebviewManager类，实现自定义浏览器" class="headerlink" title="1. 新建WebviewManager类，实现自定义浏览器"></a>1. 新建WebviewManager类，实现自定义浏览器</h5><p>新建继承UIViewController的WebviewManager类，并在.h声明webURL变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface WebviewManager : UIViewController</span><br><span class="line">@property(nonatomic,strong)NSString *webURL;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>通过webURL调用NSURLRequest 封装的requestWithURL方法打开浏览器，并在视图中显示，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//WebviewManager.m</span><br><span class="line">#import &quot;WebviewManager.h&quot;</span><br><span class="line">#import&lt;WebKit/WebKit.h&gt;</span><br><span class="line">@interface WebviewManager ()</span><br><span class="line">@property(nonatomic,strong)WKWebView *webView;</span><br><span class="line">@end</span><br><span class="line">@implementation WebviewManager</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    btn.frame = CGRectMake(20, 30, 40, 24);</span><br><span class="line">    [btn setTitle:@&quot;返回&quot; forState:UIControlStateNormal];</span><br><span class="line">    [btn addTarget:self action:@selector(backAction)</span><br><span class="line">              forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    btn.titleLabel.font = [UIFont systemFontOfSize:15];</span><br><span class="line">    [btn setTitleColor:[UIColor blackColor]  forState:UIControlStateNormal];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line">    self.webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 64, [[UIScreen mainScreen]bounds].size.width, [[UIScreen mainScreen]bounds].size.height-64)];</span><br><span class="line">    [self.view addSubview:self.webView];</span><br><span class="line">    [self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:self.webURL]]];   </span><br><span class="line">&#125;</span><br><span class="line">- (void)backAction&#123;</span><br><span class="line">    [self dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-新建Webview类，实现RCTBridgeModule协议"><a href="#2-新建Webview类，实现RCTBridgeModule协议" class="headerlink" title="2. 新建Webview类，实现RCTBridgeModule协议"></a>2. 新建Webview类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的Webview类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface Webview : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加RCT-EXPORT-MODULE-宏"><a href="#3-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="3. 添加RCT_EXPORT_MODULE()宏"></a>3. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，Webview的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“WebviewPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="4-添加React-Native跟控制器"><a href="#4-添加React-Native跟控制器" class="headerlink" title="4. 添加React Native跟控制器"></a>4. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="5-声明被JavaScript-调用的方法"><a href="#5-声明被JavaScript-调用的方法" class="headerlink" title="5. 声明被JavaScript 调用的方法"></a>5. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起打开浏览器方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="6-URL规范检测"><a href="#6-URL规范检测" class="headerlink" title="6. URL规范检测"></a>6. URL规范检测</h5><p>arguments字典是JavaScript调用方法传参用的，arguments字典里面的具体字段可以和JavaScript约定好，打开浏览器的url就是通过arguments字典传过来的，传过来的url字段还不能直接使用，需要检测是否符合url规范，否则是不能正常打开网页的。<br>URL规范检测代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)smartURLForString:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    NSString *     result;</span><br><span class="line">    NSString *  trimmedStr;</span><br><span class="line">    NSRange     schemeMarkerRange;</span><br><span class="line">    NSString *  scheme;</span><br><span class="line">    assert(str != nil);</span><br><span class="line">    result = nil;</span><br><span class="line">    trimmedStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br><span class="line">    if ( (trimmedStr != nil) &amp;&amp; (trimmedStr.length != 0) ) &#123;</span><br><span class="line">        schemeMarkerRange = [trimmedStr rangeOfString:@&quot;://&quot;];</span><br><span class="line">        if (schemeMarkerRange.location == NSNotFound) &#123;</span><br><span class="line">            result = [NSString stringWithFormat:@&quot;http://%@&quot;, trimmedStr];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scheme = [trimmedStr substringWithRange:NSMakeRange(0, schemeMarkerRange.location)];</span><br><span class="line">            assert(scheme != nil);</span><br><span class="line">            if ( ([scheme compare:@&quot;http&quot;  options:NSCaseInsensitiveSearch] == NSOrderedSame)</span><br><span class="line">                || ([scheme compare:@&quot;https&quot; options:NSCaseInsensitiveSearch] == NSOrderedSame) ) &#123;</span><br><span class="line">                result = trimmedStr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // It looks like this is some unsupported URL scheme.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-根据传参打开浏览器"><a href="#7-根据传参打开浏览器" class="headerlink" title="7. 根据传参打开浏览器"></a>7. 根据传参打开浏览器</h5><p>此浏览器插件支持打开自定义浏览器和打开默认浏览器，具体使用哪种方法打开浏览器，需要JavaScript通过arguments字典以字段的形式传过来，这里就使用openType字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Webview.m</span><br><span class="line">#import &quot;Webview.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation Webview</span><br><span class="line">RCT_EXPORT_MODULE(WebviewPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    if ([arguments.allKeys containsObject:@&quot;url&quot;]) &#123;</span><br><span class="line">        NSString *url = [NSString stringWithFormat:@&quot;%@&quot;,arguments[@&quot;url&quot;]];</span><br><span class="line">        NSString *openURL = [self smartURLForString:url];</span><br><span class="line">        NSString *openType = arguments[@&quot;openType&quot;];</span><br><span class="line">        if (!ValidStr(url)&amp;&amp;!ValidStr(openType)) &#123;</span><br><span class="line">            CIBNSLog(@&quot;参数错误&quot;);</span><br><span class="line">            failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if ([openType isEqualToString:[NSString stringWithFormat:@&quot;0&quot;]]) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    WebviewManager *manager = [[WebviewManager alloc]init];</span><br><span class="line">                    manager.webURL = openURL;</span><br><span class="line">                    UIViewController *vc = RCTPresentedViewController();</span><br><span class="line">                    [vc presentViewController:manager animated:YES completion:nil];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSURL *urlStr = [NSURL URLWithString:openURL];</span><br><span class="line">                    [[UIApplication sharedApplication] openURL:urlStr];</span><br><span class="line">                    completion(@[@&#123;@&quot;status&quot;:@&quot;1&quot;,@&quot;data&quot;:@&quot;成功&quot;&#125;]);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        failure(@[@&#123;@&quot;resultCode&quot;:@&quot;0&quot;,@&quot;resultMessage&quot;:@&quot;参数错误&quot;&#125;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-Javascript调用浏览器方法"><a href="#8-Javascript调用浏览器方法" class="headerlink" title="8. Javascript调用浏览器方法"></a>8. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const WebviewPlugin = NativeModules.WebviewPlugin;</span><br><span class="line">WebviewPlugin.open(&#123;url:&quot;http://www.baidu.com&quot;,openType:&quot;1&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
&lt;p&gt;在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS--React Native网络请求插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native网络请求插件/</id>
    <published>2018-12-16T09:11:01.000Z</published>
    <updated>2018-12-16T09:13:40.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><a id="more"></a><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍网络请求插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>网络请求插件是需要实现前端与服务端的数据交互，其中包括GET请求、POST请求、文件上传、单/多张图片上传、文件下载等功能。这些功能将通过封装后的方法暴漏出来，通过RN接口提供给Javascript开发使用。</p><p>具体的实现思路如下：</p><ol><li><p>新建NetWorkPlugin类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>导入AFNetworking请求库</p></li><li><p>新建NetworkHelper类，封装实现网络请求功能</p></li><li><p>实现GET请求</p></li><li><p>实现POST请求</p></li><li><p>实现文件上传</p></li><li><p>实现单/多张图片上传</p></li><li><p>实现文件下载</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建NetWorkPlugin类，实现RCTBridgeModule协议"><a href="#1-新建NetWorkPlugin类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建NetWorkPlugin类，实现RCTBridgeModule协议"></a>1. 新建NetWorkPlugin类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的NetWorkPlugin类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface NetWorkPlugin : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，NetWorkPlugin的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“NetWorkPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。下面通过举例来展示声明的方法，通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// NetWorkPlugin.m</span><br><span class="line">#import &quot;NetWorkPlugin.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation NetWorkPlugin</span><br><span class="line">RCT_EXPORT_MODULE(NetWorkPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(post:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;POST网络请求执行方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-导入AFNetworking请求库"><a href="#5-导入AFNetworking请求库" class="headerlink" title="5. 导入AFNetworking请求库"></a>5. 导入AFNetworking请求库</h5><p>网络请求使用的第三方库是AFNetworking，这个库很常见，也比较常用，就不做过多的描述，可手动导入也可使用cocoapods自动导入，导入之后在.m文件中引入头文件。</p><h5 id="6-新建NetworkHelper类，封装实现网络请求功能"><a href="#6-新建NetworkHelper类，封装实现网络请求功能" class="headerlink" title="6. 新建NetworkHelper类，封装实现网络请求功能"></a>6. 新建NetworkHelper类，封装实现网络请求功能</h5><p>新建继承NSObject的NetworkHelper类，定义枚举类型来判断网络状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NetworkStatusType) &#123;</span><br><span class="line">    /** 未知网络*/</span><br><span class="line">    NetworkStatusUnknown,</span><br><span class="line">    /** 无网络*/</span><br><span class="line">    NetworkStatusNotReachable,</span><br><span class="line">    /** 手机网络*/</span><br><span class="line">    NetworkStatusReachableViaWWAN,</span><br><span class="line">    /** WIFI网络*/</span><br><span class="line">    NetworkStatusReachableViaWiFi</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>定义网络状态的Block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^NetworkStatus)(NetworkStatusType status);</span><br></pre></td></tr></table></figure></p><p>实时获取网络状态,通过Block回调实时获取(此方法可多次调用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkStatusWithBlock:(NetworkStatus)networkStatus;</span><br></pre></td></tr></table></figure></p><h5 id="7-实现GET请求"><a href="#7-实现GET请求" class="headerlink" title="7. 实现GET请求"></a>7. 实现GET请求</h5><p>声明GET请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)GET:(NSString *)URL</span><br><span class="line">                        parameters:(id)parameters</span><br><span class="line">                           success:(HttpRequestSuccess)success</span><br><span class="line">                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><h5 id="8-实现POST请求"><a href="#8-实现POST请求" class="headerlink" title="8. 实现POST请求"></a>8. 实现POST请求</h5><p>声明POST请求方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                         parameters:(id)parameters</span><br><span class="line">                            success:(HttpRequestSuccess)success</span><br><span class="line">                            failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>POST请求具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)POST:(NSString *)URL</span><br><span class="line">                parameters:(id)parameters</span><br><span class="line">                   success:(HttpRequestSuccess)success</span><br><span class="line">                   failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    [self setAFHTTPSessionManagerProperty:^(AFHTTPSessionManager *sessionManager) &#123;</span><br><span class="line">        [sessionManager.requestSerializer setQueryStringSerializationWithBlock:^NSString * _Nonnull(NSURLRequest * _Nonnull request, id  _Nonnull parameters, NSError * _Nullable __autoreleasing * _Nullable error) &#123;</span><br><span class="line">            return parameters;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-实现文件上传"><a href="#9-实现文件上传" class="headerlink" title="9. 实现文件上传"></a>9. 实现文件上传</h5><p>声明文件上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param names       文件对应服务器上的字段</span><br><span class="line"> *  @param filePaths   文件本地的沙盒路径</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                            names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                                        filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                                        progress:(HttpProgress)progress</span><br><span class="line">                                         success:(HttpRequestSuccess)success</span><br><span class="line">                                         failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>文件上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadFileWithURL:(NSString *)URL</span><br><span class="line">                             parameters:(id)parameters</span><br><span class="line">                                  names:(NSArray&lt;NSString *&gt; *)names</span><br><span class="line">                              filePaths:(NSArray&lt;NSString *&gt; *)filePaths</span><br><span class="line">                               progress:(HttpProgress)progress</span><br><span class="line">                                success:(HttpRequestSuccess)success</span><br><span class="line">                                failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; filePaths.count; i++) &#123;</span><br><span class="line">            NSString *name = names[i];</span><br><span class="line">            NSString *filePath = filePaths[i];</span><br><span class="line">            [formData appendPartWithFileURL:[NSURL fileURLWithPath:filePath] name:name error:&amp;error];</span><br><span class="line">        &#125;</span><br><span class="line">        (failure &amp;&amp; error) ? failure(error) : nil;</span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        //上传进度</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="10-实现单-多张图片上传"><a href="#10-实现单-多张图片上传" class="headerlink" title="10. 实现单/多张图片上传"></a>10. 实现单/多张图片上传</h5><p>声明单/多张图片上传方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL        请求地址</span><br><span class="line"> *  @param parameters 请求参数</span><br><span class="line"> *  @param name       图片对应服务器上的字段</span><br><span class="line"> *  @param images     图片数组</span><br><span class="line"> *  @param fileNames  图片文件名数组, 可以为nil, 数组内的文件名默认为当前日期时间&quot;yyyyMMddHHmmss&quot;</span><br><span class="line"> *  @param imageScale 图片文件压缩比 范围 (0.f ~ 1.f)</span><br><span class="line"> *  @param imageType  图片文件的类型,例:png、jpg(默认类型)....</span><br><span class="line"> *  @param progress   上传进度信息</span><br><span class="line"> *  @param success    请求成功的回调</span><br><span class="line"> *  @param failure    请求失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回的对象可取消请求,调用cancel方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                                        parameters:(id)parameters</span><br><span class="line">                                              name:(NSString *)name</span><br><span class="line">                                            images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                         fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                                        imageScale:(CGFloat)imageScale</span><br><span class="line">                                         imageType:(NSString *)imageType</span><br><span class="line">                                          progress:(HttpProgress)progress</span><br><span class="line">                                           success:(HttpRequestSuccess)success</span><br><span class="line">                                           failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>图片经过等比压缩后得到的二进制文件，默认图片的文件名, 若fileNames为nil就使用，单/多张图片上传具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)uploadImagesWithURL:(NSString *)URL</span><br><span class="line">                               parameters:(id)parameters</span><br><span class="line">                                     name:(NSString *)name</span><br><span class="line">                                   images:(NSArray&lt;UIImage *&gt; *)images</span><br><span class="line">                                fileNames:(NSArray&lt;NSString *&gt; *)fileNames</span><br><span class="line">                               imageScale:(CGFloat)imageScale</span><br><span class="line">                                imageType:(NSString *)imageType</span><br><span class="line">                                 progress:(HttpProgress)progress</span><br><span class="line">                                  success:(HttpRequestSuccess)success</span><br><span class="line">                                  failure:(HttpRequestFailed)failure &#123;</span><br><span class="line"></span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line"></span><br><span class="line">    NSURLSessionTask *sessionTask = [_sessionManager POST:AllReplaceURL parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line"></span><br><span class="line">        for (NSUInteger i = 0; i &lt; images.count; i++) &#123;</span><br><span class="line">            NSData *imageData = UIImageJPEGRepresentation(images[i], imageScale ?: 1.f);</span><br><span class="line"></span><br><span class="line">            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">            formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;;</span><br><span class="line">            NSString *str = [formatter stringFromDate:[NSDate date]];</span><br><span class="line">            NSString *imageFileName = NSStringFormat(@&quot;%@%ld.%@&quot;,str,i,imageType?:@&quot;jpg&quot;);</span><br><span class="line"></span><br><span class="line">            [formData appendPartWithFileData:imageData</span><br><span class="line">                                        name:name</span><br><span class="line">                                    fileName:fileNames ? NSStringFormat(@&quot;%@.%@&quot;,fileNames[i],imageType?:@&quot;jpg&quot;) : imageFileName</span><br><span class="line">                                    mimeType:NSStringFormat(@&quot;image/%@&quot;,imageType ?: @&quot;jpg&quot;)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(uploadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;responseObject = %@&quot;,[self jsonToString:responseObject]);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        success ? success(responseObject) : nil;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">        if (_isOpenLog) &#123;NSLog(@&quot;error = %@&quot;,error);&#125;</span><br><span class="line">        [[self allSessionTask] removeObject:task];</span><br><span class="line">        failure ? failure(error) : nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    sessionTask ? [[self allSessionTask] addObject:sessionTask] : nil ;</span><br><span class="line">    return sessionTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="11-实现文件下载"><a href="#11-实现文件下载" class="headerlink" title="11. 实现文件下载"></a>11. 实现文件下载</h5><p>声明文件下载方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param URL      请求地址</span><br><span class="line"> *  @param fileDir  文件存储目录(默认存储目录为Download)</span><br><span class="line"> *  @param progress 文件下载的进度信息</span><br><span class="line"> *  @param success  下载成功的回调(回调参数filePath:文件的路径)</span><br><span class="line"> *  @param failure  下载失败的回调</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回NSURLSessionDownloadTask实例，可用于暂停继续，暂停调用suspend方法，开始下载调用resume方法</span><br><span class="line"> */</span><br><span class="line">+ (__kindof NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                                       fileDir:(NSString *)fileDir</span><br><span class="line">                                      progress:(HttpProgress)progress</span><br><span class="line">                                       success:(void(^)(NSString *filePath))success</span><br><span class="line">                                       failure:(HttpRequestFailed)failure;</span><br></pre></td></tr></table></figure></p><p>在下载过程中可以获取到下载进度，下载流程为：缓存目录拼接完成，打开文件管理器，创建Download目录，拼接文件路径，返回文件位置的URL路径。文件下载具体的方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionTask *)downloadWithURL:(NSString *)URL</span><br><span class="line">                              fileDir:(NSString *)fileDir</span><br><span class="line">                             progress:(HttpProgress)progress</span><br><span class="line">                              success:(void(^)(NSString *))success</span><br><span class="line">                              failure:(HttpRequestFailed)failure &#123;</span><br><span class="line">    NSString *AllReplaceURL = [self replaceURL:URL];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:AllReplaceURL]];</span><br><span class="line">    __block NSURLSessionDownloadTask *downloadTask = [_sessionManager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            progress ? progress(downloadProgress) : nil;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;</span><br><span class="line">        NSString *downloadDir = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:fileDir ? fileDir : @&quot;Download&quot;];</span><br><span class="line"></span><br><span class="line">        NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line"></span><br><span class="line">        [fileManager createDirectoryAtPath:downloadDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br><span class="line"></span><br><span class="line">        NSString *filePath = [downloadDir stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line"></span><br><span class="line">        return [NSURL fileURLWithPath:filePath];</span><br><span class="line"></span><br><span class="line">    &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        [[self allSessionTask] removeObject:downloadTask];</span><br><span class="line">        if(failure &amp;&amp; error) &#123;failure(error) ; return ;&#125;;</span><br><span class="line">        success ? success(filePath.absoluteString /** NSURL-&gt;NSString*/) : nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    [downloadTask resume];</span><br><span class="line">    downloadTask ? [[self allSessionTask] addObject:downloadTask] : nil ;</span><br><span class="line"></span><br><span class="line">    return downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="12-Javascript调用浏览器方法"><a href="#12-Javascript调用浏览器方法" class="headerlink" title="12. Javascript调用浏览器方法"></a>12. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const NetWorkPlugin = NativeModules.NetWorkPlugin;</span><br><span class="line">NetworkPlugin.post(&#123;url:&quot;http://192.168.1.1:8080/ApiSystem/login&quot;,params:&#123;name:&quot;15842137500&quot;,login_type:&quot;0&quot;,password:&quot;000000&quot;&#125;,headers:&#123;&#125;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line"></span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
&lt;p&gt;在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-React Native 原生密码键盘插件</title>
    <link href="https://fanbaoying.github.io/iOS-React-Native-%E5%8E%9F%E7%94%9F%E5%AF%86%E7%A0%81%E9%94%AE%E7%9B%98%E6%8F%92%E4%BB%B6/"/>
    <id>https://fanbaoying.github.io/iOS-React-Native-原生密码键盘插件/</id>
    <published>2018-12-08T12:48:03.000Z</published>
    <updated>2018-12-08T12:58:26.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p><p>在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。</p><a id="more"></a><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。这篇文章重点介绍原生密码键盘插件的开发与使用</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><p>原生密码键盘插件是需要实现自定以键盘包含数字、大写字母、小写字母、特殊字符四种切换方式，并且需要实现随机键盘和非随机键盘模式。<br>实现根据密码包含数字、大写字母、小写字母、特殊字符种类判断密码强度和长度。<br>为了密码的安全考虑，实现对输出密码进行SM3加密。<br>实现键盘类型，其中包括以下6种类型：</p><blockquote><p> FBYCustomKeyBordType_NumWord,//数字及字母键盘<br>    FBYCustomKeyBordType_WordNum,//字母及数字键盘<br>    FBYCustomKeyBordType_NumWordSymbol,//数字及字母,标点键盘<br>    FBYCustomKeyBordType_WordNumSymbol,//字母及数字,标点键盘<br>    FBYCustomKeyBordType_Num,//仅数字键盘<br>    FBYCustomKeyBordType_Word//仅字母键盘</p></blockquote><p>基本键盘截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-439e92cad094e974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="66.png"></p><p>实现键盘视图显示类型，其中包括以下5种类型：</p><blockquote><p> FBYCustomKeyBordShowType_Common,//普通<br>    FBYCustomKeyBordShowType_Text,//文本框<br>    FBYCustomKeyBordShowType_Pass,//密码<br>    FBYCustomKeyBordShowType_PayPass,//支付密码格<br>    FBYCustomKeyBordShowType_NoTitle//无标题</p></blockquote><p>带有文本框的键盘：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-a49793a2fd35fc83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="88.png"></p><p>有支付密码格的键盘：<br><img src="https://upload-images.jianshu.io/upload_images/2829694-a23509f64f8eda1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="99.png"></p><p>打开默认浏览器和打开自定义浏览器，具体的实现思路如下：</p><ol><li><p>新建CustomKeyboard类，实现RCTBridgeModule协议</p></li><li><p>添加RCT_EXPORT_MODULE()宏</p></li><li><p>添加React Native跟控制器</p></li><li><p>声明被JavaScript 调用的方法</p></li><li><p>新建数字键盘FBYNumKeyBord类，实现相应视图及功能</p></li><li><p>新建字母键盘FBYWordKeyBord类，实现相应视图及功能</p></li><li><p>新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能</p></li><li><p>新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能</p></li><li><p>新建符号键盘FBYCustomKeyBord类，实现键盘类型切换功能</p></li><li><p>实现根据密码判断密码强度和长度功能</p></li><li><p>实现输出密码SM3加密功能</p></li><li><p>根据传参分析调用自定义键盘</p></li><li><p>Javascript调用浏览器方法</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><h5 id="1-新建CustomKeyboard类，实现RCTBridgeModule协议"><a href="#1-新建CustomKeyboard类，实现RCTBridgeModule协议" class="headerlink" title="1. 新建CustomKeyboard类，实现RCTBridgeModule协议"></a>1. 新建CustomKeyboard类，实现RCTBridgeModule协议</h5><p>新建继承NSObject的CustomKeyboard类，并实现RCTBridgeModule协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface CustomKeyboard : NSObject&lt;RCTBridgeModule&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="2-添加RCT-EXPORT-MODULE-宏"><a href="#2-添加RCT-EXPORT-MODULE-宏" class="headerlink" title="2. 添加RCT_EXPORT_MODULE()宏"></a>2. 添加RCT_EXPORT_MODULE()宏</h5><p>为了实现RCTBridgeModule协议，CustomKeyboard的类需要包含RCT_EXPORT_MODULE()宏。<br>并在这个宏里面添加一个参数“KeybordPlugin”用来指定在 JavaScript 中访问这个模块的名字。<br>如果你不指定，默认就会使用这个 Objective-C 类的名字。<br>如果类名以 RCT 开头，则 JavaScript 端引入的模块名会自动移除这个前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5 id="3-添加React-Native跟控制器"><a href="#3-添加React-Native跟控制器" class="headerlink" title="3. 添加React Native跟控制器"></a>3. 添加React Native跟控制器</h5><p>如果不添加React Native跟控制器，view将不能正常显示出来，实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>引入<react rctutils.h="">之后，在视图初始化或者显示的时候，按照如下方法调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *vc = RCTPresentedViewController();</span><br></pre></td></tr></table></figure></react></p><h5 id="4-声明被JavaScript-调用的方法"><a href="#4-声明被JavaScript-调用的方法" class="headerlink" title="4. 声明被JavaScript 调用的方法"></a>4. 声明被JavaScript 调用的方法</h5><p>React Native需要明确的声明要给 JavaScript 导出的方法，否则 React Native 不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(onKeyboard:(NSDictionary *)arguments</span><br><span class="line">                  :(RCTResponseSenderBlock)sucessCallback</span><br><span class="line">                  :(RCTResponseSenderBlock)failCallback)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;调起原生密码键盘方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="5-新建数字键盘FBYNumKeyBord类，实现相应视图及功能"><a href="#5-新建数字键盘FBYNumKeyBord类，实现相应视图及功能" class="headerlink" title="5. 新建数字键盘FBYNumKeyBord类，实现相应视图及功能"></a>5. 新建数字键盘FBYNumKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYNumKeyBord类中，视图包含0-9数字按钮、ABC字母切换按钮、@%#特殊字符切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-2417576b5300316d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="number.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//FBYNumKeyBord.m</span><br><span class="line">- (void)setRandom:(BOOL)random&#123;</span><br><span class="line">    _random = random;</span><br><span class="line">    if (random) &#123;</span><br><span class="line">        NSMutableArray *newArray = [NSMutableArray arrayWithArray:self.numArray];</span><br><span class="line">        for(int i = 0; i&lt; self.numArray.count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int m = (arc4random() % (self.numArray.count - i)) + i;</span><br><span class="line">            [newArray exchangeObjectAtIndex:i withObjectAtIndex: m];</span><br><span class="line">        &#125;</span><br><span class="line">        self.numArray = newArray;</span><br><span class="line">        for (UIButton *btn in self.subviews) &#123;</span><br><span class="line">            [btn removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">        [self addControl];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="6-新建字母键盘FBYWordKeyBord类，实现相应视图及功能"><a href="#6-新建字母键盘FBYWordKeyBord类，实现相应视图及功能" class="headerlink" title="6. 新建字母键盘FBYWordKeyBord类，实现相应视图及功能"></a>6. 新建字母键盘FBYWordKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYWordKeyBord类中，视图包含26个字母按钮、大小写切换按钮、123数字键盘切换按钮、@%#特殊字符切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-5c0e7fc781441217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="1234.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//FBYWordKeyBord.m</span><br><span class="line">for (int i = 0; i&lt; 26; i++) &#123;</span><br><span class="line">        FBYCustomKeyBordButton *btn = [FBYCustomKeyBordButton buttonWithTitle:self.wordArray[i] tag:i delegate:self];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchDown:) forControlEvents:(UIControlEventTouchDown)];</span><br><span class="line">         [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpOutside)];</span><br><span class="line">         [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchCancel)];</span><br><span class="line">        [btnArray addObject:btn];</span><br><span class="line">        [self addSubview:btn];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="7-新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能"><a href="#7-新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能" class="headerlink" title="7. 新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能"></a>7. 新建纯数字键盘FBYNumOnlyKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYNumOnlyKeyBord类中，视图包含0-9数字按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-fe5cee6594182af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="0987.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//FBYNumOnlyKeyBord.m</span><br><span class="line">for (int i=0;i&lt;self.btnArray.count;i++) &#123;</span><br><span class="line">        UIButton *btn =self.btnArray[i];</span><br><span class="line">        if(i&lt;9)&#123;</span><br><span class="line">            btn.frame = CGRectMake(btn.tag % 3 * (btnW ), btn.tag / 3 * (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==9)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 1 * (btnW ),  3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==10)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 0* (btnW ),  3* (btnH ) , btnW, btnH);</span><br><span class="line"></span><br><span class="line">        &#125;else if (i==11)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 2* (btnW ), 3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;else if (i==12)&#123;</span><br><span class="line">            btn.frame = CGRectMake( 0* (btnW ), 3* (btnH ), btnW, btnH);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="8-新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能"><a href="#8-新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能" class="headerlink" title="8. 新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能"></a>8. 新建符号键盘FBYSymbolKeyBord类，实现相应视图及功能</h5><p>在数字键盘FBYSymbolKeyBord类中，视图包含30种特殊字符按钮、123数字键盘切换按钮、ABC字母切换按钮、回删按钮、完成按钮和取消按钮。<br>实现相应按钮的点击功能以及实现随机键盘和非随机键盘两种模式。<br>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-629be3c087db45af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="4321.png"></p><p>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//FBYSymbolKeyBord.m</span><br><span class="line">- (NSArray *)symbolArray&#123;</span><br><span class="line">    if (!_symbolArray) &#123;</span><br><span class="line">        _symbolArray = @[@&quot;*&quot;,@&quot;/&quot;,@&quot;:&quot;,@&quot;;&quot;,@&quot;(&quot;,@&quot;)&quot;,@&quot;[&quot;,@&quot;]&quot;,@&quot;$&quot;,@&quot;=&quot;,@&quot;!&quot;,@&quot;^&quot;,@&quot;&amp;&quot;,@&quot;%&quot;,@&quot;+&quot;,@&quot;-&quot;,@&quot;￥&quot;,@&quot;?&quot;,@&quot;&#123;&quot;,@&quot;&#125;&quot;,@&quot;#&quot;,@&quot;_&quot;,@&quot;\\&quot;,@&quot;|&quot;,@&quot;~&quot;,@&quot;`&quot;,@&quot;∑&quot;,@&quot;€&quot;,@&quot;£&quot;,@&quot;。&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return _symbolArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addControl&#123;</span><br><span class="line">    NSMutableArray *btnArray = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">        FBYCustomKeyBordButton *btn = [FBYCustomKeyBordButton buttonWithTitle:self.symbolArray[i] tag:i delegate:self];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchDown:) forControlEvents:(UIControlEventTouchDown)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchUpOutside)];</span><br><span class="line">        [btn addTarget:self action:@selector(btnTouchCancel:) forControlEvents:(UIControlEventTouchCancel)];</span><br><span class="line">        [self addSubview:btn];</span><br><span class="line">        [btnArray addObject:btn];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="9-新建FBYCustomKeyBord类，实现键盘类型切换功能"><a href="#9-新建FBYCustomKeyBord类，实现键盘类型切换功能" class="headerlink" title="9. 新建FBYCustomKeyBord类，实现键盘类型切换功能"></a>9. 新建FBYCustomKeyBord类，实现键盘类型切换功能</h5><p>FBYCustomKeyBord类中根据JS调用键盘时传入的参数，来实现何种键盘模式，实现键盘类型，共有6种类型：数字及字母、字母及数字、数字及字母特殊字符、字母及数字特殊字符、仅数字、仅字母。<br>键盘视图显示类型，共包括5种类型：普通、文本框、密码、支付密码格、无标题。<br>核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-(void)setKeybordType:(FBYCustomKeyBordType)keybordType&#123;</span><br><span class="line">    _keybordType=keybordType;</span><br><span class="line">    [self.numPad removeFromSuperview];</span><br><span class="line">    if(_keybordType==FBYCustomKeyBordType_NumWord)&#123;</span><br><span class="line">        self.numPad.random=self.random;</span><br><span class="line">        self.numPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_WordNum)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_Num)&#123;</span><br><span class="line">        self.numOnlyPad.random=self.random;</span><br><span class="line">        self.numOnlyPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numOnlyPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_NumWordSymbol)&#123;</span><br><span class="line">        self.numPad.random=self.random;</span><br><span class="line">        self.numPad.delegate=self;</span><br><span class="line">        [self addSubview:self.numPad];</span><br><span class="line">    &#125;else if(_keybordType==FBYCustomKeyBordType_Word)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;else if (keybordType==FBYCustomKeyBordType_WordNumSymbol)&#123;</span><br><span class="line">        self.wordPad.random=self.random;</span><br><span class="line">        self.wordPad.delegate=self;</span><br><span class="line">        [self addSubview:self.wordPad];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="10-实现根据密码判断密码强度和长度功能"><a href="#10-实现根据密码判断密码强度和长度功能" class="headerlink" title="10. 实现根据密码判断密码强度和长度功能"></a>10. 实现根据密码判断密码强度和长度功能</h5><p>根据密码字符串获取其长度,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//FBYCustomKeyBord.m</span><br><span class="line">#pragma mark 长度计算</span><br><span class="line">-(NSUInteger)messageLength:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line"></span><br><span class="line">    NSUInteger length= msg.length;</span><br><span class="line">    NSLog(@&quot;%lu&quot;,(unsigned long)length);</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据密码字符串message，通过正则校验，判断字符串中包含几种字符，进而判断其密码强度。<br>总共是数字、大写字母、小写字母、特殊字符四种状态，包含两种强度为弱，包含三种强度为中，包含四种强度为强,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//FBYCustomKeyBord.m</span><br><span class="line">#pragma mark 强度计算</span><br><span class="line">-(NSUInteger)messageStrength:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line">    NSUInteger length= msg.length;</span><br><span class="line">    BOOL capitalBool = NO;</span><br><span class="line">    BOOL lowercaseBool = NO;</span><br><span class="line">    BOOL numberBool = NO;</span><br><span class="line">    BOOL stringBool = NO;</span><br><span class="line">    NSString* result1;</span><br><span class="line">    NSString* result2;</span><br><span class="line">    NSString* result3;</span><br><span class="line">    NSString* result4;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        char commitChar = [msg characterAtIndex:i];</span><br><span class="line">        if((commitChar&gt;64)&amp;&amp;(commitChar&lt;91))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有大写英文字母&quot;);</span><br><span class="line">            capitalBool = YES;</span><br><span class="line">        &#125;else if((commitChar&gt;96)&amp;&amp;(commitChar&lt;123))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有小写英文字母&quot;);</span><br><span class="line">            lowercaseBool = YES;</span><br><span class="line">        &#125;else if((commitChar&gt;47)&amp;&amp;(commitChar&lt;58))&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有数字&quot;);</span><br><span class="line">            numberBool = YES;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;字符串中含有空格&quot;);</span><br><span class="line">            stringBool = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result1 = [NSString stringWithFormat:@&quot;%d&quot;,capitalBool];</span><br><span class="line">    result2 = [NSString stringWithFormat:@&quot;%d&quot;,lowercaseBool];</span><br><span class="line">    result3 = [NSString stringWithFormat:@&quot;%d&quot;,numberBool];</span><br><span class="line">    result4 = [NSString stringWithFormat:@&quot;%d&quot;,stringBool];</span><br><span class="line"></span><br><span class="line">    NSMutableArray* resultArray = [[NSMutableArray alloc] init];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result1]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result2]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result3]];</span><br><span class="line">    [resultArray addObject:[NSString stringWithFormat:@&quot;%@&quot;,result4]];</span><br><span class="line">    int intResult=0;</span><br><span class="line">    for (int j=0; j&lt;[resultArray count]; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([[resultArray objectAtIndex:j] isEqualToString:@&quot;1&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            intResult++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSUInteger result;</span><br><span class="line">    if (intResult == 4)&#123;</span><br><span class="line">        result = 3;</span><br><span class="line">    &#125;else if (intResult == 3)&#123;</span><br><span class="line">        result = 2;</span><br><span class="line">    &#125;else if (intResult == 2)&#123;</span><br><span class="line">        result = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="11-实现输出密码SM3加密功能"><a href="#11-实现输出密码SM3加密功能" class="headerlink" title="11. 实现输出密码SM3加密功能"></a>11. 实现输出密码SM3加密功能</h5><p> 这里的密码加密采用的是国密SM3加密方式，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 加密设置</span><br><span class="line">-(NSString *)encryptMessage:(NSString *)message&#123;</span><br><span class="line">    NSString *msg=[message copy];</span><br><span class="line">    return [self sm3:msg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 对字符串做sm3处理</span><br><span class="line">- (NSString *) sm3:(NSString *) input</span><br><span class="line">&#123;</span><br><span class="line">    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSData *outputData = [CustomKBSM3Coded sm3_hashWithPainData:inputData];</span><br><span class="line">    //NSString *outputString = [GTMBase64 stringByEncodingData:outputData];</span><br><span class="line">    NSString *outputString = [self convertDataToHexStr:outputData];</span><br><span class="line">    NSString *upper = [outputString uppercaseString];</span><br><span class="line">    return upper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="12-根据传参打开浏览器"><a href="#12-根据传参打开浏览器" class="headerlink" title="12. 根据传参打开浏览器"></a>12. 根据传参打开浏览器</h5><p>此浏览器插件支持打开自定义浏览器和打开默认浏览器，具体使用哪种方法打开浏览器，需要JavaScript通过arguments字典以字段的形式传过来，这里就使用openType字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// CustomKeyboard.m</span><br><span class="line">#import &quot;CustomKeyboard.h&quot;</span><br><span class="line">#import &lt;React/RCTUtils.h&gt;</span><br><span class="line">@interface CustomKeyboard ()&lt;FBYCustomKeyBordDelegate&gt;</span><br><span class="line">@property(strong,nonatomic)RCTResponseSenderBlock sucessCallback;</span><br><span class="line">@property(strong,nonatomic)RCTResponseSenderBlock failCallback;</span><br><span class="line">@property (nonatomic, strong) FBYCustomKeyBord *keyBoard;</span><br><span class="line">@property(assign,nonatomic)FBYCustomKeyBordType keybordType;</span><br><span class="line">@property(assign,nonatomic)FBYCustomKeyBordShowType keybordShowType;</span><br><span class="line">@property(strong,nonatomic)NSString *tag;</span><br><span class="line">@property(strong,nonatomic)NSString *isUp;</span><br><span class="line">@end</span><br><span class="line">@implementation CustomKeyboard</span><br><span class="line">RCT_EXPORT_MODULE(KeybordPlugin);</span><br><span class="line">RCT_EXPORT_METHOD(open:(NSDictionary *)arguments</span><br><span class="line">                  withCompletionHandler:(RCTResponseSenderBlock)completion</span><br><span class="line">                  failureHandler:(RCTResponseSenderBlock)failure)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.keyBoard = [FBYCustomKeyBord instance];</span><br><span class="line">        self.keyBoard.delegate = self;</span><br><span class="line">        self.sucessCallback = sucessCallback;</span><br><span class="line">        self.failCallback =  failCallback;</span><br><span class="line">        NSString *isUp=@&quot;1&quot;;</span><br><span class="line">        NSString *isRandom=@&quot;0&quot;;</span><br><span class="line">        NSString *type=@&quot;4&quot;;</span><br><span class="line">        NSString *showType=@&quot;0&quot;;</span><br><span class="line">        NSString *isEncrypt=@&quot;0&quot;;</span><br><span class="line">        //是否是随机键盘</span><br><span class="line">        self.keyBoard.random = YES;</span><br><span class="line">        self.keybordType = FBYCustomKeyBordType_Num;   </span><br><span class="line">        self.keybordShowType = FBYCustomKeyBordShowType_Common;     </span><br><span class="line">        self.keyBoard.keybordType = self.keybordType;</span><br><span class="line">        //弹起键盘或收起键盘</span><br><span class="line">        self.keyBoard.keybordShowType = self.keybordShowType;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if ((isUp==nil) || isUp.intValue == 1) &#123;</span><br><span class="line">                [self.keyBoard popKeyBordInParent:RCTPresentedViewController()];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [self.keyBoard disappearSwitchBtnClickWithBlock:^&#123;</span><br><span class="line">                    self.sucessCallback(@[@&#123;SucessReslutCode:@&quot;1&quot;,SucessData:@&quot;ok&quot;&#125;]);</span><br><span class="line">                    CIBNSLog(@&quot;成功调起密码键盘方法&quot;);</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//键盘数据回调</span><br><span class="line">-(void)customKeybord:(FBYCustomKeyBord *)keybord didReturnMessage:(NSString *)message withLength:(NSUInteger)length withStrength:(NSUInteger)strength&#123;</span><br><span class="line">    if(self.tag == nil)&#123;</span><br><span class="line">        self.tag = [CustomKeyboard getSecondTimeStringSince1970];</span><br><span class="line">    &#125;</span><br><span class="line">    if (![self.isUp isEqualToString:@&quot;0&quot;]) &#123;</span><br><span class="line">        self.sucessCallback(@[@&#123;SucessReslutCode:@&quot;1&quot;,SucessData:@&#123;@&quot;pwdLength&quot;:[NSString stringWithFormat:@&quot;%lu&quot;,(unsigned long)length],@&quot;pwdStrong&quot;:[NSString stringWithFormat:@&quot;%lu&quot;,strength],@&quot;pwdValue&quot;:message&#125;&#125;]);</span><br><span class="line">        NSLog(@&quot;成功调起密码键盘方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="13-Javascript调用浏览器方法"><a href="#13-Javascript调用浏览器方法" class="headerlink" title="13. Javascript调用浏览器方法"></a>13. Javascript调用浏览器方法</h5><p>现在从 Javascript 里可以这样调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules &#125; from &quot;react-native&quot;;</span><br><span class="line">const CustomkeyBoardPlugin = NativeModules.KeybordPlugin;</span><br><span class="line">CustomkeyBoardPlugin.onKeyboard(&#123;isRandom:&quot;1&quot;,isUp:&quot;1&quot;,type:&quot;4&quot;,showType:&quot;3&quot;&#125;,(msg) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(msg));</span><br><span class="line">                                         &#125;,(err) =&gt; &#123;</span><br><span class="line">                                         Alert.alert(JSON.stringify(err));</span><br><span class="line">                                         &#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。&lt;/p&gt;
&lt;p&gt;在React Native移动平台项目开发中，除了React Native 提供的封装好的部分插件和原声组建外，在实际的项目中还需要使用到很多其他的插件，比如网络请求、数据库、相机、相册、通讯录、视频播放器、浏览器、蓝牙连接、图片处理、消息推送、地图、统计、埋点等等APP开发中需要用到的功能，都为IDE开发平台提供封装好的插件，以便项目开发使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-React Native集" scheme="https://fanbaoying.github.io/categories/iOS-React-Native%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>第三方微信登录 | 静默授权与网页授权的实现</title>
    <link href="https://fanbaoying.github.io/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95-%E9%9D%99%E9%BB%98%E6%8E%88%E6%9D%83%E4%B8%8E%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fanbaoying.github.io/第三方微信登录-静默授权与网页授权的实现/</id>
    <published>2018-04-17T01:24:45.000Z</published>
    <updated>2018-04-17T01:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>第三方登录有QQ、微信、微博、支付宝等等，如果现在自己的项目中实现这些登录，即可以使用友盟的sdk，也可以一个一个接入，各有各的有点，这里不做赘述。</p><p>今天和大家分享的是，在项目中实现微信登录，虽然微信官网给出了接入文档，但是我在接入的过程中，遇到一些问题，在此做出总结以便大家参考。主要讲微信snsapi_base静默授权与snsapi_userinfo网页授权的实现。</p><a id="more"></a><h2 id="二：准备工作"><a href="#二：准备工作" class="headerlink" title="二：准备工作"></a>二：准备工作</h2><p>移动应用微信登录是基于OAuth2.0标准协议构建的微信OAuth2.0授权登录系统。</p><p>在进行微信OAuth2.0授权登录接入之前，需要完成一下工作才可以开始介接入：</p><ol><li>在微信开放平台注册开发者帐号；</li><li>拥有一个已审核通过的移动应用；</li><li>并获得相应的AppID和AppSecret；</li><li>申请微信登录且通过审核。</li></ol><h2 id="三：授权流程"><a href="#三：授权流程" class="headerlink" title="三：授权流程"></a>三：授权流程</h2><p>微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为：</p><ol><li>第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；</li><li>通过code参数加上AppID和AppSecret等，通过API换取access_token；</li><li>通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。</li></ol><p>获取access_token时序图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-006de32d62d4a298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="h.png"></p><h2 id="四：静默授权与网页授权的实现"><a href="#四：静默授权与网页授权的实现" class="headerlink" title="四：静默授权与网页授权的实现"></a>四：静默授权与网页授权的实现</h2><h4 id="1-静默授权与网页授权的区别"><a href="#1-静默授权与网页授权的区别" class="headerlink" title="1. 静默授权与网页授权的区别"></a>1. 静默授权与网页授权的区别</h4><p>网页授权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.scope = @&quot;snsapi_userinfo&quot;;</span><br></pre></td></tr></table></figure></p><p>静默授权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.scope = @&quot;snsapi_base&quot;;</span><br></pre></td></tr></table></figure></p><p>snsapi_base与snsapi_userinfo属于微信网页授权获取用户信息的两种作用域：</p><p>snsapi_base只能获取access_token和openID</p><p>snsapi_userinfo可以获取更详细的用户资料，比如头像、昵称、性别等</p><h4 id="2-获取CODE"><a href="#2-获取CODE" class="headerlink" title="2. 获取CODE"></a>2. 获取CODE</h4><p>再登录按钮的点击事件中写入一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//构造SendAuthReq结构体</span><br><span class="line">SendAuthReq* req =[[[SendAuthReq alloc]init]autorelease];</span><br><span class="line">req.scope = @&quot;snsapi_userinfo&quot;;</span><br><span class="line">req.state = @&quot;123&quot;;</span><br><span class="line">//第三方向微信终端发送一个SendAuthReq消息结构</span><br><span class="line">[WXApi sendReq:req];</span><br></pre></td></tr></table></figure><p>在AppDelegate的didFinishLaunchingWithOptions方法中注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WXApi registerApp:@&quot;wx1234567890&quot;];</span><br></pre></td></tr></table></figure><p>“wx1234567890”为appid，请更换为自己项目的appid</p><p>拉起微信打开授权登录页如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-fa107c90fd2394c5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>点击确认登陆，授权后回调 WXApiDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(void)onResp:(BaseReq *)resp</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     ErrCode ERR_OK = 0(用户同意)</span><br><span class="line">     ERR_AUTH_DENIED = -4（用户拒绝授权）</span><br><span class="line">     ERR_USER_CANCEL = -2（用户取消）</span><br><span class="line">     code    用户换取access_token的code，仅在ErrCode为0时有效</span><br><span class="line">     state   第三方程序发送时用来标识其请求的唯一性的标志，由第三方程序调用sendReq时传入，由微信终端回传，state字符串长度不能超过1K</span><br><span class="line">     lang    微信客户端当前语言</span><br><span class="line">     country 微信用户当前国家信息</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if ([resp isKindOfClass:[SendAuthResp class]]) //判断是否为授权请求，否则与微信支付等功能发生冲突</span><br><span class="line">    &#123;</span><br><span class="line">        SendAuthResp *aresp = (SendAuthResp *)resp;</span><br><span class="line">        if (aresp.errCode== 0)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;code %@&quot;,aresp.code);</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;wechatDidLoginNotification&quot; object:self userInfo:@&#123;@&quot;code&quot;:aresp.code&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用通知，将aresp.code传递到登录页面</p><h4 id="3-通过code获取access-token"><a href="#3-通过code获取access-token" class="headerlink" title="3. 通过code获取access_token"></a>3. 通过code获取access_token</h4><p>在登录页面通过通知，获取到code之后，请求以下链接获取access_token：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>appid：应用唯一标识，在微信开放平台提交应用审核通过后获得</li><li>secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</li><li>code：填写第一步获取的code参数</li><li>grant_type：填authorization_code</li></ul><p>网络请求返回的参数格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">&quot;expires_in&quot;:7200,</span><br><span class="line">&quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;scope&quot;:&quot;SCOPE&quot;,</span><br><span class="line">&quot;unionid&quot;:&quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：接口调用凭证</li><li>expires_in：access_token接口调用凭证超时时间，单位（秒）</li><li>refresh_token：用户刷新access_token</li><li>openid：授权用户唯一标识</li><li>scope：用户授权的作用域，使用逗号（,）分隔</li><li>unionid：当且仅当该移动应用已获得该用户的userinfo授权时，才会出现该字段</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><p>1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）；<br>2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为；<br>3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。</p><p>还有就是要注意网络授权<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">网页授权access_token</a> 与 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">普通access_token</a>的区别：<br>1、网页授权的access_token在每次获取openID时一起更新，在接口调用频次限制中为“无上限”；<br>2、普通access_token一般限制为2000次/日，需要自己保存起来并定时更新。</p></blockquote><p>到这里同时获得access_token和openid，静默授权与网页授权操作都是一样的。根据官网文档，网页授权还可以进一步操作，获取用户更多详细信息。</p><h4 id="4-获取用户个人信息（UnionID机制）"><a href="#4-获取用户个人信息（UnionID机制）" class="headerlink" title="4. 获取用户个人信息（UnionID机制）"></a>4. 获取用户个人信息（UnionID机制）</h4><p>此接口用于获取用户个人信息，开发者可通过OpenID来获取用户基本信息，接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：调用凭证</li><li>openid：普通用户的标识，对当前开发者帐号唯一</li></ul><p>正确的Json返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">&quot;nickname&quot;:&quot;NICKNAME&quot;,</span><br><span class="line">&quot;sex&quot;:1,</span><br><span class="line">&quot;province&quot;:&quot;PROVINCE&quot;,</span><br><span class="line">&quot;city&quot;:&quot;CITY&quot;,</span><br><span class="line">&quot;country&quot;:&quot;COUNTRY&quot;,</span><br><span class="line">&quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span><br><span class="line">&quot;privilege&quot;:[</span><br><span class="line">&quot;PRIVILEGE1&quot;,</span><br><span class="line">&quot;PRIVILEGE2&quot;</span><br><span class="line">],</span><br><span class="line">&quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-静默授权获取到用户详细资料"><a href="#5-静默授权获取到用户详细资料" class="headerlink" title="5. 静默授权获取到用户详细资料"></a>5. 静默授权获取到用户详细资料</h4><p>在第3步通过snsapi_base，同时获得access_token和openid，</p><p>把这里的access_token和openid用于下面接口中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>access_token：调用凭证</li><li>openid：普通用户的标识，对当前开发者帐号唯一</li><li>lang：国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语，默认为zh-CN</li></ul><p>Json返回结果和snsapi_userinfo下获取的用户详情一样。</p><p>但是这个方法的前提是同一个公众号内，用户关注了，如果是其他公众号，还是需要用户点击授权的。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;第三方登录有QQ、微信、微博、支付宝等等，如果现在自己的项目中实现这些登录，即可以使用友盟的sdk，也可以一个一个接入，各有各的有点，这里不做赘述。&lt;/p&gt;
&lt;p&gt;今天和大家分享的是，在项目中实现微信登录，虽然微信官网给出了接入文档，但是我在接入的过程中，遇到一些问题，在此做出总结以便大家参考。主要讲微信snsapi_base静默授权与snsapi_userinfo网页授权的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>AVFoundation | 封装一个好用的视频播放器</title>
    <link href="https://fanbaoying.github.io/AVFoundation-%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://fanbaoying.github.io/AVFoundation-封装一个好用的视频播放器/</id>
    <published>2018-04-06T07:25:43.000Z</published>
    <updated>2018-04-08T01:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="video.png"></p><p>上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。</p><a id="more"></a><ul><li><p>CoreAudio : 处理所有音频事件.是由多个框架整合在一起的总称,为音频和MIDI内容的录制,播放和处理提供相应接口.设置可以针对音频信号进行完全控制,并通过Audio Units来构建一些复杂的音频处理.有兴趣的可以单独了解一下这个框架。</p></li><li><p>CoreMedia: 是AVFoundation所用到低层级媒体管道的一部分.提供音频样本和视频帧处理所需的低层级数据类型和接口。</p></li><li><p>CoreAnimation: 动画相关框架, 封装了支持OpenGL和OpenGL ES功能的ObjC各种类. AVFoundation可以利用CoreAnimation让开发者能够在视频的编辑和播放过程中添加动画和图片效果。</p></li></ul><p>下面我就和大家详细的分享一下，如何使用AVFoundation来实现一个好用的视频播放器。如果好用或者对你有所帮助，不要忘了关注点个赞呦！！！</p><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>视频控制界面实现</p></li><li><p>用于视频显示的View创建</p></li><li><p>视频数据下载器FBYVideoDownload创建</p></li><li><p>播放、暂停、横竖屏操作方法实现</p></li><li><p>监听播放进度</p></li><li><p>控制存储缓冲范围</p></li><li><p>拖动滑块，控制快进快退</p></li><li><p>定义临时文件路径</p></li><li><p>定义缓存文件夹路径</p></li><li><p>发起视频路径网路请求方法</p></li><li><p>播放结束设置</p></li><li><p>前后视频播放控制</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-视频控制界面实现"><a href="#1-视频控制界面实现" class="headerlink" title="1. 视频控制界面实现"></a>1. 视频控制界面实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (FBYVideoPlayerView *)videoPlayControl&#123;</span><br><span class="line">    if (!_videoPlayControl) &#123;</span><br><span class="line">        _videoPlayControl = [[FBYVideoPlayerView alloc] initWithFrame:self.backgroundView.bounds];</span><br><span class="line">        [self.backgroundView addSubview:_videoPlayControl];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return _videoPlayControl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-用于视频显示的View创建"><a href="#2-用于视频显示的View创建" class="headerlink" title="2. 用于视频显示的View创建"></a>2. 用于视频显示的View创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)videoShowView&#123;</span><br><span class="line">    if (!_videoShowView) &#123;</span><br><span class="line">        _videoShowView = [[UIView alloc] init];</span><br><span class="line">        _videoShowView.layer.masksToBounds = YES;</span><br><span class="line">        [self.backgroundView addSubview:_videoShowView];</span><br><span class="line">    &#125;</span><br><span class="line">    return _videoShowView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-视频数据下载器FBYVideoDownload创建"><a href="#3-视频数据下载器FBYVideoDownload创建" class="headerlink" title="3. 视频数据下载器FBYVideoDownload创建"></a>3. 视频数据下载器FBYVideoDownload创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, weak) id &lt;FBYVideoDownloadDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">//定义初始化方法 传入videoUrl参数（NSString）</span><br><span class="line">- (instancetype)initWithURL:(NSString *)videoUrl withDelegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">//开始下载</span><br><span class="line">- (void)start;</span><br><span class="line">//暂停</span><br><span class="line">- (void)suspend;</span><br><span class="line">//关闭</span><br><span class="line">- (void)cancel;</span><br></pre></td></tr></table></figure><h4 id="4-播放、暂停、横竖屏操作方法实现"><a href="#4-播放、暂停、横竖屏操作方法实现" class="headerlink" title="4. 播放、暂停、横竖屏操作方法实现"></a>4. 播放、暂停、横竖屏操作方法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//全屏</span><br><span class="line">[_videoPlayControl setFullScreenButtonClick_block:^&#123;</span><br><span class="line">    if (weakSelf.delegate &amp;&amp; [weakSelf.delegate respondsToSelector:@selector(videoPlayerDidFullScreenButtonClick)]) &#123;</span><br><span class="line">        [weakSelf.delegate videoPlayerDidFullScreenButtonClick];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">//播放/暂停</span><br><span class="line">[_videoPlayControl setPlayButtonClick_block:^(BOOL play) &#123;</span><br><span class="line">    if (play) &#123;</span><br><span class="line">        [weakSelf.player play];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [weakSelf.player pause];</span><br><span class="line">    &#125;</span><br><span class="line">    weakSelf.playButtonState = !weakSelf.playButtonState;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="5-监听播放进度"><a href="#5-监听播放进度" class="headerlink" title="5. 监听播放进度"></a>5. 监听播放进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.timeObserve = [self.player addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) &#123;</span><br><span class="line">        CGFloat current = CMTimeGetSeconds(time);</span><br><span class="line">        CGFloat total = CMTimeGetSeconds(weakSelf.currentPlayerItem.duration);</span><br><span class="line">        CGFloat progress = current / total;</span><br><span class="line"></span><br><span class="line">        weakSelf.videoPlayControl.currentTime = current;</span><br><span class="line">        weakSelf.videoPlayControl.playValue = progress;</span><br><span class="line"></span><br><span class="line">        if (weakSelf.isCanToGetLocalTime) &#123;</span><br><span class="line">            weakSelf.localTime = [weakSelf getLocalTime];</span><br><span class="line">        &#125;</span><br><span class="line">        NSInteger timeNow = [weakSelf getLocalTime];</span><br><span class="line">        if (timeNow - weakSelf.localTime &gt; 1.5) &#123;</span><br><span class="line">            [weakSelf.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">            weakSelf.isCanToGetLocalTime = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h4 id="6-监听播放器的状态"><a href="#6-监听播放器的状态" class="headerlink" title="6. 监听播放器的状态"></a>6. 监听播放器的状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="7-监听当前的缓冲进度"><a href="#7-监听当前的缓冲进度" class="headerlink" title="7. 监听当前的缓冲进度"></a>7. 监听当前的缓冲进度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;loadedTimeRanges&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="8-监听到当前没有缓冲数据"><a href="#8-监听到当前没有缓冲数据" class="headerlink" title="8. 监听到当前没有缓冲数据"></a>8. 监听到当前没有缓冲数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.currentPlayerItem addObserver:self forKeyPath:@&quot;playbackBufferEmpty&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure><h4 id="9-控制存储缓冲范围"><a href="#9-控制存储缓冲范围" class="headerlink" title="9. 控制存储缓冲范围"></a>9. 控制存储缓冲范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)playForActivity&#123;</span><br><span class="line">    if (self.playButtonState) &#123;</span><br><span class="line">        [self.player play];</span><br><span class="line">    &#125;</span><br><span class="line">    self.isBufferEmpty = NO;</span><br><span class="line">    self.isPlaying = YES;</span><br><span class="line">    [self.videoPlayControl videoPlayerDidBeginPlay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-拖动滑块，控制快进快退"><a href="#10-拖动滑块，控制快进快退" class="headerlink" title="10. 拖动滑块，控制快进快退"></a>10. 拖动滑块，控制快进快退</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//拖动滑块</span><br><span class="line">[_videoPlayControl setSliderTouchEnd_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">//快进快退</span><br><span class="line">[_videoPlayControl setFastFastForwardAndRewind_block:^(CGFloat time) &#123;</span><br><span class="line">            [weakSelf seekToTimePlay:time];</span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure><h4 id="11-定义临时文件路径"><a href="#11-定义临时文件路径" class="headerlink" title="11. 定义临时文件路径"></a>11. 定义临时文件路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoTempPath = [NSString tempFilePathWithFileName:videoName];</span><br></pre></td></tr></table></figure><h4 id="12-定义缓存文件夹路径"><a href="#12-定义缓存文件夹路径" class="headerlink" title="12. 定义缓存文件夹路径"></a>12. 定义缓存文件夹路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.videoCachePath = [NSString cacheFilePathWithName:videoName];</span><br></pre></td></tr></table></figure><h4 id="13-发起视频路径网路请求方法"><a href="#13-发起视频路径网路请求方法" class="headerlink" title="13. 发起视频路径网路请求方法"></a>13. 发起视频路径网路请求方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendHttpRequst</span><br><span class="line">&#123;</span><br><span class="line">    [_fileHandle seekToEndOfFile];</span><br><span class="line">    NSURL *url = [NSURL URLWithString:_videoUrl];</span><br><span class="line">    NSMutableURLRequest *requeset = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    //指定头信息  当前已下载的进度</span><br><span class="line">    [requeset setValue:[NSString stringWithFormat:@&quot;bytes=%ld-&quot;, _curruentLength] forHTTPHeaderField:@&quot;Range&quot;];</span><br><span class="line"></span><br><span class="line">    //创建请求</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self.session dataTaskWithRequest:requeset];</span><br><span class="line">    self.dataTask = dataTask;</span><br><span class="line"></span><br><span class="line">    //发起请求</span><br><span class="line">    [self.dataTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-播放结束设置"><a href="#14-播放结束设置" class="headerlink" title="14. 播放结束设置"></a>14. 播放结束设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)playerItemDidPlayToEnd:(NSNotification *)notification&#123;</span><br><span class="line">    //重新开始播放</span><br><span class="line">    __weak typeof(self) weak_self = self;</span><br><span class="line">    [self.player seekToTime:CMTimeMake(0, 1) completionHandler:^(BOOL finished) &#123;</span><br><span class="line">        __strong typeof(weak_self) strong_self = weak_self;</span><br><span class="line">        if (!strong_self) return;</span><br><span class="line">        [strong_self.player play];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-前后视频播放控制"><a href="#15-前后视频播放控制" class="headerlink" title="15. 前后视频播放控制"></a>15. 前后视频播放控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//进入后台</span><br><span class="line">- (void)appDidEnterBackground&#123;</span><br><span class="line">    if (self.stopWhenAppDidEnterBackground) &#123;</span><br><span class="line">        [self pauseVideo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//进入前台</span><br><span class="line">- (void)appDidEnterForeground&#123;</span><br><span class="line">    [self playVideo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYVideoData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"><a href="#2-在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理" class="headerlink" title="2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理"></a>2. 在项目中引入FBYVideoPlayer并继承FBYVideoPlayerDelegate代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYVideoPlayer.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;FBYVideoPlayerDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic ,strong) FBYVideoPlayer *videoPlayer;</span><br><span class="line">@property (nonatomic ,strong) UIView *videoPlayBGView;</span><br><span class="line">@property (nonatomic ,copy)   NSString*videoUrl;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-初始化创建基层view"><a href="#3-初始化创建基层view" class="headerlink" title="3. 初始化创建基层view"></a>3. 初始化创建基层view</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayBGView = [[UIView alloc] initWithFrame:CGRectMake(0, 90, SCREEN_WIDTH, SCREEN_WIDTH * 0.6)];</span><br><span class="line">self.videoPlayBGView.backgroundColor = [UIColor blackColor];</span><br><span class="line">    [self.view addSubview:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="4-初始化调用视频播放方法"><a href="#4-初始化调用视频播放方法" class="headerlink" title="4. 初始化调用视频播放方法"></a>4. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h4 id="5-初始化调用视频播放方法"><a href="#5-初始化调用视频播放方法" class="headerlink" title="5. 初始化调用视频播放方法"></a>5. 初始化调用视频播放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.videoPlayer = [[FBYVideoPlayer alloc] init];</span><br><span class="line">self.videoPlayer.delegate = self;</span><br><span class="line">[self.videoPlayer playWithUrl:self.videoUrl showView:self.videoPlayBGView];</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYVideoPlayer-iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-a5c6e5a55dcb11f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;video.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是iOS系统下媒体应用的结构层. AVKit框架用于简化媒体应用的创建过程,如果你只需要看电影,那么使用这个就可以了, UKit可以支持简单的录制功能 . 而更多功能需要低层级框架支持.下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>人脸识别 -- 活体检测(张嘴摇头识别)</title>
    <link href="https://fanbaoying.github.io/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%B4%BB%E4%BD%93%E6%A3%80%E6%B5%8B-%E5%BC%A0%E5%98%B4%E6%91%87%E5%A4%B4%E8%AF%86%E5%88%AB/"/>
    <id>https://fanbaoying.github.io/人脸识别-活体检测-张嘴摇头识别/</id>
    <published>2018-03-19T01:14:22.000Z</published>
    <updated>2018-03-19T01:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。</p><p>大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。</p><p>在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>点击识别按钮，调用相机</p></li><li><p>CameraRules类，检测相机权限</p></li><li><p>初始化页面，创建摄像页面，创建张嘴数据和摇头数据</p></li><li><p>开启识别，脸部框识别</p></li><li><p>脸部部位识别，脸部识别判断是否检测到人脸</p></li><li><p>检测到人脸之后，判断位置</p></li><li><p>位置判断合适，判断是否张嘴</p></li><li><p>张嘴判断完毕，验证是否摇头</p></li><li><p>摇头判断完毕，3秒倒计时拍照</p></li><li><p>拍照完毕，选择重拍或者上传图片</p></li><li><p>选择重拍重复5-9步骤，选择上传将图片数据回调</p></li><li><p>数据clean</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-点击识别按钮，调用相机"><a href="#1-点击识别按钮，调用相机" class="headerlink" title="1. 点击识别按钮，调用相机"></a>1. 点击识别按钮，调用相机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if([CameraRules isCapturePermissionGranted])&#123;</span><br><span class="line">        [self setDeviceAuthorized:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSString* info=@&quot;没有相机权限&quot;;</span><br><span class="line">            [self showAlert:info];</span><br><span class="line">            [self setDeviceAuthorized:NO];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-CameraRules类，检测相机权限"><a href="#2-CameraRules类，检测相机权限" class="headerlink" title="2. CameraRules类，检测相机权限"></a>2. CameraRules类，检测相机权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//检测相机权限</span><br><span class="line">+(BOOL)isCapturePermissionGranted&#123;</span><br><span class="line">    if([AVCaptureDevice respondsToSelector:@selector(authorizationStatusForMediaType:)])&#123;</span><br><span class="line">        AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];</span><br><span class="line">        if(authStatus ==AVAuthorizationStatusRestricted || authStatus ==AVAuthorizationStatusDenied)&#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(authStatus==AVAuthorizationStatusNotDetermined)&#123;</span><br><span class="line">            dispatch_semaphore_t sema = dispatch_semaphore_create(0);</span><br><span class="line">            __block BOOL isGranted=YES;</span><br><span class="line">            [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) &#123;</span><br><span class="line">                isGranted=granted;</span><br><span class="line">                dispatch_semaphore_signal(sema);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">            return isGranted;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据"><a href="#3-初始化页面，创建摄像页面，创建张嘴数据和摇头数据" class="headerlink" title="3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据"></a>3. 初始化页面，创建摄像页面，创建张嘴数据和摇头数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建摄像页面，创建张嘴数据和摇头数据</span><br><span class="line">[self faceUI];</span><br><span class="line">[self faceCamera];</span><br><span class="line">[self faceNumber];</span><br></pre></td></tr></table></figure><h4 id="4-开启识别，脸部框识别"><a href="#4-开启识别，脸部框识别" class="headerlink" title="4. 开启识别，脸部框识别"></a>4. 开启识别，脸部框识别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">float cx = (left+right)/2;</span><br><span class="line">float cy = (top + bottom)/2;</span><br><span class="line">float w = right - left;</span><br><span class="line">float h = bottom - top;</span><br><span class="line">float ncx = cy ;</span><br><span class="line">float ncy = cx ;</span><br><span class="line"></span><br><span class="line">CGRect rectFace = CGRectMake(ncx-w/2 ,ncy-w/2 , w, h);</span><br><span class="line"></span><br><span class="line">if(!isFrontCamera)&#123;</span><br><span class="line">    rectFace=rSwap(rectFace);</span><br><span class="line">    rectFace=rRotate90(rectFace, faceImg.height, faceImg.width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL isNotLocation = [self identifyYourFaceLeft:left right:right top:top bottom:bottom];</span><br><span class="line"></span><br><span class="line">if (isNotLocation==YES) &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-脸部部位识别，脸部识别判断是否检测到人脸"><a href="#5-脸部部位识别，脸部识别判断是否检测到人脸" class="headerlink" title="5. 脸部部位识别，脸部识别判断是否检测到人脸"></a>5. 脸部部位识别，脸部识别判断是否检测到人脸</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for(id key in keys)&#123;</span><br><span class="line">    id attr=[landmarkDic objectForKey:key];</span><br><span class="line">    if(attr &amp;&amp; [attr isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line"></span><br><span class="line">        if(!isFrontCamera)&#123;</span><br><span class="line">            p=pSwap(p);</span><br><span class="line">            p=pRotate90(p, faceImg.height, faceImg.width);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isCrossBorder == YES) &#123;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        p=pScale(p, widthScaleBy, heightScaleBy);</span><br><span class="line"></span><br><span class="line">        [arrStrPoints addObject:NSStringFromCGPoint(p)];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-检测到人脸之后，判断位置动作提醒"><a href="#6-检测到人脸之后，判断位置动作提醒" class="headerlink" title="6. 检测到人脸之后，判断位置动作提醒"></a>6. 检测到人脸之后，判断位置动作提醒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if (right - left &lt; 230 || bottom - top &lt; 250) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太远了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else if (right - left &gt; 320 || bottom - top &gt; 320) &#123;</span><br><span class="line">    self.textLabel.text = @&quot;太近了&quot;;</span><br><span class="line">    [self delateNumber];</span><br><span class="line">    isCrossBorder = YES;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    if (isJudgeMouth != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复张嘴动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line"></span><br><span class="line">        if (left &lt; 100 || top &lt; 100 || right &gt; 460 || bottom &gt; 400) &#123;</span><br><span class="line">            isCrossBorder = YES;</span><br><span class="line">            isJudgeMouth = NO;</span><br><span class="line">            self.textLabel.text = @&quot;调整下位置先&quot;;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (isJudgeMouth == YES &amp;&amp; isShakeHead != YES) &#123;</span><br><span class="line">        self.textLabel.text = @&quot;请重复摇头动作&quot;;</span><br><span class="line">        [self tomAnimationWithName:@&quot;shakeHead&quot; count:4];</span><br><span class="line">        number = 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        takePhotoNumber += 1;</span><br><span class="line">        if (takePhotoNumber == 2) &#123;</span><br><span class="line">            [self timeBegin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isCrossBorder = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-位置判断合适，判断是否张嘴"><a href="#7-位置判断合适，判断是否张嘴" class="headerlink" title="7. 位置判断合适，判断是否张嘴"></a>7. 位置判断合适，判断是否张嘴</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (rightX &amp;&amp; leftX &amp;&amp; upperY &amp;&amp; lowerY &amp;&amp; isJudgeMouth != YES) &#123;</span><br><span class="line"></span><br><span class="line">    number ++;</span><br><span class="line">    if (number == 1 || number == 300 || number == 600 || number ==900) &#123;</span><br><span class="line">        mouthWidthF = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">        mouthHeightF = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">        NSLog(@&quot;%d,%d&quot;,mouthWidthF,mouthHeightF);</span><br><span class="line">    &#125;else if (number &gt; 1200) &#123;</span><br><span class="line">        [self delateNumber];</span><br><span class="line">        [self tomAnimationWithName:@&quot;openMouth&quot; count:2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mouthWidth = rightX - leftX &lt; 0 ? abs(rightX - leftX) : rightX - leftX;</span><br><span class="line">    mouthHeight = lowerY - upperY &lt; 0 ? abs(lowerY - upperY) : lowerY - upperY;</span><br><span class="line">    NSLog(@&quot;%d,%d&quot;,mouthWidth,mouthHeight);</span><br><span class="line">    NSLog(@&quot;张嘴前：width=%d，height=%d&quot;,mouthWidthF - mouthWidth,mouthHeight - mouthHeightF);</span><br><span class="line">    if (mouthWidth &amp;&amp; mouthWidthF) &#123;</span><br><span class="line"></span><br><span class="line">        if (mouthHeight - mouthHeightF &gt;= 20 &amp;&amp; mouthWidthF - mouthWidth &gt;= 15) &#123;</span><br><span class="line">            isJudgeMouth = YES;</span><br><span class="line">            imgView.animationImages = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-张嘴判断完毕，验证是否摇头"><a href="#8-张嘴判断完毕，验证是否摇头" class="headerlink" title="8. 张嘴判断完毕，验证是否摇头"></a>8. 张嘴判断完毕，验证是否摇头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if ([key isEqualToString:@&quot;mouth_middle&quot;] &amp;&amp; isJudgeMouth == YES) &#123;</span><br><span class="line"></span><br><span class="line">        if (bigNumber == 0 ) &#123;</span><br><span class="line">            firstNumber = p.x;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &gt; bigNumber) &#123;</span><br><span class="line">            bigNumber = p.x;</span><br><span class="line">        &#125;else if (p.x &lt; smallNumber) &#123;</span><br><span class="line">            smallNumber = p.x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bigNumber - smallNumber &gt; 60) &#123;</span><br><span class="line">            isShakeHead = YES;</span><br><span class="line">            [self delateNumber];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="9-摇头判断完毕，3秒倒计时拍照"><a href="#9-摇头判断完毕，3秒倒计时拍照" class="headerlink" title="9. 摇头判断完毕，3秒倒计时拍照"></a>9. 摇头判断完毕，3秒倒计时拍照</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(timeCount &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        self.textLabel.text = [NSString  stringWithFormat:@&quot;%ld s后拍照&quot;,(long)timeCount];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        [theTimer invalidate];</span><br><span class="line">        theTimer=nil;</span><br><span class="line"></span><br><span class="line">        [self didClickTakePhoto];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="10-拍照完毕，选择重拍或者上传图片"><a href="#10-拍照完毕，选择重拍或者上传图片" class="headerlink" title="10. 拍照完毕，选择重拍或者上传图片"></a>10. 拍照完毕，选择重拍或者上传图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickPhotoAgain</span><br><span class="line">&#123;</span><br><span class="line">    [self delateNumber];</span><br><span class="line"></span><br><span class="line">    [self.previewLayer.session startRunning];</span><br><span class="line">    self.textLabel.text = @&quot;请调整位置&quot;;</span><br><span class="line"></span><br><span class="line">    [backView removeFromSuperview];</span><br><span class="line"></span><br><span class="line">    isJudgeMouth = NO;</span><br><span class="line">    isShakeHead = NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-选择重拍重复5-9步骤，选择上传将图片数据回调"><a href="#11-选择重拍重复5-9步骤，选择上传将图片数据回调" class="headerlink" title="11. 选择重拍重复5-9步骤，选择上传将图片数据回调"></a>11. 选择重拍重复5-9步骤，选择上传将图片数据回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)didClickUpPhoto</span><br><span class="line">&#123;</span><br><span class="line">    //上传照片成功</span><br><span class="line">    [self.faceDelegate sendFaceImage:imageView.image];</span><br><span class="line">    [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-数据clean"><a href="#12-数据clean" class="headerlink" title="12. 数据clean"></a>12. 数据clean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)delateNumber</span><br><span class="line">&#123;</span><br><span class="line">    number = 0;</span><br><span class="line">    takePhotoNumber = 0;</span><br><span class="line"></span><br><span class="line">    mouthWidthF = 0;</span><br><span class="line">    mouthHeightF = 0;</span><br><span class="line">    mouthWidth = 0;</span><br><span class="line">    mouthHeight = 0;</span><br><span class="line"></span><br><span class="line">    smallNumber = 0;</span><br><span class="line">    bigNumber = 0;</span><br><span class="line">    firstNumber = 0;</span><br><span class="line"></span><br><span class="line">    imgView.animationImages = nil;</span><br><span class="line">    imgView.image = [UIImage imageNamed:@&quot;shakeHead0&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四：讯飞SDK下载及配置"><a href="#四：讯飞SDK下载及配置" class="headerlink" title="四：讯飞SDK下载及配置"></a>四：讯飞SDK下载及配置</h2><h4 id="1-SDK下载"><a href="#1-SDK下载" class="headerlink" title="1. SDK下载"></a>1. SDK下载</h4><p>因为项目中使用到讯飞人脸识别SDK，需要去<a href="http://console.xfyun.cn/app/edit?appId=NWFhNjI3OTM%3D&amp;appName=RkJZRmFjZVJlY29nbml0aW9uX2lPUw%3D%3D" target="_blank" rel="noopener">讯飞开放平台</a>创建应用，下载SDK。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-b10687203a879c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><h4 id="2-添加系统库"><a href="#2-添加系统库" class="headerlink" title="2. 添加系统库"></a>2. 添加系统库</h4><p>将开发工具包中lib目录下的iflyMSC.framework添加到工程中。同时请将Demo中依赖的其他库也添加到工程中。 按下图示例添加 SDK 所需要的 iOS系统库：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-93809e5d166a1633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="88.png"></p><h4 id="3-设置Bitcode"><a href="#3-设置Bitcode" class="headerlink" title="3. 设置Bitcode"></a>3. 设置Bitcode</h4><p>在Targets - Build Settings 中搜索Bitcode 即可，找到相应选项，设置为NO，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-3414999985ccd080.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="333.jpg"></p><h4 id="4-用户隐私权限配置"><a href="#4-用户隐私权限配置" class="headerlink" title="4. 用户隐私权限配置"></a>4. 用户隐私权限配置</h4><p>在Info.plist 中增加下图设置：</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-19d0d89539d05cbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="444.png"></p><h2 id="五：项目实际使用"><a href="#五：项目实际使用" class="headerlink" title="五：项目实际使用"></a>五：项目实际使用</h2><h4 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h4><p>下载demo，将demo中FBYFaceData文件夹引入项目中。</p><h4 id="2-在项目中引入FBYFaceRecognitionViewController"><a href="#2-在项目中引入FBYFaceRecognitionViewController" class="headerlink" title="2. 在项目中引入FBYFaceRecognitionViewController"></a>2. 在项目中引入FBYFaceRecognitionViewController</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYFaceRecognitionViewController.h&quot;</span><br></pre></td></tr></table></figure><h4 id="3-在项目识别按钮的点击事件中添加代码"><a href="#3-在项目识别按钮的点击事件中添加代码" class="headerlink" title="3. 在项目识别按钮的点击事件中添加代码"></a>3. 在项目识别按钮的点击事件中添加代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)pushToFaceStreamDetectorVC</span><br><span class="line">&#123;</span><br><span class="line">    FBYFaceRecognitionViewController *faceVC = [[FBYFaceRecognitionViewController alloc]init];</span><br><span class="line">    faceVC.faceDelegate = self;</span><br><span class="line">    [self.navigationController pushViewController:faceVC animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-图片回调函数"><a href="#4-图片回调函数" class="headerlink" title="4. 图片回调函数"></a>4. 图片回调函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)sendFaceImage:(UIImage *)faceImage</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;图片上传成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendFaceImageError &#123;</span><br><span class="line">    NSLog(@&quot;图片上传失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本篇文章demo源码："><a href="#本篇文章demo源码：" class="headerlink" title="本篇文章demo源码："></a>本篇文章demo源码：</h2><p><a href="https://github.com/fanbaoying/FBYFaceRecognitionDemo_iOS" target="_blank" rel="noopener">demo源码</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;最近项目在做了身份证银行卡识别之后，开始实现人脸识别和活体识别，其中人脸识别包括人脸入库、人脸查找、人脸1：N对比、人脸N:N对比，另外活体识别运用在安全登录功能。&lt;/p&gt;
&lt;p&gt;大家都熟知的支付宝使用face++ 的服务来实现人脸识别，在实际项目中使用了讯飞的人脸识别SDK进行二次封装来实现活体识别。主要实现了张嘴和摇头两个活体动作的识别。据我所知，讯飞的服务是基于face++,识别率还是很高，并且iOS和Android都对应有封装好的SDK。&lt;/p&gt;
&lt;p&gt;在实际运用中，有很多app为了高度保证用户使用的安全问题，除了常规的账号密码登录之外，相继实现了指纹登录，手势登录，第三方登陆（QQ、微信、支付宝）、刷脸登录，接下里我就和大家分享一下如何实现人脸识别的活体检测，这是实现刷脸登录最基础的实现。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 识别集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%AF%86%E5%88%AB%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 实现点击图片放大</title>
    <link href="https://fanbaoying.github.io/iOS-%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7/"/>
    <id>https://fanbaoying.github.io/iOS-实现点击图片放大/</id>
    <published>2018-03-06T02:02:13.000Z</published>
    <updated>2018-03-06T02:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：简介"><a href="#一：简介" class="headerlink" title="一：简介"></a>一：简介</h2><p>在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。</p><p>另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。</p><a id="more"></a><h2 id="二：实现思路分析"><a href="#二：实现思路分析" class="headerlink" title="二：实现思路分析"></a>二：实现思路分析</h2><ol><li><p>给UIImageView添加手势</p></li><li><p>封装一个继承NSObject的FBYImageZoom类</p></li><li><p>写一个函数用来接收出入的UIImageView</p></li><li><p>根据传入的UIImageView重新绘制在Window中</p></li><li><p>添加放大后背景视图的颜色和透明度</p></li><li><p>使用动画放大展示ImageView</p></li><li><p>添加恢复ImageView原始尺寸的tap点击事件</p></li><li><p>完成之后将背景视图删掉</p></li></ol><h2 id="三：实现源码分析"><a href="#三：实现源码分析" class="headerlink" title="三：实现源码分析"></a>三：实现源码分析</h2><p>根据实现思路分析，一步步进行编码实现：</p><h4 id="1-给UIImageView添加手势"><a href="#1-给UIImageView添加手势" class="headerlink" title="1. 给UIImageView添加手势"></a>1. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.myImageView = [[UIImageView alloc]initWithFrame:CGRectMake(50, 150, SCREEN_WIDTH-100, SCREEN_WIDTH-100)];</span><br><span class="line">self.myImageView.image = [UIImage imageNamed:@&quot;bankcard&quot;];</span><br><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br><span class="line">[_myImageView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line">[_myImageView setUserInteractionEnabled:YES];</span><br><span class="line">[self.view addSubview:_myImageView];</span><br></pre></td></tr></table></figure><h4 id="2-封装一个继承NSObject的FBYImageZoom类"><a href="#2-封装一个继承NSObject的FBYImageZoom类" class="headerlink" title="2. 封装一个继承NSObject的FBYImageZoom类"></a>2. 封装一个继承NSObject的FBYImageZoom类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYImageZoom : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="3-写一个函数用来接收出入的UIImageView"><a href="#3-写一个函数用来接收出入的UIImageView" class="headerlink" title="3. 写一个函数用来接收出入的UIImageView"></a>3. 写一个函数用来接收出入的UIImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @param contentImageview 图片所在的imageView</span><br><span class="line"> */</span><br><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview;</span><br></pre></td></tr></table></figure><h4 id="4-根据传入的UIImageView重新绘制在Window中"><a href="#4-根据传入的UIImageView重新绘制在Window中" class="headerlink" title="4. 根据传入的UIImageView重新绘制在Window中"></a>4. 根据传入的UIImageView重新绘制在Window中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+(void)ImageZoomWithImageView:(UIImageView *)contentImageview&#123;</span><br><span class="line"></span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    [self scanBigImageWithImage:contentImageview.image frame:[contentImageview convertRect:contentImageview.bounds toView:window]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-添加放大后背景视图的颜色和透明度"><a href="#5-添加放大后背景视图的颜色和透明度" class="headerlink" title="5. 添加放大后背景视图的颜色和透明度"></a>5. 添加放大后背景视图的颜色和透明度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当前视图</span><br><span class="line">    UIWindow *window = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    //背景</span><br><span class="line">    UIView *backgroundView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">    [backgroundView setBackgroundColor:[UIColor colorWithRed:107/255.0 green:107/255.0 blue:99/255.0 alpha:0.6]];</span><br></pre></td></tr></table></figure><h4 id="6-使用动画放大展示ImageView"><a href="#6-使用动画放大展示ImageView" class="headerlink" title="6. 使用动画放大展示ImageView"></a>6. 使用动画放大展示ImageView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//动画放大所展示的ImageView</span><br><span class="line">[UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">    CGFloat y,width,height;</span><br><span class="line">    y = ([UIScreen mainScreen].bounds.size.height - image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width) * 0.5;</span><br><span class="line">    //宽度为屏幕宽度</span><br><span class="line">    width = [UIScreen mainScreen].bounds.size.width;</span><br><span class="line">    //高度 根据图片宽高比设置</span><br><span class="line">    height = image.size.height * [UIScreen mainScreen].bounds.size.width / image.size.width;</span><br><span class="line">    [imageView setFrame:CGRectMake(0, y, width, height)];</span><br><span class="line">    //重要！ 将视图显示出来</span><br><span class="line">    [backgroundView setAlpha:1];</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="7-添加恢复ImageView原始尺寸的tap点击事件"><a href="#7-添加恢复ImageView原始尺寸的tap点击事件" class="headerlink" title="7. 添加恢复ImageView原始尺寸的tap点击事件"></a>7. 添加恢复ImageView原始尺寸的tap点击事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件同样是类方法 -&gt; 作用是再次点击回到初始大小</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hideImageView:)];</span><br><span class="line">[backgroundView addGestureRecognizer:tapGestureRecognizer];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  恢复imageView原始尺寸</span><br><span class="line"> */</span><br><span class="line">+(void)hideImageView:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    UIView *backgroundView = tap.view;</span><br><span class="line">    //原始imageview</span><br><span class="line">    UIImageView *imageView = [tap.view viewWithTag:1024];</span><br><span class="line">    //恢复</span><br><span class="line">    [UIView animateWithDuration:0.4 animations:^&#123;</span><br><span class="line">        [imageView setFrame:oldframe];</span><br><span class="line">        [backgroundView setAlpha:0];</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        [backgroundView removeFromSuperview];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-完成之后将背景视图删掉"><a href="#8-完成之后将背景视图删掉" class="headerlink" title="8. 完成之后将背景视图删掉"></a>8. 完成之后将背景视图删掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//完成后操作-&gt;将背景视图删掉</span><br><span class="line">[backgroundView removeFromSuperview];</span><br></pre></td></tr></table></figure><h2 id="四：项目实际使用"><a href="#四：项目实际使用" class="headerlink" title="四：项目实际使用"></a>四：项目实际使用</h2><h4 id="1-引入封装类FBYImageZoom"><a href="#1-引入封装类FBYImageZoom" class="headerlink" title="1. 引入封装类FBYImageZoom"></a>1. 引入封装类FBYImageZoom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYImageZoom.h&quot;</span><br></pre></td></tr></table></figure><h4 id="2-给UIImageView添加手势"><a href="#2-给UIImageView添加手势" class="headerlink" title="2. 给UIImageView添加手势"></a>2. 给UIImageView添加手势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//添加点击事件</span><br><span class="line">UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(scanBigImageClick:)];</span><br></pre></td></tr></table></figure><h4 id="3-调用封装类函数"><a href="#3-调用封装类函数" class="headerlink" title="3. 调用封装类函数"></a>3. 调用封装类函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//浏览大图点击事件</span><br><span class="line">-(void)scanBigImageClick:(UITapGestureRecognizer *)tap&#123;</span><br><span class="line">    NSLog(@&quot;点击图片&quot;);</span><br><span class="line">    UIImageView *clickedImageView = (UIImageView *)tap.view;</span><br><span class="line">    [FBYImageZoom ImageZoomWithImageView:clickedImageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里点击图片放大到全屏就完成了</p><h2 id="五：项目展示"><a href="#五：项目展示" class="headerlink" title="五：项目展示"></a>五：项目展示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161f900f7b9f73d6?w=300&amp;h=500&amp;f=gif&amp;s=1992499" alt=""></p><h4 id="六-本篇文章demo源码："><a href="#六-本篇文章demo源码：" class="headerlink" title="六. 本篇文章demo源码："></a>六. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYImageZoom-iOS" target="_blank" rel="noopener">github demo</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：简介&quot;&gt;&lt;a href=&quot;#一：简介&quot; class=&quot;headerlink&quot; title=&quot;一：简介&quot;&gt;&lt;/a&gt;一：简介&lt;/h2&gt;&lt;p&gt;在项目中免不了会遇到，实名认证上传身份证、绑定银行卡等功能。在实际操作中呢，会涉及到上传图片，在页面布局时，可能图片不是一张，考虑到布局的美观等因素，显示图片的位置变得很小，如果想查看上传的图片是否清晰，内容是否完整，可能就需要放大才能实现，下面就和大家分享一下我封装的一类，完美的实现了图片的缩放功能。&lt;/p&gt;
&lt;p&gt;另外，这些博文都是来源于我日常开发中的技术总结，在时间允许的情况下，我会针对技术点分别分享iOS、Android两个版本，尽量附上demo以供大家参考，如果有其他技术点需要，可在文章后留言，我会尽全力帮助大家。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIDatePicker | 时间选择器</title>
    <link href="https://fanbaoying.github.io/iOS-UIDatePicker%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E6%83%85/"/>
    <id>https://fanbaoying.github.io/iOS-UIDatePicker的使用详情/</id>
    <published>2018-02-09T07:25:17.000Z</published>
    <updated>2018-02-11T01:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：UIDatePicker的介绍"><a href="#一：UIDatePicker的介绍" class="headerlink" title="一：UIDatePicker的介绍"></a>一：UIDatePicker的介绍</h2><p>UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。<br>日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。<br>你也可以对其进行定制，令其使用任何范围的日期。</p><p>UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。<br>iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。<br>使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。<br>UIDatePicker给出了倒计时模式，但是并没有实现相关事件。<br>如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。</p><a id="more"></a><h2 id="二：UIDatePicker的使用"><a href="#二：UIDatePicker的使用" class="headerlink" title="二：UIDatePicker的使用"></a>二：UIDatePicker的使用</h2><h2 id="2-1-创建并添加一个UIDatePicker对象"><a href="#2-1-创建并添加一个UIDatePicker对象" class="headerlink" title="2.1 创建并添加一个UIDatePicker对象"></a>2.1 创建并添加一个UIDatePicker对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  DatePicker</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">//创建对象</span><br><span class="line">@property (nonatomic, strong) UIDatePicker *datePicker;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="2-2-配置UIDatePicker对象"><a href="#2-2-配置UIDatePicker对象" class="headerlink" title="2.2 配置UIDatePicker对象"></a>2.2 配置UIDatePicker对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupDateKeyPan &#123;</span><br><span class="line"></span><br><span class="line">    UIDatePicker *datePicker = [[UIDatePicker alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置地区: zh-中国</span><br><span class="line">    datePicker.locale = [NSLocale localeWithLocaleIdentifier:@&quot;zh&quot;];</span><br><span class="line"></span><br><span class="line">    //设置日期模式(Displays month, day, and year depending on the locale setting)</span><br><span class="line">    datePicker.datePickerMode = UIDatePickerModeCountDownTimer;</span><br><span class="line">    // 设置当前显示时间</span><br><span class="line">    [datePicker setDate:[NSDate date] animated:YES];</span><br><span class="line">    // 设置显示最大时间（此处为当前时间）</span><br><span class="line">    [datePicker setMaximumDate:[NSDate date]];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line"></span><br><span class="line">    //监听DataPicker的滚动</span><br><span class="line">    [datePicker addTarget:self action:@selector(dateChange:) forControlEvents:UIControlEventValueChanged];</span><br><span class="line"></span><br><span class="line">    self.datePicker = datePicker;</span><br><span class="line"></span><br><span class="line">    //设置时间输入框的键盘框样式为时间选择器</span><br><span class="line">    self.timeTextField.inputView = datePicker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-禁止用户输入文字"><a href="#2-3-禁止用户输入文字" class="headerlink" title="2.3 禁止用户输入文字"></a>2.3 禁止用户输入文字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//禁止用户输入文字</span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">  return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-显示文本"><a href="#2-4-显示文本" class="headerlink" title="2.4 显示文本"></a>2.4 显示文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)dateChange:(UIDatePicker *)datePicker &#123;</span><br><span class="line"></span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line"></span><br><span class="line">    //设置时间格式</span><br><span class="line">    formatter.dateFormat = @&quot;yyyy年 MM月 dd日&quot;;</span><br><span class="line">    NSString *dateStr = [formatter  stringFromDate:datePicker.date];</span><br><span class="line"></span><br><span class="line">    self.timeTextField.text = dateStr;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="三：选择模式"><a href="#三：选择模式" class="headerlink" title="三：选择模式"></a>三：选择模式</h2><p>日期/时间选取器持4种不同模式的选择方式。<br>通过设置 datePickerMode 属性，可以定义选择模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.datePickerMode = UIDatePickerModeTime;</span><br></pre></td></tr></table></figure></p><p>支持的模式：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a1d8372b?w=600&amp;h=214&amp;f=png&amp;s=93770" alt="支持模式"></p><p>四种时间模式样式截图如下：</p><h4 id="3-1-UIDatePickerModeTime"><a href="#3-1-UIDatePickerModeTime" class="headerlink" title="3.1 UIDatePickerModeTime"></a>3.1 UIDatePickerModeTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a01a3438?w=600&amp;h=1065&amp;f=jpeg&amp;s=20585" alt="UIDatePickerModeTime"><br>在这种模式下，显示时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-2-UIDatePickerModeDate"><a href="#3-2-UIDatePickerModeDate" class="headerlink" title="3.2 UIDatePickerModeDate"></a>3.2 UIDatePickerModeDate</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a20f7db1?w=600&amp;h=1065&amp;f=jpeg&amp;s=28097" alt="UIDatePickerModeDate"></p><p>在这种模式下，显示年、月、日。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-3-UIDatePickerModeDateAndTime"><a href="#3-3-UIDatePickerModeDateAndTime" class="headerlink" title="3.3 UIDatePickerModeDateAndTime"></a>3.3 UIDatePickerModeDateAndTime</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa39d537561?w=600&amp;h=1065&amp;f=jpeg&amp;s=28835" alt="UIDatePickerModeDateAndTime"></p><p>在这种模式下，显示日期的月、日、星期，时间的时、分、AM／PM标志(可选)。具体的显示顺序取决于设备的本地化设置。</p><h4 id="3-4-UIDatePickerModeCountDownTimer"><a href="#3-4-UIDatePickerModeCountDownTimer" class="headerlink" title="3.4 UIDatePickerModeCountDownTimer"></a>3.4 UIDatePickerModeCountDownTimer</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605eaa3a24ca874?w=600&amp;h=1065&amp;f=jpeg&amp;s=21341" alt="UIDatePickerModeCountDownTimer"></p><p>在这种模式下，显示时、分。应用程序必须实现一个计数器（NSTimer对象），让倒计时中的时间不断减少。</p><h2 id="四：日期范围"><a href="#四：日期范围" class="headerlink" title="四：日期范围"></a>四：日期范围</h2><p>你可以通过设置mininumDate 和 maxinumDate 属性，来指定使用的日期范围。如果用户试图滚动到超出这一范围的日期，表盘会回滚到最近的有效日期。两个方法都需要NSDate 对象作参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDate* minDate = [[NSDate alloc]initWithString:@&quot;1900-01-01 00:00:00 -0500&quot;];    </span><br><span class="line">NSDate* maxDate = [[NSDate alloc]initWithString:@&quot;2099-01-01 00:00:00 -0500&quot;];    </span><br><span class="line"></span><br><span class="line">datePicker.minimumDate = minDate;    </span><br><span class="line">datePicker.maximumDate = maxDate;</span><br></pre></td></tr></table></figure></p><p>如果两个日期范围属性中任何一个未被设置，则默认行为将会允许用户选择过去或未来的任意日期。这在某些情况下很有用处，比如，当选择生日时，可以是过去的任意日期，但终止与当前日期。如果你希望设置默认显示的日期，可以使用date属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datePicker.date = minDate;</span><br></pre></td></tr></table></figure><p>此外，你还可以用 setDate 方法。如果选择了使用动画，则表盘会滚动到你指定的日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[datePicker setDate:maxDate animated:YES];</span><br></pre></td></tr></table></figure><h4 id="4-本篇文章demo源码："><a href="#4-本篇文章demo源码：" class="headerlink" title="4. 本篇文章demo源码："></a>4. 本篇文章demo源码：</h4><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">UIDatePicker–DEMO</a></p><hr><p>欢迎关注我的公众号：网罗开发</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/29/1613fe638def80c9?w=300&amp;h=300&amp;f=jpeg&amp;s=21616" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;a href=&quot;#一：UIDatePicker的介绍&quot; class=&quot;headerlink&quot; title=&quot;一：UIDatePicker的介绍&quot;&gt;&lt;/a&gt;一：UIDatePicker的介绍&lt;/h2&gt;&lt;p&gt;UIDatePicker 是一个控制器类，封装了 UIPickerView，但是他是UIControl的子类，专门用于接受日期、时间和持续时长的输入。&lt;br&gt;日期选取器的各列会按照指定的风格进行自动配置，这样就让开发者不必关心如何配置表盘这样的底层操作。&lt;br&gt;你也可以对其进行定制，令其使用任何范围的日期。&lt;/p&gt;
&lt;p&gt;UIDatePicker这个类的对象让用户可以在多个车轮上选择日期和时间。&lt;br&gt;iPhone手机上的‘时钟’应用程序中的时间与闹铃中便使用了该控件。&lt;br&gt;使用这个控件时，如果你能配置正确，当用户滚动车轮到一个新的日期或者时间上时，利用UIControlEventValueChanged触发事件。&lt;br&gt;UIDatePicker给出了倒计时模式，但是并没有实现相关事件。&lt;br&gt;如果你使用该模式，必须在应用程序中设置一个NSTime对象，让倒计时中的时间不断减少。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 文集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS发红包页面</title>
    <link href="https://fanbaoying.github.io/iOS%E5%8F%91%E7%BA%A2%E5%8C%85%E9%A1%B5%E9%9D%A2/"/>
    <id>https://fanbaoying.github.io/iOS发红包页面/</id>
    <published>2018-02-07T09:38:47.000Z</published>
    <updated>2018-02-07T09:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS APP发红包页面制作，可直接参考源码，节约开发时间。<br><a href="https://github.com/fanbaoying/GiveRedEnvelopes" target="_blank" rel="noopener">点击获取GitHub 源码</a></p><p>来源：来自 qq:668562416 “西安 - 梦龙雪糕” 的贡献</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2829694-0086035242f8609e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="22.png"></p><p>其他干货信息：</p><ul><li><a href="https://github.com/fanbaoying/MsgPlaySound" target="_blank" rel="noopener">获取系统震动和声音</a>(来自”西安 - 梦龙雪糕” 的贡献)</li><li><a href="https://github.com/fanbaoying/AFN-YYCache" target="_blank" rel="noopener">AFN-YYCache二次封装网络请求</a>(来自”MrGoodbye”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYFMDBDemo" target="_blank" rel="noopener">FMDB | 实现数据的增删改查</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYDataDisplay-iOS" target="_blank" rel="noopener">iOS折线图统计图</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYIDCardRecognition-Android" target="_blank" rel="noopener">Android 银行卡身份证识别demo</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYBankCardRecognition-iOS" target="_blank" rel="noopener">iOS 银行卡识别demo</a>(来自”FBY展菲”的贡献)</li><li><a href="https://github.com/fanbaoying/FBYIDCardRecognition-iOS" target="_blank" rel="noopener">iOS 身份证识别demo</a>(来自”FBY展菲”的贡献)</li></ul><p>更多干货信息请到：GitHub: <a href="https://github.com/fanbaoying" target="_blank" rel="noopener">https://github.com/fanbaoying</a> 下载</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS APP发红包页面制作，可直接参考源码，节约开发时间。&lt;br&gt;&lt;a href=&quot;https://github.com/fanbaoying/GiveRedEnvelopes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击获取GitHub 源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：来自 qq:668562416 “西安 - 梦龙雪糕” 的贡献&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 贡献集" scheme="https://fanbaoying.github.io/categories/iOS-%E8%B4%A1%E7%8C%AE%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Apple Pay开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-Apple-Pay%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-Apple-Pay开发流程/</id>
    <published>2018-02-06T08:00:31.000Z</published>
    <updated>2018-02-06T08:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下Apple_pay，其他支付也写了对应教程，并且给出了连接。</p><a id="more"></a><h2 id="二：支付流程介绍"><a href="#二：支付流程介绍" class="headerlink" title="二：支付流程介绍"></a>二：支付流程介绍</h2><h2 id="2-1-Apple-Pay-页面演示"><a href="#2-1-Apple-Pay-页面演示" class="headerlink" title="2.1 Apple Pay 页面演示"></a>2.1 Apple Pay 页面演示</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3bdb0c80?w=1240&amp;h=871&amp;f=png&amp;s=238050" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3f1fee30?w=1240&amp;h=974&amp;f=png&amp;s=216268" alt="Apple Pay 页面演示"></p><ol><li>买家在手机应用中购买商品或服务，在订单页面中展示 Apple Pay 按钮</li><li>通过银联控件，掉起 Apple Pay 支付页面</li><li>用户通过支付页面验证 Touch ID，输入银行卡密码 是否需要输入银行卡密码取决于交易限额和银行支持情况</li><li>支付成功，商户应用内展示成功页面<br>(1)支付成功页面应参照 UI 示例，展示“银联”标识，“云闪付”标识。<br>(2)银联 SDK 控件支持折扣功能。在折扣活动期间，商户应用内应参照实例 UI 进行原金 额、折扣金额的展示</li></ol><h3 id="2-2-Apple-Pay-支付的实现方式"><a href="#2-2-Apple-Pay-支付的实现方式" class="headerlink" title="2.2 Apple Pay 支付的实现方式"></a>2.2 Apple Pay 支付的实现方式</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3bcc2b63?w=1240&amp;h=774&amp;f=png&amp;s=76672" alt="Apple Pay 支付的实现方式"></p><p>1-2. 商户生成订单，通过商户 SERVER 端将订单信息发送给银联支付网关;<br>3-4. 银联支付网关记录订单信息，返回用来标识订单的 TN 号，经由商户 SERVER 返回至给 商户 APP;<br>5.商户 APP 调用银联 SDK，将 TN 号传递给银联 SDK<br>6.银联 SDK 向 Apple 公司的 PASSKIT FRAMEWORK 发起支付请求;<br>7.接口返回加密的支付 Token 信息;<br>8-9.银联 SDK 将支付 Token 传递给银联支付网关，完成交易认证;<br>10-12.银联将支付结果返回给商户 APP，商户 SERVER，商户 APP 负责提示用户交易结果。</p><h2 id="三：工程配置"><a href="#三：工程配置" class="headerlink" title="三：工程配置"></a>三：工程配置</h2><p>bundleID设置</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3be01987?w=1069&amp;h=245&amp;f=png&amp;s=55370" alt="bundleID设置"></p><p>Capability中启用Apple Pay权限，并选择merchantID，<a href="https://juejin.im/post/5a31e031f265da430a50971e" target="_blank" rel="noopener">merchantID申请流程</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db41f7cd8f?w=873&amp;h=476&amp;f=png&amp;s=47034" alt="启用Apple Pay权限"></p><p>之后项目会多一个Applepay的配置文件ApplePayYasin.entitlements</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db3e704842?w=1136&amp;h=204&amp;f=png&amp;s=49705" alt="项目文件"></p><h2 id="四：下载Apple-Pay-SDK"><a href="#四：下载Apple-Pay-SDK" class="headerlink" title="四：下载Apple Pay SDK"></a>四：下载Apple Pay SDK</h2><p><a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">Apple Pay SDK</a></p><p>下载之后，找到.h文件和库文件，使用UPPaymentControl需要将paymentcontrol/inc目录下UPAPayPlugin.h、UPAPayPluginDelegate.h文件和paymentcontrol/libs目录下的libUPAPayPlugin.a文件添加到商户应用的工程中</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db909531af?w=1238&amp;h=376&amp;f=png&amp;s=79656" alt="SDK路径"></p><h2 id="五：调用支付接口"><a href="#五：调用支付接口" class="headerlink" title="五：调用支付接口"></a>五：调用支付接口</h2><p>在调用银联支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UPAPayPlugin.h&quot;</span><br><span class="line"></span><br><span class="line">// TODO 商户需要换用自己的mertchantID</span><br><span class="line">#define kAppleMerchantID        @&quot;merchant.com.AgreePay.ApplePayAgree&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//当获得的tn不为空时，调用支付接口</span><br><span class="line">if (tn != nil &amp;&amp; tn.length &gt; 0) &#123;</span><br><span class="line">        [UPAPayPlugin startPay:tn</span><br><span class="line">        mode:@&quot;01&quot;</span><br><span class="line">        viewController:ViewController</span><br><span class="line">        delegate:self andAPMechantID:kAppleMerchantID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法需要的几个参数文档上都写的有，tn是交易流水号，服务器端传回来的，客户端只有凭借这个参数才能调用支付控件 进行支付的。只需要调用一个方法就行啦！！！</p><h2 id="六：支付结果回调"><a href="#六：支付结果回调" class="headerlink" title="六：支付结果回调"></a>六：支付结果回调</h2><p>就在调起支付的ViewController 中写入下面代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -</span><br><span class="line">#pragma mark 响应控件返回的支付结果</span><br><span class="line">#pragma mark -</span><br><span class="line">- (void)UPAPayPluginResult:(UPPayResult *)result</span><br><span class="line">&#123;</span><br><span class="line">    if(result.paymentResultStatus == UPPaymentResultStatusSuccess) &#123;</span><br><span class="line">        NSString *otherInfo = result.otherInfo?result.otherInfo:@&quot;&quot;;</span><br><span class="line">        NSString *successInfo = [NSString stringWithFormat:@&quot;支付成功\n%@&quot;,otherInfo];</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%@&quot;,successInfo);</span><br><span class="line"></span><br><span class="line">    &#125;else if(result.paymentResultStatus == UPPaymentResultStatusCancel)&#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;支付取消&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;else if (result.paymentResultStatus == UPPaymentResultStatusFailure) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *errorInfo = [NSString stringWithFormat:@&quot;%@&quot;,result.errorDescription];</span><br><span class="line">        NSLog(@&quot;支付失败%@&quot;,errorInfo);</span><br><span class="line">    &#125;else if (result.paymentResultStatus == UPPaymentResultStatusUnknownCancel)  &#123;</span><br><span class="line"></span><br><span class="line">        //TODO UPPAymentResultStatusUnknowCancel表示发起支付以后用户取消，导致支付状态不确认，需要查询商户后台确认真实的支付结果</span><br><span class="line">//        NSString *errorInfo = [NSString stringWithFormat:@&quot;支付过程中用户取消了，请查询后台确认订单&quot;];</span><br><span class="line">//        [self showAlertMessage:errorInfo];</span><br><span class="line">        NSLog(@&quot;支付过程中用户取消了，请查询后台确认订单&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f3db620e1851?w=744&amp;h=1368&amp;f=png&amp;s=163923" alt="支付调起截图"></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下Apple_pay，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 最新版本支付宝支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-最新版本支付宝支付开发流程/</id>
    <published>2018-02-06T07:58:32.000Z</published>
    <updated>2018-02-06T08:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>最近支付宝，微信，银联支付类sdk均做了更新，其中支付宝sdk变化比较大，由原来需要导入六个文件：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li><li>Order.h和Order.m</li><li>Until文件夹</li><li>openssl文件夹</li><li>libcrypto.a和libssl.a</li></ul><p>在新版之后只需要导入两个文件就可以解决了，文件如下：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li></ul><p>下面我在旧版文章的基础上，为大家详细介绍最新版本支付宝支付开发流程。</p><a id="more"></a><p>因为工作的需要，我先后总结了iOS支付相关的近五类支付开发文章，分别是支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，做这些总结第一是方便以后的查阅，第二也为大家提供方便， 以免在用到的地方重复踩坑。</p><blockquote><p>注意开始填坑！！！</p></blockquote><h2 id="二：交互流程"><a href="#二：交互流程" class="headerlink" title="二：交互流程"></a>二：交互流程</h2><p>建议先把开发文档仔仔细细看一遍，一定要看，刚开始的时候没有老老实实地看完，结果遇到很多的坑，浪费的挺多的时间的，所以建议一定要好好看看，特别是<a href="https://doc.open.alipay.com/doc2/detail?spm=0.0.0.0.w6njr9&amp;treeId=59&amp;articleId=103658&amp;docType=1" target="_blank" rel="noopener">交互流程</a>这一部分。</p><h3 id="2-1-功能流程"><a href="#2-1-功能流程" class="headerlink" title="2.1 功能流程"></a>2.1 功能流程</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090db631c91f4e?w=848&amp;h=456&amp;f=png&amp;s=79224" alt="功能流程图"></p><p>流程说明：</p><ul><li>第4步：调用支付接口</li><li>第5步：支付请求</li><li>第8步：接口返回支付结果</li><li>第12步：异步发送支付通知</li></ul><h3 id="2-2-数据交互"><a href="#2-2-数据交互" class="headerlink" title="2.2 数据交互"></a>2.2 数据交互</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090dbeccf4cb9c?w=885&amp;h=469&amp;f=png&amp;s=93602" alt="数据交互图"></p><p>数据交互说明：</p><ol><li>构造订单数据并签名</li><li>发送请求数据</li><li>手机支付宝支付开发包对请求数据进行处理</li><li>返回处理的结果数据</li><li>商户对获取的返回结果数据进行处理</li></ol><h2 id="三：下载支付宝SDK"><a href="#三：下载支付宝SDK" class="headerlink" title="三：下载支付宝SDK"></a>三：下载支付宝SDK</h2><p>支付宝业务众多，真想找到想要的支付sdk还是要费一番功夫的，这里给出了<a href="https://docs.open.alipay.com/54/104509" target="_blank" rel="noopener">最新的sdk地址</a>（注意的是下载出来的SDK包里面并没有传说中的开发文档，需要其他地方找或者看网页上的）。</p><p>公钥、私钥、PID、sellerID、key这些东西的用途和获取方式在文档上都有详细的说明，这里不再赘述，一定要把概念分清楚再去做，不然一会就乱了。如果遇到问题的话咱们可以再一起探讨。</p><h2 id="四：-导入库集成SDK"><a href="#四：-导入库集成SDK" class="headerlink" title="四： 导入库集成SDK"></a>四： 导入库集成SDK</h2><h3 id="4-1-导入文件和关键库"><a href="#4-1-导入文件和关键库" class="headerlink" title="4.1 导入文件和关键库"></a>4.1 导入文件和关键库</h3><p>官方demo文件</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/26/16090ea4e1572b1f?w=778&amp;h=370&amp;f=png&amp;s=46381" alt=""></p><p>把iOS包中的压缩文件中以下文件拷贝到项目文件夹下，并导入到项目工程中：</p><ul><li>AlipaySDK.framework</li><li>AlipaySDK.bundle</li></ul><p>在Build Phases选项卡的Link Binary With Libraries中，增加以下依赖：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f21ff23afc13?w=800&amp;h=387&amp;f=png&amp;s=161849" alt="配置截图"><br>其中，需要注意的是：</p><ul><li>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；</li><li>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib（如下图）。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f21ff158304a?w=800&amp;h=63&amp;f=png&amp;s=15152" alt=""></p><p>此时，假如你启动工程，很大几率上你会发现报error的情况。<br>报错#include <openssl opensslconf.h=""> not find<br>这是一个神奇的大坑，我Google了好久，也不得其解，然后经网友提醒之后想起来#import “”和#import &lt;&gt;的区别。</openssl></p><blockquote><p>解决方法：Targets -&gt; Build Settings 下的 Header Search Paths。添加如下目录 “$(SRCROOT)/项目名称/文件的绝对地址”<br>如图：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2200ab48e0b?w=910&amp;h=519&amp;f=png&amp;s=274742" alt="3.png"></p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>在需要调用AlipaySDK的文件中，增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在支付宝的接入文档中，是将生成一个订单这步放在客户端来做了，但这个最好是 放在服务器端来做。<br>后台生成订单然后拼接，签名，然后服务器端直接给客户端传一个加密签名过的参数就可以了，这样比较安全。<br>所有的订单信息，商户信息等都掌握在自己的手中，这样的话APP端就不怕被拦截数据，并且调用起来也就特别简单了，只需要调用支付的接口。<br>如果只需要发送订单和处理支付返回结果，只需要添加AlipaySDK.bundle和AlipaySDK.framework这两个就行了，下载的SDK中很容易发现。<br>快捷支付方法是这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)payOrder:(NSString *)orderStr fromScheme:(NSString *)schemeStr callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>在支付的按钮中，使用支付宝这个类，再调用这个方法就行啦！如下如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[AlipaySDK defaultService] payOrder:credential fromScheme:fromScheme callback:^(NSDictionary* resultDic) &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,resultDic);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h3 id="4-4-配置支付宝客户端返回url处理方法"><a href="#4-4-配置支付宝客户端返回url处理方法" class="headerlink" title="4.4 配置支付宝客户端返回url处理方法"></a>4.4 配置支付宝客户端返回url处理方法</h3><p>如示例AliSDKDemo\APAppDelegate.m文件中，增加引用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure></p><p>在@implementation  AppDelegate中以下代码中的NSLog改为实际业务处理代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line"></span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-项目配置"><a href="#4-5-项目配置" class="headerlink" title="4.5 项目配置"></a>4.5 项目配置</h3><p>最后，不要忘了还要写一个URL Scheme，在Targets -&gt; Info 下最后一个即可找到，<br>点击“Info”选项卡，在“URL Types”选项中，点击“+”。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f220218b212e?w=1044&amp;h=348&amp;f=jpeg&amp;s=30900" alt="项目配置"></p><p>到这里支付宝支付就基本完成了，如果小伙伴们在集成过程中遇到什么问题，可以留言给我或者添加qq，在线帮你解决。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;最近支付宝，微信，银联支付类sdk均做了更新，其中支付宝sdk变化比较大，由原来需要导入六个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AlipaySDK.framework&lt;/li&gt;
&lt;li&gt;AlipaySDK.bundle&lt;/li&gt;
&lt;li&gt;Order.h和Order.m&lt;/li&gt;
&lt;li&gt;Until文件夹&lt;/li&gt;
&lt;li&gt;openssl文件夹&lt;/li&gt;
&lt;li&gt;libcrypto.a和libssl.a&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在新版之后只需要导入两个文件就可以解决了，文件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AlipaySDK.framework&lt;/li&gt;
&lt;li&gt;AlipaySDK.bundle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我在旧版文章的基础上，为大家详细介绍最新版本支付宝支付开发流程。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 微信支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-微信支付开发流程/</id>
    <published>2018-02-06T07:53:12.000Z</published>
    <updated>2018-02-06T08:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1" target="_blank" rel="noopener">微信支付开发文档</a>里面有详细的字段和说明。<br>微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）</p><a id="more"></a><h2 id="二：业务流程"><a href="#二：业务流程" class="headerlink" title="二：业务流程"></a>二：业务流程</h2><p>以下是交互时序图，统一下单API、支付结果通知API和查询订单API等都涉及签名过程，调用都必须在商户服务器端完成。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27888c19afc?w=894&amp;h=1042&amp;f=png&amp;s=35313" alt="交互时序图"></p><p>商户系统和微信支付系统主要交互说明：</p><ul><li><ol><li>用户在商户APP中选择商品，提交订单，选择微信支付。</li></ol></li><li><ol><li>商户后台收到用户支付单，调用微信支付统一下单接口。</li></ol></li><li><ol><li>统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为appid，partnerid，prepayid，noncestr，timestamp，package。</li></ol></li><li><ol><li>商户APP调起微信支付。</li></ol></li><li><ol><li>商户后台接收支付通知。</li></ol></li><li><ol><li>商户后台查询支付结果。</li></ol></li></ul><h2 id="三：下载微信SDK"><a href="#三：下载微信SDK" class="headerlink" title="三：下载微信SDK"></a>三：下载微信SDK</h2><p>如果集成了友盟分享里的微信，那就不用下载,也不用配置环境，因为配置友盟分享的时候已经把微信支付的环境都配置好了（包括框架，schema跳转，白名单）如果没有集成过友盟分享那么请到<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">微信开放平台下载SDK</a>。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f278a718dc7b?w=800&amp;h=278&amp;f=png&amp;s=44629" alt="下载微信SDK"></p><blockquote><p> 建议把iOS头文件和支付示例都下载下来</p></blockquote><h2 id="四：导入库集成SDK"><a href="#四：导入库集成SDK" class="headerlink" title="四：导入库集成SDK"></a>四：导入库集成SDK</h2><h3 id="4-1-导入SDK库"><a href="#4-1-导入SDK库" class="headerlink" title="4.1 导入SDK库"></a>4.1 导入SDK库</h3><p>导入上面那个iOS头文件和库下载下载出来的SDK包的就行，然后需要链接上依赖库，在Target —&gt; BuildPhases —&gt; Link Binary With Libraries— 点击+号 -&gt; 搜索你需要的系统库。</p><ul><li>SystemConfiguration.framework</li><li>libz.tbd</li><li>libsqlite3.0.tbd</li><li>CoreTelephony.framework</li><li>QuartzCore.framework</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2788cdb89fc?w=800&amp;h=606&amp;f=png&amp;s=84310" alt="导入SDK库"></p><h3 id="4-2-设置URL-Scheme"><a href="#4-2-设置URL-Scheme" class="headerlink" title="4.2 设置URL Scheme"></a>4.2 设置URL Scheme</h3><p>商户在微信开放平台申请开发APP应用后，微信开放平台会生成APP的唯一标识APPID，在<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5" target="_blank" rel="noopener">APP端开发步骤</a>里面说得很清楚了，需要填在URL Schemes这个地方。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27889fad2d9?w=800&amp;h=443&amp;f=png&amp;s=89206" alt="URL Scheme"></p><h3 id="4-2-在Appdelegate中注册APPID"><a href="#4-2-在Appdelegate中注册APPID" class="headerlink" title="4.2 在Appdelegate中注册APPID"></a>4.2 在Appdelegate中注册APPID</h3><p>首先要在Appdelegate中引用头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//微信支付</span><br><span class="line">#import &quot;WXApi.h&quot;</span><br></pre></td></tr></table></figure></p><p>然后注册APPID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">//    向微信终端注册ID</span><br><span class="line"></span><br><span class="line">    [WXApi registerApp:@&quot;wxd930ea5d5a258f4f&quot;];</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在支付成功之后，支付结果返回，需要获取url，也需要在Appdelegate中完成，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line"></span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if ([url.host isEqualToString:@&quot;pay&quot;]) &#123;</span><br><span class="line">        // 处理微信的支付结果</span><br><span class="line">        [WXApi handleOpenURL:url delegate:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        //跳转支付宝钱包进行支付，处理支付结果</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if ([url.host isEqualToString:@&quot;pay&quot;]) &#123;</span><br><span class="line">        // 处理微信的支付结果</span><br><span class="line">        [WXApi handleOpenURL:url delegate:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>微信SDK自带的方法，处理从微信客户端完成操作后返回程序之后的回调方法,显示支付结果的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(void) onResp:(BaseResp*)resp</span><br><span class="line">&#123;</span><br><span class="line">    //启动微信支付的response</span><br><span class="line">    NSString *payResoult = [NSString stringWithFormat:@&quot;errcode:%d&quot;, resp.errCode];</span><br><span class="line">    if([resp isKindOfClass:[PayResp class]])&#123;</span><br><span class="line">        //支付返回结果，实际支付结果需要去微信服务器端查询</span><br><span class="line">        switch (resp.errCode) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                payResoult = @&quot;支付结果：成功！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case -1:</span><br><span class="line">                payResoult = @&quot;支付结果：失败！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case -2:</span><br><span class="line">                payResoult = @&quot;用户已经退出支付！&quot;;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                payResoult = [NSString stringWithFormat:@&quot;支付结果：失败！retcode = %d, retstr = %@&quot;, resp.errCode,resp.errStr];</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-调用支付接口"><a href="#4-3-调用支付接口" class="headerlink" title="4.3 调用支付接口"></a>4.3 调用支付接口</h3><p>在调用微信支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;WXApi.h&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中，需要上传的参数包括：appid、partid（商户号）、prepayid（预支付订单ID）、noncestr（参与签名的随机字符串）、timestamp（参与签名的时间戳）、sign（签名字符串）这六个。<br>在点击支付的控制器中使用核心代码来调起微信客户端支付,这些个参数都是后台传给你的。 加上了注释，应该很好理解的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 微信支付方法</span><br><span class="line">- (void)WechatPay&#123;</span><br><span class="line"></span><br><span class="line">    //需要创建这个支付对象</span><br><span class="line">    PayReq *req   = [[PayReq alloc] init];</span><br><span class="line">    //由用户微信号和AppID组成的唯一标识，用于校验微信用户</span><br><span class="line">    req.openID = appid;</span><br><span class="line">    // 商家id，在注册的时候给的</span><br><span class="line">    req.partnerId = partnerid;</span><br><span class="line">    // 预支付订单这个是后台跟微信服务器交互后，微信服务器传给你们服务器的，你们服务器再传给你</span><br><span class="line">    req.prepayId  = prepayid;</span><br><span class="line">    // 根据财付通文档填写的数据和签名</span><br><span class="line">    req.package  = package;</span><br><span class="line">    // 随机编码，为了防止重复的，在后台生成</span><br><span class="line">    req.nonceStr  = noncestr;</span><br><span class="line">    // 这个是时间戳，也是在后台生成的，为了验证支付的</span><br><span class="line">    NSString * stamp = timestamp;</span><br><span class="line">    req.timeStamp = stamp.intValue;</span><br><span class="line">    // 这个签名也是后台做的</span><br><span class="line">    req.sign = sign;</span><br><span class="line">    //发送请求到微信，等待微信返回onResp</span><br><span class="line">    [WXApi sendReq:req];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-判断手机是否安装微信客户端"><a href="#4-4-判断手机是否安装微信客户端" class="headerlink" title="4.4 判断手机是否安装微信客户端"></a>4.4 判断手机是否安装微信客户端</h3><p>在需要微信支付的地方调用封装的类方法之后会跳转到微信app,如果没有安装则没有任何反应。这里需要注意，因为没有安装微信，必须要提供webview的方式登录微信来支付，否则苹果公司会拒绝应用上架。但是微信又不自带webview的方式，（支付宝是自带的）所以要判断用户有没有安装微信，如果没有安装微信就不显示微信支付这个按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 判断手机有没有微信</span><br><span class="line">    if ([WXApi isWXAppInstalled]) &#123;</span><br><span class="line">        wechatButton.hidden = NO;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        wechatButton.hidden = YES;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里微信支付就基本完成了，如果小伙伴们在集成过程中遇到什么问题，可以留言给我或者添加qq，在线帮你解决。</p><h2 id="后续：常见问题解决"><a href="#后续：常见问题解决" class="headerlink" title="后续：常见问题解决"></a>后续：常见问题解决</h2><ol><li>如果支付完成后，一直留在微信，那就检查下URLType中的Scheme设置问题。</li><li>能够打开微信客户端，但是打开后只有中间一个白色的 “确定按钮”，点击后会回到客户端上，如果是这样，那应该是prepayid 参数的问题，过期了，或者不是真实的id。</li><li>微信支付的单位是分</li><li>工程-&gt;build setttings -&gt; 搜索other linker flags 添加-Objc -all_load ，运行工程可能会崩溃，原因是程序没有找到sdk库。</li><li><p>白名单：不配置白名单也可以调起支付，如果调不起支付，查看是否是白名单的问题。<br>打开工程里的info.plist文件 添加LSApplicationQueriesSchemes数组并添加wechat 和 weixin字符串。<br>或者info.plist右键-&gt;source code打开添加下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;&lt;string&gt;wechat&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;weixin &lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></li><li><p>中文名的工程会报这个错误，英文名则不会，这是因为缺少UIKit库 在WXApiObject.h里导入库#import <uikit uikit.h="">。</uikit></p></li></ol><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信支付开发文档&lt;/a&gt;里面有详细的字段和说明。&lt;br&gt;微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 银联支付开发流程</title>
    <link href="https://fanbaoying.github.io/iOS-%E9%93%B6%E8%81%94%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/iOS-银联支付开发流程/</id>
    <published>2018-02-06T07:42:06.000Z</published>
    <updated>2018-02-06T08:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付</a>，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44a1979e7?w=800&amp;h=493&amp;f=png&amp;s=144804" alt="银联手机控件SDK"></p><h2 id="二：支付流程介绍"><a href="#二：支付流程介绍" class="headerlink" title="二：支付流程介绍"></a>二：支付流程介绍</h2><p>通过支付控件进行交易的流程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44cf785ab?w=800&amp;h=604&amp;f=png&amp;s=80017" alt="业务流程图"><br>流程图说明：<br>　　(1)用户在客户端中点击购买商品，客户端发起订单生成请求到商户后台;<br>　　(2)商户后台收到订单生成请求后，按照《手机控件支付产品接口规范》组织并推送订单信息至银联后台;<br>　　(3)银联后台接收订单信息并检查通过后，生成对应交易流水号(即TN)，并回复至商户后台(应答要素：交易流水号等);<br>　　(4)商户后台接收到交易流水号(TN)，将交易流水号返回至客户端;<br>　　(5)客户端通过交易流水号(TN)调用支付控件;<br>　　(6)用户在支付控件中输入相关支付信息后，由支付控件向银联后台发起支付请求;<br>　　(7)支付成功后，银联后台将支付结果通知给商户后台;<br>　　(8)银联后台同时也将支付结果通知支付控件;<br>　　(9)支付控件显示支付结果并将支付结果返回至客户端;<br>　　此处备注：我们是通过后台获取订单，我们可以根据商品id等信息通过后台接口获取订单信息，对订单支付流程的签名加密过程后台完成。</p><h2 id="三：下载银联SDK"><a href="#三：下载银联SDK" class="headerlink" title="三：下载银联SDK"></a>三：下载银联SDK</h2><p><a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付SDK</a></p><p>下载之后，找到.h文件和库文件，使用UPPaymentControl需要将paymentcontrol/inc目录下UPPaymentControl.h文件和paymentcontrol/libs目录下的libPaymentControl.a文件添加到商户应用的工程中</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b4488acca3?w=800&amp;h=165&amp;f=png&amp;s=56174" alt="SDK路径"></p><h2 id="四：工程配置"><a href="#四：工程配置" class="headerlink" title="四：工程配置"></a>四：工程配置</h2><h3 id="4-1-导入SDK库"><a href="#4-1-导入SDK库" class="headerlink" title="4.1 导入SDK库"></a>4.1 导入SDK库</h3><p>导入上面那个iOS头文件和库下载下载出来的SDK包的就行，然后需要链接上依赖库，在Target —&gt; BuildPhases —&gt; Link Binary With Libraries— 点击+号 -&gt; 搜索你需要的系统库。</p><ul><li>CFNetwork.framework</li><li>SystemConfiguration.framework</li><li>libz</li><li>libPaymentControl.a</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2788cdb89fc?w=800&amp;h=606&amp;f=png&amp;s=84310" alt="导入SDK库"></p><h3 id="4-2-设置URL-Scheme"><a href="#4-2-设置URL-Scheme" class="headerlink" title="4.2 设置URL Scheme"></a>4.2 设置URL Scheme</h3><p>在工程info.plist设置中添加一个URL Types回调协议(在UPPayDemo工程中使用“UPPayDemo”作为协议)，用于在支付完成后返回商户客户端。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27889fad2d9?w=800&amp;h=443&amp;f=png&amp;s=89206" alt="URL Scheme"></p><h3 id="4-3-http请求设置"><a href="#4-3-http请求设置" class="headerlink" title="4.3 http请求设置"></a>4.3 http请求设置</h3><p>进行http请求时，需要在工程对应的plist文件中添加NSAppTransportSecurity Dictionary 并同时设置里面NSAllowsArbitraryLoads 属性值为 YES</p><h3 id="4-4-添加协议白名单"><a href="#4-4-添加协议白名单" class="headerlink" title="4.4 添加协议白名单"></a>4.4 添加协议白名单</h3><p>需要在工程对应的plist文件中，添加LSApplicationQueriesSchemes Array并加入uppaysdk、uppaywallet、uppayx1、uppayx2、uppayx3五个item，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44a6be849?w=1038&amp;h=556&amp;f=png&amp;s=83234" alt="添加白名单"></p><h3 id="4-5-调用支付接口"><a href="#4-5-调用支付接口" class="headerlink" title="4.5 调用支付接口"></a>4.5 调用支付接口</h3><p>在调用银联支付类里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UPPaymentControl.h&quot;</span><br></pre></td></tr></table></figure><p>在调起支付的方法中代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//当获得的tn不为空时，调用支付接口</span><br><span class="line">if (tn != nil &amp;&amp; tn.length &gt; 0) &#123;</span><br><span class="line">        [[UPPaymentControl defaultControl]startPay:tn</span><br><span class="line">        fromScheme:@&quot;URL Scheme&quot;</span><br><span class="line">        mode:tnModel</span><br><span class="line">        viewController:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法需要的几个参数文档上都写的有，tn是交易流水号，服务器端传回来的，客户端只有凭借这个参数才能调用支付控件 进行支付的。只需要调用一个方法就行啦！！！</p><h3 id="4-6-支付结果回调"><a href="#4-6-支付结果回调" class="headerlink" title="4.6 支付结果回调"></a>4.6 支付结果回调</h3><p>在支付成功之后，支付结果返回，需要获取url，需要在Appdelegate中完成<br>在Appdelegate里面，首先增加头文件引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UPPaymentControl.h&quot;</span><br></pre></td></tr></table></figure><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">            openURL:(NSURL *)url</span><br><span class="line">  sourceApplication:(NSString *)sourceApplication</span><br><span class="line">         annotation:(id)annotation &#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;uppayresult&quot;])&#123;</span><br><span class="line">        //银联支付结果</span><br><span class="line">        [[UPPaymentControl defaultControl] handlePaymentResult:url completeBlock:^(NSString *code, NSDictionary *data) &#123;</span><br><span class="line">            //结果code为成功时，先校验签名，校验成功后做后续处理</span><br><span class="line">            if([code isEqualToString:@&quot;success&quot;]) &#123;</span><br><span class="line">                //交易成功</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;fail&quot;]) &#123;</span><br><span class="line">                //交易失败</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;cancel&quot;]) &#123;</span><br><span class="line">                //交易取消</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NOTE: 9.0以后使用新API接口</span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;uppayresult&quot;])&#123;</span><br><span class="line">        //银联支付结果</span><br><span class="line">        [[UPPaymentControl defaultControl] handlePaymentResult:url completeBlock:^(NSString *code, NSDictionary *data) &#123;</span><br><span class="line">            //结果code为成功时，先校验签名，校验成功后做后续处理</span><br><span class="line">            if([code isEqualToString:@&quot;success&quot;]) &#123;</span><br><span class="line">                //交易成功</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;fail&quot;]) &#123;</span><br><span class="line">                //交易失败</span><br><span class="line">            &#125;else if([code isEqualToString:@&quot;cancel&quot;]) &#123;</span><br><span class="line">                //交易取消</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-7-常见问题解决"><a href="#4-7-常见问题解决" class="headerlink" title="4.7 常见问题解决"></a>4.7 常见问题解决</h3><p>1.由于支付控件使用到了C、C++和OC混编的情况，将涉及到引用UPPaymentControl.h的源文件的后缀名都改为.mm;</p><p>2.由于在UPPayDemo工程中添加了自定义的库文件libPaymentControl.a，当编译Demo工程时，应该检查工程设置Search Paths里的Framework Search Paths、Header Search Paths、Library Search Paths的路径设置，看设置路径是否正确，另外还要注意里边是否多余一些不确定的路径。</p><p>3.控件界面无限加载，请参考控件使用指南iOS “添加SDK包“里“添加-ObjC宏”，特别注意大小写不要弄混。(此步骤操作有问题时也可修改为 -force_load+空格+控件路径，如：-force_load (PROJECT_DIR)/ libPaymentControl.a)。</p><p>4.控件闪退异常’NSInvalidArgumentException’, reason: ‘-[__NSCFConstantString newSizeWithFont:详略]’<br>　　出现以上问题是由于添加-ObjC宏的地方没有配置正确，如果配-ObjC实在解决不了的话，可尝试去掉-ObjC，改为-force_load+空格+控件路径，如：-force_load $(PROJECT_DIR)/ libPaymentControl.a。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、支付宝网页支付转客户端、微信支付、银联支付、Apple_pay，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://open.unionpay.com/ajweb/help/file/techFile?productId=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;银联手机控件支付&lt;/a&gt;，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 支付集" scheme="https://fanbaoying.github.io/categories/iOS-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android 银联控件支付开发流程</title>
    <link href="https://fanbaoying.github.io/Android-%E9%93%B6%E8%81%94%E6%8E%A7%E4%BB%B6%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/Android-银联控件支付开发流程/</id>
    <published>2018-02-06T07:36:54.000Z</published>
    <updated>2018-02-06T07:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付</a>，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d687fbdf7?w=800&amp;h=472&amp;f=png&amp;s=140075" alt="银联手机控件SDK"></p><h2 id="二：支付流程介绍"><a href="#二：支付流程介绍" class="headerlink" title="二：支付流程介绍"></a>二：支付流程介绍</h2><p>通过支付控件进行交易的流程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f2b44cf785ab?w=800&amp;h=604&amp;f=png&amp;s=80017" alt="业务流程图"><br>流程图说明：<br>　　(1)用户在客户端中点击购买商品，客户端发起订单生成请求到商户后台;<br>　　(2)商户后台收到订单生成请求后，按照《手机控件支付产品接口规范》组织并推送订单信息至银联后台;<br>　　(3)银联后台接收订单信息并检查通过后，生成对应交易流水号(即TN)，并回复至商户后台(应答要素：交易流水号等);<br>　　(4)商户后台接收到交易流水号(TN)，将交易流水号返回至客户端;<br>　　(5)客户端通过交易流水号(TN)调用支付控件;<br>　　(6)用户在支付控件中输入相关支付信息后，由支付控件向银联后台发起支付请求;<br>　　(7)支付成功后，银联后台将支付结果通知给商户后台;<br>　　(8)银联后台同时也将支付结果通知支付控件;<br>　　(9)支付控件显示支付结果并将支付结果返回至客户端;<br>　　此处备注：我们是通过后台获取订单，我们可以根据商品id等信息通过后台接口获取订单信息，对订单支付流程的签名加密过程后台完成。</p><h2 id="三：下载银联SDK"><a href="#三：下载银联SDK" class="headerlink" title="三：下载银联SDK"></a>三：下载银联SDK</h2><p><a href="https://open.unionpay.com/ajweb/help/file/techFile?productId=3" target="_blank" rel="noopener">银联手机控件支付SDK</a></p><p>下载之后，找到两个jar包，将UPPayAssistEx.jar和UPPayPluginExPro.jar添加到商户应用的工程中</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6f4b263a?w=800&amp;h=270&amp;f=png&amp;s=73837" alt="SDK路径"></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6574a83b?w=796&amp;h=556&amp;f=png&amp;s=204593" alt="SDK路径"></p><h2 id="四：导入开发SDK"><a href="#四：导入开发SDK" class="headerlink" title="四：导入开发SDK"></a>四：导入开发SDK</h2><p>导入sdk流程同支付宝导入流程一样，这里就借用支付宝导入流程进行介绍。</p><h3 id="4-1-如果项目开发使用的Eclipse软件，导入步骤如下："><a href="#4-1-如果项目开发使用的Eclipse软件，导入步骤如下：" class="headerlink" title="4.1 如果项目开发使用的Eclipse软件，导入步骤如下："></a>4.1 如果项目开发使用的Eclipse软件，导入步骤如下：</h3><p>1.将alipaySDK-20150602.jar包放入商户应用工程的libs目录下，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bd81ee8?w=392&amp;h=68&amp;f=png&amp;s=10285" alt="201.png"></p><p>2.进入商户应用工程的Java Build Path，将libs目录下的alipaySDK-20150602.jar导入，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bfaafda?w=1078&amp;h=436&amp;f=png&amp;s=243108" alt="202.png"></p><p>3.选中Order and Export，勾选alipaySDK-20150602.jar，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f824fb2?w=1078&amp;h=486&amp;f=png&amp;s=283277" alt="203.png"></p><blockquote><p>将上图的支付宝sdk更换成银联控件支付的两个jar包即可</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6a4e8c58?w=796&amp;h=556&amp;f=png&amp;s=204593" alt="103.png"></p><h3 id="4-2-如果项目开发使用的Android-Studio软件，导入步骤如下："><a href="#4-2-如果项目开发使用的Android-Studio软件，导入步骤如下：" class="headerlink" title="4.2 如果项目开发使用的Android Studio软件，导入步骤如下："></a>4.2 如果项目开发使用的Android Studio软件，导入步骤如下：</h3><p>1.将银联SDK拷贝到项目libs文件夹下，如果没有libs文件夹，就新建一个。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6c66e215?w=642&amp;h=222&amp;f=png&amp;s=26199" alt="105.png"></p><p>2.如果sdk使用过程中，提示找不到文件。<br>进行如下操作，选中sdk文件，右击选择Reveal in Finder</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f59e85f?w=982&amp;h=1266&amp;f=png&amp;s=249602" alt="302.png"></p><h2 id="除了导入jar包之外，还要导入资源包和依赖包，如下图："><a href="#除了导入jar包之外，还要导入资源包和依赖包，如下图：" class="headerlink" title="除了导入jar包之外，还要导入资源包和依赖包，如下图："></a>除了导入jar包之外，还要导入资源包和依赖包，如下图：</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f7d6815f35c?w=496&amp;h=596&amp;f=png&amp;s=98530" alt="106.png"></p><h2 id="五：修改AndroidManifest-xml配置"><a href="#五：修改AndroidManifest-xml配置" class="headerlink" title="五：修改AndroidManifest.xml配置"></a>五：修改AndroidManifest.xml配置</h2><p>1.在商户应用工程的AndroidManifest.xml文件里面添加声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-library</span><br><span class="line">    android:name=&quot;org.simalliance.openmobileapi&quot;</span><br><span class="line">    android:required=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.unionpay.uppay.PayActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden&quot;</span><br><span class="line">    android:excludeFromRecents=&quot;true&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:screenOrientation=&quot;portrait&quot;</span><br><span class="line">    android:windowSoftInputMode=&quot;adjustResize&quot; /&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.unionpay.UPPayWapActivity&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden&quot;</span><br><span class="line">    android:screenOrientation=&quot;portrait&quot;</span><br><span class="line">    android:windowSoftInputMode=&quot;adjustResize&quot; /&gt;</span><br></pre></td></tr></table></figure><p>和权限声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.nfc.hce&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;org.simalliance.openmobileapi.SMARTCARD&quot; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，银联支付的前期配置已经完成，下面需要完成支付代码编写。</p></blockquote><h2 id="六：支付接口调用"><a href="#六：支付接口调用" class="headerlink" title="六：支付接口调用"></a>六：支付接口调用</h2><ol><li>在点击支付按钮的点击事件中，我提供的是从后端获取订单信息。</li><li>需要在新线程中调用支付接口。代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//    支付按钮</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        //起一个线程</span><br><span class="line">        Runnable payRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String data = null;</span><br><span class="line">                PayBean payBean = new PayBean();</span><br><span class="line">                payBean.setOrderTime(&quot;&quot;);</span><br><span class="line">                String json = new Gson().toJson(payBean);</span><br><span class="line">                //json为获取后端结果时需要提供给后端订单信息，例如：时间、金额、订单属性等</span><br><span class="line">                Log.i(&quot;charge request&quot;, json);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //data为后端返回数据，其中包括订单字符串</span><br><span class="line">                    data = postJson(CHARGE_URL, json);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // Json解析data</span><br><span class="line">                ChargeBean charge = new Gson().fromJson(data, ChargeBean.class);</span><br><span class="line">                String tn = (String)charge.getResult().getCredential();</span><br><span class="line">                //在mHandler中处理微信调起支付和返回结果回调</span><br><span class="line">                Message msg = new Message();</span><br><span class="line">                msg.what = SDK_PAY_UPPAY;</span><br><span class="line">                msg.obj = charge;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 必须异步调用</span><br><span class="line">        Thread payThread = new Thread(payRunnable);</span><br><span class="line">        payThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>在mHandler中处理调起支付</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (msg.what == SDK_PAY_UPPAY)&#123;</span><br><span class="line">                String tn = (String) msg.obj;</span><br><span class="line">                Log.i(&quot;charge&quot;, tn);</span><br><span class="line">                int ret = UPPayAssistEx.startPay (ThirdActivity.this, null, null, tn, &quot;01&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ol><li>支付结果回调</li></ol><p>支付完成后，获取支付控件支付结果，并添加相应处理逻辑，只需实现调用Activity中的onActivityResult()方法即可，支付成功时会返回商户客户端支付结果和签名信息。</p><p>控件返回的结果信息仅作为参考，商户订单是否成功支付应该以商户后台主动到全渠道查询的结果或者收到全渠道支付结果通知为准。<br>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">        /*************************************************</span><br><span class="line">         * 步骤3：处理银联手机支付控件返回的支付结果</span><br><span class="line">         ************************************************/</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String msg = &quot;&quot;;</span><br><span class="line">        /*</span><br><span class="line">         * 支付控件返回字符串:success、fail、cancel 分别代表支付成功，支付失败，支付取消</span><br><span class="line">         */</span><br><span class="line">        String str = data.getExtras().getString(&quot;pay_result&quot;);</span><br><span class="line">        if (str.equalsIgnoreCase(&quot;success&quot;)) &#123;</span><br><span class="line">            // 支付成功后，extra中如果存在result_data，取出校验</span><br><span class="line">            // result_data结构见c）result_data参数说明</span><br><span class="line">            if (data.hasExtra(&quot;result_data&quot;)) &#123;</span><br><span class="line">                msg = &quot;支付成功！&quot;;</span><br><span class="line">            &#125; else if (str.equalsIgnoreCase(&quot;fail&quot;)) &#123;</span><br><span class="line">                msg = &quot;支付失败！&quot;;</span><br><span class="line">            &#125; else if (str.equalsIgnoreCase(&quot;cancel&quot;)) &#123;</span><br><span class="line">                msg = &quot;用户取消了支付&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AlertDialog.Builder builder = new AlertDialog.Builder(this);</span><br><span class="line">            builder.setTitle(&quot;支付结果通知&quot;);</span><br><span class="line">            builder.setMessage(msg);</span><br><span class="line">            builder.setInverseBackgroundForced(true);</span><br><span class="line">            builder.setNegativeButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                    dialog.dismiss();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.create().show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下三种为常用结果判断</p><blockquote><p>success为支付成功<br>fail为支付失败<br>cancel为取消支付</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下银联控件支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://open.unionpay.com/ajweb/help/file/techFile?productId=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;银联手机控件支付&lt;/a&gt;，里面包含需要的库文件和详细的文档。鉴于小伙伴们不容易找到，好事做到底，送上截图方便下载。&lt;/p&gt;
    
    </summary>
    
      <category term="Android 支付集" scheme="https://fanbaoying.github.io/categories/Android-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 微信支付开发流程</title>
    <link href="https://fanbaoying.github.io/Android-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <id>https://fanbaoying.github.io/Android-微信支付开发流程/</id>
    <published>2018-02-06T07:35:22.000Z</published>
    <updated>2018-02-06T07:47:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。<br>今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。</p><p>集成前首先要看看文档，<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1" target="_blank" rel="noopener">微信支付开发文档</a>里面有详细的字段和说明。<br>微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）</p><a id="more"></a><h2 id="二：业务流程"><a href="#二：业务流程" class="headerlink" title="二：业务流程"></a>二：业务流程</h2><p>以下是交互时序图，统一下单API、支付结果通知API和查询订单API等都涉及签名过程，调用都必须在商户服务器端完成。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f27888c19afc?w=894&amp;h=1042&amp;f=png&amp;s=35313" alt="交互时序图"></p><p>商户系统和微信支付系统主要交互说明：</p><ul><li><ol><li>用户在商户APP中选择商品，提交订单，选择微信支付。</li></ol></li><li><ol><li>商户后台收到用户支付单，调用微信支付统一下单接口。</li></ol></li><li><ol><li>统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为appid，partnerid，prepayid，noncestr，timestamp，package。</li></ol></li><li><ol><li>商户APP调起微信支付。</li></ol></li><li><ol><li>商户后台接收支付通知。</li></ol></li><li><ol><li>商户后台查询支付结果。</li></ol></li></ul><h2 id="三：下载微信SDK"><a href="#三：下载微信SDK" class="headerlink" title="三：下载微信SDK"></a>三：下载微信SDK</h2><p><a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1" target="_blank" rel="noopener">微信开放平台下载SDK</a><br>建议把Android头文件和支付示例都下载下来</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f32563772c4?w=800&amp;h=265&amp;f=png&amp;s=35629" alt="下载微信SDK"></p><h2 id="四：后台设置"><a href="#四：后台设置" class="headerlink" title="四：后台设置"></a>四：后台设置</h2><p>商户在微信开放平台申请开发应用后，微信开放平台会生成APP的唯一标识APPID。由于需要保证支付安全，需要在开放平台绑定商户应用包名和应用签名，设置好后才能正常发起支付。设置界面在【开放平台】中的栏目【管理中心 / 修改应用 / 修改开发信息】里面。如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f325b14d820?w=764&amp;h=722&amp;f=png&amp;s=18177" alt="102.png"></p><p>应用包名：是在APP项目配置文件AndroidManifest.xml中声明的package值，例如DEMO中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package=&quot;net.sourceforge.simcpux&quot;</span><br></pre></td></tr></table></figure></p><p>应用签名：根据项目的应用包名和编译使用的keystore，可由签名工具生成一个32位的md5串，在调试的手机上安装签名工具后，运行可生成应用签名串，如下图所示，绿色串即应用签名。</p><p>签名工具下载地址</p><p><a href="https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk" target="_blank" rel="noopener">https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk</a></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f3255fa05d8?w=538&amp;h=295&amp;f=png&amp;s=93202" alt="103.png"></p><blockquote><p>net.sourceforge.simcpux 是项目包名</p></blockquote><h2 id="五：导入开发SDK"><a href="#五：导入开发SDK" class="headerlink" title="五：导入开发SDK"></a>五：导入开发SDK</h2><p>导入sdk流程同支付宝导入流程一样，这里就借用支付宝导入流程进行介绍。</p><h3 id="5-1-如果项目开发使用的Eclipse软件，导入步骤如下："><a href="#5-1-如果项目开发使用的Eclipse软件，导入步骤如下：" class="headerlink" title="5.1 如果项目开发使用的Eclipse软件，导入步骤如下："></a>5.1 如果项目开发使用的Eclipse软件，导入步骤如下：</h3><p>1.将alipaySDK-20150602.jar包放入商户应用工程的libs目录下，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bd81ee8?w=392&amp;h=68&amp;f=png&amp;s=10285" alt="201.png"></p><p>2.进入商户应用工程的Java Build Path，将libs目录下的alipaySDK-20150602.jar导入，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43bfaafda?w=1078&amp;h=436&amp;f=png&amp;s=243108" alt="202.png"></p><p>3.选中Order and Export，勾选alipaySDK-20150602.jar，如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f824fb2?w=1078&amp;h=486&amp;f=png&amp;s=283277" alt="203.png"></p><blockquote><p>将上图的支付宝sdk更换成微信sdk即可</p></blockquote><h3 id="5-2-如果项目开发使用的Android-Studio软件，导入步骤如下："><a href="#5-2-如果项目开发使用的Android-Studio软件，导入步骤如下：" class="headerlink" title="5.2 如果项目开发使用的Android Studio软件，导入步骤如下："></a>5.2 如果项目开发使用的Android Studio软件，导入步骤如下：</h3><p>1.将微信SDK拷贝到项目libs文件夹下，如果没有libs文件夹，就新建一个。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f325c159f90?w=628&amp;h=198&amp;f=png&amp;s=24859" alt="301.png"></p><p>2.如果sdk使用过程中，提示找不到文件。<br>进行如下操作，选中sdk文件，右击选择Reveal in Finder</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052ed43f59e85f?w=982&amp;h=1266&amp;f=png&amp;s=249602" alt="302.png"></p><h2 id="六：修改AndroidManifest-xml配置"><a href="#六：修改AndroidManifest-xml配置" class="headerlink" title="六：修改AndroidManifest.xml配置"></a>六：修改AndroidManifest.xml配置</h2><p>1.在商户应用工程的AndroidManifest.xml文件里面添加声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信--&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">     android:name=&quot;.wxapi.WXPayEntryActivity&quot;</span><br><span class="line">     android:exported=&quot;true&quot;</span><br><span class="line">     android:launchMode=&quot;singleTop&quot;&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>和权限声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--微信--&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，微信支付的前期配置已经完成，下面需要完成支付代码编写。</p></blockquote><h2 id="七：支付接口调用"><a href="#七：支付接口调用" class="headerlink" title="七：支付接口调用"></a>七：支付接口调用</h2><ol><li>在点击支付按钮的点击事件中，我提供的是从后端获取订单信息。</li><li>需要在新线程中调用支付接口。代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//    微信按钮</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        //起一个线程</span><br><span class="line">        Runnable payRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                String data = null;</span><br><span class="line">                PayBean payBean = new PayBean();</span><br><span class="line">                payBean.setOrderTime(&quot;&quot;);</span><br><span class="line">                String json = new Gson().toJson(payBean);</span><br><span class="line">                //json为获取后端结果时需要提供给后端订单信息，例如：时间、金额、订单属性等</span><br><span class="line">                Log.i(&quot;charge request&quot;, json);</span><br><span class="line">                try &#123;</span><br><span class="line">                    //data为后端返回数据，其中包括订单字符串</span><br><span class="line">                    data = postJson(CHARGE_URL, json);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // Json解析data</span><br><span class="line">                ChargeWXBean charge = new Gson().fromJson(data.replace(&quot;package&quot;, &quot;packages&quot;), ChargeWXBean.class);</span><br><span class="line">                //在mHandler中处理微信调起支付和返回结果回调</span><br><span class="line">                Message msg = new Message();</span><br><span class="line">                msg.what = SDK_PAY_WECHAT;</span><br><span class="line">                msg.obj = charge;</span><br><span class="line">                mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 必须异步调用</span><br><span class="line">        Thread payThread = new Thread(payRunnable);</span><br><span class="line">        payThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>在mHandler中处理调起支付</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (msg.what == SDK_PAY_WECHAT) &#123;</span><br><span class="line"></span><br><span class="line">                ChargeWXBean charge =  (ChargeWXBean) msg.obj;</span><br><span class="line">                String packsges = charge.getResult().getCredential().getPackages();</span><br><span class="line">                String appid = charge.getResult().getCredential().getAppid();</span><br><span class="line">                String partenerid = charge.getResult().getCredential().getPartnerid();</span><br><span class="line">                String prepayid = charge.getResult().getCredential().getPrepayid();</span><br><span class="line">                String noncestr = charge.getResult().getCredential().getNoncestr();</span><br><span class="line">                String timestamp = charge.getResult().getCredential().getTimestamp();</span><br><span class="line">                String sign = charge.getResult().getCredential().getSign();</span><br><span class="line">//              商户APP工程中引入微信JAR包，调用API前，需要先向微信注册您的APPID，代码如下：</span><br><span class="line">                final IWXAPI msgApi = WXAPIFactory.createWXAPI(ThirdActivity.this, null);</span><br><span class="line">               // 将该app注册到微信   </span><br><span class="line">                msgApi.registerApp(appid);</span><br><span class="line"></span><br><span class="line">                PayReq req = new PayReq();</span><br><span class="line">                req.appId = appid;</span><br><span class="line">                req.partnerId = partenerid;</span><br><span class="line">                req.prepayId = prepayid;</span><br><span class="line">                req.nonceStr = noncestr;</span><br><span class="line">                req.timeStamp = timestamp;</span><br><span class="line">                req.packageValue = packsges;</span><br><span class="line">                req.sign = sign;</span><br><span class="line">                msgApi.sendReq(req);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ol><li>支付结果回调</li></ol><p>参照微信SDK Sample，在net.sourceforge.simcpux.wxapi包路径中实现WXPayEntryActivity类(包名或类名不一致会造成无法回调)，在WXPayEntryActivity类中实现onResp函数，支付完成后，微信APP会返回到商户APP并回调onResp函数，开发者需要在该函数中接收通知，判断返回错误码，如果支付成功则去后台查询支付结果再展示用户实际支付结果。注意一定不能以客户端返回作为用户支付的结果，应以服务器端的接收的支付通知或查询API返回的结果为准。(net.sourceforge.simcpux为你的项目包名)代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResp(BaseResp resp) &#123;</span><br><span class="line">    Log.d(TAG,&quot;onPayFinish,errCode=&quot;+resp.errCode);</span><br><span class="line"></span><br><span class="line">    // 判断resultStatus 为“0”则代表支付成功，具体状态码代表含义可参考接口文档</span><br><span class="line">    if (resp.errCode.equals(&quot;0&quot;)) &#123;</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;else if (resp.errCode.equals(&quot;-1&quot;))&#123;</span><br><span class="line"></span><br><span class="line">        // -1为支付失败，包括用户主动取消支付，或者系统返回的错误</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;else if (resp.errCode.equals(&quot;-2&quot;))&#123;</span><br><span class="line"></span><br><span class="line">        // -2为取消支付，或者系统返回的错误</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;取消支付&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 其他为系统返回的错误</span><br><span class="line">        Toast.makeText(ThirdActivity.this, &quot;支付错误&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下三种为常用结果判断</p><blockquote><p>0为支付成功<br>-1为支付失败<br>-2为取消支付</p></blockquote><h2 id="调起支付页面截图"><a href="#调起支付页面截图" class="headerlink" title="调起支付页面截图"></a>调起支付页面截图</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16052f3256a7f969?w=800&amp;h=696&amp;f=png&amp;s=77705" alt="002.png"></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;项目中要用到支付功能，需要支付宝支付、微信支付、银联支付，所以打算总结一下，方便以后的查阅，也方便大家， 用到的地方避免再次被坑。&lt;br&gt;今天我们就主要介绍一下微信支付，其他支付也写了对应教程，并且给出了连接。&lt;/p&gt;
&lt;p&gt;集成前首先要看看文档，&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信支付开发文档&lt;/a&gt;里面有详细的字段和说明。&lt;br&gt;微信支付是需要签名的，跟支付宝一样，可以在客户端签名，也可以在后台签名（当然，为了安全还是推荐在服务器上做签名，逻辑也比较好理解）&lt;/p&gt;
    
    </summary>
    
      <category term="Android 支付集" scheme="https://fanbaoying.github.io/categories/Android-%E6%94%AF%E4%BB%98%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>iOS 静态库详解与开发</title>
    <link href="https://fanbaoying.github.io/iOS-%E9%9D%99%E6%80%81%E5%BA%93%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    <id>https://fanbaoying.github.io/iOS-静态库详解与开发/</id>
    <published>2018-02-01T04:02:34.000Z</published>
    <updated>2018-02-01T05:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><h4 id="1-什么是库？"><a href="#1-什么是库？" class="headerlink" title="1. 什么是库？"></a>1. 什么是库？</h4><p>库是共享程序代码的方式，一般分为静态库和动态库。</p><p>静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。</p><p>动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2829694-2ca66d6c17532fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="库.png"></p><h4 id="2-两种形式中-framework的区别"><a href="#2-两种形式中-framework的区别" class="headerlink" title="2. 两种形式中.framework的区别"></a>2. 两种形式中.framework的区别</h4><p>如上图所示，静态库的形式包含.a和.framework两种形式，动态库的形式包含.dylib和.framework。<br>静态库和动态库都有.framework，但是各有所指，系统的.framework是动态库，我们自己建立的.framework是静态库。</p><h4 id="3-静态库中-a与-framework的区别"><a href="#3-静态库中-a与-framework的区别" class="headerlink" title="3. 静态库中.a与.framework的区别"></a>3. 静态库中.a与.framework的区别</h4><p>.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。<br>.a文件不能直接使用，至少还有.h文件配合，.framework文件可以直接使用，因为本身包含了h文件和其他文件</p><h4 id="4-静态库的优点"><a href="#4-静态库的优点" class="headerlink" title="4. 静态库的优点"></a>4. 静态库的优点</h4><ul><li>实现程序的模块化，将固定的业务模块化成静态库。</li><li>方便共享代码，即可以和别人分享你的代码库，但别人又看不到你代码的实现。</li><li>开发第三方sdk的需要，例如两个公司之间业务交流，不可能把源代码都发送给另一个公司，这时候将私密内容打包成静态库，别人只能调用接口，而不能知道其中实现的细节。</li></ul><p>公司项目需要开发出一套同时支持微信支付、支付宝支付、银联支付的sdk，既要满足本公司项目需求，还需要提供给友方公司使用。</p><p>同时集成三家第三方的支付sdk，其中有大量的配置冲突需要解决。这篇文章通过demo和大家介绍一下如何开发自己的静态库.a文件，分享给大家，同时对工作进行总结。</p><h2 id="二：静态库实现"><a href="#二：静态库实现" class="headerlink" title="二：静态库实现"></a>二：静态库实现</h2><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">静态库生成demo</a><br><a href="https://github.com/fanbaoying/FBYURLSDKDemo" target="_blank" rel="noopener">静态库使用demo</a></p><h4 id="1-新建一个静态库工程"><a href="#1-新建一个静态库工程" class="headerlink" title="1. 新建一个静态库工程"></a>1. 新建一个静态库工程</h4><p>打开Xcode，点击File\New\Project，选择iOS\Framework &amp; Library\Cocoa Touch Static Library新建一个静态库工程。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-5c10466b1eb83783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><p>将工程命名为FBYSDKDemo，然后将工程保存到一个空目录下。<br>静态库工程由头文件FBYSDKDemo.h和实现文件FBYSDKDemo.m组成，这些文件将被编译为库本身，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-c890566ea7b83b00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.png"></p><p>在开发中，为了让开发的静态库使用起来更方便，只需要让使用者导入一个头文件，便可以访问你所提供的接口，并且通过接口进行数据回调。</p><h2 id="2-导入头文件"><a href="#2-导入头文件" class="headerlink" title="2. 导入头文件"></a>2. 导入头文件</h2><p>导入UIKit的头文件，这是创建一个库所需要的。当你在创建不同的组成类时，你将会为它们添加到这个文件中，确保它们能够被库的使用者获取到。</p><p>打开FBYSDKDemo.h，引入头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br></pre></td></tr></table></figure></p><p>点击Build Phases，展开Link Binary with Libraries这一部分，点击+添加一个新的framework，找到UIKit.framework，点击add添加进来。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-73af75316bd9c807.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="33.png"></p><p>如果不结合头文件，静态库是没有用的，静态库编译一组文件，在这些文件中类和方法都以二进制数据的形式存在。<br>在静态库中类分为两类，一类是公开的public，一类是私有的只能内部访问使用。</p><p>接下来，需要在build栏中添加新的phase，来包含所有头文件。<br>在Xcode的Build Phases界面，选择Editor\Add Build Phase\Add Headers Build Phase。</p><p>注意：如果发现按上面找到的菜单项是不可点击的，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-ec4c0abb01fd6703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="44.png"></p><p>点击下方Build Phases界面的白色区域来获取Xcode的应用焦点，然后重新试一下</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-1aa858ffe3ebcd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="55.png"></p><p>把FBYSDKDemo.h从项目中拖到Copy Headers下的Public部分。<br>这里是要保证用户可以使用库中公开的类或者接口。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-5bcdf62ad6da934f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="66.png"></p><p>Copy Headers下的Public部分中所添加的类均是对外公开的。<br>这里有三个分组，Public公开的，Private下的头文件是可以被用户看到的，Project下的文件是私有的，这里建议尽量将文件放在Public和Project下。</p><h2 id="3-添加配置"><a href="#3-添加配置" class="headerlink" title="3. 添加配置"></a>3. 添加配置</h2><p>添加配置主要是在Build Settings下操作，点击项目名，然后选择FBYSDKDemo静态库目标，选择Build Setting栏，然后搜索public header，双击Public Headers Folder Path，在弹出视图中键入如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include/$(PROJECT_NAME)</span><br></pre></td></tr></table></figure></p><p>截图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-69c53a921d485524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="77.png"></p><p>因为你创建好的静态文件供他人使用，最好禁掉无效代码和debug符号，让用户自己选择对自己的项目有利的部分使用。<br>在搜索框中分别搜索Dead Code Stripping、Strip Debug Symbol During Copy、Strip Style配置如下：</p><ul><li>Dead Code Stripping设置为NO</li><li>Strip Debug Symbol During Copy 全部设置为NO</li><li>Strip Style设置为Non-Global Symbols</li></ul><p>到目前为止，项目的构建已经完成，选择目标为Generic iOS Device，按下command + B进行编译，工程导航栏中Product目录下libRWUIControls.a文件将从红色变为黑色，表明现在该文件已经存在了。右键单击libRWUIControls.a，选择Show in Finder，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-fc1fa643726aba34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="83.png"></p><p>上图就可以看到对外公开的FBYSDKDemo.h类，其他实现类均以二进制的形式在libFBYSDKDemo.a中。</p><h4 id="4-功能实现"><a href="#4-功能实现" class="headerlink" title="4. 功能实现"></a>4. 功能实现</h4><p>这里以实现静态库的开发为主，功能部分实现一个简单的功能demo来举例。</p><p>在头文件FBYSDKDemo.h中实现如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">typedef void (^FBYSDKCompletion)(NSString *result);</span><br><span class="line"></span><br><span class="line">@interface FBYSDKDemo : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *  @param urltype       网页类型信息 urltype可为iOS、Android</span><br><span class="line"> *  @param completion    根据urltype获取到相应网页url结果回调</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">- (void)urlType:(NSString *)urltype withCompletion:(FBYSDKCompletion)completion;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其中urltype为网页类型信息 urltype可为iOS、Android，根据urltype获取到相应网页url结果回调completion。</p><p>在实现文件FBYSDKDemo.m中代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYSDKDemo.h&quot;</span><br><span class="line"></span><br><span class="line">@interface FBYSDKDemo ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation FBYSDKDemo</span><br><span class="line"></span><br><span class="line">- (void)urlType:(NSString *)urltype withCompletion:(FBYSDKCompletion)completion&#123;</span><br><span class="line"></span><br><span class="line">    if ([urltype isEqualToString:[NSString stringWithFormat:@&quot;iOS&quot;]]) &#123;</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            completion(@&quot;https://juejin.im/post/5a41c04c6fb9a044fc44fd23&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else if ([urltype isEqualToString:[NSString stringWithFormat:@&quot;Android&quot;]]) &#123;</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            completion(@&quot;https://juejin.im/post/5a31e6adf265da430c11d41f&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>选择目标为Generic iOS Device，按下command + B进行编译。</p><h4 id="5-合并静态库"><a href="#5-合并静态库" class="headerlink" title="5. 合并静态库"></a>5. 合并静态库</h4><p>选择目标为Generic iOS Device，编译运行后，右键单击libRWUIControls.a，选择Show in Finder显示的libFBYSDKDemo.a可在真机，如果在虚拟机中运行会报错。</p><p>所以还要选择目标为虚拟机(例如iPhone 7)，然后编译运行,右键单击libRWUIControls.a，选择Show in Finder显示的libFBYSDKDemo.a可在虚拟机中运行，如果在真机中运行会报错。</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-a3e708bee87e2ab4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="85.png"></p><p>合并方法：打开终端，输入 lipo -create 真机库.a的路径 模拟器库.a的路径 －output 合成库的名字(可以复制模库.a的路径，修改名字).a；回车就可以在模拟库的文件夹中看到新合成的.a文件了，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-f248aa80f8e0d51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="87.png"></p><p>合成后静态库文件截图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-ac84b824650886ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="86.png"></p><p>libFBYSDKDemo_all.a文件即为静态库文件，一个通用的静态库.a就做好了。</p><h2 id="三：静态库使用"><a href="#三：静态库使用" class="headerlink" title="三：静态库使用"></a>三：静态库使用</h2><h4 id="1-导入静态库"><a href="#1-导入静态库" class="headerlink" title="1. 导入静态库"></a>1. 导入静态库</h4><p>导入静态库和.h头文件，注意下图选项：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-4f6e12c405f4cca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="89.png"></p><h4 id="2-调用函数"><a href="#2-调用函数" class="headerlink" title="2. 调用函数"></a>2. 调用函数</h4><p>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)blogsBtn:(UIButton *)sender &#123;</span><br><span class="line"></span><br><span class="line">    if (sender.tag == 6000) &#123;</span><br><span class="line"></span><br><span class="line">        [FBYSDKDemo urlType:@&quot;iOS&quot; withCompletion:^(NSString *result) &#123;</span><br><span class="line"></span><br><span class="line">            [self contentURL:result];</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;else if (sender.tag == 6001) &#123;</span><br><span class="line"></span><br><span class="line">        [FBYSDKDemo urlType:@&quot;Android&quot; withCompletion:^(NSString *result) &#123;</span><br><span class="line"></span><br><span class="line">            [self contentURL:result];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>result就是通过sdk回调获取到的结果。</p><h4 id="3-DEMO截图如下"><a href="#3-DEMO截图如下" class="headerlink" title="3. DEMO截图如下"></a>3. DEMO截图如下</h4><p><img src="http://upload-images.jianshu.io/upload_images/2829694-9a2fd73f4f291b21.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DEMO截图"></p><p>本篇文章demo源码：</p><p><a href="https://github.com/fanbaoying/FBYSDKDemo" target="_blank" rel="noopener">静态库生成demo</a><br><a href="https://github.com/fanbaoying/FBYURLSDKDemo" target="_blank" rel="noopener">静态库使用demo</a></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;h4 id=&quot;1-什么是库？&quot;&gt;&lt;a href=&quot;#1-什么是库？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是库？&quot;&gt;&lt;/a&gt;1. 什么是库？&lt;/h4&gt;&lt;p&gt;库是共享程序代码的方式，一般分为静态库和动态库。&lt;/p&gt;
&lt;p&gt;静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。&lt;/p&gt;
&lt;p&gt;动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>WKUIDelegate协议 - 手机网站支付转Native支付</title>
    <link href="https://fanbaoying.github.io/WKUIDelegate%E5%8D%8F%E8%AE%AE-%E6%89%8B%E6%9C%BA%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E8%BD%ACNative%E6%94%AF%E4%BB%98/"/>
    <id>https://fanbaoying.github.io/WKUIDelegate协议-手机网站支付转Native支付/</id>
    <published>2018-01-31T06:16:07.000Z</published>
    <updated>2018-01-31T06:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>为了节约开发成本，很多Native-H5混合App采用手机网站支付的方式去实现支付模块。但手机网站支付的网络依赖比较严重，也通常需要经过更多的验证，这种种原因导致手机网站支付的成功率比Native支付低，对商户的利益造成影响。</p><a id="more"></a><p>官方文档使用的是UIWebViewDelegate协议</p><h2 id="二：新旧版本区别"><a href="#二：新旧版本区别" class="headerlink" title="二：新旧版本区别"></a>二：新旧版本区别</h2><h4 id="1-旧版本"><a href="#1-旧版本" class="headerlink" title="1. 旧版本"></a>1. 旧版本</h4><p>获取到的url order info，从h5链接中获取订单串接口函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString*)fetchOrderInfoFromH5PayUrl:(NSString*)urlStr;</span><br><span class="line">- (void)payUrlOrder:(NSString *)orderStr</span><br><span class="line">         fromScheme:(NSString *)schemeStr</span><br><span class="line">           callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>上面两个函数自版本15.4.0起已废弃。</p><h4 id="2-新版本"><a href="#2-新版本" class="headerlink" title="2. 新版本"></a>2. 新版本</h4><p>新版本推荐使用下面方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  从h5链接中获取订单串并支付接口（自版本15.4.0起，推荐使用该接口）</span><br><span class="line"> *</span><br><span class="line"> *  @param urlStr     拦截的 url string</span><br><span class="line"> *</span><br><span class="line"> *  @return YES为成功获取订单信息并发起支付流程；NO为无法获取订单信息，输入url是普通url</span><br><span class="line"> */</span><br><span class="line">- (BOOL)payInterceptorWithUrl:(NSString *)urlStr</span><br><span class="line">                   fromScheme:(NSString *)schemeStr</span><br><span class="line">                     callback:(CompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>旧版本在官方推荐的UIWebViewDelegate协议中使用，暂时没有遇到问题。</p><p>如果在WKUIDelegate协议中使用fetchOrderInfoFromH5PayUrl函数，获得的获取到的url order info为空，无法调起支付。</p><p>下面我就给大家介绍一下使用WKUIDelegate协议怎么解决手机网站支付转Native支付。</p><h2 id="三：SDK导入流程"><a href="#三：SDK导入流程" class="headerlink" title="三：SDK导入流程"></a>三：SDK导入流程</h2><h4 id="1-下载sdk"><a href="#1-下载sdk" class="headerlink" title="1.下载sdk"></a>1.<a href="https://docs.open.alipay.com/54/104509" target="_blank" rel="noopener">下载sdk</a></h4><p>把iOS包中的压缩文件中以下文件拷贝到项目文件夹下，并导入到项目工程中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AlipaySDK.bundle</span><br><span class="line">AlipaySDK.framework</span><br></pre></td></tr></table></figure></p><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2.添加依赖"></a>2.添加依赖</h4><p>在Build Phases选项卡的Link Binary With Libraries中，增加以下依赖：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f45ce7a16e86?w=1112&amp;h=538&amp;f=png&amp;s=143033" alt="h5alipay.png"></p><p>注意：</p><p>如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd。</p><p>如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib。</p><h2 id="四：使用说明："><a href="#四：使用说明：" class="headerlink" title="四：使用说明："></a>四：使用说明：</h2><h4 id="1-头文件引用"><a href="#1-头文件引用" class="headerlink" title="1.头文件引用"></a>1.头文件引用</h4><p>在需要调用AlipaySDK的文件中，增加头文件引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br><span class="line"></span><br><span class="line">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line">@interface ViewController ()&lt;WKNavigationDelegate,WKUIDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) WKWebView *webView;</span><br><span class="line">//进度条</span><br><span class="line">@property (weak, nonatomic) CALayer *progresslayer;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>//初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)stopRunning&#123;</span><br><span class="line"></span><br><span class="line">    WKWebView *webView = [[WKWebView alloc]initWithFrame:CGRectMake(0, 64, SCREEN_WIDTH, SCREEN_HEIGHT-64)];</span><br><span class="line"></span><br><span class="line">    [self.view addSubview:webView];</span><br><span class="line">    self.webView = webView;</span><br><span class="line"></span><br><span class="line">    webView.navigationDelegate = self;</span><br><span class="line">    webView.UIDelegate = self;</span><br><span class="line"></span><br><span class="line">    //添加属性监听</span><br><span class="line">    [webView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line"></span><br><span class="line">    //进度条</span><br><span class="line">    UIView *progress = [[UIView alloc]initWithFrame:CGRectMake(0, 64, CGRectGetWidth(self.view.frame), 3)];</span><br><span class="line">    progress.backgroundColor = [UIColor clearColor];</span><br><span class="line">    [self.view addSubview:progress];</span><br><span class="line">    CALayer *layer = [CALayer layer];</span><br><span class="line">    layer.frame = CGRectMake(0, 0, 0, 3);</span><br><span class="line">    layer.backgroundColor = [UIColor blueColor].CGColor;</span><br><span class="line">    [progress.layer addSublayer:layer];</span><br><span class="line">    self.progresslayer = layer;</span><br><span class="line">    [webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:_customLabel.text]]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-调用接口"><a href="#2-调用接口" class="headerlink" title="2.调用接口"></a>2.调用接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[AlipaySDK defaultService]fetchOrderInfoFromH5PayUrl:url]</span><br></pre></td></tr></table></figure><h4 id="3-实现WKUIDelegate协议，拦截H5的URL"><a href="#3-实现WKUIDelegate协议，拦截H5的URL" class="headerlink" title="3.实现WKUIDelegate协议，拦截H5的URL"></a>3.实现WKUIDelegate协议，拦截H5的URL</h4><p>如果返回的resultCode为9000，接入方可以提示用户支付成功；</p><p>返回结果不是9000的情况，无需做任何处理。如果returnUrl不为空，建议接入方跳转到该returnUrl。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction*)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">    decisionHandler(WKNavigationActionPolicyAllow);//允许跳转</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,navigationAction.request.URL.absoluteString);</span><br><span class="line"></span><br><span class="line">    if ([navigationAction.request.URL.absoluteString hasPrefix:@&quot;alipay://alipayclient/&quot;]) &#123;</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line"></span><br><span class="line">        if ([[UIApplication sharedApplication] canOpenURL:navigationAction.request.URL]) &#123;</span><br><span class="line">            [[UIApplication sharedApplication] openURL:navigationAction.request.URL options:@&#123;UIApplicationOpenURLOptionUniversalLinksOnly: @NO&#125; completionHandler:^(BOOL success) &#123;</span><br><span class="line"></span><br><span class="line">                __weak APWebViewController* wself = self;</span><br><span class="line">                BOOL isIntercepted = [[AlipaySDK defaultService] payInterceptorWithUrl:[navigationAction.request.URL absoluteString] fromScheme:@&quot;alisdkdemo&quot; callback:^(NSDictionary *result) &#123;</span><br><span class="line">                    // 处理支付结果</span><br><span class="line">                    NSLog(@&quot;%@&quot;, result);</span><br><span class="line">                    // isProcessUrlPay 代表 支付宝已经处理该URL</span><br><span class="line">                    if ([result[@&quot;isProcessUrlPay&quot;] boolValue]) &#123;</span><br><span class="line">                        // returnUrl 代表 第三方App需要跳转的成功页URL</span><br><span class="line">                        NSString* urlStr = result[@&quot;returnUrl&quot;];</span><br><span class="line">                        [wself loadWithUrlStr:urlStr];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;];</span><br><span class="line"></span><br><span class="line">                if (isIntercepted) &#123;</span><br><span class="line"></span><br><span class="line">                    NSLog(@&quot;URL非支付宝支付URL&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-支付结果回调处理"><a href="#4-支付结果回调处理" class="headerlink" title="4.支付结果回调处理"></a>4.支付结果回调处理</h4><p>支付宝客户端返回url处理方法，在AppDelegate.m文件中，增加头文件引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AlipaySDK/AlipaySDK.h&gt;</span><br></pre></td></tr></table></figure></p><p>在@implementation AppDelegate中增加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //如果极简开发包不可用，会跳转支付宝钱包进行支付，需要将支付宝钱包的支付结果回传给开发包</span><br><span class="line">    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;</span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">    //【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([url.host isEqualToString:@&quot;platformapi&quot;])&#123;//支付宝钱包快登授权返回authCode</span><br><span class="line"></span><br><span class="line">        [[AlipaySDK defaultService] processAuthResult:url standbyCallback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">            //【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】</span><br><span class="line">            NSLog(@&quot;result = %@&quot;,resultDic);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;为了节约开发成本，很多Native-H5混合App采用手机网站支付的方式去实现支付模块。但手机网站支付的网络依赖比较严重，也通常需要经过更多的验证，这种种原因导致手机网站支付的成功率比Native支付低，对商户的利益造成影响。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android 使用广播系统解决app开机自启动问题</title>
    <link href="https://fanbaoying.github.io/Android-%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3app%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://fanbaoying.github.io/Android-使用广播系统解决app开机自启动问题/</id>
    <published>2018-01-31T04:01:37.000Z</published>
    <updated>2018-01-31T06:20:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanbaoying/PowerBoot" target="_blank" rel="noopener">Demo地址</a>  如果有所帮助记得关注，点Star<br>总结一下使用ACTION_BOOT_COMPLETED的广播，解决app开机自启动的问题<br>1.首先在你的工程上建一个广播接受的类，继承BroadcastReceiver：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package guide.example.com.guidedemo;</span><br><span class="line"></span><br><span class="line">import android.content.BroadcastReceiver;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by fby on 2017/6/26.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class BootReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    static final String action_boot =&quot;android.intent.action.BOOT_COMPLETED&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive (Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        Log.i(&quot;charge start&quot;, &quot;启动完成&quot;);</span><br><span class="line"></span><br><span class="line">        if (intent.getAction().equals(action_boot))&#123;</span><br><span class="line"></span><br><span class="line">            Intent mBootIntent = new Intent(context, MainActivity.class);</span><br><span class="line">            // 下面这句话必须加上才能开机自动运行app的界面</span><br><span class="line">            mBootIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            context.startActivity(mBootIntent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后要在AndroidManifest.xml中加入权限和配置相关信息：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>3.在application标签中，配置以下相关信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//BootReceiver是上面建的广播类</span><br><span class="line">        &lt;receiver android:name=&quot;.BootReceiver&quot;&gt;  </span><br><span class="line">            &lt;intent-filter&gt;  </span><br><span class="line">                &lt;!--注册开机广播地址--&gt;  </span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;&gt;            </span><br><span class="line">                &lt;/action&gt;  </span><br><span class="line"></span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;  </span><br><span class="line">            &lt;/intent-filter&gt;  </span><br><span class="line">        &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><p>补充说明：<br>1.查看系统中是否安装了类似360管家的软件，为了加快开机速度，默认是关闭掉开机广播的，只需要在设置中打开即可。<br>2.如果监听不到广播，可以尝试同时监听广播和sd卡。<br>3.同时监听广播和sd卡，在application标签中，配置以下相关信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.broadcastReceiver.BootCompletedReceiver&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot; /&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;data android:scheme=&quot;package&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanbaoying/PowerBoot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo地址&lt;/a&gt;  如果有所帮助记得关注，点Star&lt;br&gt;总结一下使用ACTION_BOOT_COMPLETED的广播，解决app开机自启动的问题&lt;br&gt;1.首先在你的工程上建一个广播接受的类，继承BroadcastReceiver：&lt;/p&gt;
    
    </summary>
    
      <category term="Android文集" scheme="https://fanbaoying.github.io/categories/Android%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Android" scheme="https://fanbaoying.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>码出一个高颜值原生折线图</title>
    <link href="https://fanbaoying.github.io/%E7%A0%81%E5%87%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E9%A2%9C%E5%80%BC%E5%8E%9F%E7%94%9F%E6%8A%98%E7%BA%BF%E5%9B%BE/"/>
    <id>https://fanbaoying.github.io/码出一个高颜值原生折线图/</id>
    <published>2018-01-31T02:34:30.000Z</published>
    <updated>2018-01-31T06:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p>在项目中遇到数据展示需求时，往往会通过，以列表的形式展示出数据或者以表格的形式展示。但是并不能直观的观察数据的变化，如果通过图表的形式来展示，就可以更快捷的获取到数据变化情况。</p><p>图表展示的方式大致分为折线图、柱状图、饼状图等等，那么如何码出一个高颜值原生折线图呢？<a href="https://github.com/fanbaoying/FBYDataDisplay-iOS" target="_blank" rel="noopener">demo源码</a>已经放在GitHub上，下面来介绍一下如何使用。</p><a id="more"></a><h2 id="二：项目展示"><a href="#二：项目展示" class="headerlink" title="二：项目展示"></a>二：项目展示</h2><p>运行后的展示截图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-412e7b8951ec0bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="三：-实现思路分析"><a href="#三：-实现思路分析" class="headerlink" title="三： 实现思路分析"></a>三： 实现思路分析</h2><p>实现折线图的核心代码是下面四个类：</p><ul><li>FBYLineGraphBaseView</li><li>FBYLineGraphContentView</li><li>FBYLineGraphColorView</li><li>FBYLineGraphView<br>下面针对这四个类实现做一个详细的流程分析。</li></ul><h4 id="1-折线图基础框架实现-FBYLineGraphBaseView类"><a href="#1-折线图基础框架实现-FBYLineGraphBaseView类" class="headerlink" title="1. 折线图基础框架实现(FBYLineGraphBaseView类)"></a>1. 折线图基础框架实现(FBYLineGraphBaseView类)</h4><p>折线图基础框架包括Y轴刻度标签、X轴刻度标签、与x轴平行的网格线的间距、网格线的起始点、x 轴长度、y 轴长度，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYLineGraphBaseView : UIView</span><br><span class="line"></span><br><span class="line">//Y轴刻度标签</span><br><span class="line">@property (nonatomic, strong) NSArray *yMarkTitles;</span><br><span class="line"></span><br><span class="line">//X轴刻度标签</span><br><span class="line">@property (nonatomic, strong) NSArray *xMarkTitles;</span><br><span class="line"></span><br><span class="line">// 与x轴平行的网格线的间距</span><br><span class="line">@property (nonatomic, assign) CGFloat xScaleMarkLEN;</span><br><span class="line"></span><br><span class="line">//网格线的起始点</span><br><span class="line">@property (nonatomic, assign) CGPoint startPoint;</span><br><span class="line"></span><br><span class="line">//x 轴长度</span><br><span class="line">@property (nonatomic, assign) CGFloat yAxis_L;</span><br><span class="line"></span><br><span class="line">//y 轴长度</span><br><span class="line">@property (nonatomic, assign) CGFloat xAxis_L;</span><br><span class="line"></span><br><span class="line">//绘图</span><br><span class="line">- (void)mapping;</span><br><span class="line"></span><br><span class="line">//更新做标注数据</span><br><span class="line">- (void)reloadDatas;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="2-折线图数据内容显示-FBYLineGraphContentView类"><a href="#2-折线图数据内容显示-FBYLineGraphContentView类" class="headerlink" title="2. 折线图数据内容显示(FBYLineGraphContentView类)"></a>2. 折线图数据内容显示(FBYLineGraphContentView类)</h4><p>折线图数据内容显示是继承FBYLineGraphBaseView类进行实现，其中主要包括，X轴最大值、数据内容来实现，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;FBYLineGraphBaseView.h&quot;</span><br><span class="line">@interface FBYLineGraphContentView : FBYLineGraphBaseView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSArray *valueArray;</span><br><span class="line">@property (nonatomic, assign) CGFloat maxValue;</span><br><span class="line"></span><br><span class="line">//绘图</span><br><span class="line">- (void)mapping;</span><br><span class="line"></span><br><span class="line">//更新折线图数据</span><br><span class="line">- (void)reloadDatas;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-折线图颜色控制类-FBYLineGraphColorView类"><a href="#3-折线图颜色控制类-FBYLineGraphColorView类" class="headerlink" title="3. 折线图颜色控制类(FBYLineGraphColorView类)"></a>3. 折线图颜色控制类(FBYLineGraphColorView类)</h4><p>折线图颜色控制类主要控制选中远点边框宽度和整体布局颜色，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYLineGraphColorView : UIView</span><br><span class="line"></span><br><span class="line">//颜色设置</span><br><span class="line">@property (nonatomic, assign) CGFloat borderWidth;</span><br><span class="line">@property (nonatomic, assign) UIColor *borderColor;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCenter:(CGPoint)center radius:(CGFloat)radius;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4 id="3-折线图核心代码类-FBYLineGraphView类"><a href="#3-折线图核心代码类-FBYLineGraphView类" class="headerlink" title="3. 折线图核心代码类(FBYLineGraphView类)"></a>3. 折线图核心代码类(FBYLineGraphView类)</h4><p>折线图核心代码类主要给引用类提供配置接口和数据接口，其中包括表名、Y轴刻度标签title、Y轴最大值、X轴刻度标签的长度（单位长度）、设置折线图显示的数据和对应X坐标轴刻度标签，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FBYLineGraphView : UIView</span><br><span class="line"></span><br><span class="line">//表名</span><br><span class="line">@property (nonatomic, strong) NSString *title;</span><br><span class="line"></span><br><span class="line">//Y轴刻度标签title</span><br><span class="line">@property (nonatomic, strong) NSArray *yMarkTitles;</span><br><span class="line"></span><br><span class="line">//Y轴最大值</span><br><span class="line">@property (nonatomic, assign) CGFloat maxValue;</span><br><span class="line"></span><br><span class="line">//X轴刻度标签的长度（单位长度）</span><br><span class="line">@property (nonatomic, assign) CGFloat xScaleMarkLEN;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  设置折线图显示的数据和对应X坐标轴刻度标签</span><br><span class="line"> *</span><br><span class="line"> *  @param xMarkTitlesAndValues 折线图显示的数据和X坐标轴刻度标签</span><br><span class="line"> *  @param titleKey             标签（如:9月1日）</span><br><span class="line"> *  @param valueKey             数据 (如:80)</span><br><span class="line"> */</span><br><span class="line">- (void)setXMarkTitlesAndValues:(NSArray *)xMarkTitlesAndValues titleKey:(NSString *)titleKey valueKey:(NSString *)valueKey;</span><br><span class="line"></span><br><span class="line">- (void)mapping;</span><br><span class="line">- (void)reloadDatas;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="四：如何在项目中使用"><a href="#四：如何在项目中使用" class="headerlink" title="四：如何在项目中使用"></a>四：如何在项目中使用</h2><h4 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h4><p>在demo中找到FBYLineGraph文件夹，将文件夹拖入自己的项目中。DEMO截图</p><p><img src="http://upload-images.jianshu.io/upload_images/2829694-ac73ffe325cbacb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B0375CE3-F420-4E36-842F-6491EA0047F9.png"></p><h4 id="2-代码引用"><a href="#2-代码引用" class="headerlink" title="2. 代码引用"></a>2. 代码引用</h4><p>2.1 首先在项目中需要使用的页面引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FBYLineGraphView.h&quot;</span><br></pre></td></tr></table></figure><p>2.2 初始化折线图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FBYLineGraphView *LineGraphView = [[FBYLineGraphView alloc] initWithFrame:CGRectMake(10, 100, SCREEN_WIDTH - 20, 220)];</span><br></pre></td></tr></table></figure><p>2.3 设置折线图属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LineGraphView.title = @&quot;折线统计图&quot;; // 折线图名称</span><br><span class="line">LineGraphView.maxValue = 100;   // 最大值</span><br><span class="line">LineGraphView.xScaleMarkLEN = 60; // 每格的宽度如果不设置，系统默认平均分配</span><br></pre></td></tr></table></figure><p>2.4 给折线图添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LineGraphView.yMarkTitles = @[@&quot;0&quot;,@&quot;20&quot;,@&quot;40&quot;,@&quot;60&quot;,@&quot;80&quot;,@&quot;100&quot;]; // Y轴刻度标签</span><br><span class="line"></span><br><span class="line">[LineGraphView setXMarkTitlesAndValues:@[@&#123;@&quot;item&quot;:@&quot;1月1日&quot;,@&quot;count&quot;:@10&#125;,@&#123;@&quot;item&quot;:@&quot;1月2日&quot;,@&quot;count&quot;:@80&#125;,@&#123;@&quot;item&quot;:@&quot;1月3日&quot;,@&quot;count&quot;:@68&#125;,@&#123;@&quot;item&quot;:@&quot;1月4日&quot;,@&quot;count&quot;:@100&#125;,@&#123;@&quot;item&quot;:@&quot;1月5日&quot;,@&quot;count&quot;:@60&#125;,@&#123;@&quot;item&quot;:@&quot;1月6日&quot;,@&quot;count&quot;:@56&#125;,@&#123;@&quot;item&quot;:@&quot;1月7日&quot;,@&quot;count&quot;:@11&#125;] titleKey:@&quot;item&quot; valueKey:@&quot;count&quot;]; // X轴刻度标签及相应的值</span><br></pre></td></tr></table></figure><p>可以根据自己项目获取的数据进行修改，不过数据格式不要改动。</p><p>2.5 设置完数据和属性，绘制展示折线图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//设置完数据等属性后绘图折线图</span><br><span class="line">[LineGraphView mapping];</span><br><span class="line">[self.view addSubview:LineGraphView];</span><br></pre></td></tr></table></figure><p>设置完上面的，一个高颜值原生折线统计图就可以使用了。<br>如果好用就请点赞关注，会不定期更新更多干货。更多源码可以去GitHub下载。</p><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;在项目中遇到数据展示需求时，往往会通过，以列表的形式展示出数据或者以表格的形式展示。但是并不能直观的观察数据的变化，如果通过图表的形式来展示，就可以更快捷的获取到数据变化情况。&lt;/p&gt;
&lt;p&gt;图表展示的方式大致分为折线图、柱状图、饼状图等等，那么如何码出一个高颜值原生折线图呢？&lt;a href=&quot;https://github.com/fanbaoying/FBYDataDisplay-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo源码&lt;/a&gt;已经放在GitHub上，下面来介绍一下如何使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>FMDB | 实现数据的增删改查</title>
    <link href="https://fanbaoying.github.io/FMDB-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <id>https://fanbaoying.github.io/FMDB-实现数据的增删改查/</id>
    <published>2018-01-30T06:50:04.000Z</published>
    <updated>2018-01-31T06:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>是一个轻量级的数据库，用于将网络资源存储在本地。<br>项目中使用 ARC 还是 MRC，对使用 FMDB 都没有任何影响，FMDB 会在编译项目时自动匹配。<br>FMDB 将 SQLite API 进行了很友好的封装，使用起来非常方便。</p><p>下面是对FMDB的使用总结，分享给大家，另外附一份<a href="https://github.com/fanbaoying/FBYFMDBDemo" target="_blank" rel="noopener">demo</a>供大家参考。</p><a id="more"></a><h2 id="二：FMDB优点"><a href="#二：FMDB优点" class="headerlink" title="二：FMDB优点"></a>二：FMDB优点</h2><ul><li><p>1.使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</p></li><li><p>2.对比苹果自带的Core Data框架，更加轻量级和灵活</p></li><li><p>3.提供了多线程安全的数据库操作方法，有效地防止数据混乱</p></li></ul><h2 id="三：将FMDB第三方库引入到项目"><a href="#三：将FMDB第三方库引入到项目" class="headerlink" title="三：将FMDB第三方库引入到项目"></a>三：将FMDB第三方库引入到项目</h2><p>下载<a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a>库文件，demo中是直接导入项目中，可直接下载demo引用库文件，也可以使用CocoaPods导入。</p><blockquote><p>注意：需要 libsqlite3.dylib 依赖（具体流程 Project-&gt;TARGETS-&gt;Build Phases-&gt;Link Binary With Libraries,然后点击＋号引用该动态库）</p></blockquote><h2 id="四：FMDB主要的核心类"><a href="#四：FMDB主要的核心类" class="headerlink" title="四：FMDB主要的核心类"></a>四：FMDB主要的核心类</h2><h4 id="4-1-FMDatabase"><a href="#4-1-FMDatabase" class="headerlink" title="4.1 FMDatabase"></a>4.1 FMDatabase</h4><p>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1.获得数据库文件的路径</span><br><span class="line">NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line">self.dbPath = fileName;</span><br><span class="line">//2.获得数据库</span><br><span class="line">FMDatabase *db=[FMDatabase databaseWithPath:self.dbPath];</span><br></pre></td></tr></table></figure><h4 id="4-2-FMResultSet"><a href="#4-2-FMResultSet" class="headerlink" title="4.2 FMResultSet"></a>4.2 FMResultSet</h4><p>使用FMResultSet执行查询后的结果集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.执行查询语句</span><br><span class="line">FMResultSet *resultSet = [self.db executeQuery:@&quot;SELECT * FROM t_userData&quot;];</span><br><span class="line"></span><br><span class="line">// 2.遍历结果</span><br><span class="line">while ([resultSet next]) &#123;</span><br><span class="line"></span><br><span class="line">    NSString *nameStr = [resultSet stringForColumn:@&quot;userName&quot;];</span><br><span class="line">    [self.nameArr addObject:nameStr];</span><br><span class="line"></span><br><span class="line">    NSString *ageStr = [resultSet stringForColumn:@&quot;userAge&quot;];</span><br><span class="line">    [self.ageArr addObject:ageStr];</span><br><span class="line"></span><br><span class="line">    NSString *idStr = [resultSet stringForColumn:@&quot;id&quot;];</span><br><span class="line">    [self.idArr addObject:idStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-FMDatabaseQueue"><a href="#4-3-FMDatabaseQueue" class="headerlink" title="4.3 FMDatabaseQueue"></a>4.3 FMDatabaseQueue</h4><p>FMDatabaseQueue是在多线程下查询和更新数据库用到的类</p><h2 id="五：使用FMDB进行增删改查"><a href="#五：使用FMDB进行增删改查" class="headerlink" title="五：使用FMDB进行增删改查"></a>五：使用FMDB进行增删改查</h2><p>通常对数据库的操作，我们一般称为CURD,即对表进行创建(Create)、更新(Update)、读取(Read)和删除(Delete)操作。</p><h4 id="5-1-数据类型分析"><a href="#5-1-数据类型分析" class="headerlink" title="5.1 数据类型分析"></a>5.1 数据类型分析</h4><p>对数据库中存储的每一个值都有一个类型</p><ul><li>NULL 这个值为空值</li><li>INTEGER 值被标识为整数，依据值的大小可以依次被存储1～8个字节</li><li>REAL 所有值都是浮动的数值</li><li>TEXT 值为文本字符串</li><li>BLOB 值为blob数据</li></ul><h4 id="5-2-FMDB库文件使用"><a href="#5-2-FMDB库文件使用" class="headerlink" title="5.2 FMDB库文件使用"></a>5.2 FMDB库文件使用</h4><p>1.引入头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FMDB.h&quot;</span><br></pre></td></tr></table></figure><p>2.定义属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface viewController ()</span><br><span class="line">@property(nonatomic,strong)FMDatabase *db;</span><br><span class="line"></span><br><span class="line">@property(strong,nonatomic)NSString * dbPath;</span><br><span class="line"></span><br><span class="line">@property(strong,nonatomic)UITextField *nameTxteField;</span><br><span class="line">@property(strong,nonatomic)UITextField *ageTxteField;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>3.获取数据库文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获得数据库文件的路径</span><br><span class="line">NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line">self.dbPath = fileName;</span><br></pre></td></tr></table></figure><p>4.建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//2.获得数据库</span><br><span class="line">FMDatabase *db=[FMDatabase databaseWithPath:self.dbPath];</span><br><span class="line">//3.打开数据库</span><br><span class="line">if ([db open]) &#123;</span><br><span class="line">    //4.创表</span><br><span class="line">    BOOL result=[db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_userData (id integer PRIMARY KEY AUTOINCREMENT, userName text NOT NULL, userAge text NOT NULL);&quot;];</span><br><span class="line">    if (result)&#123;</span><br><span class="line">        NSLog(@&quot;创表成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;创表失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">self.db=db;</span><br><span class="line"></span><br><span class="line">[self insert];</span><br></pre></td></tr></table></figure><h4 id="5-3-新增数据"><a href="#5-3-新增数据" class="headerlink" title="5.3 新增数据"></a>5.3 新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//新增数据</span><br><span class="line">-(void)insert&#123;</span><br><span class="line">    BOOL res = [self.db executeUpdate:@&quot;INSERT INTO t_userData (userName, userAge) VALUES (?, ?);&quot;, _nameTxteField.text, _ageTxteField.text];</span><br><span class="line"></span><br><span class="line">    if (!res) &#123;</span><br><span class="line">        NSLog(@&quot;增加数据失败&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;增加数据成功&quot;);</span><br><span class="line"></span><br><span class="line">        UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;新增数据成功&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">        [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">        [self performSelector:@selector(dismiss:) withObject:alert afterDelay:0.5];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-16c71ca322a2b65f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="81.png"></p><h4 id="5-4-删除数据"><a href="#5-4-删除数据" class="headerlink" title="5.4 删除数据"></a>5.4 删除数据</h4><p>删除数据分为删除一条数据和删除整表数据</p><ol><li>删除一条数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 删除一条数据</span><br><span class="line">- (void)deleteData:(NSInteger)userid&#123;</span><br><span class="line">    //1.获得数据库文件的路径</span><br><span class="line">    NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line"></span><br><span class="line">    //2.获得数据库</span><br><span class="line">    FMDatabase *db = [FMDatabase databaseWithPath:fileName];</span><br><span class="line">    if ([db open]) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *str = [NSString stringWithFormat:@&quot;DELETE FROM t_userData WHERE id = %ld&quot;,userid];</span><br><span class="line">        BOOL res = [db executeUpdate:str];</span><br><span class="line">        if (!res) &#123;</span><br><span class="line">            NSLog(@&quot;数据删除失败&quot;);</span><br><span class="line">            [self lookData];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;数据删除成功&quot;);</span><br><span class="line">            [self lookData];</span><br><span class="line">        &#125;</span><br><span class="line">        [db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.删除整表数据</p><p>删除整表数据只需要将删除一条数据的语句更换为如下语句即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;DELETE FROM t_userData&quot;;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-69882fd7bdce9017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="84.png"></p><h4 id="5-5-修改数据"><a href="#5-5-修改数据" class="headerlink" title="5.5 修改数据"></a>5.5 修改数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 更新数据</span><br><span class="line">- (void)updateData &#123;</span><br><span class="line">    //获得数据库文件的路径</span><br><span class="line">    NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line">    self.dbPath = fileName;</span><br><span class="line"></span><br><span class="line">    FMDatabase *db = [FMDatabase databaseWithPath:self.dbPath];</span><br><span class="line">    if ([db open]) &#123;</span><br><span class="line">        NSString *sql = @&quot;UPDATE t_userData SET userName = ? , userAge = ? WHERE id = ?&quot;;</span><br><span class="line">        BOOL res = [db executeUpdate:sql,_nameTxteField.text,_ageTxteField.text,_userId];</span><br><span class="line">        if (!res) &#123;</span><br><span class="line">            NSLog(@&quot;数据修改失败&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;数据修改成功&quot;);</span><br><span class="line"></span><br><span class="line">            UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;数据修改成功&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">            [self presentViewController:alert animated:YES completion:nil];</span><br><span class="line">            [self performSelector:@selector(dismiss:) withObject:alert afterDelay:1.0];</span><br><span class="line">        &#125;</span><br><span class="line">        [db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-a7fb5e676e437a20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="82.png"></p><h4 id="5-6-查询数据"><a href="#5-6-查询数据" class="headerlink" title="5.6 查询数据"></a>5.6 查询数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//查询数据</span><br><span class="line">- (void)lookData &#123;</span><br><span class="line"></span><br><span class="line">    //1.获得数据库文件的路径</span><br><span class="line">    NSString *doc=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *fileName=[doc stringByAppendingPathComponent:@&quot;userData.sqlite&quot;];</span><br><span class="line"></span><br><span class="line">    //2.获得数据库</span><br><span class="line">    FMDatabase *db=[FMDatabase databaseWithPath:fileName];</span><br><span class="line"></span><br><span class="line">    //3.打开数据库</span><br><span class="line">    if ([db open]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    self.db=db;</span><br><span class="line"></span><br><span class="line">    // 1.执行查询语句</span><br><span class="line">    FMResultSet *resultSet = [self.db executeQuery:@&quot;SELECT * FROM t_userData&quot;];</span><br><span class="line"></span><br><span class="line">    // 2.遍历结果</span><br><span class="line">    while ([resultSet next]) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *nameStr = [resultSet stringForColumn:@&quot;userName&quot;];</span><br><span class="line">        [self.nameArr addObject:nameStr];</span><br><span class="line">        NSString *ageStr = [resultSet stringForColumn:@&quot;userAge&quot;];</span><br><span class="line">        [self.ageArr addObject:ageStr];</span><br><span class="line">        NSString *idStr = [resultSet stringForColumn:@&quot;id&quot;];</span><br><span class="line">        [self.idArr addObject:idStr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.myTableView reloadData];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2829694-7120f1885f2c7aa8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="83.png"></p><blockquote><p>希望可以帮助大家，如有问题可加QQ技术交流群: 668562416</p><p>如果哪里有什么不对或者不足的地方，还望读者多多提意见或建议</p><p>如需转载请联系我，经过授权方可转载，谢谢</p></blockquote><h2 id="公众号：网罗开发"><a href="#公众号：网罗开发" class="headerlink" title="公众号：网罗开发"></a>公众号：网罗开发</h2><p><img src="http://upload-images.jianshu.io/upload_images/2829694-48307b4d71bc5800.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：介绍&quot;&gt;&lt;a href=&quot;#一：介绍&quot; class=&quot;headerlink&quot; title=&quot;一：介绍&quot;&gt;&lt;/a&gt;一：介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FMDB&lt;/a&gt;是一个轻量级的数据库，用于将网络资源存储在本地。&lt;br&gt;项目中使用 ARC 还是 MRC，对使用 FMDB 都没有任何影响，FMDB 会在编译项目时自动匹配。&lt;br&gt;FMDB 将 SQLite API 进行了很友好的封装，使用起来非常方便。&lt;/p&gt;
&lt;p&gt;下面是对FMDB的使用总结，分享给大家，另外附一份&lt;a href=&quot;https://github.com/fanbaoying/FBYFMDBDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;供大家参考。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
