<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swift社区</title>
  
  <subtitle>做最好的 Swift 社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fanbaoying.github.io/"/>
  <updated>2022-03-24T02:37:42.291Z</updated>
  <id>https://fanbaoying.github.io/</id>
  
  <author>
    <name>Swift社区</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode - 20 有效的括号</title>
    <link href="https://fanbaoying.github.io/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>https://fanbaoying.github.io/LeetCode-20-有效的括号/</id>
    <published>2022-03-24T02:36:23.000Z</published>
    <updated>2022-03-24T02:37:42.291Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 19 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://upload-images.jianshu.io/upload_images/2829694-bb33acfd8ecc9401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsPhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(<span class="number">_</span> digits: String)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> digits.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">String</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> combinations = [<span class="type">String</span>](), combination = <span class="string">""</span></span><br><span class="line">        <span class="keyword">let</span> numberToStr = [<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]</span><br><span class="line">        </span><br><span class="line">        dfs(&amp;combinations, &amp;combination, numberToStr, digits, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> combinations</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> combinations: <span class="keyword">inout</span> [String], <span class="number">_</span> combination: <span class="keyword">inout</span> String, <span class="number">_</span> numberToStr: [String], <span class="number">_</span> digits: String, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> combination.<span class="built_in">count</span> == digits.<span class="built_in">count</span> &#123;</span><br><span class="line">            combinations.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentStr = fetchCurrentStr(from: digits, at: index, numberToStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> currentStr &#123;</span><br><span class="line">            combination.append(char)</span><br><span class="line">            dfs(&amp;combinations, &amp;combination, numberToStr, digits, index + <span class="number">1</span>)</span><br><span class="line">            combination.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchCurrentStr</span><span class="params">(from digits: String, at index: Int, <span class="number">_</span> numberToStr: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; digits.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid index"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentDigitChar = digits[digits.index(digits.startIndex, offsetBy: index)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> currentDigit = <span class="type">Int</span>(<span class="type">String</span>(currentDigitChar)), currentDigit &gt;= <span class="number">0</span>, currentDigit &lt; numberToStr.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid digits"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numberToStr[currentDigit]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索，首先创建电话板</li><li>时间复杂度： O(4^n)， n 表示数字长度</li><li>空间复杂度： O(n)， n 表示数字长度</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 19 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode - 19 删除链表的倒数第 N 个结点</title>
    <link href="https://fanbaoying.github.io/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://fanbaoying.github.io/LeetCode-19-删除链表的倒数第-N-个结点/</id>
    <published>2022-03-24T02:36:10.000Z</published>
    <updated>2022-03-24T02:37:48.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 18 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveNthFromEnd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(<span class="number">_</span> head: ListNode?, <span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> dummy = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        <span class="keyword">var</span> prev: <span class="type">ListNode</span>? = dummy</span><br><span class="line">        <span class="keyword">var</span> post: <span class="type">ListNode</span>? = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move post</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">            post = post!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move prev and post at the same time</span></span><br><span class="line">        <span class="keyword">while</span> post!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">            prev = prev!.next</span><br><span class="line">            post = post!.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prev!.next = prev!.next!.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：运动员技术</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 18 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode - 18 四数之和</title>
    <link href="https://fanbaoying.github.io/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://fanbaoying.github.io/LeetCode-18-四数之和/</id>
    <published>2022-03-24T02:35:56.000Z</published>
    <updated>2022-03-24T02:37:55.066Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 17 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code>（若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 互不相同</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted(by: &lt;)</span><br><span class="line">        <span class="keyword">var</span> threeSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> twoSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt;= <span class="number">4</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            threeSum = target - nums[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> j == i + <span class="number">1</span> || nums[j] != nums[j - <span class="number">1</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                twoSum = threeSum - nums[j]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">left</span> = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] == twoSum &#123;</span><br><span class="line">                        res.append([nums[i], nums[j], nums[<span class="keyword">left</span>], nums[<span class="keyword">right</span>]])</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">repeat</span> &#123;</span><br><span class="line">                                <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] &lt; twoSum &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对数组进行排序并遍历，根据它们的和大于或小于等于目标，向左递增或向右递减</li><li>时间复杂度： O(n^3)</li><li>空间复杂度： O(nC4)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/4sum" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 17 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode - 17 电话号码的字母组合</title>
    <link href="https://fanbaoying.github.io/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://fanbaoying.github.io/LeetCode-17-电话号码的字母组合/</id>
    <published>2022-03-24T02:35:41.000Z</published>
    <updated>2022-03-24T02:38:01.430Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 16 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://images.xiaozhuanlan.com/photo/2022/21d738a264fa4c03aea3249c52eefcb9.image" alt=""></p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字</li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsPhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(<span class="number">_</span> digits: String)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> digits.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">String</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> combinations = [<span class="type">String</span>](), combination = <span class="string">""</span></span><br><span class="line">        <span class="keyword">let</span> numberToStr = [<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]</span><br><span class="line">        </span><br><span class="line">        dfs(&amp;combinations, &amp;combination, numberToStr, digits, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> combinations</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> combinations: <span class="keyword">inout</span> [String], <span class="number">_</span> combination: <span class="keyword">inout</span> String, <span class="number">_</span> numberToStr: [String], <span class="number">_</span> digits: String, <span class="number">_</span> index: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> combination.<span class="built_in">count</span> == digits.<span class="built_in">count</span> &#123;</span><br><span class="line">            combinations.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentStr = fetchCurrentStr(from: digits, at: index, numberToStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> currentStr &#123;</span><br><span class="line">            combination.append(char)</span><br><span class="line">            dfs(&amp;combinations, &amp;combination, numberToStr, digits, index + <span class="number">1</span>)</span><br><span class="line">            combination.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchCurrentStr</span><span class="params">(from digits: String, at index: Int, <span class="number">_</span> numberToStr: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; digits.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid index"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> currentDigitChar = digits[digits.index(digits.startIndex, offsetBy: index)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> currentDigit = <span class="type">Int</span>(<span class="type">String</span>(currentDigitChar)), currentDigit &gt;= <span class="number">0</span>, currentDigit &lt; numberToStr.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Invalid digits"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> numberToStr[currentDigit]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典的深度优先搜索，首先创建电话板</li><li>时间复杂度： O(4^n)， n 表示数字长度</li><li>空间复杂度： O(n)， n 表示数字长度</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 16 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode - 16 最接近的三数之和</title>
    <link href="https://fanbaoying.github.io/LeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://fanbaoying.github.io/LeetCode-16-最接近的三数之和/</id>
    <published>2022-03-24T02:33:38.000Z</published>
    <updated>2022-03-24T02:34:51.786Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 15 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0], target = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 1000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSumClosest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">threeSumClosest</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> minDiff = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted()</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">let</span> twoSum = target - nums[i]</span><br><span class="line">                <span class="keyword">var</span> <span class="keyword">left</span> = i + <span class="number">1</span></span><br><span class="line">                <span class="keyword">var</span> <span class="keyword">right</span> = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> diff = nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>] - twoSum</span><br><span class="line">        </span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(diff) &lt; <span class="built_in">abs</span>(minDiff) &#123;</span><br><span class="line">                        minDiff = diff</span><br><span class="line">                    &#125;</span><br><span class="line">        </span><br><span class="line">                    <span class="keyword">if</span> diff == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> target</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> diff &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> + <span class="number">1</span>]</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                            <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">                        &#125; <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> - <span class="number">1</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> target + minDiff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对数组进行排序，并在更新 diff 时对其进行迭代，根据它们的和大于或小于目标而向左递增或向右递减</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(nC3)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/3sum-closest" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（**Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 15 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode - 15 三数之和（Top 100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88Top-100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-15-三数之和（Top-100）/</id>
    <published>2022-03-24T02:33:16.000Z</published>
    <updated>2022-03-24T02:34:24.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 14 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt;= <span class="number">3</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nums = nums.sorted()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;nums.<span class="built_in">count</span> - <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> firstNum = nums[i], remainingSum = -firstNum</span><br><span class="line">            <span class="keyword">var</span> m = i + <span class="number">1</span>, n = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> m &lt; n &#123;</span><br><span class="line">                <span class="keyword">if</span> nums[m] + nums[n] == remainingSum &#123;</span><br><span class="line">                    res.append([firstNum, nums[m], nums[n]])</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">repeat</span> &#123;</span><br><span class="line">                        m += <span class="number">1</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> nums[m] == nums[m - <span class="number">1</span>] &amp;&amp; m &lt; n</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">repeat</span> &#123;</span><br><span class="line">                        n -= <span class="number">1</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> nums[n] == nums[n + <span class="number">1</span>] &amp;&amp; m &lt; n</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[m] + nums[n] &lt; remainingSum &#123;</span><br><span class="line">                    m += <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n -= <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：对数组进行排序并遍历，根据它们的和大于或不大于目标，向左递增或向右递减</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(nC3)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/3sum" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2829694-8d80389416deefc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 14 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode - 14 最长公共前缀</title>
    <link href="https://fanbaoying.github.io/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>https://fanbaoying.github.io/LeetCode-14-最长公共前缀/</id>
    <published>2022-03-11T03:43:13.000Z</published>
    <updated>2022-03-11T03:46:01.330Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 13 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestCommonPrefix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="number">_</span> strs: [String])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> firstStr = strs.first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> res = <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i, char) <span class="keyword">in</span> firstStr.enumerated() &#123;</span><br><span class="line">            <span class="comment">// dropFirst(_ k: Int = 1) returns a Substring struct</span></span><br><span class="line">            <span class="keyword">for</span> str <span class="keyword">in</span> strs.<span class="built_in">dropFirst</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> i == str.<span class="built_in">count</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Another easy way: Array(str)[i], time complexity is linear though</span></span><br><span class="line">                <span class="keyword">let</span> currentStrChar = str[str.index(str.startIndex, offsetBy: i)]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> char != currentStrChar &#123;</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(char)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：首先使用第一个字符串作为结果，在迭代数组时修改</li><li>时间复杂度： O(nm)</li><li>空间复杂度： O(m)</li></ul><blockquote><p> <code>m</code> 为最长前缀长度</p></blockquote><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/longest-common-prefix/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 13 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 13  罗马数字转整数</title>
    <link href="https://fanbaoying.github.io/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://fanbaoying.github.io/LeetCode-13-罗马数字转整数/</id>
    <published>2022-03-11T03:43:00.000Z</published>
    <updated>2022-03-11T03:45:17.026Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 12 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr><tr><td>I</td><td>1 </td></tr><tr><td>V</td><td>5 </td></tr><tr><td>X</td><td>10 </td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500 </td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li><li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况</li><li><code>IL</code> 和 <code>IM</code> 这样的例子并不符合题目要求，<code>49</code> 应该写作 <code>XLIX</code>，<code>999</code> 应该写作 <code>CMXCIX</code> </li><li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article" title="罗马数字 - Mathematics" target="_blank" rel="noopener">罗马数字 - Mathematics</a></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomanToInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dict = initDict()</span><br><span class="line">        <span class="keyword">let</span> chars = [<span class="type">Character</span>](s.characters.<span class="built_in">reverse</span>())</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;chars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> current = dict[<span class="type">String</span>(chars[i])] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; current &lt; dict[<span class="type">String</span>(chars[i - <span class="number">1</span>])] &#123;</span><br><span class="line">                res -= current</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += current</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">initDict</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>: <span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">String</span>: <span class="type">Int</span>]()</span><br><span class="line">        </span><br><span class="line">        dict[<span class="string">"I"</span>] = <span class="number">1</span></span><br><span class="line">        dict[<span class="string">"V"</span>] = <span class="number">5</span></span><br><span class="line">        dict[<span class="string">"X"</span>] = <span class="number">10</span></span><br><span class="line">        dict[<span class="string">"L"</span>] = <span class="number">50</span></span><br><span class="line">        dict[<span class="string">"C"</span>] = <span class="number">100</span></span><br><span class="line">        dict[<span class="string">"D"</span>] = <span class="number">500</span></span><br><span class="line">        dict[<span class="string">"M"</span>] = <span class="number">1000</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dict</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：从头到尾进行迭代，根据不同情况进行添加或减去</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(n)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/roman-to-integer/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 12 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 12 整数转罗马数字</title>
    <link href="https://fanbaoying.github.io/LeetCode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>https://fanbaoying.github.io/LeetCode-12-整数转罗马数字/</id>
    <published>2022-03-11T03:42:47.000Z</published>
    <updated>2022-03-11T03:44:42.067Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 11 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr><tr><td>I</td><td>1 </td></tr><tr><td>V</td><td>5 </td></tr><tr><td>X</td><td>10 </td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500 </td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= num &lt;= 3999</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerToRoman</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(<span class="number">_</span> num: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> num &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nums = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> symbols = [<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>]</span><br><span class="line">        <span class="keyword">var</span> res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">var</span> digit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> number = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> current = number / nums[digit]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;current &#123;</span><br><span class="line">                res += symbols[digit]</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            number -= current * nums[digit]</span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alternate solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerToRomanWithDictionaries</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(<span class="number">_</span> num: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> num &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="string">""</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> thousands = [<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>]</span><br><span class="line">        <span class="keyword">let</span> hundreds = [<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>]</span><br><span class="line">        <span class="keyword">let</span> tens = [<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>]</span><br><span class="line">        <span class="keyword">let</span> ones = [<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> thousands[num / <span class="number">1000</span>] + hundreds[num % <span class="number">1000</span> / <span class="number">100</span>] + tens[num % <span class="number">100</span> / <span class="number">10</span>] + ones[num % <span class="number">10</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：符号由大到小相加，同时减去相对数</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/integer-to-roman" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 11 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 11 盛最多水的容器（前100）</title>
    <link href="https://fanbaoying.github.io/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E5%89%8D100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode-11-盛最多水的容器（前100）/</id>
    <published>2022-03-11T03:42:31.000Z</published>
    <updated>2022-03-11T03:44:08.132Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定 <code>n</code> 个非负整数 <code>a1, a2, ..., an</code> ，其中每个代表坐标 <code>(i, ai)</code> 处的一个点。 绘制 <code>n</code> 条垂直线，使得线 <code>i</code> 的两个端点位于 <code>(i, ai)</code> 和 <code>(i, 0)</code>。 找出两条线，它们与 <code>x</code> 轴一起形成一个容器，这样容器中的水最多。</p><p><strong>注意</strong>：不能倾斜容器。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2aee331defa4c29b9965d7b876b42a7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：  height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：  49</span><br><span class="line">说明：  上述垂直线由数组 [1,8,6,2,5,4,8,3,7] 表示。 在这种情况下，容器可以容纳的最大水面积（蓝色部分）为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：  height = [1,1]</span><br><span class="line">输出：  1</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： height = [4,3,2,1,4]</span><br><span class="line">输出： 16</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： height = [1,2,1]</span><br><span class="line">输出： 2</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li>n == height.length</li><li>2 &lt;= n &lt;= 10^5</li><li>0 &lt;= height[i] &lt;= 10^4</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerMostWater</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(<span class="number">_</span> height: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> maxRes = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">right</span> = height.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">left</span> &lt; <span class="keyword">right</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> minHeight = <span class="built_in">min</span>(height[<span class="keyword">left</span>], height[<span class="keyword">right</span>])</span><br><span class="line">        </span><br><span class="line">            maxRes = <span class="built_in">max</span>(maxRes, (<span class="keyword">right</span> - <span class="keyword">left</span>) * minHeight)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> minHeight == height[<span class="keyword">left</span>] &#123;</span><br><span class="line">                <span class="keyword">left</span> += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">right</span> -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxRes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：首先给定最大宽度，然后在宽度减小的同时，向高度增加方向前进。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/container-with-most-water/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>[译]解决 iOS 15 上 APP 莫名其妙地退出登录</title>
    <link href="https://fanbaoying.github.io/%E8%AF%91-%E8%A7%A3%E5%86%B3-iOS-15-%E4%B8%8A-APP-%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95-1/"/>
    <id>https://fanbaoying.github.io/译-解决-iOS-15-上-APP-莫名其妙地退出登录-1/</id>
    <published>2022-03-10T06:13:32.000Z</published>
    <updated>2022-03-10T06:18:34.233Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png" alt=""></p><p>在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：在打开我们的应用程序(Cookpad) 时他们被莫名其妙的反复退出到登录页。非常令人惊讶的是，这并不是我们在测试 iOS 15 beta 版的时候发现的问题。</p><p>如果你是来找修复方法的，那就直接向下滚动到结论，但如果你想了解更多关于我们如何调试这个特定问题，那就开始吧。</p><h2 id="复现反馈的问题"><a href="#复现反馈的问题" class="headerlink" title="复现反馈的问题"></a>复现反馈的问题</h2><p>用户报告中的具体信息有限，我们唯一知道的是：从 iOS 15 开始，用户打开程序后会发现自己已经退出登录。</p><p>我们没有视频，也没有具体的步骤来重现这个问题，所以我努力尝试以各种方式启动应用程序，希望能亲眼看到它。我试着重新安装应用程序，我试着在有网络连接和没有网络连接的情况下启动，我试着强制退出，经过30分钟的努力，我放弃了，我开始回复用户说我没找到具体问题。</p><p>直到我再次解锁手机，没有做任何操作，就启动了 Cookpad，我发现APP就像我们的用户所反馈的那样，直接退出到了登录界面!</p><p>在那之后，我无法准确的复现该问题，但似乎与暂停使用手机一段时间后再次使用它有关。</p><h2 id="缩小问题范围"><a href="#缩小问题范围" class="headerlink" title="缩小问题范围"></a>缩小问题范围</h2><p>我担心从 Xcode 重新安装应用程序可能会影响问题的复现，所以在这样做之前，是时候查看代码并试图缩小问题的范围。根据我们的实现，我想出了三个潜在的原因。</p><ul><li>1、<code>UserDefaults</code> 中的数据被清除。</li><li>2、一个意外的API调用返回HTTP 401并触发退出登录。</li><li>3、<code>Keychain</code> 抛出了一个错误。</li></ul><p>我能够排除前两个潜在的原因，这要归功于我在自己重现该问题后观察到的一些微妙行为。</p><ul><li>登录界面没有要求我选择地区——这表明<code>UserDefaults</code>中的数据没有问题，因为我们的 “已显示地区选择 “偏好设置仍然生效。</li><li>主用户界面没有显示，即使是短暂的也没有——这表明没有尝试进行网络请求，所以 API 是问题原因可能还为时过早。</li></ul><p>这就把<code>Keychain</code>留给了我们，指引我进入下一个问题。是什么发生了改变以及为什么它如此难以复现？</p><h2 id="是什么发生了改变以及为什么它如此难以复现？"><a href="#是什么发生了改变以及为什么它如此难以复现？" class="headerlink" title="是什么发生了改变以及为什么它如此难以复现？"></a>是什么发生了改变以及为什么它如此难以复现？</h2><p>我粗略地看了一下发布说明，在谷歌上快速搜索了一下，我找不到任何东西，所以我不得不继续挖掘以更好地了解这个问题。</p><p>对<code>Keychain</code>数据的访问是通过 <a href="https://developer.apple.com/documentation/security" target="_blank" rel="noopener"><em>Security</em></a> 框架提供的，这是一个众所周知的棘手的问题。虽然有很多第三方库来包装这个框架以使事情变得更容易，但我们还是基于一些苹果的示例代码来维护我们自己的简单封装。</p><p>看一下这段代码，我们调用 <a href="https://developer.apple.com/documentation/security/1398306-secitemcopymatching?language=objc" target="_blank" rel="noopener"><em>SecItemCopyMatching</em></a> 方法来加载我们的访问令牌，它返回数据以及描述结果的 <a href="https://osstatus.com/" target="_blank" rel="noopener"><em>OSStatus</em></a> 代码。然而，不幸的是，虽然我们的封装器会将不成功的结果与状态代码一起抛出，用于调试，但我们在下一层中却抛弃了这些信息，只是将错误视为 <code>nil</code>。</p><p>我们实行了每周一次的发布计划，多亏了大量的自动化。此时，我们即将发布的下一个截止点（代码冻结）是在第二天。因为我们还没有完全了解这个问题有多普遍，而且我们也不确定是否能够在代码冻结前发布一个修复程序，所以我利用这个机会通过使用Crashlytics(崩溃日志记录工具) 增加一些额外的非致命性日志来解决缺乏可观察性的问题。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/64e699daa0417f6a10ae4e9fa861008b.png" alt="虽然我们无法改变加载会话的行为，但我们能够开始记录错误并更好地记录我们实现的当前行为。"></p><p>这个结果给了我们一些很好的观察点，然后我们可以在接下来的几周内观察。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/8af9cb1ce53fdb1ab4cda921451c34cc.png" alt="在10.58.0和10.59.0版本中，受影响的用户数量慢慢减少，这是由于我们在努力确定根本原因时引入了一项缓解措施，该措施在10.60.0中得到了修复。"></p><p>此时，我能够捕捉到返回的确切错误代码。罪魁祸首是<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>：</p><blockquote><p>不允许与 <em>Security Server</em> 交互。</p></blockquote><p>这个错误告诉我们，我们正试图在数据不可用的时间点上从<code>Keychain</code>中读取数据。这通常会发生在你试图读取已存储的数据，并将其可访问性设置为<a href="https://developer.apple.com/documentation/security/ksecattraccessiblewhenunlocked" target="_blank" rel="noopener"><em>kSecAttrAccessibleWhenUnlocked</em></a>，而设备仍处于锁定状态。</p><p>现在这完全说得通了，但唯一的问题是，在 Cookpad 中，我们只在应用启动时从<code>Keychain</code>中读取信息，而我的假设是，用户一定是点击了应用图标来启动应用，因此设备在这时应该总是解锁的，对吗？</p><p>那么，究竟发生了什么变化呢？即使我能够重现这个问题，我也100%确定我的手机在我点击应用图标的时候是解锁的，所以我不明白为什么会出现这个<code>Keychain</code>错误。</p><p>我决心找到原因，用一个调试工具替换了我们的应用程序的实现，该工具将尝试并记录其生命周期中不同节点的<code>Keychain</code>读取。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/d58d7a078b6141c722ff3efe698953d3.png" alt=""></p><p>在能够复现问题的场景中，我观察到以下结果：</p><ul><li><code>main.swift</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.init()</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.applicationProtectedDataDidBecomeAvailable(_:)</code><br>— 成功</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 成功</li><li><code>ViewController.viewDidAppear(_:)</code> — 成功</li></ul><p>所以这（一半）解释了它。为了避免在我们的AppDelegate上持有一些隐式解包的可选属性，我们在<code>init()</code>方法中进行了一些设置，其中一部分涉及从<code>Keychain</code>中读取访问令牌。这就是为什么读取会失败，以及最终为什么一些用户会发现自己被登出了。</p><p>我在这里学到了重要的一课，即我不应该假设受保护的数据在<code>AppDelegate</code>初始化时是可用的，但说实话，我还是不高兴，因为我不明白为什么它不可用。毕竟，我们已经很多年没有改变过这部分代码了，而且它在iOS 12、13和14系统中一直运行良好，那么是什么原因呢？</p><h2 id="寻找根本原因"><a href="#寻找根本原因" class="headerlink" title="寻找根本原因"></a>寻找根本原因</h2><p>我的调试界面很有用，但它缺少了一些有助于回答所有问题的重要信息：<strong>时间</strong>。</p><p>我知道在<code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code>之前，“受保护的数据” 是不可用的，但它仍然没有意义，因为为了重现这个问题，我正在执行以下操作：</p><p>1、启动应用程序<br>2、简单使用<br>3、强制退出应用<br>4、锁定我的设备并将其放置约 30 分钟<br>5、解锁设备<br>6、再次启动应用</p><p>每当我在第 6 步中再次启动应用程序时，我 100% 确定设备已解锁，因此我坚信我应该能够从 <code>AppDelegate.init()</code>中的<code>Keychain</code>读取数据。</p><p>直到我看了所有这些步骤的时间，事情才开始变得有点意义。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/ffa4e4a3730d3fd5ed1891fa73539f24.png" alt=""></p><p>再次仔细查看时间戳：</p><ul><li><code>main.swift</code> — 11:38:47</li><li><code>AppDelegate.init()</code> — 11:38:47</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 12:03:04</li><li><code>ViewController.viewDidAppear(_:)</code> — 12:03:04</li></ul><p>在我真正解锁手机并点击应用图标之前的25分钟，应用程序本身就已经启动了!</p><p>现在，我实际上从未想过有这么大的延迟，实际上是<a href="https://twitter.com/_saagarjha" target="_blank" rel="noopener">@_saagarjha</a>建议我检查时间戳，之后，他指给我看这条推特。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/6ea72a16b7326fe97fcdfd33c4758f6d.png" alt="Twitter：Apple开发人员文档的首页"></p><blockquote><p>推特翻译：<br>有趣的iOS 15优化。Duet 现在试图先发制人地 “预热” 第三方应用程序，在你点击一个应用程序图标前几分钟，通过dyld和预主静态初始化器运行它们。然后，该应用程序被暂停，随后的 “启动”似乎更快。</p></blockquote><p>现在一切都说得通了。我们最初没有测试到它，因为我们很可能没有给 iOS 15 beta 版足够的时间来 “学习” 我们的使用习惯，所以这个问题只在现实世界的场景中再现，即设备认为我很快就要启动应用程序。我仍然不知道这种预测是如何形成的，但我只想把它归结为 “Siri智能”，然后就到此为止了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从iOS 15开始，系统可能决定在用户实际尝试打开你的应用程序之前对其进行 “预热”，这可能会增加受保护的数据在你认为应该无法使用的时候的被访问概率。</p><p>通过等待<code>application(_:didFinishLaunchingWithOptions:)</code>委托回调来保护自己，如果可能的话，留意<code>UIApplication.isProtectedDataAvailable</code>（或对应委托的回调/通知）并相应处理。</p><p>我们仍然发现了非常少的非致命问题，在<code>application(_:didFinishLaunchingWithOptions:)</code>中报告<code>isProtectedDataAvailable</code>为<code>false</code>，在我们可以推迟从钥匙串阅读的访问令牌之外，这将是一个大规模的任务，现在它不值得进行进一步调查。</p><p>这是一个相当难调试的bug，而且行为的变化似乎完全没有记录，这对我来说真的没有帮助。如果你也被这个问题所困扰，请考虑复制<a href="https://openradar.appspot.com/FB9780579" target="_blank" rel="noopener">FB9780579</a>。</p><p>我从中学到了很多东西，我希望你也一样！</p><p><strong>更新：</strong> 自从发表这篇文章以来，实际上很多人都向我指出了<a href="https://developer.apple.com/documentation/uikit/app_and_environment/responding_to_the_launch_of_your_app/about_the_app_launch_sequence#3894431" target="_blank" rel="noopener">苹果公司关于预热行为的相对完善的文档</a>。然而，其他人也告诉我，他们仍然观察到与某些场景中记录的行为不同的行为，因此请谨慎行事。</p><blockquote><p>译自：<a href="https://sourcediving.com/solving-mysterious-logout-issues-on-ios-15-8b818c089466" target="_blank" rel="noopener">Solving Mysterious Logout Issues on iOS 15</a></p></blockquote><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的各种交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量，排名不分先后：</p><ul><li><a href="https://blog.csdn.net/mobanchengshuang" title="张安宇" target="_blank" rel="noopener">张安宇@微软</a></li><li><a href="https://github.com/niyaoyao" title="倪瑶" target="_blank" rel="noopener">倪瑶@Trip.com</a></li><li><a href="https://ming1016.github.io" title="戴铭" target="_blank" rel="noopener">戴铭@快手</a></li><li><a href="https://github.com/fanbaoying" title="展菲" target="_blank" rel="noopener">展菲@ESP</a></li><li><a href="https://weibo.com/u/3878455011" title="杜鑫瑶" target="_blank" rel="noopener">杜鑫瑶@新浪</a></li><li><a href="https://www.jianshu.com/u/855d6ea2b3d1" title="韦弦" target="_blank" rel="noopener">韦弦@Gwell</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：
      
    
    </summary>
    
      <category term="iOS文集" scheme="https://fanbaoying.github.io/categories/iOS%E6%96%87%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 10 正则表达式匹配（前100）</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%2010%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E5%89%8D100%EF%BC%89/"/>
    <id>https://fanbaoying.github.io/LeetCode - 10 正则表达式匹配（前100）/</id>
    <published>2022-03-10T06:13:13.000Z</published>
    <updated>2022-03-10T06:35:12.679Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>本题为 LeetCode 前 100 高频题</strong></p><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 9 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：困难</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>已知一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code> 的，而不是部分字符串。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot; p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;mississippi&quot; p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 30</code></li><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegularExpressionMatching</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(<span class="number">_</span> s: String, <span class="number">_</span> p: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sChars = <span class="type">Array</span>(s), pChars = <span class="type">Array</span>(p)</span><br><span class="line">        <span class="keyword">var</span> dp = <span class="type">Array</span>(repeating: <span class="type">Array</span>(repeating: <span class="literal">false</span>, <span class="built_in">count</span>: pChars.<span class="built_in">count</span> + <span class="number">1</span>), <span class="built_in">count</span>: sChars.<span class="built_in">count</span> + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...pChars.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="comment">// jump over "" vs. "x*" case</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = i == <span class="number">0</span> || i &gt; <span class="number">1</span> &amp;&amp; dp[<span class="number">0</span>][i - <span class="number">2</span>] &amp;&amp; pChars[i - <span class="number">1</span>] == <span class="string">"*"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...sChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>...pChars.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> j &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> pCurrent = pChars[j - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> pCurrent != <span class="string">"*"</span> &#123;</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (pCurrent == <span class="string">"."</span> || pCurrent == sChars[i - <span class="number">1</span>])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">1</span> &amp;&amp; (sChars[i - <span class="number">1</span>] == pChars[j - <span class="number">2</span>] || pChars[j - <span class="number">2</span>] == <span class="string">"."</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[sChars.<span class="built_in">count</span>][pChars.<span class="built_in">count</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：经典二维动态规划</li><li>时间复杂度： O(mn)</li><li>空间复杂度： O(mn)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>前往 <a href="https://leetcode.com/problems/regular-expression-matching" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="往期回顾"><a href="#往期回顾" class="headerlink" title="往期回顾"></a>往期回顾</h2><p>已发布的文章中有 <strong>5 篇高频题</strong></p><p><a href="https://mp.weixin.qq.com/s/BwUa6IN4O3DWLmoMAzoFeg" target="_blank" rel="noopener">LeetCode - #1 两数之和</a> </p><p>难度水平：<strong>容易</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★★★★★ </td></tr><tr><td>Facebook</td><td>★★★★★ </td></tr><tr><td>Airbnb</td><td>★★★★★  </td></tr><tr><td>Microsoft</td><td>★★★★★</td></tr><tr><td>LinkedIn</td><td>★★★★ </td></tr></tbody></table><p><a href="https://mp.weixin.qq.com/s/wFUafzkwiLe7GtP7Uyz9Eg" target="_blank" rel="noopener">LeetCode - #2 两数相加</a> </p><p>难度水平：<strong>中等</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Microsoft</td><td>★★★★</td></tr><tr><td>Amazon</td><td>★★ </td></tr><tr><td>Airbnb</td><td>★★  </td></tr></tbody></table><p><a href="https://mp.weixin.qq.com/s/bHLoloSfGphlBQsPXkH6pg" target="_blank" rel="noopener">LeetCode - #3 最长未重复子字符串</a> </p><p>难度水平：<strong>中等</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr></tbody></table><p><a href="https://mp.weixin.qq.com/s/QKO2sD2T1H-tFUcakgHUwA" target="_blank" rel="noopener">LeetCode - #4 求两个有序数组的中间值</a> </p><p>难度水平：<strong>困难</strong></p><p><a href="https://mp.weixin.qq.com/s/XUY2DCQfRVPmt-5cXRvRag" target="_blank" rel="noopener">LeetCode - #5 求最长的镜像字符串</a> </p><p>难度水平：<strong>中等</strong>，公司面试使用频率如下：</p><table><thead><tr><th>公司</th><th>频率 </th></tr></thead><tbody><tr><td>Amazon</td><td>★★ </td></tr></tbody></table><blockquote><p>难度水平：容易、中等、困难<br>公司使用频率：1 ～ 6 颗 ★</p></blockquote><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本题为 LeetCode 前 100 高频题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 9 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：困难&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 9 判断回文数字</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%209%20%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/"/>
    <id>https://fanbaoying.github.io/LeetCode - 9 判断回文数字/</id>
    <published>2022-03-10T06:12:47.000Z</published>
    <updated>2022-03-10T06:35:03.505Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：简单</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个整数 <code>x</code>，如果 <code>x</code> 是回文整数，则返回 <code>true</code>。</p><p>当一个整数向后读与向前读相同时，它就是<strong>回文</strong>。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：  x = 121</span><br><span class="line">输出：  真</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：  x = -121</span><br><span class="line">输出：  假</span><br><span class="line">说明：  从左到右依次为 -121。 从右到左，它变成 121-。 因此它不是回文。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： x = 10</span><br><span class="line">输出： 假</span><br><span class="line">说明： 从右到左读取 01。 因此它不是回文。</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： x = -101</span><br><span class="line">输出： 假</span><br></pre></td></tr></table></figure><p><strong>约束条件：</strong></p><ul><li><code>-$2^31$ &lt;= x &lt;= $2^31$ - 1</code></li></ul><p><strong>跟进：</strong>你能在不将整数转换为字符串的情况下解决它吗？</p><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PalindromeNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> x = x</span><br><span class="line">        <span class="keyword">var</span> div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            div = div * <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">left</span> = x / div</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">right</span> = x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">left</span> != <span class="keyword">right</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            x = (x % div) / <span class="number">10</span></span><br><span class="line">            div = div / <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：负数不是回文。</li><li>时间复杂度： O(1)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/palindrome-number/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 8 字符串转换整数(atoi)</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%208%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/"/>
    <id>https://fanbaoying.github.io/LeetCode - 8 字符串转换整数-atoi/</id>
    <published>2022-03-10T06:12:25.000Z</published>
    <updated>2022-03-10T06:34:54.832Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>实现一个 <code>func myAtoi(_ str: String) -&gt; Int</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 <code>C/C++</code> 中的 <code>atoi</code> 函数）。</p><p>函数 <code>func myAtoi(_ str: String) -&gt; Int</code> 的算法如下：</p><ul><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，<code>&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32</code>）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−2^31,  2^31 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2^31</code> 的整数应该被固定为 <code>−2^31</code> ，大于 <code>2^31 − 1</code> 的整数应该被固定为 <code>2^31 − 1</code> 。</li><li>返回整数作为最终结果。</li></ul><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li><li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li></ul><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &apos;-&apos; 或者 &apos;+&apos;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;-42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &apos;-&apos; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &apos;-&apos; 或者 &apos;+&apos;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;words and 987&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &apos;-&apos; 或者 &apos;+&apos;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;words and 987&quot;（由于当前字符 &apos;w&apos; 不是一个数字，所以读入停止）</span><br><span class="line">         ^</span><br><span class="line">解析得到整数 0 ，因为没有读入任何数字。</span><br><span class="line">由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 5</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：str = &quot;-91283472332&quot;</span><br><span class="line">输出：-2147483648</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;-91283472332&quot;（读入 &apos;-&apos; 字符，所以结果应该是负数）</span><br><span class="line">          ^</span><br><span class="line">第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）</span><br><span class="line">                     ^</span><br><span class="line">解析得到整数 -91283472332 。</span><br><span class="line">由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。</span><br></pre></td></tr></table></figure><p>约束条件：</p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Atoi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(<span class="number">_</span> str: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span>, flag = <span class="number">1</span>, index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> intMax = <span class="number">2147483647</span>, intMin = -<span class="number">2147483648</span>, strChars = <span class="type">Array</span>(str)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// trim</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; strChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> currentChar = strChars[index]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// trim</span></span><br><span class="line">            <span class="keyword">guard</span> currentChar.isWhitespace <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> index &lt; strChars.<span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// handle flag</span></span><br><span class="line">        <span class="keyword">if</span> strChars[index] == <span class="string">"-"</span> &#123;</span><br><span class="line">            flag = -<span class="number">1</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> strChars[index] == <span class="string">"+"</span> &#123;</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cast to number</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; strChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> currentChar = strChars[index]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> currentChar.isNumber <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res = res * <span class="number">10</span> + currentChar.wholeNumberValue!</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> res &gt;= intMax &#123;</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> intMax</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag == -<span class="number">1</span> &amp;&amp; res &gt; intMax &#123;</span><br><span class="line">                    <span class="keyword">return</span> intMin</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> flag * res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：修剪，正和负，整数溢出，是字符数字</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/string-to-integer-atoi/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 3 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 7 反转整数</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%207%20%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>https://fanbaoying.github.io/LeetCode - 7 反转整数/</id>
    <published>2022-03-10T03:24:27.000Z</published>
    <updated>2022-03-10T06:34:44.559Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 6 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个有符号的 32 位整数 x，返回其数字反转的 x。 如果反转 x 导致值超出有符号的 32 位整数范围 <code>-$2^31$ &lt;= x &lt;= $2^31$ - 1</code>，则返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：  x = 123</span><br><span class="line">输出：  321</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：  x = -123</span><br><span class="line">输出：  -321</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： x = 120</span><br><span class="line">输出：  21</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： x = 0</span><br><span class="line">输出：  0</span><br></pre></td></tr></table></figure><p>约束条件：</p><ul><li><code>-$2^31$ &lt;= x &lt;= $2^31$ - 1</code></li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> x = x</span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> res &gt; <span class="type">Int</span>(<span class="type">Int32</span>.<span class="built_in">max</span>) / <span class="number">10</span> || res &lt; <span class="type">Int</span>(<span class="type">Int32</span>.<span class="built_in">min</span>) / <span class="number">10</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x = x / <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：使用 % 10 反向迭代数字的数字，并使用 * 10 相应地更新结果。</li><li>注意：适时处理整数溢出。</li><li>时间复杂度： O(n)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/reverse-integer/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 6 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 6 字符串“之”字形转换</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%206%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9C%E4%B9%8B%E2%80%9D%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2/"/>
    <id>https://fanbaoying.github.io/LeetCode - 6 字符串“之”字形转换/</id>
    <published>2022-03-10T03:23:49.000Z</published>
    <updated>2022-03-10T06:34:32.205Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 5 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h1 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h1><p>已知一个字符串 <code>“PAYPALISHIRING”</code> 在确定的行数上以 “之” 字形图案书写，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>然后逐行阅读获得一个新的字符串：<code>“PAHNAPLSIIGYIR”</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(s: String, <span class="number">_</span> numRows: Int)</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><p>已知一个字符串和行数，在上述方法内编写转换的代码。</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出： &quot;PAHNAPLSIIGYIR&quot;</span><br><span class="line">解释： </span><br><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出： &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释： </span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出： &quot;A&quot;</span><br></pre></td></tr></table></figure><p>约束条件：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 英文字母 <code>,</code> 和 <code>.</code>组成。</li><li><code>1 &lt;= numRows &lt;= 1000</code></li></ul><h1 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(s: String, <span class="number">_</span> numRows: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> ret: [<span class="type">Character</span>] = []</span><br><span class="line">        <span class="keyword">var</span> chars: [<span class="type">Character</span>] = [<span class="type">Character</span>](s.characters)</span><br><span class="line">        <span class="keyword">let</span> cnt = chars.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;numRows &#123;</span><br><span class="line">            <span class="keyword">let</span> len = <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">            <span class="keyword">var</span> index = i</span><br><span class="line">            <span class="keyword">while</span> index &lt; cnt &#123;</span><br><span class="line">                ret.append(chars[index])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> tmpIndex = index + <span class="number">2</span> * (numRows - i - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> tmpIndex &lt; cnt &#123;</span><br><span class="line">                        ret.append(chars[tmpIndex])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                index += len</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(ret)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：第一行和最后一行，循环长度为 <code>(2 * numRows - 2)</code>对于它们之间的每一行，应该插入另一个数字，<code>index = index + 2 * (numRows - i - 1)</code></li><li>时间复杂度： O(log(n + m))</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的仓库：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/longest-palindromic-substring/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h1 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h1><p>我们是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。</p><p>后续还会翻译大量资料到我们公众号，有感兴趣的朋友，可以加入我们</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 5 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 5 求最长的镜像字符串</title>
    <link href="https://fanbaoying.github.io/LeetCode%20-%205%20%E6%B1%82%E6%9C%80%E9%95%BF%E7%9A%84%E9%95%9C%E5%83%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://fanbaoying.github.io/LeetCode - 5 求最长的镜像字符串/</id>
    <published>2022-03-08T09:57:50.000Z</published>
    <updated>2022-03-10T06:10:41.392Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题库：<a href="https://github.com/SwiftCommunityRes/LeetCode--Swift" target="_blank" rel="noopener">https://github.com/SwiftCommunityRes/LeetCode–Swift</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们社区陆续会将顾毅（<strong>Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长</strong>）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。</p><p>LeetCode 算法到目前我们已经更新了 4 期，我们会保持更新时间和进度（<strong>周一、周三、周五早上 9:00 发布</strong>），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。</p><p>不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。<strong>如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。</strong></p><blockquote><p>难度水平：中等</p></blockquote><a id="more"></a><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><p>给定一个字符串 <code>s</code>, 返回 <code>s</code> 中的最长回文子字符串.</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;babad&quot;</span><br><span class="line">输出： &quot;bab&quot;</span><br><span class="line">解释： &quot;aba&quot; 同样是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;cbbd&quot;</span><br><span class="line">输出： &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;a&quot;</span><br><span class="line">输出： &quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： s = &quot;ac&quot;</span><br><span class="line">输出： &quot;a&quot;</span><br></pre></td></tr></table></figure><p>约束条件：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成。</li></ul><h2 id="3-答案"><a href="#3-答案" class="headerlink" title="3. 答案"></a>3. 答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> s.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> sChars = <span class="type">Array</span>(s)</span><br><span class="line">        <span class="keyword">var</span> maxLen = <span class="number">0</span>, start = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;sChars.<span class="built_in">count</span> &#123;</span><br><span class="line">            searchPalindrome(sChars, i, i, &amp;start, &amp;maxLen)</span><br><span class="line">            searchPalindrome(sChars, i, i + <span class="number">1</span>, &amp;start, &amp;maxLen)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(sChars[start..&lt;start + maxLen])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">searchPalindrome</span><span class="params">(<span class="number">_</span> chars: [Character], <span class="number">_</span> l: Int, <span class="number">_</span> r: Int, <span class="number">_</span> start: <span class="keyword">inout</span> Int, <span class="number">_</span> maxLen: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> l = l, r = r</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> &amp;&amp; r &lt; chars.<span class="built_in">count</span> &amp;&amp; chars[l] == chars[r] &#123;</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> maxLen &lt; r - l - <span class="number">1</span> &#123;</span><br><span class="line">            start = l + <span class="number">1</span></span><br><span class="line">            maxLen = r - l - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要思想：从中心的每个索引中找到最长的镜像字符串。</li><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>该算法题解的 github 仓库是：<a href="https://github.com/soapyigu/LeetCode-Swift" title="LeetCode-Swift" target="_blank" rel="noopener">LeetCode-Swift</a></p><p>点击前往 <a href="https://leetcode.com/problems/longest-palindromic-substring/" title="LeetCode" target="_blank" rel="noopener">LeetCode</a> 练习</p><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>公众号是由 Swift 爱好者共同维护，我们会分享以 Swift 实战、SwiftUI、Swift 基础为核心的技术内容，也整理收集优秀的学习资料。欢迎关注公众号：<strong>Swift社区</strong>，后台点击进群，联系我们获取更多内容。</p><p><img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题库：&lt;a href=&quot;https://github.com/SwiftCommunityRes/LeetCode--Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SwiftCommunityRes/LeetCode–Swift&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们社区陆续会将顾毅（&lt;strong&gt;Netflix 增长黑客，《iOS 面试之道》作者，ACE 职业健身教练。微博:@故胤道长&lt;/strong&gt;）的 Swift 算法题题解整理为文字版以方便大家学习与阅读。&lt;/p&gt;
&lt;p&gt;LeetCode 算法到目前我们已经更新了 4 期，我们会保持更新时间和进度（&lt;strong&gt;周一、周三、周五早上 9:00 发布&lt;/strong&gt;），每期的内容不多，我们希望大家可以在上班路上阅读，长久积累会有很大提升。&lt;/p&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，Swift社区 伴你前行。&lt;strong&gt;如果大家有建议和意见欢迎在文末留言，我们会尽力满足大家的需求。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;难度水平：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode-Swift" scheme="https://fanbaoying.github.io/categories/LeetCode-Swift/"/>
    
    
      <category term="Swift" scheme="https://fanbaoying.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>京东七鲜一面总结</title>
    <link href="https://fanbaoying.github.io/%E4%BA%AC%E4%B8%9C%E4%B8%83%E9%B2%9C%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
    <id>https://fanbaoying.github.io/京东七鲜一面总结/</id>
    <published>2022-01-19T09:57:31.000Z</published>
    <updated>2022-01-19T09:58:28.777Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanbaoying/FBYInterview-iOS" target="_blank" rel="noopener">面试资源库</a><br>如有帮助请点个 Star。</p><h2 id="1-http-链接到断开的过程？"><a href="#1-http-链接到断开的过程？" class="headerlink" title="1. http 链接到断开的过程？"></a>1. http 链接到断开的过程？</h2><h3 id="第一步：TCP建立连接：三次握手"><a href="#第一步：TCP建立连接：三次握手" class="headerlink" title="第一步：TCP建立连接：三次握手"></a>第一步：TCP建立连接：三次握手</h3><p>   HTTP 是应用层协议，他的工作还需要数据层协议的支持，最常与它搭配的就是 TCP 协议（应用层、数据层是 <code>OSI</code> 七层模型中的，以后有机会会说到的）。TCP 协议称为数据传输协议，是可靠传输，面向连接的，并且面向字节流的。</p><p><strong>面向连接</strong>：通信之前先建立连接，确保双方在线。<br><strong>可靠传输</strong>：在网络正常的情况下，数据不会丢失。<br><strong>面向字节流</strong>：传输灵活，但是 TCP 的传输存在粘包问题，没有明显的数据约定。</p><p>在正式发送请求之前，需要先建立 TCP 连接。建立 TCP 连接的过程简单地来说就是客户端和服务端之间发送三次消息来确保连接的建立，这个过程称为<strong>三次握手</strong>。</p><a id="more"></a><h3 id="第二步：浏览器发送请求命令"><a href="#第二步：浏览器发送请求命令" class="headerlink" title="第二步：浏览器发送请求命令"></a>第二步：浏览器发送请求命令</h3><p><strong>TCP 连接建立完成后，客户端就可以向服务端发送请求报文来请求了</strong></p><p>请求报文分为请求行、请求头、空行、请求体，服务端通过请求行和请求头中的内容获取客户端的信息，通过请求体中的数据获取客户端的传递过来的数据。</p><h3 id="第三步：应答响应"><a href="#第三步：应答响应" class="headerlink" title="第三步：应答响应"></a>第三步：应答响应</h3><p><strong>在接收到客户端发来的请求报文并确认完毕之后。服务端会向客户端发送响应报文</strong></p><p>响应报文是有状态行、响应头、空行和响应体组成，服务端通过状态行和响应头告诉客户端请求的状态和如何对数据处理等信息，真正的数据则在响应体中传输给客户端。</p><h3 id="第四步：断开-TCP-连接"><a href="#第四步：断开-TCP-连接" class="headerlink" title="第四步：断开 TCP 连接"></a>第四步：断开 TCP 连接</h3><p><strong>当请求完成后，还需要断开 tcp 连接，断开的过程</strong></p><p>断开的过程简单地说就算客户端和服务端之间发送四次信息来确保连接的断开，所以称为四次挥手。</p><h2 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h2><p>一、<strong>单向请求</strong> HTTP 请求是单向的，是只能由客户端发起请求，由服务端响应的<strong>请求-响应模式</strong>。（如果你需要双向请求，可以用 socket）</p><p>二、<strong>基于 TCP 协议</strong> HTTP 是应用层协议，所以其数据传输部分是基于 TCP 协议实现的。</p><p>三、<strong>无状态</strong> HTTP 请求是无状态的，即没有记忆功能，不能获取之前请求或响应的内容。起初这种简单的模式，能够加快处理速度，保证协议的稳定，但是随着应用的发展，这种无状态的模式会使我们的业务实现变得麻烦，比如说需要保存用户的登录状态，就得专门使用数据库来实现。于是乎，为了实现状态的保持，引入了 Cookie 技术来管理状态。</p><p>四、<strong>无连接</strong> HTTP 协议不能保存连接状态，每次连接只处理一个请求，用完即断，从而达到节约传输时间、提高并发性。在 TCP 连接断开之后，客户端和服务端就像陌生人一样，下次再发送请求，就得重新建立连接了。有时候，当我们需要发送一段频繁的请求时，这种无连接的状态反而会耗费更多的请求时间（因为建立和断开连接本身也需要时间），于是乎，<code>HTTP1.1</code> 中提出了持久连接的概念，可以在请求头中设置 <code>Connection: keep-alive</code> 来实现。</p><h2 id="2-深拷贝、浅拷贝"><a href="#2-深拷贝、浅拷贝" class="headerlink" title="2. 深拷贝、浅拷贝"></a>2. 深拷贝、浅拷贝</h2><blockquote><p>深拷贝、浅拷贝实例说明？</p></blockquote><p><strong>深拷贝</strong>：是对对象本身的拷贝；<br><strong>浅拷贝</strong>：是对指针的拷贝；</p><p>在 oc 中父类的指针可以指向子类的对象，这是多态的一个特性<br>声明一个 NSString 对象，让它指向一个 <code>NSMutableString</code> 对象，这一点是完全可以的，因为 <code>NSMutableString</code> 的父类就是 NSString。<code>NSMutableString</code> 是一个可以改变的对象，如果我们用 <code>strong</code> 修饰，NSString 对象强引用了 <code>NSMutableString</code> 对象。假如我们在其他的地方修改了这个 <code>NSMutableString</code> 对象，那么 NSString 的值会随之改变。</p><p><strong>关于copy修饰相关</strong></p><p>1、<strong>对 NSString 进行 copy</strong> -&gt;  这是一个浅拷贝，但是因为是不可变对象，后期值也不会改变；</p><p>2、<strong>对 NSString 进行 mutableCopy</strong>  -&gt; 这是一个深拷贝，但是拷贝出来的是一个可变的对象 NSMutableString；</p><p>3、<strong>对 NSMutableString 进行 copy</strong>  -&gt; 这是一个深拷贝，拷贝出来一个不可变的对象；</p><p>4、<strong>对 NSmutableString 进行 mutableCopy</strong> -&gt; 这是一个深拷贝，拷贝出来一个可变的对象；</p><p><strong>总结：</strong></p><p>对对象进行 <code>mutableCopy</code>，不管对象是可变的还是不可变的都是深拷贝，并且拷贝出来的对象都是可变的；</p><p>对对象进行 <code>copy</code>，copy 出来的都是不可变的。</p><p>对于系统的非容器类对象，我们可以认为，如果对一不可变对象复制，copy 是指针复制（浅拷贝）和 <code>mutableCopy</code> 就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是 copy 返回的对象是不可变的。</p><p>指 <code>NSArray</code>，<code>NSDictionary</code> 等。对于容器类本身，上面讨论的结论也是适用的，需要探讨的是复制后容器内对象的变化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy返回不可变对象，mutablecopy返回可变对象</span></span><br><span class="line"><span class="built_in">NSArray</span> *array1 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *arrayCopy1 = [array1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="comment">//arrayCopy1是和array同一个NSArray对象（指向相同的对象），包括array里面的元素也是指向相同的指针</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array1 retain count: %d"</span>,[array1 retainCount]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array1 retain count: %d"</span>,[arrayCopy1 retainCount]);</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArrayCopy1 = [array1 mutableCopy];</span><br></pre></td></tr></table></figure><p><code>mArrayCopy1</code> 是 <code>array1</code> 的可变副本，指向的对象和 <code>array1</code> 不同，但是其中的元素和 <code>array1</code> 中的元素指向的是同一个对象。</p><p><code>mArrayCopy1</code> 还可以修改自己的对象 <code>[mArrayCopy1 addObject:@&quot;de&quot;]</code>;</p><p><code>[mArrayCopy1 removeObjectAtIndex:0];</code> <code>array1</code> 和 <code>arrayCopy1</code> 是指针复制，而 <code>mArrayCopy1</code> 是对象复制，<code>mArrayCopy1</code> 还可以改变期内的元素：删除或添加。但是注意的是，容器内的元素内容都是指针复制。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *mArray1 = [<span class="built_in">NSArray</span> arrayWithObjects:[<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"a"</span>],<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *mArrayCopy2 = [mArray1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArrayMCopy1 = [mArray1 mutableCopy];</span><br><span class="line"><span class="built_in">NSMutableString</span> *testString = [mArray1 objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[testString appendString:<span class="string">@" tail"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@-%@-%@"</span>,mArray1,mArrayMCopy1,mArrayCopy2);</span><br><span class="line">结果：mArray1,mArrayMCopy1,mArrayCopy2三个数组的首元素都发生了变化！</span><br></pre></td></tr></table></figure><p><strong>补充：来自开发者留言</strong> </p><p>面试时我有时会问说说 <code>copy</code> 和 <code>mutableCopy</code>，候选人几乎 100% 说你是说深拷贝和浅拷贝啊 ….，我会说不是！</p><p>&gt; 下面用 <code>NSArray</code>、<code>NSMutableArray</code> 举例，因为 <code>NSString</code>、<code>NSMutableString</code> 并不会再引用其它对象，因此不足以说明问题。</p><p>1、<code>NSArray</code> 等类型的 <code>copy</code> 实际并没有 <code>copy</code>，或者最多只能说 <code>copy</code> 了引用，因为 <code>copy</code> 方法只返回了 <code>self</code>，这是对内存的优化；</p><p>2、而 <code>NSMutableArray</code> 的 <code>copy</code> 确实 <code>copy</code> 了，得到的是新的 <code>NSArray</code> 对象，但并不是所谓的深拷贝，因为它只浅浅地 <code>copy</code> 了一个 <code>NSArray</code>，其中的内容仍然是 <code>NSMutableArray</code> 的内容，可以用 == 直接判等；</p><p>3、<code>NSArray</code> 和 <code>NSMutableArray</code> 的 <code>mutableCopy</code> 与 2 相似，只是结果是个 <code>NSMutableArray</code>；</p><p>4、以上说法一般只适用于 Foundation 提供的一些类型，很多时候并不适用于自己写的类 —— 思考一下你自己写的类是怎么实现 <code>NSCopying</code> 协议的？有实现 <code>NSMutableCopying</code> 协议吗？</p><p>所以 ObjC 并没有所谓的深拷贝，要想实现真正的深拷贝，基本上只能依赖序列化+反序列化，这样得到的结果才是深到见底的深拷贝。</p><p>如果你说道理大家都懂，深拷贝、浅拷贝只是一种叫法而已，那我只能说你太不严谨了，官方文档从来没这么教过；而且这种说法也不利于初学者理解，以及再学习其它语言时触类旁通，比如 Java。</p><p>所以建议严谨一点可以叫引用拷贝和浅拷贝，深拷贝很少用到；或者非要两个互为反义词，可以叫真拷贝和假拷贝。</p><h2 id="3-load-和-initialize-区别"><a href="#3-load-和-initialize-区别" class="headerlink" title="3. load 和 initialize 区别"></a>3. load 和 initialize 区别</h2><blockquote><p><code>load</code> 方法和 <code>initialize</code> 方法区别，以及在子类、父类、分类中调用顺序？</p></blockquote><h3 id="void-load"><a href="#void-load" class="headerlink" title="+(void)load"></a>+(void)load</h3><p>1、<code>+load</code> 方法加载顺序：父类&gt; 子类&gt; 分类 （<code>load</code> 方法都会加载）注意：（如果分类中有 <code>A</code>, <code>B</code>,顺序要看 <code>A</code>, <code>B</code> 加入工程中顺序） ，可能结果：<code>（ 父类&gt; 子类&gt; 分类A&gt; 分类B ）</code> 或者<code>（ 父类&gt; 子类&gt; 分类B&gt; 分类A ）</code></p><p>2、<code>+load</code> 方法不会被覆盖（比如有父类，子类，分类A，分类B,这四个 <code>load</code> 方法都会加载）。</p><p>3、<code>+load</code> 方法调用在 <code>main</code>函数前</p><h3 id="void-initialize"><a href="#void-initialize" class="headerlink" title="+(void)initialize"></a>+(void)initialize</h3><p>1、分类 （子类没有 <code>initialize</code> 方法，父类存在或者没有 1<code>initialize</code> 方法）</p><p>2、分类&gt; 子类 （多个分类就看编译顺序，只有存在一个）</p><p>3、父类&gt; 子类 （分类没有 <code>initialize</code> 方法）</p><p>4、父类 (子类，分类都没有 <code>initialize</code> 方法)</p><h3 id="总结-initialize："><a href="#总结-initialize：" class="headerlink" title="总结 +initialize："></a>总结 +initialize：</h3><p>1、当调用子类的 <code>+ initialize</code> 方法时候,先调用父类的,如果父类有分类, 那么分类的 <code>+ initialize</code> 会覆盖掉父类的</p><p>2、分类的 <code>+ initialize</code> 会覆盖掉父类的</p><p>3、子类的 <code>+ initialize</code> 不会覆盖分类的</p><p>4、父类的 <code>+ initialize</code> 不一定会调用, 因为有可能父类的分类重写了它</p><p>5、发生在main函数后。</p><h2 id="4-同名方法调用顺序"><a href="#4-同名方法调用顺序" class="headerlink" title="4. 同名方法调用顺序"></a>4. 同名方法调用顺序</h2><blockquote><p>同名方法在子类、父类、分类的调用顺序？</p></blockquote><p><a href="https://www.jianshu.com/p/e5c89e9045cf" title="load,initialize方法调用源码分析" target="_blank" rel="noopener">load,initialize方法调用源码分析</a></p><p><strong>注意</strong>：<code>+load</code> 方法是根据方法地址直接调用，并不是经过 <code>objc_msgSend</code> 函数调用（通过 <code>isa</code> 和 <code>superclass</code> 找方法），所以不会存在方法覆盖的问题。</p><h2 id="5-事件响应链"><a href="#5-事件响应链" class="headerlink" title="5. 事件响应链"></a>5. 事件响应链</h2><blockquote><p>事件响应链（同一个控制器有三个view，如何判断是否拥有相同的父视图）</p></blockquote><p>iOS 系统检测到手指触摸( <code>Touch</code> )操作时会将其打包成一个 <code>UIEvent</code> 对象，并放入当前活动 <code>Application</code> 的事件队列，单例的 <code>UIApplication</code> 会从事件队列中取出触摸事件并传递给单例的 <code>UIWindow</code> 来处理，<code>UIWindow</code> 对象首先会使用 <code>hitTest:withEvent:</code> 方法寻找此次 <code>Touch</code> 操作初始点所在的视图(<code>View</code>)，即需要将触摸事件传递给其处理的视图，这个过程称之为 <code>hit-test view</code>。</p><p><code>UIAppliction</code> –&gt; <code>UIWiondw</code> –&gt;递归找到最适合处理事件的控件–&gt;控件调用 <code>touches</code> 方法–&gt;判断是否实现 <code>touches</code> 方法–&gt;没有实现默认会将事件传递给上一个响应者–&gt;找到上一个响应者。</p><p><code>UIResponder</code> 是所有响应对象的基类，在 <code>UIResponder</code> 类中定义了处理上述各种事件的接口。我们熟悉的 <code>UIApplication</code>、 <code>UIViewController</code>、 <code>UIWindow</code> 和所有继承自 <code>UIView</code> 的 <code>UIKit</code> 类都直接或间接的继承自 <code>UIResponder</code>，所以它们的实例都是可以构成响应者链的响应者对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何获取父视图</span></span><br><span class="line"><span class="built_in">UIResponder</span> *nextResponder = gView.nextResponder;</span><br><span class="line"><span class="built_in">NSMutableString</span> *p = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"--"</span>];</span><br><span class="line"><span class="keyword">while</span> (nextResponder) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@%@"</span>, p, <span class="built_in">NSStringFromClass</span>([nextResponder <span class="keyword">class</span>]));</span><br><span class="line">    [p appendString:<span class="string">@"--"</span>];</span><br><span class="line">    nextResponder = nextResponder.nextResponder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有父视图则 <code>nextResponder</code> 指向父视图如果是控制器根视图则指向控制器；</p><p>控制器如果在导航控制器中则指向导航控制器的相关显示视图最后指向导航控制器；</p><p>如果是根控制器则指向 <code>UIWindow</code>；</p><p><code>UIWindow</code> 的 <code>nexResponder</code> 指向 <code>UIApplication</code> 最后指向 <code>AppDelegate</code>。</p><h2 id="6-TCP丢包"><a href="#6-TCP丢包" class="headerlink" title="6.TCP丢包"></a>6.TCP丢包</h2><blockquote><p>TCP 会不会丢包？该怎么处理？网络断开会断开链接还是一直等待，如果一直网络断开呢？</p></blockquote><p>TCP 在不可靠的网络上实现可靠的传输，必然会有丢包。TCP 是一个“<strong>流</strong>”协议，一个详细的包将会被 TCP 拆分为好几个包上传，也是将会把小的封裝成大的上传，这就是说 TCP 粘包和拆包难题。</p><p><a href="https://blog.csdn.net/weixin_41563161/article/details/105310459" title="TCP丢包总结" target="_blank" rel="noopener">TCP丢包总结</a></p><h2 id="7-自动释放池"><a href="#7-自动释放池" class="headerlink" title="7.自动释放池"></a>7.自动释放池</h2><blockquote><p>自动释放池创建和释放的时机，在子线程是什么时候创建释放的？</p></blockquote><p>默认主线程的运行循环（<code>runloop</code>）是开启的，子线程的运行循环(<code>runloop</code>)默认是不开启的，也就意味着子线程中不会创建 <code>autoreleasepool</code>，所以需要我们自己在子线程中创建一个自动释放池。（子线程里面使用的类方法都是 <code>autorelease</code>,就会没有池子可释放，也就意味着后面没有办法进行释放，造成内存泄漏。）</p><p>在主线程中如果产生事件那么 <code>runloop</code> 才回去创建 <code>autoreleasepool</code>，通过这个道理我们就知道为什么子线程中不会创建自动释放池了，因为子线程的 <code>runloop</code> 默认是关闭的，所以他不会自动创建 <code>autoreleasepool</code>，需要我们手动添加。</p><p>如果你生成一个子线程的时候，要在线程开始执行的时候，尽快创建一个自动释放池，否则会内存泄露。因为子线程无法访问主线程的自动释放池。</p><h2 id="8-计算机编译流程"><a href="#8-计算机编译流程" class="headerlink" title="8.计算机编译流程"></a>8.计算机编译流程</h2><p><strong>源文件：</strong> 载入<code>.h</code>、<code>.m</code>、<code>.cpp</code> 等文件</p><p><strong>预处理：</strong> 替换宏，删除注释，展开头文件，产生 <code>.i</code> 文件</p><p><strong>编译：</strong> 将 <code>.i</code> 文件转换为汇编语言，产生 <code>.s</code> 文件</p><p><strong>汇编：</strong> 将汇编文件转换为机器码文件，产生 <code>.o</code> 文件</p><p><strong>链接：</strong> 对 <code>.o</code> 文件中引用其他库的地方进行引用，生成最后的可执行文件</p><p><a href="https://www.jianshu.com/p/db765ff4e36a" title="dyld加载流程" target="_blank" rel="noopener">dyld加载流程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanbaoying/FBYInterview-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试资源库&lt;/a&gt;&lt;br&gt;如有帮助请点个 Star。&lt;/p&gt;
&lt;h2 id=&quot;1-http-链接到断开的过程？&quot;&gt;&lt;a href=&quot;#1-http-链接到断开的过程？&quot; class=&quot;headerlink&quot; title=&quot;1. http 链接到断开的过程？&quot;&gt;&lt;/a&gt;1. http 链接到断开的过程？&lt;/h2&gt;&lt;h3 id=&quot;第一步：TCP建立连接：三次握手&quot;&gt;&lt;a href=&quot;#第一步：TCP建立连接：三次握手&quot; class=&quot;headerlink&quot; title=&quot;第一步：TCP建立连接：三次握手&quot;&gt;&lt;/a&gt;第一步：TCP建立连接：三次握手&lt;/h3&gt;&lt;p&gt;   HTTP 是应用层协议，他的工作还需要数据层协议的支持，最常与它搭配的就是 TCP 协议（应用层、数据层是 &lt;code&gt;OSI&lt;/code&gt; 七层模型中的，以后有机会会说到的）。TCP 协议称为数据传输协议，是可靠传输，面向连接的，并且面向字节流的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向连接&lt;/strong&gt;：通信之前先建立连接，确保双方在线。&lt;br&gt;&lt;strong&gt;可靠传输&lt;/strong&gt;：在网络正常的情况下，数据不会丢失。&lt;br&gt;&lt;strong&gt;面向字节流&lt;/strong&gt;：传输灵活，但是 TCP 的传输存在粘包问题，没有明显的数据约定。&lt;/p&gt;
&lt;p&gt;在正式发送请求之前，需要先建立 TCP 连接。建立 TCP 连接的过程简单地来说就是客户端和服务端之间发送三次消息来确保连接的建立，这个过程称为&lt;strong&gt;三次握手&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>百度一面总结</title>
    <link href="https://fanbaoying.github.io/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
    <id>https://fanbaoying.github.io/百度一面总结/</id>
    <published>2022-01-19T09:54:58.000Z</published>
    <updated>2022-01-19T09:57:09.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fanbaoying/FBYInterview-iOS" target="_blank" rel="noopener">面试资源库</a><br>如有帮助请点个 Star。</p><h2 id="1-二进制重排"><a href="#1-二进制重排" class="headerlink" title="1. 二进制重排"></a>1. 二进制重排</h2><h3 id="1-1-clang-插桩具体如何做的"><a href="#1-1-clang-插桩具体如何做的" class="headerlink" title="1.1 clang 插桩具体如何做的"></a>1.1 clang 插桩具体如何做的</h3><h3 id="1-2-c-方法-clang-插桩能否取到？"><a href="#1-2-c-方法-clang-插桩能否取到？" class="headerlink" title="1.2 c++ 方法 clang 插桩能否取到？"></a>1.2 c++ 方法 clang 插桩能否取到？</h3><p>不能<br>可以取到 <code>c</code> 函数，<code>oc</code> 方法，<code>block</code>，<code>swift</code> 方法<br>但是可以用 <code>-finstrument-functions</code> 在编译期插桩 “<strong>hook</strong>”，或者使用并不完美但成本最低的静态扫描方案。</p><h3 id="1-3-除了二进制重排，还有哪些启动优化的方法"><a href="#1-3-除了二进制重排，还有哪些启动优化的方法" class="headerlink" title="1.3 除了二进制重排，还有哪些启动优化的方法"></a>1.3 除了二进制重排，还有哪些启动优化的方法</h3><a id="more"></a><h4 id="1-3-1-pre-main-阶段"><a href="#1-3-1-pre-main-阶段" class="headerlink" title="1.3.1 pre main 阶段"></a>1.3.1 pre main 阶段</h4><ol><li>Load dylibs </li></ol><ul><li>尽量不使用内嵌（<code>embedded</code>）的 <code>dylib</code>，加载内嵌 <code>dylib</code> 性能开销较大</li><li>合并已有的 <code>dylib</code> 和使用静态库（<code>static archives</code>），减少 <code>dylib</code> 的使用个数</li><li>懒加载 <code>dylib</code>，但是要注意 <code>dlopen()</code> 可能造成一些问题，且实际上懒加载做的工作会更多</li></ul><ol><li>Rebase/Bind</li></ol><p>在 <code>dylib</code> 的加载过程中，系统为了安全考虑，引入了 <code>ASLR</code>（Address Space Layout Randomization）技术和代码签名。由于ASLR的存在，镜像（<code>Image</code>，包括可执行文件、<code>dylib</code> 和 <code>bundle</code>）会在随机的地址上加载，和之前指针指向的地址（<code>preferred_address</code>）会有一个偏差（<code>slide</code>），<code>dyld</code>需要修正这个偏差，来指向正确的地址。 </p><ul><li>减少 ObjC 类（<code>clas</code>s）、方法（<code>selector</code>）、分类（<code>category</code>）的数量</li><li>减少 <code>C++</code> 虚函数的数量（创建虚函数表有开销）</li><li>使用 <code>swiftStructs</code> (内部有优化，符号数量更少)</li></ul><ol><li><code>Objc setUp</code> </li><li><code>Initializers</code></li></ol><ul><li>少在类的 <code>+load</code>方法里做事情，尽量把这些事情推迟到 <code>+initiailize</code></li><li>减少构造器函数个数，在构造器函数里少做些事情</li><li>减少 <code>C++</code> 静态全局变量的个数</li></ul><h4 id="1-3-2-main-阶段"><a href="#1-3-2-main-阶段" class="headerlink" title="1.3.2 main 阶段"></a>1.3.2 main 阶段</h4><ol><li>梳理各个二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器或 <code>tabBar</code> 控制器的 <code>viewDidAppear</code> 方法里，并且保证只执行一次（按项目结构，放在合适的地方）</li><li>梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。</li><li>避免复杂/多余的计算。</li><li>避免在用户看到的第一个界面（首页控制器或注册登录页面）的 <code>viewDidLoad</code> 和 <code>viewWillAppear</code> 做太多事情，这 2 个方法执行完，第一个页面才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理</li><li>首页控制器或注册登录页面用纯代码方式来构建</li></ol><h3 id="1-4-link-map数据结构"><a href="#1-4-link-map数据结构" class="headerlink" title="1.4 link map数据结构"></a>1.4 link map数据结构</h3><p><code>Link Map File</code> 中文直译为链接映射文件，它是在 Xcode 生成可执行文件的同时生成的链接信息文件，用于描述可执行文件的构造部分，包括了代码段和数据段的分布情况</p><h4 id="1-4-1-linkMapfile-的组成"><a href="#1-4-1-linkMapfile-的组成" class="headerlink" title="1.4.1 linkMapfile 的组成"></a>1.4.1 linkMapfile 的组成</h4><ol><li><strong>Path</strong>：<code>Path</code> 是生成可执行文件的路径。 </li><li><strong>Arch</strong>：<code>Arch</code> 指代架构类型。 </li><li><strong>Object files</strong>：<code>Object Files</code> 列举了可执行文件里所有的 <code>obj</code> 以及 <code>tbd</code>。每一行代表对文件的编号。 </li><li><strong>Sections</strong>： 每个 <code>Section</code> 包含了 <code>Address</code>、<code>Size</code>、<code>Segment</code> 以及 <code>Section</code>。<code>Mach-O</code> 文件中的虚拟地址最终会被映射到物理地址上，这些地址会被分为不同的段类型：  <code>TEXT</code>、  <code>DATA</code> 以及 <code>LINKEDIT</code> 等。各个段的含义如下：  <blockquote><p><code>TEXT</code> 包含了被执行的代码。这些代码是只读、可执行<br><code>DATA</code> 包含了包含了将会被更改的数据，例如全局变量、静态变量等，可读写，但是不可执行<br><code>LINKEDIT</code> 包含了加载程序的元数据，比如函数名称和地址，只读。<br><code>Segment</code> 又被划分成了不同的 <code>Section</code>，不同的 <code>Section</code> 存储了不同的信息，例如 <code>objc _ methname</code> 为方法的名称</p></blockquote></li><li><strong>Symbols</strong> ：Symbols包含的信息有：</li></ol><ul><li><strong>Address</strong>：起始地址</li><li><strong>Size</strong>：所占内存大小，这里使用16进制表示。</li><li><strong>File</strong>：该Name所在的文件编号，也就是Object files部分的中括号的数字。 </li></ul><ol><li><code>Dead Stripped Symbols</code></li></ol><h3 id="1-5-具体的优化时间获取？有没有看过实际线上优化多少？"><a href="#1-5-具体的优化时间获取？有没有看过实际线上优化多少？" class="headerlink" title="1.5 具体的优化时间获取？有没有看过实际线上优化多少？"></a>1.5 具体的优化时间获取？有没有看过实际线上优化多少？</h3><ol><li><strong>pre-main阶段测量</strong>：<code>DYLD_PRINT_STATISTICS</code></li><li><strong>main()阶段测量</strong>：先在 <code>main()</code> 函数里用变量 <code>StartTime  didFinishLaunchingWithOptions</code> 再获取一下当前时间</li></ol><h2 id="2-VC生命周期"><a href="#2-VC生命周期" class="headerlink" title="2. VC生命周期"></a>2. VC生命周期</h2><ol><li><code>+load</code>: 程序启动后，在系统的 <code>main</code> 函数调用之前，系统就会加载所有的 <code>load</code> 方法，提前进行一些资源包的配置或者 <code>hook</code>，(可以打断点看看结果，本人亲测过) </li><li><code>+initialize</code>: 当前类或者其子类未被初始化过时会首次调用，若以后当前类或者子类再多次初始化时不会再调用，一般提前为初始化做一些工作 </li><li><code>+alloc</code>: 系统为当前类分配内存时调用，在C语言中就是 <code>malloc</code> 这一步 </li><li><code>-initWithCoder</code>: 通过 <code>storyBoard</code> 方式实例化的 vc，需要经过反序列化，这个方法会被调用 </li><li><code>-initWithNibName:bundle</code>: 通过 <code>xib</code> 文件或者 <code>init</code> 方法实例化的 vc，这个方法都会被调用，其实 <code>init</code> 方法最终都会走该方法 </li><li><code>-init</code>: 通过纯代码实例化Vc会调用，其最终会调用 <code>initWithNibName:bundle:</code> 方法 </li><li><code>-loadView</code>: 实例化Vc后，可以加载一些系统常规的View </li><li><code>-viewDidLoad</code>: 一般加载自定义的view或者初始化属性，视图加载完毕后会调用 </li><li><code>-viewWillAppear</code>: 视图即将出现会调用 </li><li><code>-viewWillDisappear</code>: 视图即将消失会调用 </li><li><code>-viewWillLayoutSubviews</code>: 视图加载完毕后即将要布局 </li><li><code>-viewDidLayoutSubviews</code>: 视图加载完毕后布局也完成了 </li><li><code>-didReceiveMemoryWarning</code>: 加载视图时，内存消耗太大，出现内存警告，会调用 </li><li><code>-dealloc</code>: 实例化被销毁，进行内存的回收会调用 </li></ol><h2 id="3-copy-mutableCopy"><a href="#3-copy-mutableCopy" class="headerlink" title="3. copy / mutableCopy"></a>3. copy / mutableCopy</h2><p><strong>可变对象复制：</strong></p><p>都是深拷贝，但是 <code>copy</code> 返回的对象是不可变的。</p><p>对于容器而言，其元素对象始终是指针复制。如果需要元素对象也是对象复制，就需要实现深拷贝。</p><h2 id="4-NSUserDefault存储位置"><a href="#4-NSUserDefault存储位置" class="headerlink" title="4. NSUserDefault存储位置"></a>4. NSUserDefault存储位置</h2><p><code>~/Library/Preferences</code> 下，用 <code>plist</code> 文件存储</p><h2 id="5-Https如何保证数据安全"><a href="#5-Https如何保证数据安全" class="headerlink" title="5. Https如何保证数据安全"></a>5. Https如何保证数据安全</h2><p>是由 <code>SSL+HTTP</code> 协议构建的可进行加密传输、身份认证的网络协议</p><h3 id="公私钥加密之后是否还有加密"><a href="#公私钥加密之后是否还有加密" class="headerlink" title="公私钥加密之后是否还有加密"></a>公私钥加密之后是否还有加密</h3><p>对称加密+非对称加密这两种方式，我们可以用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据</p><h2 id="6-git-reset"><a href="#6-git-reset" class="headerlink" title="6. git reset"></a>6. git reset</h2><p>可以让 <code>HEAD</code> 这个指针指向其他的地方<br>它有三种模式，<code>soft</code>, <code>mixed</code>, <code>hard</code></p><h3 id="6-1-reset-soft"><a href="#6-1-reset-soft" class="headerlink" title="6.1 reset soft"></a>6.1 reset soft</h3><p>保留工作目录，并把重置 <code>HEAD</code> 所带来的新的差异放进暂存区<br><code>reset --soft</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 时，保留工作目录和暂存区中的内容，并把重置 <code>HEAD</code> 所带来的新的差异放进暂存区。</p><h3 id="6-2-reset-mixed"><a href="#6-2-reset-mixed" class="headerlink" title="6.2 reset mixed"></a>6.2 reset mixed</h3><p><code>reset</code> 不加参数(<code>mixed</code>)：保留工作目录，并清空暂存区<br><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code>参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 <code>reset</code> 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（<code>mixed</code>）放在工作目录中」。</p><h3 id="6-3-reset-hard"><a href="#6-3-reset-hard" class="headerlink" title="6.3 reset hard"></a>6.3 reset hard</h3><p>重置 <code>stage</code> 区和工作目录<br><code>reset --hard</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 的同时，重置 <code>stage</code> 区和工作目录里的内容。当你在 <code>reset</code> 后面加了 <code>--hard</code> 参数时，你的 <code>stage</code> 区和工作目录里的内容会被完全重置为和 <code>HEAD</code> 的新位置相同的内容。换句话说，就是你的没有 <code>commit</code> 的修改会被全部擦掉。</p><p>学无止境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/fanbaoying/FBYInterview-iOS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试资源库&lt;/a&gt;&lt;br&gt;如有帮助请点个 Star。&lt;/p&gt;
&lt;h2 id=&quot;1-二进制重排&quot;&gt;&lt;a href=&quot;#1-二进制重排&quot; class=&quot;headerlink&quot; title=&quot;1. 二进制重排&quot;&gt;&lt;/a&gt;1. 二进制重排&lt;/h2&gt;&lt;h3 id=&quot;1-1-clang-插桩具体如何做的&quot;&gt;&lt;a href=&quot;#1-1-clang-插桩具体如何做的&quot; class=&quot;headerlink&quot; title=&quot;1.1 clang 插桩具体如何做的&quot;&gt;&lt;/a&gt;1.1 clang 插桩具体如何做的&lt;/h3&gt;&lt;h3 id=&quot;1-2-c-方法-clang-插桩能否取到？&quot;&gt;&lt;a href=&quot;#1-2-c-方法-clang-插桩能否取到？&quot; class=&quot;headerlink&quot; title=&quot;1.2 c++ 方法 clang 插桩能否取到？&quot;&gt;&lt;/a&gt;1.2 c++ 方法 clang 插桩能否取到？&lt;/h3&gt;&lt;p&gt;不能&lt;br&gt;可以取到 &lt;code&gt;c&lt;/code&gt; 函数，&lt;code&gt;oc&lt;/code&gt; 方法，&lt;code&gt;block&lt;/code&gt;，&lt;code&gt;swift&lt;/code&gt; 方法&lt;br&gt;但是可以用 &lt;code&gt;-finstrument-functions&lt;/code&gt; 在编译期插桩 “&lt;strong&gt;hook&lt;/strong&gt;”，或者使用并不完美但成本最低的静态扫描方案。&lt;/p&gt;
&lt;h3 id=&quot;1-3-除了二进制重排，还有哪些启动优化的方法&quot;&gt;&lt;a href=&quot;#1-3-除了二进制重排，还有哪些启动优化的方法&quot; class=&quot;headerlink&quot; title=&quot;1.3 除了二进制重排，还有哪些启动优化的方法&quot;&gt;&lt;/a&gt;1.3 除了二进制重排，还有哪些启动优化的方法&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>[译]解决 iOS 15 上 APP 莫名其妙地退出登录</title>
    <link href="https://fanbaoying.github.io/%E8%AF%91-%E8%A7%A3%E5%86%B3-iOS-15-%E4%B8%8A-APP-%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95/"/>
    <id>https://fanbaoying.github.io/译-解决-iOS-15-上-APP-莫名其妙地退出登录/</id>
    <published>2021-12-08T11:45:38.000Z</published>
    <updated>2021-12-08T11:46:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png" alt=""></p><p>在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：在打开我们的应用程序(Cookpad) 时他们被莫名其妙的反复退出到登录页。非常令人惊讶的是，这并不是我们在测试 iOS 15 beta 版的时候发现的问题。</p><p>如果你是来找修复方法的，那就直接向下滚动到结论，但如果你想了解更多关于我们如何调试这个特定问题，那就开始吧。</p><a id="more"></a><h2 id="复现反馈的问题"><a href="#复现反馈的问题" class="headerlink" title="复现反馈的问题"></a>复现反馈的问题</h2><p>用户报告中的具体信息有限，我们唯一知道的是：从 iOS 15 开始，用户打开程序后会发现自己已经退出登录。</p><p>我们没有视频，也没有具体的步骤来重现这个问题，所以我努力尝试以各种方式启动应用程序，希望能亲眼看到它。我试着重新安装应用程序，我试着在有网络连接和没有网络连接的情况下启动，我试着强制退出，经过30分钟的努力，我放弃了，我开始回复用户说我没找到具体问题。</p><p>直到我再次解锁手机，没有做任何操作，就启动了 Cookpad，我发现APP就像我们的用户所反馈的那样，直接退出到了登录界面!</p><p>在那之后，我无法准确的复现该问题，但似乎与暂停使用手机一段时间后再次使用它有关。</p><h2 id="缩小问题范围"><a href="#缩小问题范围" class="headerlink" title="缩小问题范围"></a>缩小问题范围</h2><p>我担心从 Xcode 重新安装应用程序可能会影响问题的复现，所以在这样做之前，是时候查看代码并试图缩小问题的范围。根据我们的实现，我想出了三个潜在的原因。</p><ul><li>1、<code>UserDefaults</code> 中的数据被清除。</li><li>2、一个意外的API调用返回HTTP 401并触发退出登录。</li><li>3、<code>Keychain</code> 抛出了一个错误。</li></ul><p>我能够排除前两个潜在的原因，这要归功于我在自己重现该问题后观察到的一些微妙行为。</p><ul><li>登录界面没有要求我选择地区——这表明<code>UserDefaults</code>中的数据没有问题，因为我们的 “已显示地区选择 “偏好设置仍然生效。</li><li>主用户界面没有显示，即使是短暂的也没有——这表明没有尝试进行网络请求，所以 API 是问题原因可能还为时过早。</li></ul><p>这就把<code>Keychain</code>留给了我们，指引我进入下一个问题。是什么发生了改变以及为什么它如此难以复现？</p><h2 id="是什么发生了改变以及为什么它如此难以复现？"><a href="#是什么发生了改变以及为什么它如此难以复现？" class="headerlink" title="是什么发生了改变以及为什么它如此难以复现？"></a>是什么发生了改变以及为什么它如此难以复现？</h2><p>我粗略地看了一下发布说明，在谷歌上快速搜索了一下，我找不到任何东西，所以我不得不继续挖掘以更好地了解这个问题。</p><p>对<code>Keychain</code>数据的访问是通过 <a href="https://developer.apple.com/documentation/security" title="Security" target="_blank" rel="noopener">Security</a> 框架提供的，这是一个众所周知的棘手的问题。虽然有很多第三方库来包装这个框架以使事情变得更容易，但我们还是基于一些苹果的示例代码来维护我们自己的简单封装。</p><p>看一下这段代码，我们调用 <a href="https://developer.apple.com/documentation/security/1398306-secitemcopymatching?language=objc" title="SecItemCopyMatching" target="_blank" rel="noopener">SecItemCopyMatching</a> 方法来加载我们的访问令牌，它返回数据以及描述结果的 <a href="https://osstatus.com/" target="_blank" rel="noopener"><em>OSStatus</em></a> 代码。然而，不幸的是，虽然我们的封装器会将不成功的结果与状态代码一起抛出，用于调试，但我们在下一层中却抛弃了这些信息，只是将错误视为 <code>nil</code>。</p><p>我们实行了每周一次的发布计划，多亏了大量的自动化。此时，我们即将发布的下一个截止点（代码冻结）是在第二天。因为我们还没有完全了解这个问题有多普遍，而且我们也不确定是否能够在代码冻结前发布一个修复程序，所以我利用这个机会通过使用Crashlytics(崩溃日志记录工具) 增加一些额外的非致命性日志来解决缺乏可观察性的问题。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/64e699daa0417f6a10ae4e9fa861008b.png" alt="虽然我们无法改变加载会话的行为，但我们能够开始记录错误并更好地记录我们实现的当前行为。"></p><p>这个结果给了我们一些很好的观察点，然后我们可以在接下来的几周内观察。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/8af9cb1ce53fdb1ab4cda921451c34cc.png" alt="在10.58.0和10.59.0版本中，受影响的用户数量慢慢减少，这是由于我们在努力确定根本原因时引入了一项缓解措施，该措施在10.60.0中得到了修复。"></p><p>此时，我能够捕捉到返回的确切错误代码。罪魁祸首是<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" title="errSecInteractionNotAllowed" target="_blank" rel="noopener">errSecInteractionNotAllowed</a>：</p><blockquote><p>不允许与 <em>Security Server</em> 交互。</p></blockquote><p>这个错误告诉我们，我们正试图在数据不可用的时间点上从<code>Keychain</code>中读取数据。这通常会发生在你试图读取已存储的数据，并将其可访问性设置为<a href="https://developer.apple.com/documentation/security/ksecattraccessiblewhenunlocked" title="kSecAttrAccessibleWhenUnlocked" target="_blank" rel="noopener">kSecAttrAccessibleWhenUnlocked</a>，而设备仍处于锁定状态。</p><p>现在这完全说得通了，但唯一的问题是，在 Cookpad 中，我们只在应用启动时从<code>Keychain</code>中读取信息，而我的假设是，用户一定是点击了应用图标来启动应用，因此设备在这时应该总是解锁的，对吗？</p><p>那么，究竟发生了什么变化呢？即使我能够重现这个问题，我也100%确定我的手机在我点击应用图标的时候是解锁的，所以我不明白为什么会出现这个<code>Keychain</code>错误。</p><p>我决心找到原因，用一个调试工具替换了我们的应用程序的实现，该工具将尝试并记录其生命周期中不同节点的<code>Keychain</code>读取。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/d58d7a078b6141c722ff3efe698953d3.png" alt=""></p><p>在能够复现问题的场景中，我观察到以下结果：</p><ul><li><code>main.swift</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.init()</code> — 失败 (<a href="https://developer.apple.com/documentation/security/errsecinteractionnotallowed?changes=_3" target="_blank" rel="noopener"><em>errSecInteractionNotAllowed</em></a>)</li><li><code>AppDelegate.applicationProtectedDataDidBecomeAvailable(_:)</code><br>— 成功</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 成功</li><li><code>ViewController.viewDidAppear(_:)</code> — 成功</li></ul><p>所以这（一半）解释了它。为了避免在我们的AppDelegate上持有一些隐式解包的可选属性，我们在<code>init()</code>方法中进行了一些设置，其中一部分涉及从<code>Keychain</code>中读取访问令牌。这就是为什么读取会失败，以及最终为什么一些用户会发现自己被登出了。</p><p>我在这里学到了重要的一课，即我不应该假设受保护的数据在<code>AppDelegate</code>初始化时是可用的，但说实话，我还是不高兴，因为我不明白为什么它不可用。毕竟，我们已经很多年没有改变过这部分代码了，而且它在iOS 12、13和14系统中一直运行良好，那么是什么原因呢？</p><h2 id="寻找根本原因"><a href="#寻找根本原因" class="headerlink" title="寻找根本原因"></a>寻找根本原因</h2><p>我的调试界面很有用，但它缺少了一些有助于回答所有问题的重要信息：<strong>时间</strong>。</p><p>我知道在<code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code>之前，“受保护的数据” 是不可用的，但它仍然没有意义，因为为了重现这个问题，我正在执行以下操作：</p><p>1、启动应用程序<br>2、简单使用<br>3、强制退出应用<br>4、锁定我的设备并将其放置约 30 分钟<br>5、解锁设备<br>6、再次启动应用</p><p>每当我在第 6 步中再次启动应用程序时，我 100% 确定设备已解锁，因此我坚信我应该能够从 <code>AppDelegate.init()</code>中的<code>Keychain</code>读取数据。</p><p>直到我看了所有这些步骤的时间，事情才开始变得有点意义。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/ffa4e4a3730d3fd5ed1891fa73539f24.png" alt=""></p><p>再次仔细查看时间戳：</p><ul><li><code>main.swift</code> — 11:38:47</li><li><code>AppDelegate.init()</code> — 11:38:47</li><li><code>AppDelegate.application(_:didFinishLaunchingWithOptions:)</code> — 12:03:04</li><li><code>ViewController.viewDidAppear(_:)</code> — 12:03:04</li></ul><p>在我真正解锁手机并点击应用图标之前的25分钟，应用程序本身就已经启动了!</p><p>现在，我实际上从未想过有这么大的延迟，实际上是<a href="https://twitter.com/_saagarjha" target="_blank" rel="noopener">@_saagarjha</a>建议我检查时间戳，之后，他指给我看这条推特。</p><p><img src="https://images.xiaozhuanlan.com/photo/2021/6ea72a16b7326fe97fcdfd33c4758f6d.png" alt="Twitter：Apple开发人员文档的首页"></p><blockquote><p>推特翻译：<br>有趣的iOS 15优化。Duet 现在试图先发制人地 “预热” 第三方应用程序，在你点击一个应用程序图标前几分钟，通过dyld和预主静态初始化器运行它们。然后，该应用程序被暂停，随后的 “启动”似乎更快。</p></blockquote><p>现在一切都说得通了。我们最初没有测试到它，因为我们很可能没有给 iOS 15 beta 版足够的时间来 “学习” 我们的使用习惯，所以这个问题只在现实世界的场景中再现，即设备认为我很快就要启动应用程序。我仍然不知道这种预测是如何形成的，但我只想把它归结为 “Siri智能”，然后就到此为止了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从iOS 15开始，系统可能决定在用户实际尝试打开你的应用程序之前对其进行 “预热”，这可能会增加受保护的数据在你认为应该无法使用的时候的被访问概率。</p><p>通过等待<code>application(_:didFinishLaunchingWithOptions:)</code>委托回调来保护自己，如果可能的话，留意<code>UIApplication.isProtectedDataAvailable</code>（或对应委托的回调/通知）并相应处理。</p><p>我们仍然发现了非常少的非致命问题，在<code>application(_:didFinishLaunchingWithOptions:)</code>中报告<code>isProtectedDataAvailable</code>为<code>false</code>，在我们可以推迟从钥匙串阅读的访问令牌之外，这将是一个大规模的任务，现在它不值得进行进一步调查。</p><p>这是一个相当难调试的bug，而且行为的变化似乎完全没有记录，这对我来说真的没有帮助。如果你也被这个问题所困扰，请考虑复制<a href="https://openradar.appspot.com/FB9780579" title="FB9780579" target="_blank" rel="noopener">FB9780579</a>。</p><p>我从中学到了很多东西，我希望你也一样！</p><p><strong>更新：</strong> 自从发表这篇文章以来，实际上很多人都向我指出了<a href="https://developer.apple.com/documentation/uikit/app_and_environment/responding_to_the_launch_of_your_app/about_the_app_launch_sequence#3894431" title="苹果公司关于预热行为的相对完善的文档" target="_blank" rel="noopener">苹果公司关于预热行为的相对完善的文档</a>。然而，其他人也告诉我，他们仍然观察到与某些场景中记录的行为不同的行为，因此请谨慎行事。</p><blockquote><p>译自：<a href="https://sourcediving.com/solving-mysterious-logout-issues-on-ios-15-8b818c089466" title="Solving Mysterious Logout Issues on iOS 15" target="_blank" rel="noopener">Solving Mysterious Logout Issues on iOS 15</a></p></blockquote><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p><strong>Swift社区</strong>是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 <strong>Swift实战</strong>、<strong>SwiftUl</strong>、<strong>Swift基础</strong>为核心的技术内容，也整理收集优秀的学习资料。</p><p>欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的各种交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。</p><p>特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量，排名不分先后：</p><ul><li><a href="https://blog.csdn.net/mobanchengshuang" title="张安宇" target="_blank" rel="noopener">张安宇@微软</a></li><li><a href="https://github.com/niyaoyao" title="倪瑶" target="_blank" rel="noopener">倪瑶@Trip.com</a></li><li><a href="https://ming1016.github.io" title="戴铭" target="_blank" rel="noopener">戴铭@快手</a></li><li><a href="https://github.com/fanbaoying" title="展菲" target="_blank" rel="noopener">展菲@ESP</a></li><li><a href="https://weibo.com/u/3878455011" title="杜鑫瑶" target="_blank" rel="noopener">杜鑫瑶@新浪</a></li><li><a href="https://www.jianshu.com/u/855d6ea2b3d1" title="韦弦" target="_blank" rel="noopener">韦弦@Gwell</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2021/c0ee348b4710dabb70eb5ab6bb45064a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 iOS 15 公开推出后， 我们开始从用户端收到反馈报告：在打开我们的应用程序(Cookpad) 时他们被莫名其妙的反复退出到登录页。非常令人惊讶的是，这并不是我们在测试 iOS 15 beta 版的时候发现的问题。&lt;/p&gt;
&lt;p&gt;如果你是来找修复方法的，那就直接向下滚动到结论，但如果你想了解更多关于我们如何调试这个特定问题，那就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fanbaoying.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fanbaoying.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
